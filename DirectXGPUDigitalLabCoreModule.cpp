#include "stdafx.h"
#include <tchar.h>
#include <strsafe.h>
#include "DirectXNetworkPacketManagementClass.h"
#include "DirectXGPUDigitalLabClassFactory.h"
#include "DirectXGPUDigitalLabCoreModule.h"
#include "Registry.h"
#include "Direct2DManagementClass.h"
#include "Direct2DImageProcessingManager.h"
#include "DirectXGPUDigitalLabClassFactory.h"
#include "DirectXConnectedApplicationLauncher.h"
#include "DirectXCloudServerConnectionManager.h"
#include "GPUDigitalLabGuid.h"
#include <objbase.h>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <jsrt.h>
#include <time.h>
#include <sstream>
#include <map>
#include <VersionHelpers.h>


struct LinearFunctionStruct
{
	int pSegmentNumber;
	int pPixelNumberEight;
	int pPixelNumberTwo;
	float xPosition0;
	float yPosition0;
	float xPosition1;
	float yPosition1;
	float pKCoefficient;
	float pBCoefficient;
	float pDistanceValue;
};

//оператор проверки на равенство для unique
bool operator==(const PixelObject& a, const PixelObject b)
{
	return a.xPosition == b.xPosition && a.yPosition == b.yPosition;
}


//оператор проверки на равенство для unique
bool operator==(const OutputPixelObjectWithAngleValues& a, const OutputPixelObjectWithAngleValues& b)
{
	return a.xPosition == b.xPosition && a.yPosition == b.yPosition;
}


bool WayToSortFloatsAscending(float pFloatA, float pFloatB)
{
	bool pSortVar = false;
	pSortVar = pFloatA < pFloatB;
	return pSortVar;
}



bool WayToSortFloatsDescending(float pFloatA, float pFloatB)
{
	bool pSortVar = false;
	pSortVar = pFloatA > pFloatB;
	return pSortVar;
}
PixelObject GeneratePixelObjectStructureFromParameters(int pPixelNumberValue,
	float pXPositionValue,
	float pYPositionValue,
	float pRedComponent,
	float pGreenComponent,
	float pBlueComponent)
{
	PixelObject newPixel = PixelObject(pPixelNumberValue,
		pXPositionValue,
		pYPositionValue,
		pRedComponent,
		pGreenComponent,
		pBlueComponent);
	return newPixel;
}





void SplitPixelVectorsBasedUponXPosition(vector<PixelObject> pPixelArrayInput, float pXConstant,
	float pYValue,
	vector<PixelObject> *ppFinalOutputVectorOne, vector<PixelObject> *ppFinalOutputVectorTwo)
{
	vector<PixelObject> pPixelObjectOne = vector<PixelObject>();
	vector<PixelObject> pPixelObjectTwo = vector<PixelObject>();
	for (PixelObject pPixelObject : pPixelArrayInput)
	{
		if ((pPixelObject.xPosition == pXConstant) && (pPixelObject.yPosition <= pYValue) )
		{
			pPixelObjectOne.push_back(pPixelObject);
		}
		else if ((pPixelObject.xPosition == pXConstant) && (pPixelObject.yPosition > pYValue))
		{
			pPixelObjectTwo.push_back(pPixelObject);
		}
	}
	*ppFinalOutputVectorOne = pPixelObjectOne;
	*ppFinalOutputVectorTwo = pPixelObjectTwo;
}


void SplitPixelVectorsBasedUponYPosition(vector<PixelObject> pPixelArrayInput, float pXValue, float pYConstant,
	vector<PixelObject> *ppFinalOutputVectorOne, vector<PixelObject> *ppFinalOutputVectorTwo)
{
	vector<PixelObject> pPixelObjectOne = vector<PixelObject>();
	vector<PixelObject> pPixelObjectTwo = vector<PixelObject>();
	for (PixelObject pPixelObject : pPixelArrayInput)
	{
		if ((pPixelObject.yPosition == pYConstant) && (pPixelObject.xPosition <= pXValue))
		{
			pPixelObjectOne.push_back(pPixelObject);
		}
		else if ((pPixelObject.yPosition == pYConstant) && (pPixelObject.xPosition > pXValue))
		{
			pPixelObjectTwo.push_back(pPixelObject);
		}
	}
	*ppFinalOutputVectorOne = pPixelObjectOne;
	*ppFinalOutputVectorTwo = pPixelObjectTwo;
}



float ComputePixelArrayIntensitySum(vector<PixelObjectGrayScale> pVectorGrayScale)
{
	float pPixelIntensitySum = 0.0f;
	for (PixelObjectGrayScale pGrayPixel : pVectorGrayScale)
	{
		pPixelIntensitySum = pPixelIntensitySum + pGrayPixel.pGreyLevel;
	}
	return pPixelIntensitySum;
}



BOOL SortingFloatsAscending (float i, float j)
{
	return (i < j); 
}





bool BinaryPredicateForPixels(PixelObject pixelObjectOne, PixelObject pixelObjectTwo)
{
	bool pResult = false;

	if (pixelObjectOne.pixelNumber == pixelObjectTwo.pixelNumber)
	{
		pResult = true;
	}
	else if (pixelObjectOne.pixelNumber != pixelObjectTwo.pixelNumber)
	{
		pResult = false;
	}
	return pResult;
}


bool WayToSortPixelsAscendingForXPosition(PixelObject pPixelOne, PixelObject pPixelTwo)
{
	bool pResult = false;
	pResult = (pPixelOne.xPosition < pPixelTwo.xPosition) && (pPixelOne.yPosition == pPixelTwo.yPosition);
	return pResult;
}
bool WayToSortPixelsAscendingForYPosition(PixelObject pPixelOne, PixelObject pPixelTwo)
{
	bool pResult = false;
	pResult = (pPixelOne.yPosition < pPixelTwo.yPosition) && (pPixelOne.xPosition == pPixelTwo.xPosition);
	return pResult;
}
float ComputeMedianForPixelArrayForXValue(vector<PixelObject> pPixelArray)
{
	PixelObject pFirtstElement = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pLastElement = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	float pMedianValue = 0.0f;
	std::sort(pPixelArray.begin(), pPixelArray.end(), WayToSortPixelsAscendingForXPosition);
	pFirtstElement = pPixelArray[0];
	pLastElement = pPixelArray[pPixelArray.size() - 1];
	pMedianValue = (pLastElement.xPosition - pFirtstElement.xPosition) / 2.0f + pFirtstElement.xPosition;
	return pMedianValue;
}
float ComputeMedianForPixelArrayForYValue(vector<PixelObject> pPixelArray)
{
	PixelObject pFirtstElement = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pLastElement = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	float pMedianValue = 0.0f;
	std::sort(pPixelArray.begin(), pPixelArray.end(), WayToSortPixelsAscendingForYPosition);
	pFirtstElement = pPixelArray[0];
	pLastElement = pPixelArray[pPixelArray.size() - 1];
	pMedianValue = (pLastElement.yPosition - pFirtstElement.yPosition) / 2.0f + pFirtstElement.yPosition;
	return pMedianValue;
}



float ComputeAverageXForPixelArray(vector<PixelObject> pPixelObjectVector)
{
	float pXPositionSum = 0.0;
	float pXPositionAverage = 0.0f;
	if (pPixelObjectVector.size() > 0)
	{
		for (PixelObject pPixelObjectVar : pPixelObjectVector)
		{
			pXPositionSum = pXPositionSum + pPixelObjectVar.xPosition;
		}

		pXPositionAverage = round(pXPositionSum / pPixelObjectVector.size());
	}
	else
	{
		pXPositionAverage = 0.0f;
	}

	return pXPositionAverage;
}


float ComputeAverageYForPixelArray(vector<PixelObject> pPixelObjectVector)
{
	float pYPositionSum = 0.0;
	float pYPositionAverage = 0.0f;
	
	if (pPixelObjectVector.size() > 0)
	{
		for (PixelObject pPixelObjectVar : pPixelObjectVector)
		{
			pYPositionSum = pYPositionSum + pPixelObjectVar.yPosition;
		}

		pYPositionAverage = round(pYPositionSum / pPixelObjectVector.size());
	}
	else
	{
		pYPositionAverage = 0.0f;
	}

	return pYPositionAverage;
}




float ComputeAverageXForPixelArrayWithYConstantAndXRange(vector<PixelObject> pPixelObjectVector,
	float pMinimumX, float pMaximumX, float pYConstant)
{
	float pXPositionSum = 0.0;
	float pXPositionAverage = 0.0f;
	int pPixelCounter = 0;
	if (pPixelObjectVector.size() > 0)
	{
		for (PixelObject pPixelObjectVar : pPixelObjectVector)
		{
			if ((pPixelObjectVar.xPosition >= pMinimumX) && (pPixelObjectVar.xPosition <= pMaximumX) && (pPixelObjectVar.yPosition == pYConstant))
			{
				pXPositionSum = pXPositionSum + pPixelObjectVar.xPosition;
				pPixelCounter = pPixelCounter + 1;
			}
		}

		pXPositionAverage = round(pXPositionSum / pPixelCounter);
	}
	else
	{
		pXPositionAverage = 0.0f;
	}

	return pXPositionAverage;
}


float ComputeAverageYForPixelArrayWithXConstantAndYRange(vector<PixelObject> pPixelObjectVector,
	float pMinimumY, float pMaximumY, float pXConstant)
{
	float pYPositionSum = 0.0;
	float pYPositionAverage = 0.0f;
	int pPixelCounter = 0;

	if (pPixelObjectVector.size() > 0)
	{
		for (PixelObject pPixelObjectVar : pPixelObjectVector)
		{
			if ((pPixelObjectVar.xPosition == pXConstant) && (pPixelObjectVar.yPosition >= pMinimumY) && (pPixelObjectVar.yPosition <= pMaximumY))
			{
				pYPositionSum = pYPositionSum + pPixelObjectVar.yPosition;
				pPixelCounter = pPixelCounter + 1;
			}
		}

		pYPositionAverage = round(pYPositionSum / pPixelCounter);
	}
	else
	{
		pYPositionAverage = 0.0f;
	}

	return pYPositionAverage;
}









LinearFunctionStruct ComputeLineEquationBetweenPixels(int pSegmentId, PixelObject pPixelObjectEight, PixelObject pPixelObjectTwo)
{
	cout << "Computing K Coefficient Of Line for pixels Eight and seven" << endl;
	float pKCoefficient17 = 0.0f;
	float pBCoefficient17 = 0.0F;
	pKCoefficient17 = (pPixelObjectTwo.yPosition - pPixelObjectEight.yPosition) / (pPixelObjectTwo.xPosition - pPixelObjectEight.xPosition);
	pBCoefficient17 = pPixelObjectEight.yPosition - pKCoefficient17 * pPixelObjectEight.xPosition;

	float pLineDistance = 0.0f;
	pLineDistance = sqrtf(pow((pPixelObjectTwo.yPosition - pPixelObjectEight.yPosition), 2) + pow((pPixelObjectTwo.xPosition - pPixelObjectEight.xPosition), 2));

	LinearFunctionStruct pLineEquationParameters;
	pLineEquationParameters.pSegmentNumber = pSegmentId;
	pLineEquationParameters.pPixelNumberEight = pPixelObjectEight.pixelNumber;
	pLineEquationParameters.pPixelNumberTwo = pPixelObjectTwo.pixelNumber;
	pLineEquationParameters.xPosition0 = pPixelObjectEight.xPosition;
	pLineEquationParameters.yPosition0 = pPixelObjectEight.yPosition;
	pLineEquationParameters.xPosition1 = pPixelObjectTwo.xPosition;
	pLineEquationParameters.yPosition1 = pPixelObjectTwo.yPosition;
	pLineEquationParameters.pKCoefficient = pKCoefficient17;
	pLineEquationParameters.pBCoefficient = pBCoefficient17;
	pLineEquationParameters.pDistanceValue = pLineDistance;
	return pLineEquationParameters;
}


bool ComparePositions(PixelObjectGrayScale i1, PixelObjectGrayScale i2)
{
	return (i1.xPosition < i2.xPosition && i1.yPosition < i2.yPosition);
}

bool SortByXPosition(const PixelObjectGrayScale &lhs, const PixelObjectGrayScale &rhs)
{
	return (lhs.xPosition < rhs.xPosition && lhs.yPosition == rhs.yPosition);
}

bool SortByCbPosition(const PixelObjectGrayScale &lhs, const PixelObjectGrayScale &rhs)
{
	return (lhs.yPosition < rhs.yPosition && lhs.yPosition == rhs.yPosition);
}

struct less_than_grayscale_pixel_by_y
{
	inline bool operator() (const PixelObjectGrayScale& struct1, const PixelObjectGrayScale& struct2)
	{
		return (struct1.yPosition < struct2.yPosition && struct1.xPosition == struct2.xPosition);
	}
};


struct less_than_grayscale_pixel_by_x
{
	inline bool operator() (const PixelObjectGrayScale& struct1, const PixelObjectGrayScale& struct2)
	{
		return (struct1.xPosition < struct2.xPosition && struct1.yPosition == struct2.yPosition);
	}
};

struct less_then_grayscale_pixel_by_y
{
	inline bool operator() (const PixelObjectGrayScale& struct1, PixelObjectGrayScale& struct2)
	{
		return (struct1.yPosition < struct2.yPosition && struct1.xPosition == struct2.xPosition);
	}
} pSortGrayscalePixelsByCbAscending;


struct less_than_image_derivative_by_x
{
	inline bool operator() (const CImageDerivativeClass& struct1, const CImageDerivativeClass& struct2)
	{
		return (struct1.pXPosition < struct2.pXPosition && struct1.pYPosition == struct2.pYPosition);
	}
} pSortImageDerivativeByXAscending;

struct less_than_image_derivative_by_y
{
	inline bool operator() (const CImageDerivativeClass& struct1, const CImageDerivativeClass& struct2)
	{
		return (struct1.pYPosition < struct2.pYPosition && struct1.pXPosition == struct2.pXPosition);
	}
}  pSortImageDerivativeByCbAscending;




#define MAX_TREE_HT 192

struct MinHeapNode
{
	float data;
	unsigned frequency;
	struct MinHeapNode *left, *right;
};

struct MinHeap
{
	unsigned size;
	unsigned capacity;
	struct MinHeapNode **array;
};

struct MinHeapNode *newNode(float data, unsigned frequency)
{
	struct MinHeapNode *temp = (struct MinHeapNode *)malloc(sizeof(struct MinHeapNode));

	temp->left = temp->right = NULL;
	temp->data = data;
	temp->frequency = frequency;

	return temp;
}

bool IsPixelObjectValid(OutputPixelObjectFiltered pOutputPixelObject)
{

	return pOutputPixelObject.pUsedInComputations == false || pOutputPixelObject.pUsedInComputations == 0;

}



struct MinHeap *createMinHeap(unsigned capacity)
{
	struct MinHeap *minHeap = (struct MinHeap *)malloc(sizeof(struct MinHeap));
	minHeap->size = 0;
	minHeap->capacity = capacity;
	minHeap->array = (struct MinHeapNode **)malloc(minHeap->capacity * sizeof(struct MinHeapNode *));
	return minHeap;
}

void swapMinHeapNode(struct MinHeapNode **a, struct MinHeapNode **b)
{
	struct MinHeapNode *t = *a;
	*a = *b;
	*b = t;
}

void minHeapify(struct MinHeap *minHeap, int idx)
{
	int smallest = idx;
	int left = 2 * idx + 1;
	int right = 2 * idx + 2;

	if (left < minHeap->size && minHeap->array[left]->frequency < minHeap->array[smallest]->frequency)
		smallest = left;

	if (right < minHeap->size && minHeap->array[right]->frequency < minHeap->array[smallest]->frequency)
		smallest = right;

	if (smallest != idx)
	{
		swapMinHeapNode(&minHeap->array[smallest],
			&minHeap->array[idx]);
		minHeapify(minHeap, smallest);
	}
}

int isSizeEight(struct MinHeap *minHeap)
{

	return (minHeap->size == 1);
}

struct MinHeapNode *extractMin(struct MinHeap *minHeap)

{
	struct MinHeapNode *temp = minHeap->array[0];
	minHeap->array[0] = minHeap->array[minHeap->size - 1];

	--minHeap->size;
	minHeapify(minHeap, 0);

	return temp;
}

void insertMinHeap(struct MinHeap *minHeap, struct MinHeapNode *minHeapNode)
{
	++minHeap->size;
	int i = minHeap->size - 1;

	while (i && minHeapNode->frequency < minHeap->array[(i - 1) / 2]->frequency)
	{

		minHeap->array[i] = minHeap->array[(i - 1) / 2];
		i = (i - 1) / 2;
	}

	minHeap->array[i] = minHeapNode;
}

void buildMinHeap(struct MinHeap *minHeap)
{
	int n = minHeap->size - 1;
	int i;

	for (i = (n - 1) / 2; i >= 0; --i)
		minHeapify(minHeap, i);
}

void printArr(float arr[], int n)
{
	int i;
	for (i = 0; i < n; ++i)
		cout << arr[i];

	cout << "\n";
}

int isLeaf(struct MinHeapNode *root)
{

	return !(root->left) && !(root->right);
}

struct MinHeap *createAndBuildMinHeap(float data[], float frequency[], float size)
{
	struct MinHeap *minHeap = createMinHeap(size);

	for (int i = 0; i < size; ++i)
		minHeap->array[i] = newNode(data[i], frequency[i]);

	minHeap->size = size;
	buildMinHeap(minHeap);

	return minHeap;
}

struct MinHeapNode *buildHuffmanTree(float data[], float frequency[], float size)
{
	struct MinHeapNode *left, *right, *top;
	struct MinHeap *minHeap = createAndBuildMinHeap(data, frequency, size);

	while (!isSizeEight(minHeap))
	{
		left = extractMin(minHeap);
		right = extractMin(minHeap);

		top = newNode('$', left->frequency + right->frequency);

		top->left = left;
		top->right = right;

		insertMinHeap(minHeap, top);
	}
	return extractMin(minHeap);
}
void printCodes(struct MinHeapNode *root, float arr[], float top)
{
	int pTop = top;
	if (root->left)
	{
		arr[pTop] = 0;
		printCodes(root->left, arr, top + 1);
	}

	if (root->right)
	{
		arr[pTop] = 1;
		printCodes(root->right, arr, top + 1);
	}
	if (isLeaf(root))
	{
		cout << root->data << "  | ";
		printArr(arr, pTop);
	}
}

void HuffmanCodes(float data[], float frequency[], int size)
{
	struct MinHeapNode *root = buildHuffmanTree(data, frequency, size);

	float arr[MAX_TREE_HT], top = 0;

	printCodes(root, arr, top);
}

typedef struct _MYDATAVAR {
	TCHAR *szText;
	DWORD dwValue;
} MYDATAVAR;



bool WayToSortPixelsForXPositionAscending(PixelObject pixelOneValue, PixelObject pixelTwoValue)
{
	bool pResult = false;
	pResult = pixelOneValue.xPosition < pixelTwoValue.xPosition;
	return pResult;
}


bool WayToSortPixelsForYPositionAscending(PixelObject pixelOneValue, PixelObject pixelTwoValue)
{
	bool pResult = false;
	pResult = pixelOneValue.yPosition < pixelTwoValue.yPosition;
	return pResult;
}




bool WayToSortPixelsWihtAnglesAscending(OutputPixelObjectWithAngleValues pItemEight, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = pItemEight.pAngleSinValue < pItemTwo.pAngleSinValue;
	return pResult;
}

bool WayToSortPixelsWihtAnglesDescending(OutputPixelObjectWithAngleValues pItemEight, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = pItemEight.pAngleSinValue > pItemTwo.pAngleSinValue;
	return pResult;
}

bool WayToSortPixelsAscendingForYPositionTangents(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = pItemOne.yPosition > pItemTwo.yPosition;
	return pResult;
}

BOOL WayToSortPixelsWihtAnglesAscendingAgainstQuarters(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = (pItemOne.pQuarterNumberVar < pItemTwo.pQuarterNumberVar);
	return pResult;
}


BOOL WayToSortPixelsWihtAnglesAscendingAgainstRadiuses(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = (pItemOne.pRadiusValue > pItemTwo.pRadiusValue);
	return pResult;
}


BOOL WayToSortPixelsWihtAnglesAscendingAgainstSines(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = (pItemOne.pAngleSinValue < pItemTwo.pAngleSinValue);
	return pResult;
}


BOOL WayToSortPixelsWihtAnglesDescendingAgainstSines(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = (pItemOne.pAngleSinValue > pItemTwo.pAngleSinValue);
	return pResult;
}





BOOL WayToSortPixelsWihtAnglesYPolarAscending(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = (pItemOne.pCentreYDifference < pItemTwo.pCentreYDifference);
	return pResult;
}

BOOL WayToSortPixelsWihtAnglesYPolarDescending(OutputPixelObjectWithAngleValues pItemOne, OutputPixelObjectWithAngleValues pItemTwo)
{
	bool pResult = false;
	pResult = (pItemOne.pCentreYDifference > pItemTwo.pCentreYDifference);
	return pResult;
}

// Program for zig-zag conversion of array 
void ZigZagEnconding(float* arr, int n)
{
	// Flag true indicates relation "<" is expected, 
	// else ">" is expected.  The first expected relation 
	// is "<" 
	bool flag = true;

	for (int i = 0; i <= n - 2; i++)
	{
		if (flag)  /* "<" relation expected */
		{
			/* If we have a situation like A > B > C,
			we get A > B < C by swapping B and C */
			if (arr[i] > arr[i + 1])
				swap(arr[i], arr[i + 1]);
		}
		else /* ">" relation expected */
		{
			/* If we have a situation like A < B < C,
			we get A < C > B by swapping B and C */
			if (arr[i] < arr[i + 1])
				swap(arr[i], arr[i + 1]);
		}
		flag = !flag; /* flip flag */
	}
}

DWORD WINAPI CompareImagesThreadFunctionSemaphores(LPVOID lParam);

const LPWSTR GPUDigtialLabServiceKernel = (LPWSTR)L"Вычислительное Ядро GPUDIGITALLAB";

BOOL        g_bRepaintClient = TRUE;            // Repaint the application client area?
HANDLE pSemaphoreObjectGlobal;
HANDLE pMutexObjectGlobal;


const UINT DO_YOU_WANT_MESSAGES = 0;


LPWSTR ConvertToLPWSTR(const std::wstring& s)
{
	LPWSTR ws = new wchar_t[s.size() + 1];
	ws[s.size()] = 0;
	return ws;
}

DirectXGPUDigitalLabClassFactory* ppGPUDigitalLabClassFactory;
DirectXNetworkPacketManagementClass* m_pGPUNetworkModule = nullptr;
DirectXCloudServerConnectionManager* m_pCloudServerConnectionManagerClass = nullptr;
DirectXGPUDigitalLabCoreModule* pSaveBuffer = nullptr;

#define CONNECTING_STATE 0 
#define READING_STATE 1 
#define WRITING_STATE 2 
#define INSTANCES 13 
#define PIPE_TIMEOUT 5000
#define BUFSIZE 4096

vector<DirectXGPUDigitalLabCoreModule*> pKernelsInMemory;
HWND pGlobalWindow;

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

DEFINE_GUID(IID_IDirectXDigitalLabSoftwareKernelInterfaceObject, 0xFE78387F, 0xD150, 0x4089, 0x83, 0x2C 0xBB, 0xF0, 0x24, 0x02, 0xC8, 0x72);
DEFINE_GUID(CLSID_DirectXGPUDigitalLabSoftwareKernelObject, 0xB2ED6900, 0x321F, 0x4F80, 0xBE, 0xB7, 0xFE, 0x4F, 0x13, 0x5B, 0xCB, 0xBA);


DWORD WINAPI RpcServerListenThreadProc(LPVOID /*pParam*/);

typedef struct MyData1
{
	int val1;
	int val2;
} DATAFRAME, *PDATAFRAME;

struct KernelThreadData
{
	LPCSTR pKernerlDataItem;
};



static CLSID DMOLSimulationObj;
static CLSID DMOLSimulationClientObj;

const WCHAR FName[] = L"DMolSimulation_COM";
const WCHAR VerId[] = L"DMolSimulation.Component";
const WCHAR ProgId[] = L"DMolSimulation.Component";

LPTSTR lpszPipenameMain = TEXT("\\\\.\\pipe\\GPUDigitalLabCore");
LPTSTR lpszPipeAlgorithms = TEXT("\\\\.\\pipe\\GPUDigitalLabAlgorithms");
LPTSTR lpszPipeCloud = TEXT("\\\\.\\pipe\\GPUDigitalLabCloud");
LPTSTR lpsPipeNetwork = TEXT("\\\\.\\pipe\\GPUDigitalLabNetwork");
LPTSTR lpsPipeAgents = TEXT("\\\\.\\pipe\\GPUDigitalLabAgents");
LPTSTR lpsPipeAgentInstances = TEXT("\\\\.\\pipe\\GPUDigitalLabAgentsInstances");
LPTSTR lpsPipAgentController = TEXT("\\\\.\\pipe\\GPUDigitalLabAgentsControllers");
LPTSTR lpsConnectedApplications = TEXT("\\\\.\\pipe\\GPUDigitalLabConnectedApplications");
LPTSTR lpsExperiments = TEXT("\\\\.\\pipe\\GPUDigitalLabExperiments");
LPTSTR lpsAnimations = TEXT("\\\\.\\pipe\\GPUDigitalLabAnimations");
LPTSTR lpsJobsObject = TEXT("\\\\.\\pipe\\GPUDigitalLabJobs");
LPTSTR lpsDatabaseManager = TEXT("\\\\.\\pipe\\GPUDigitalLabDatabase");
LPTSTR lpsTaskManager = TEXT("\\\\.\\pipe\\GPUDigitalLabTaskManager");
LPTSTR lpsaAppInstance = TEXT("\\\\.\\pipe\\GPUDigitalLabApplicationInstances");
LPTSTR lpsGPUSessions = TEXT("\\\\.\\pipe\\GPUDigitalLabSessions");
BOOL g_nComObjsInUse;


const int CLSID_STRING_SIZE = 39;
DirectXGPUDigitalLabClassFactory* ppGPUDigitalLabFactory;
SERVICE_STATUS_HANDLE hServiceStatusHandle;
SERVICE_STATUS pServiceStatus;
DirectXStandardAlgorithmExecutor* pAlgorithmManagerInternal;
int InstallService();
void ControlHandler(DWORD request);
int RemoveService();
int StartServiceInstance();
void CLSIDtochar(const CLSID& clsid,
	char* szCLSID,
	int length);

void GetAnswerToRequest(LPTSTR pchRequest,
	LPTSTR pchReply,
	LPDWORD pchBytes);


DWORD WINAPI ProcessInstanceDataThreadA(LPVOID lpvParam);


DWORD WINAPI CompareImagesThreadFunction(LPVOID lParam);


bool IdenticalPixels(PixelObject pixelOne, PixelObject pixelTwo)
{
	bool pResult = false;
	pResult = (pixelOne.xPosition == pixelTwo.xPosition) && (pixelOne.yPosition == pixelTwo.yPosition);
	return pResult;
}


#define MAX_THREADS 3
#define BUF_SIZE 255

typedef struct MyData {
	HANDLE pKernelHandle;
	LPCSTR pServiceName;
} MYDATA, *PMYDATA;


typedef struct
{
	OVERLAPPED oOverlap;
	HANDLE hPipeInst;
	TCHAR chRequest[BUFSIZE];
	DWORD cbRead;
	TCHAR chReply[BUFSIZE];
	DWORD cbToWrite;
	DWORD dwState;
	BOOL fPendingIO;
} PIPEINST, *LPPIPEINST;


VOID DisconnectAndReconnect(DWORD);
BOOL ConnectTEightwClient(HANDLE, LPOVERLAPPED);
VOID GetAnswerToRequest(LPPIPEINST);
DWORD WINAPI ProcessGPUDigitalLabDataLoop(LPVOID lpParam);
void ProcessErrorHandling(LPTSTR lpszFunction);
PIPEINST pInternalPipesCollection[INSTANCES];
HANDLE pInternalEventsCollection[INSTANCES];
int TestDataProcessingThread();
void CLSIDToChar(const CLSID& clsid,
	WCHAR* szCLSID,
	int length);
void ServiceMain(int argc, char** argv);
LONG DeleteKey(HKEY hKeyParent, const char* lpszKeyChild);

void DisplayErrorBox(LPTSTR lpszFunction);
static DirectXGPUDigitalLabCoreModule* ppKernerCoreModule = nullptr;

DWORD WINAPI ProcessInstanceDataThread(LPVOID lpvParam);

struct less_then_grayscale_pixel_by_x
{
	inline bool operator() (const PixelObjectGrayScale& struct1, PixelObjectGrayScale& struct2)
	{
		return (struct1.xPosition < struct2.xPosition && struct1.yPosition == struct2.yPosition);
	}
} pSortGrayscalePixelsByXAscending;


string IntToStr(int n)
{
	stringstream result;
	result << n;
	return result.str();
}

vector<PixelObject> pCommonPixelObjectArrayEightRGB;
vector<PixelObject> pCommonPixelObjectArrayTwoRGB;
vector<OutputPixelBufferRGB> pOutputImageComparisonArrayGlobalRGB;
vector<PixelObject> pIdenticalPixelObjectArrayGlobalRGB;
vector<PixelObject> pDifferentPixelObjectArrayGlobalRGB;


vector<PixelObject> pCommonPixelObjectArrayEight;
vector<PixelObject> pCommonPixelObjectArrayTwo;
vector<PixelObjectGrayScale> pCommonPixelObjectArrayEightGrayScale;
vector<PixelObjectGrayScale> pCommonPixelObjectArrayTwoGrayScale;
vector<OutputPixelBuffer> pOutputImageComparisonArrayGlobal;
vector<PixelObjectGrayScale> pIdenticalPixelObjectArrayGlobal;
vector<PixelObjectGrayScale> pDifferentPixelObjectArrayGlobal;

bool CompareFunc(const OutputPixelObjectWithAngleValues &pAngleEight, const OutputPixelObjectWithAngleValues &pAngleTwo)
{
	return pAngleEight.pTangentValue < pAngleTwo.pTangentValue;
}


DWORD WINAPI RpcServerListenThreadProc(LPVOID lpParam)
{
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd;
	GetClientRect(hWnd, &rc);
	DirectXGPUDigitalLabCoreModule* pCoreModule = (DirectXGPUDigitalLabCoreModule*)lpParam;
	DWORD pResultOutput = 0;
	unsigned int    cMinCalls = 1;
	unsigned int    fDontWait = FALSE;
	// Start to listen for remote procedure calls
	// for all registered interfaces.
	// This call will not return until
	// RpcMgmtStopServerListening is called.
	pResultOutput = RpcServerListen(
		cMinCalls, // Recommended minimum number of threads.
		RPC_C_LISTEN_MAX_CALLS_DEFAULT, // Recommended maximum number of threads.
		fDontWait); 
		
	pCoreModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
	pCoreModule->InitializeGPUDigitalLabCore(hInstance, hWnd);
	pCoreModule->SimulateOddEvenFSM(hInstance, hWnd);
	// Start listening now.
	
	return pResultOutput;
}



DWORD WINAPI CompareImagesThreadFunction(LPVOID lParam)
{
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	HWND hWnd = (HWND)lParam;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOperationThreaded.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	DWORD pResult = 0;
	pAlgorithmManagerInternal = new DirectXStandardAlgorithmExecutor(hInstance, hWnd);

	if (pCommonPixelObjectArrayEight.size() == 0 || pCommonPixelObjectArrayTwo.size() == 0)
	{
		cout << "Data Processing Containers are empty" << endl;
		pResult = -1;
		return pResult;
	}
	

	cout << "Simulating the Image Subtraction Operation" << endl;
	
	cout << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (PixelObject pixelObject : pCommonPixelObjectArrayEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Printing Array Eight" << endl;

	pIndex = 0;
	for (PixelObject pixelObject : pCommonPixelObjectArrayTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	vector<PixelObject> ppImageTwoRGB = vector<PixelObject>();

	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = pAlgorithmManagerInternal->ConvertImageDataToGrayScale(hInstance, hWnd,
		pCommonPixelObjectArrayEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = pAlgorithmManagerInternal->ConvertImageDataToGrayScale(hInstance, pGlobalWindow,
		pCommonPixelObjectArrayTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = pAlgorithmManagerInternal->CheckIfImagesAreIdentical(hInstance, pGlobalWindow, 10, 10, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}

	pOutputImageComparisonArrayGlobal = vector<OutputPixelBuffer>();
	pIdenticalPixelObjectArrayGlobal = vector<PixelObjectGrayScale>();
	pDifferentPixelObjectArrayGlobal = vector<PixelObjectGrayScale>();


	// Copying vector by copy function 
	std::copy(ppVerificationOutputArray.begin(), ppVerificationOutputArray.end(), back_inserter(pOutputImageComparisonArrayGlobal));
	std::copy(ppIdenticalPixelOutputArray.begin(), ppIdenticalPixelOutputArray.end(), back_inserter(pIdenticalPixelObjectArrayGlobal));
	std::copy(ppDifferentPixelOutputArray.begin(), ppDifferentPixelOutputArray.end(), back_inserter(pDifferentPixelObjectArrayGlobal));







	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();


	return hr;
}


DirectXGPUDigitalLabCoreModule::DirectXGPUDigitalLabCoreModule(HINSTANCE hInstance, HWND hWnd)
	: DirectXComputeShaderManagementClass(hInstance, hWnd)
{

}


DirectXGPUDigitalLabCoreModule::~DirectXGPUDigitalLabCoreModule()
{

}

HRESULT DirectXGPUDigitalLabCoreModule::TestHuffmanTableBehaviour(HINSTANCE hInstance, HWND hWnd)
{
	float arr[] = { 66, 12, 23, 23, 40, 20 };
	float freq[] = { 5, 9, 12, 13, 16, 45 };

	int size = sizeof(arr) / sizeof(arr[0]);

	HuffmanCodes(arr, freq, size);

	int pKey = 0;
	cout << "Press Any Key TO Continue" << endl;
	cin >> pKey;

	return 0;
}







BOOL DirectXGPUDigitalLabCoreModule::LocateImageFile(HWND hWnd, LPWSTR pszFileName, DWORD cbFileName)
{

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"All Image Files\0"              L"*.bmp;*.dib;*.wdp;*.mdp;*.hdp;*.gif;*.png;*.jpg;*.jpeg;*.tif;*.ico\0"
		L"Windows Bitmap\0"               L"*.bmp;*.dib\0"
		L"High Definition Photo\0"        L"*.wdp;*.mdp;*.hdp\0"
		L"Graphics Interchange Format\0"  L"*.gif\0"
		L"Portable Network Graphics\0"    L"*.png\0"
		L"JPEG File Interchange Format\0" L"*.jpg;*.jpeg\0"
		L"Tiff File\0"                    L"*.tif\0"
		L"Icon\0"                         L"*.ico\0"
		L"All Files\0"                    L"*.*\0"
		L"\0";
	ofn.lpstrFile = pszFileName;
	ofn.nMaxFile = cbFileName;
	ofn.lpstrTitle = L"Open Image";
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

	return GetOpenFileName(&ofn);

}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateObjectCountingOperationOnRGBImages(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CountingObjectsOfCertainColorInsideImages.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	vector<PixelObject> pixelObjectVectorOnePartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorOnePartTwo = vector<PixelObject>();

	vector<PixelObject> pixelObjectVectorTwoPartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoPartTwo = vector<PixelObject>();


	vector<OutputPixelObjectFiltered> pOutputFilterResultOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pOutputFilterResultTwo = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterResultOneRestored = vector<PixelObject>();
	vector<PixelObject> pOutputFilterResulTwoRestored = vector<PixelObject>();
	vector<OutputPixelBufferObjectCounting> pCountingOperationOutputVector = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelVector = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelVector = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;



	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	
	
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;


	pRedValueBottom = pRedValueToSelect;
	pRedValueTop = pRedValueToSelect;
	pGreenValueBottom = pGreenValueToSelect;
	pGreenValueTop = pGreenValueToSelect;
	pBlueValueBottom = pBlueValueToSelect;
	pBlueValueTop = pBlueValueToSelect;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;



		cout << "Clippping image ONE FOR Y AXIS" << endl;
		pixelDataFile << "Clippping image ONE FOR Y AXIS" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1,  &pixelObjectVectorOnePartOne);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOnePartOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}


		cout << "Clipping for X Position" << endl;
		pixelDataFile << "Clipping for X Position" << endl;




		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOnePartTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOnePartTwo)
		{
			if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}



		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwoPartOne);

		cout << "Printing the Contents of Clipped Area" << endl;
	 pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwoPartOne)
		{
			if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}


		cout << "Clipping for X Position" << endl;
		pixelDataFile << "Clipping for X Position" << endl;




		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorTwoPartTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwoPartTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}




		pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());
		pixelObjectVectorTwoPartOne.insert(pixelObjectVectorTwoPartOne.end(), pixelObjectVectorTwoPartTwo.begin(), pixelObjectVectorTwoPartTwo.end());





		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pTopLeftX, pTopLeftY,
			pTopLeftX + pImageWidth,
			pTopLeftY + pImageHeight,
			pRedValueBottom, pRedValueTop,
			pGreenValueBottom, pGreenValueTop,
			pBlueValueBottom, pBlueValueTop,
			pixelObjectVectorOnePartOne, &pOutputFilterResultOne);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultOne)
		{

			if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pOutputFilterResultOne, &pOutputFilterResultOneRestored);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pOutputFilterResultOneRestored)
		{

			if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}


		int pEthalonNumber = 0;
		if (pEthalonVectorObject.empty() == true)
		{
			pEthalonVectorObject = vector<EthalonObjectPixels>();
			pEthalonNumber = 0;

		}
		else if (pEthalonVectorObject.empty() == false)
		{
			pEthalonNumber = pEthalonVectorObject.size();
		}

		cout << "Now We Will Create An Ethalon for an operation" << endl;
		PixelObject pFirstPixel = pOutputFilterResultOneRestored[0];
		EthalonObjectPixels pEthalonArrayObject = GenerateNewEthalonForAPixelVector(pEthalonNumber + 1, pOutputFilterResultOneRestored.size(), 1,
			pFirstPixel.RMask, pFirstPixel.GMask, pFirstPixel.BMask);
		pEthalonVectorObject.push_back(pEthalonArrayObject);



		hr = hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pTopLeftX, pTopLeftY,
			pTopLeftX + pImageWidth,
			pTopLeftY + pImageHeight,
			pRedValueBottom, pRedValueTop,
			pGreenValueBottom, pGreenValueTop,
			pBlueValueBottom, pBlueValueTop,
			pixelObjectVectorTwoPartOne, &pOutputFilterResultTwo);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		 pIndexValue = 0;


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultTwo)
		{

			if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pOutputFilterResultTwo, &pOutputFilterResulTwoRestored);

		cout << "Printing the Results of the Output" << endl;

		
		for (PixelObject pixelObject : pOutputFilterResulTwoRestored)
		{

			if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}
		vector<OutputPixelBufferObjectCounting> pOutputPixelObjectCounting = vector<OutputPixelBufferObjectCounting>();
		vector<PixelObject> pIdenticalPixelObjectBuffer = vector<PixelObject>();
		vector<PixelObject> pDifferentPixelObjectBuffer = vector<PixelObject>();

		cout << "Simulating Our Counting Operation on GPU" << endl;

		cout << "Simulating Our Counting Operation on GPU" << endl;

		hr = ppStandardAlgorithmExecutor->CompareImagePixelsAgainstCoordianteValues(hInstance,
			hWnd, 
			pOutputFilterResulTwoRestored,
			pOutputFilterResultOneRestored,
			&pOutputPixelObjectCounting,
			&pIdenticalPixelObjectBuffer,
			&pDifferentPixelObjectBuffer);
		







		pIndex = 0;
		cout << "Printing out the Output the Experiment" << endl;
		cout << "Printing out the Output the Experiment" << endl;

		for (OutputPixelBufferObjectCounting pOutputPixelValue : pOutputPixelObjectCounting)
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
			cout << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
			cout << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
			cout << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
			cout << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
			cout << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
			cout << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

			cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
			cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

			cout << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
			cout << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

			pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pixelDataFile << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
			pixelDataFile << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
			pixelDataFile << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
			pixelDataFile << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
			pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pixelDataFile << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
			pixelDataFile << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
			pixelDataFile << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
			pixelDataFile << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

			pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
			pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

			pixelDataFile << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
			pixelDataFile << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pixelDataFile << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

			pIndex++;
		}

		cout << "Printing Identical Pixel Array Buffer" << endl;
		pixelDataFile << "Printing Identical Pixel Array Bufffer" << endl;

		for (PixelObject pPixelObject : pIdenticalPixelObjectBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green  Component: " << pPixelObject.GMask << endl;
			cout << "Blue  Component: " << pPixelObject.BMask << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

		}

		cout << "Printing Different Pixel Array Buffer" << endl;
		pixelDataFile << "Printing Different Pixel Array Bufffer" << endl;


		for (PixelObject pPixelObject : pDifferentPixelObjectBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green  Component: " << pPixelObject.GMask << endl;
			cout << "Blue  Component: " << pPixelObject.BMask << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

		}

		int pObjectCountVar = 0.0;


		pObjectCountVar = ComputeTheAmountOfObjectsAgainstEthalon(pEthalonVectorObject[0], pOutputFilterResulTwoRestored);
		ColorObject pOutputColor = ColorObject(0.0f, 0.0f, 0.0f);

		ColorObject pPixelColor = ColorObject(pOutputFilterResulTwoRestored[0].RMask,
			pOutputFilterResulTwoRestored[0].GMask,
			pOutputFilterResulTwoRestored[0].BMask);

		pOutputColor = ComputeColorDifference(pEthalonVectorObject[0].pEthalonColor,
			pPixelColor);

		float pColorDifferenceRed = 0.0f;
		float pColorDifferenceGreen = 0.0f;
		float pColorDifferenceBlue = 0.0f;

		pColorDifferenceRed = pOutputColor.pRedValue;
		pColorDifferenceGreen = pOutputColor.pGreenValue;
		pColorDifferenceBlue = pOutputColor.pBlueValue;

		cout << "Printing Color Differences" << endl;
		cout << "Red Difference: " << pColorDifferenceRed << endl;
		cout << "Green Difference: " << pColorDifferenceGreen << endl;
		cout << "Blue Difference: " << pColorDifferenceBlue << endl;

		pixelDataFile << "Printing Color Differences" << endl;
		pixelDataFile << "Red Difference: " << pColorDifferenceRed << endl;
		pixelDataFile << "Green Difference: " << pColorDifferenceGreen << endl;
		pixelDataFile << "Blue Difference: " << pColorDifferenceBlue << endl;


		cout << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
		cout << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;
		pixelDataFile << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
		pixelDataFile << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;

		cout << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
		pixelDataFile << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
		pixelDataFile.close();

		return hr;

		return hr;

}


ColorObject DirectXGPUDigitalLabCoreModule::ComputeColorDifference(ColorObject pColorOne, ColorObject pColotTwo)
{
	float pColorDifferenceRed = 0.0f;
	float pColorDifferenceGreen = 0.0f;
	float pColorDifferenceBlue = 0.0f;
	
	pColorDifferenceRed = pColotTwo.pRedValue - pColorOne.pRedValue;
	pColorDifferenceGreen = pColotTwo.pGreenValue - pColorOne.pGreenValue;
	pColorDifferenceBlue = pColotTwo.pBlueValue - pColorOne.pBlueValue;

	ColorObject pOutputColor = ColorObject(pColorDifferenceRed,
		pColorDifferenceGreen, pColorDifferenceBlue);
	return pOutputColor;
}

int DirectXGPUDigitalLabCoreModule::ComputeTheAmountOfObjectsAgainstEthalon(EthalonObjectPixels pEthalonObject, vector<PixelObject> pPixelArrayToAnalyze)
{
	int pAmountOfItems = 0;
	int pAmountOfPixelsInsideEthalon = 0;
	pAmountOfPixelsInsideEthalon = pEthalonObject.GetAmountOfPixels();
	pAmountOfItems = (pPixelArrayToAnalyze.size() / pAmountOfPixelsInsideEthalon) + 1;
	return pAmountOfItems;

}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateObjectCountingOperationOnRGBImagesForRedPixelsAgainstEthalon(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CountingObjectsOfCertainColorInsideImages.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;
	int pIndex = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	
	vector<PixelObject> pixelObjectVectorTwoPartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoPartTwo = vector<PixelObject>();


	vector<OutputPixelObjectFiltered> pOutputFilterResultOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pOutputFilterResultTwo = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterResultOneRestored = vector<PixelObject>();
	vector<PixelObject> pOutputFilterResulTwoRestored = vector<PixelObject>();
	vector<OutputPixelBufferObjectCounting> pCountingOperationOutputVector = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelVector = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelVector = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;






	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;





	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;



	cout << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;
	pixelDataFile << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;

	cout << "Our First Step Is To Create an Ethalon" << endl;
	pixelDataFile << "Our First Step Is To Create an Ethalon" << endl;






	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwoPartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartOne)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorTwoPartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartTwo)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}



	pixelObjectVectorTwoPartOne.insert(pixelObjectVectorTwoPartOne.end(), pixelObjectVectorTwoPartTwo.begin(), pixelObjectVectorTwoPartTwo.end());









	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteRedColor(hInstance,
		hWnd,
		pixelObjectVectorTwoPartOne, &pOutputFilterResultTwo);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	cout << "Priniting Filter Output" << endl;
	pixelDataFile << "Prinitng Filter Output" << endl;

	for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultTwo)
	{

		if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
		{
			float pPixelNumber = pIndex;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


	


			pIndex++;
		}
	}






	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResultTwo, &pOutputFilterResulTwoRestored);

	cout << "Printing the Results of the Output" << endl;


	for (PixelObject pixelObject : pOutputFilterResulTwoRestored)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	EthalonObjectPixels pEthalonObject = GetEthalonById(0);
	int pAmountOfItems = 0;
	pAmountOfItems = ComputeTheAmountOfObjectsAgainstEthalon(pEthalonObject, pOutputFilterResulTwoRestored);
	PixelObject pSamplePixel = pOutputFilterResulTwoRestored[0];
	ColorObject pSamplePixelColor = ColorObject(pSamplePixel.RMask, pSamplePixel.GMask, pSamplePixel.BMask);
	ColorObject pEthalonColor = ColorObject(0.0f, 0.0f, 0.0f);
	pEthalonColor = pEthalonObject.GetEthalonColor();
	ColorObject pOutputColor = ColorObject(0.0f, 0.0f, 0.0f);
	pOutputColor = ComputeColorDifference(pEthalonColor, pSamplePixelColor);



	cout << "Printing Color Value Differences" << endl;
	pixelDataFile << "Printing Color Value Differences" << endl;

	cout << "Red Color Difference = " << pOutputColor.pRedValue << endl;
	cout << "Green Color Difference = " << pOutputColor.pGreenValue << endl;
	cout << "Blue Color Difference = " << pOutputColor.pBlueValue << endl;


	pixelDataFile << "Red Color Difference = " << pOutputColor.pRedValue << endl;
	pixelDataFile << "Green Color Difference = " << pOutputColor.pGreenValue << endl;
	pixelDataFile << "Blue Color Difference = " << pOutputColor.pBlueValue << endl;


	cout << "Your Image Contains Amount of ItEMS = " << pAmountOfItems << endl;
	pixelDataFile << "Your Image Contains Amount of ItEMS = " << pAmountOfItems << endl;
	
	
	
	pixelDataFile.close();

	return hr;

}


EthalonObjectPixels DirectXGPUDigitalLabCoreModule::GenerateNewEthalonForAPixelVector(int pEthalonId, float pAmountOfPixels, int pAmountOfItemsInVector, float pRedValueToSelect, float pGreenValueToSelect, float pBlueValueToSelect)
{
	EthalonObjectPixels pEthalonObject = EthalonObjectPixels(pEthalonId, pAmountOfPixels, pAmountOfItemsInVector,
		pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
	return pEthalonObject;
}

EthalonObjectPixels DirectXGPUDigitalLabCoreModule::GetEthalonById(int pEthalonId)
{
	EthalonObjectPixels pOutputEthalon = EthalonObjectPixels(0, 0.0f, 0,
		0.0f, 0.0f, 0.0f);
	for (EthalonObjectPixels pEthalonVar : pEthalonVectorObject)
	{
		int pIdVar = pEthalonVar.GetEthalonId();
		if (pIdVar == pEthalonId)
		{
			pOutputEthalon = pEthalonVar;
		}
	}

	return pOutputEthalon;

}

HRESULT DirectXGPUDigitalLabCoreModule::SimulateObjectCountingOperationOnRGBImagesForRedPixels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CountingObjectsOfCertainColorInsideImages.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	if (pEthalonVectorObject.size() > 0.0f)
	{
		pEthalonVectorObject.clear();

	}

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	vector<PixelObject> pixelObjectVectorOnePartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorOnePartTwo = vector<PixelObject>();

	vector<PixelObject> pixelObjectVectorTwoPartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoPartTwo = vector<PixelObject>();


	vector<OutputPixelObjectFiltered> pOutputFilterResultOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pOutputFilterResultTwo = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterResultOneRestored = vector<PixelObject>();
	vector<PixelObject> pOutputFilterResulTwoRestored = vector<PixelObject>();
	vector<OutputPixelBufferObjectCounting> pCountingOperationOutputVector = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelVector = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelVector = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;






	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;





	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;



	cout << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;
	pixelDataFile << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;

	cout << "Our First Step Is To Create an Ethalon" << endl;
	pixelDataFile << "Our First Step Is To Create an Ethalon" << endl;





	cout << "Clippping image ONE FOR Y AXIS" << endl;
	pixelDataFile << "Clippping image ONE FOR Y AXIS" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorOnePartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorOnePartOne)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOnePartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorOnePartTwo)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());

	cout << "We have Succesfully Loaded Our RGB Pixels for Our Ethalon Creation" << endl;
	pixelDataFile << "We have Succesfully Loaded Our RGB Pixels for Our Ethalon Creation" << endl;


	cout << "Our Next Step Is to filter the Image for Red Pixels" << endl;
	pixelDataFile << "Our Next Step Is to filter the Image for Red Pixels" << endl;

	cout << "Filtering is an operation that takes a Pixel Vector and Marks each pixel with a boolean operator that can be true or false depending on condition" << endl;
	pixelDataFile << "Filtering is an operation that takes a Pixel Vector and Marks each pixel with a boolean operator that can be true or false depending on condition" << endl;

	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteRedColor(hInstance,
		hWnd,
		pixelObjectVectorOnePartOne, &pOutputFilterResultOne);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	UINT pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

UINT pIndexValue = 0;

vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultOne)
{

	if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pRedComponent = pPixelObject.rValue;
		float pGreenComponent = pPixelObject.gValue;
		float pBlueComponent = pPixelObject.bValue;
		bool pUsedInComputations = pPixelObject.pUsedInComputations;


		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Component = " << pRedComponent << endl;
		cout << "Green Component = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Used In Computations = " << pUsedInComputations << endl;

		pixelDataFile << "Step: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "Red Component = " << pRedComponent << endl;
		pixelDataFile << "Green Component = " << pGreenComponent << endl;
		pixelDataFile << "Blue Component = " << pBlueComponent << endl;
		pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


		if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
		{
			pFinalOutputSquare.push_back(pPixelObject);
			pAmountOfFilteredPixels++;
		}



		pIndexValue++;
	}
}



//Восстановление результатов работы фильтра


	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


	cout << "Results Restoration converts filter output back to RGB Pixel Vector" << endl	;
	pixelDataFile << "Results Restoration converts filter output back to RGB Pixel Vector" << endl;

	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
	pOutputFilterResultOne, &pOutputFilterResultOneRestored);

cout << "Printing the Results of the Output" << endl;

vector<float> pXPositionValues = vector<float>();
vector<float> pYPositionValues = vector<float>();

for (PixelObject pixelObject : pOutputFilterResultOneRestored)
{

	if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

	}
}

	int pEthalonNumber = 0;
	if (pEthalonVectorObject.empty() == true)
	{
		pEthalonVectorObject = vector<EthalonObjectPixels>();
		pEthalonNumber = 0;

	}
else if (pEthalonVectorObject.empty() == false)
	{
		pEthalonNumber = pEthalonVectorObject.size();
}

	cout << "Now We Will Create An Ethalon for an operation" << endl;
	PixelObject pFirstPixel = pOutputFilterResultOneRestored[0];
	EthalonObjectPixels pEthalonArrayObject = GenerateNewEthalonForAPixelVector(pEthalonNumber + 1, pOutputFilterResultOneRestored.size(), 1,
		pFirstPixel.RMask, pFirstPixel.GMask, pFirstPixel.BMask);
	pEthalonVectorObject.push_back(pEthalonArrayObject);


	cout << "Now WE WILL Validate an image Using Ethalon" << endl;;

	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwoPartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartOne)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
		cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorTwoPartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartTwo)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}




	pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());
	pixelObjectVectorTwoPartOne.insert(pixelObjectVectorTwoPartOne.end(), pixelObjectVectorTwoPartTwo.begin(), pixelObjectVectorTwoPartTwo.end());









	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteRedColor(hInstance,
		hWnd,
		pixelObjectVectorTwoPartOne, &pOutputFilterResultTwo);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	 pIndexValue = 0;

	

	for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultTwo)
	{

		if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
		{
			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
			{
				pFinalOutputSquare.push_back(pPixelObject);
				pAmountOfFilteredPixels++;
			}



			pIndexValue++;
		}
	}






	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResultTwo, &pOutputFilterResulTwoRestored);

	cout << "Printing the Results of the Output" << endl;


	for (PixelObject pixelObject : pOutputFilterResulTwoRestored)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}



	vector<OutputPixelObjectWithAngleValues> pOutputPixelObjectLocalizedOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pOutputPixelObjectLocalizedTwo = vector<OutputPixelObjectWithAngleValues>();

	cout << "Simulating Our Counting Operation on GPU" << endl;


	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd,
		pCentre.xPosition,
		pCentre.yPosition,
		pOutputFilterResultOneRestored,
		&pOutputPixelObjectLocalizedOne);


	cout << "Printing Sector Clusters Data " << endl;
	pixelDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObjectLocalizedOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}


	cout << "Simulating Our Counting Operation on GPU" << endl;


	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd,
		pCentre.xPosition,
		pCentre.yPosition,
		pOutputFilterResulTwoRestored,
		&pOutputPixelObjectLocalizedTwo);


	cout << "Printing Sector Clusters Data " << endl;
	pixelDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObjectLocalizedTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}

	vector<PixelObject> pPolarVectorOne = vector<PixelObject>();
	vector<PixelObject> pPolarVectorTwo = vector<PixelObject>();

	hr = ppStandardAlgorithmExecutor->RestorePolarNotationOfPixels(hInstance,
		hWnd, pOutputPixelObjectLocalizedOne, &pPolarVectorOne);

	for (PixelObject pixelObject : pPolarVectorOne)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}


	hr = ppStandardAlgorithmExecutor->RestorePolarNotationOfPixels(hInstance,
		hWnd, pOutputPixelObjectLocalizedTwo, &pPolarVectorTwo);

	for (PixelObject pixelObject : pPolarVectorTwo)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}
	
	vector<OutputPixelBufferObjectCounting> pOutputArrayCounting = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelBuffer = vector<PixelObject>();
	vector<PixelObject> pDifferentlPixelBuffer = vector<PixelObject>();

	hr = ppStandardAlgorithmExecutor->CompareImagePixelsAgainstCoordianteValues(hInstance,
		hWnd, pPolarVectorOne,
		pPolarVectorTwo,
		&pOutputArrayCounting,
		&pIdenticalPixelBuffer,
		&pDifferentlPixelBuffer);









	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferObjectCounting pOutputPixelValue : pOutputArrayCounting)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		cout << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		cout << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		cout << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		cout << "X Difference = " << pOutputPixelValue.pXDifferenceValue << endl;
		cout << "Y Difference = " << pOutputPixelValue.pYDifferenceValue << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		cout << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		cout << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		cout << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		cout << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		cout << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		pixelDataFile << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		pixelDataFile << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		pixelDataFile << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		pixelDataFile << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		pixelDataFile << "X Difference = " << pOutputPixelValue.pXDifferenceValue << endl;
		pixelDataFile << "Y Difference = " << pOutputPixelValue.pYDifferenceValue << endl;
		pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		pixelDataFile << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		pixelDataFile << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		pixelDataFile << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		pixelDataFile << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		pixelDataFile << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		pixelDataFile << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		pixelDataFile << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing Identical Pixel Array Buffer" << endl;
	pixelDataFile << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	cout << "Printing Different Pixel Array Buffer" << endl;
	pixelDataFile << "Printing Different Pixel Array Bufffer" << endl;


	for (PixelObject pPixelObject : pDifferentlPixelBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	int pObjectCountVar = 0.0;


	pObjectCountVar = ComputeTheAmountOfObjectsAgainstEthalon(pEthalonVectorObject[0], pOutputFilterResulTwoRestored);
	ColorObject pOutputColor = ColorObject(0.0f, 0.0f, 0.0f);

	ColorObject pPixelColor = ColorObject(pOutputFilterResulTwoRestored[0].RMask,
		pOutputFilterResulTwoRestored[0].GMask,
		pOutputFilterResulTwoRestored[0].BMask);

	pOutputColor = ComputeColorDifference(pEthalonVectorObject[0].pEthalonColor,
		pPixelColor);

	float pColorDifferenceRed = 0.0f;
	float pColorDifferenceGreen = 0.0f;
	float pColorDifferenceBlue = 0.0f;

	pColorDifferenceRed = pOutputColor.pRedValue;
	pColorDifferenceGreen = pOutputColor.pGreenValue;
	pColorDifferenceBlue = pOutputColor.pBlueValue;

	cout << "Printing Color Differences" << endl;
	cout << "Red Difference: " << pColorDifferenceRed << endl;
	cout << "Green Difference: " << pColorDifferenceGreen << endl;
	cout << "Blue Difference: " << pColorDifferenceBlue << endl;

	pixelDataFile << "Printing Color Differences" << endl;
	pixelDataFile << "Red Difference: " << pColorDifferenceRed << endl;
	pixelDataFile << "Green Difference: " << pColorDifferenceGreen << endl;
	pixelDataFile << "Blue Difference: " << pColorDifferenceBlue << endl;


	cout << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
	cout << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;
	pixelDataFile << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
	pixelDataFile << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;

	cout << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
	pixelDataFile << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
	pixelDataFile.close();

	return hr;

}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateObjectCountingOperationOnRGBImagesForGreenPixels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CountingObjectsOfCertainColorInsideImages.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	if (pEthalonVectorObject.size() > 0.0f)
	{
		pEthalonVectorObject.clear();

	}

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	vector<PixelObject> pixelObjectVectorOnePartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorOnePartTwo = vector<PixelObject>();

	vector<PixelObject> pixelObjectVectorTwoPartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoPartTwo = vector<PixelObject>();


	vector<OutputPixelObjectFiltered> pOutputFilterResultOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pOutputFilterResultTwo = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterResultOneRestored = vector<PixelObject>();
	vector<PixelObject> pOutputFilterResulTwoRestored = vector<PixelObject>();
	vector<OutputPixelBufferObjectCounting> pCountingOperationOutputVector = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelVector = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelVector = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;






	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;





	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;



	cout << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;
	pixelDataFile << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;

	cout << "Our First Step Is To Create an Ethalon" << endl;
	pixelDataFile << "Our First Step Is To Create an Ethalon" << endl;





	cout << "Clippping image ONE FOR Y AXIS" << endl;
	pixelDataFile << "Clippping image ONE FOR Y AXIS" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorOnePartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorOnePartOne)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOnePartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorOnePartTwo)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());

	cout << "We have Succesfully Loaded Our RGB Pixels for Our Ethalon Creation" << endl;
	pixelDataFile << "We have Succesfully Loaded Our RGB Pixels for Our Ethalon Creation" << endl;


	cout << "Our Next Step Is to filter the Image for Red Pixels" << endl;
	pixelDataFile << "Our Next Step Is to filter the Image for Red Pixels" << endl;

	cout << "Filtering is an operation that takes a Pixel Vector and Marks each pixel with a boolean operator that can be true or false depending on condition" << endl;
	pixelDataFile << "Filtering is an operation that takes a Pixel Vector and Marks each pixel with a boolean operator that can be true or false depending on condition" << endl;

	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteGreenColor(hInstance,
		hWnd,
		pixelObjectVectorOnePartOne, &pOutputFilterResultOne);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	UINT pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	UINT pIndexValue = 0;

	vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


	for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultOne)
	{

		if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
		{
			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
			{
				pFinalOutputSquare.push_back(pPixelObject);
				pAmountOfFilteredPixels++;
			}



			pIndexValue++;
		}
	}



	//Восстановление результатов работы фильтра


	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


	cout << "Results Restoration converts filter output back to RGB Pixel Vector" << endl;
	pixelDataFile << "Results Restoration converts filter output back to RGB Pixel Vector" << endl;

	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResultOne, &pOutputFilterResultOneRestored);

	cout << "Printing the Results of the Output" << endl;

	vector<float> pXPositionValues = vector<float>();
	vector<float> pYPositionValues = vector<float>();

	for (PixelObject pixelObject : pOutputFilterResultOneRestored)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	int pEthalonNumber = 0;
	if (pEthalonVectorObject.empty() == true)
	{
		pEthalonVectorObject = vector<EthalonObjectPixels>();
		pEthalonNumber = 0;

	}
	else if (pEthalonVectorObject.empty() == false)
	{
		pEthalonNumber = pEthalonVectorObject.size();
	}

	cout << "Now We Will Create An Ethalon for an operation" << endl;
	PixelObject pFirstPixel = pOutputFilterResultOneRestored[0];
	EthalonObjectPixels pEthalonArrayObject = GenerateNewEthalonForAPixelVector(pEthalonNumber + 1, pOutputFilterResultOneRestored.size(), 1,
		pFirstPixel.RMask, pFirstPixel.GMask, pFirstPixel.BMask);
	pEthalonVectorObject.push_back(pEthalonArrayObject);


	cout << "Now WE WILL Validate an image Using Ethalon" << endl;;

	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwoPartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartOne)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorTwoPartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartTwo)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}




	pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());
	pixelObjectVectorTwoPartOne.insert(pixelObjectVectorTwoPartOne.end(), pixelObjectVectorTwoPartTwo.begin(), pixelObjectVectorTwoPartTwo.end());









	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteGreenColor(hInstance,
		hWnd,
		pixelObjectVectorTwoPartOne, &pOutputFilterResultTwo);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;



	for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultTwo)
	{

		if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
		{
			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
			{
				pFinalOutputSquare.push_back(pPixelObject);
				pAmountOfFilteredPixels++;
			}



			pIndexValue++;
		}
	}






	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResultTwo, &pOutputFilterResulTwoRestored);

	cout << "Printing the Results of the Output" << endl;


	for (PixelObject pixelObject : pOutputFilterResulTwoRestored)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}



	vector<OutputPixelObjectWithAngleValues> pOutputPixelObjectLocalizedOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pOutputPixelObjectLocalizedTwo = vector<OutputPixelObjectWithAngleValues>();

	cout << "Simulating Our Counting Operation on GPU" << endl;


	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd,
		pCentre.xPosition,
		pCentre.yPosition,
		pOutputFilterResultOneRestored,
		&pOutputPixelObjectLocalizedOne);


	cout << "Printing Sector Clusters Data " << endl;
	pixelDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObjectLocalizedOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}


	cout << "Simulating Our Counting Operation on GPU" << endl;


	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd,
		pCentre.xPosition,
		pCentre.yPosition,
		pOutputFilterResulTwoRestored,
		&pOutputPixelObjectLocalizedTwo);


	cout << "Printing Sector Clusters Data " << endl;
	pixelDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObjectLocalizedTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}

	vector<PixelObject> pPolarVectorOne = vector<PixelObject>();
	vector<PixelObject> pPolarVectorTwo = vector<PixelObject>();

	hr = ppStandardAlgorithmExecutor->RestorePolarNotationOfPixels(hInstance,
		hWnd, pOutputPixelObjectLocalizedOne, &pPolarVectorOne);

	for (PixelObject pixelObject : pPolarVectorOne)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}


	hr = ppStandardAlgorithmExecutor->RestorePolarNotationOfPixels(hInstance,
		hWnd, pOutputPixelObjectLocalizedTwo, &pPolarVectorTwo);

	for (PixelObject pixelObject : pPolarVectorTwo)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	vector<OutputPixelBufferObjectCounting> pOutputArrayCounting = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelBuffer = vector<PixelObject>();
	vector<PixelObject> pDifferentlPixelBuffer = vector<PixelObject>();

	hr = ppStandardAlgorithmExecutor->CompareImagePixelsAgainstCoordianteValues(hInstance,
		hWnd, pPolarVectorOne,
		pPolarVectorTwo,
		&pOutputArrayCounting,
		&pIdenticalPixelBuffer,
		&pDifferentlPixelBuffer);









	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferObjectCounting pOutputPixelValue : pOutputArrayCounting)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		cout << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		cout << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		cout << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		cout << "X Difference = " << pOutputPixelValue.pXDifferenceValue << endl;
		cout << "Y Difference = " << pOutputPixelValue.pYDifferenceValue << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		cout << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		cout << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		cout << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		cout << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		cout << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		pixelDataFile << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		pixelDataFile << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		pixelDataFile << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		pixelDataFile << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		pixelDataFile << "X Difference = " << pOutputPixelValue.pXDifferenceValue << endl;
		pixelDataFile << "Y Difference = " << pOutputPixelValue.pYDifferenceValue << endl;
		pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		pixelDataFile << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		pixelDataFile << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		pixelDataFile << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		pixelDataFile << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		pixelDataFile << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		pixelDataFile << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		pixelDataFile << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing Identical Pixel Array Buffer" << endl;
	pixelDataFile << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	cout << "Printing Different Pixel Array Buffer" << endl;
	pixelDataFile << "Printing Different Pixel Array Bufffer" << endl;


	for (PixelObject pPixelObject : pDifferentlPixelBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	int pObjectCountVar = 0.0;


	pObjectCountVar = ComputeTheAmountOfObjectsAgainstEthalon(pEthalonVectorObject[0], pOutputFilterResulTwoRestored);
	ColorObject pOutputColor = ColorObject(0.0f, 0.0f, 0.0f);

	ColorObject pPixelColor = ColorObject(pOutputFilterResulTwoRestored[0].RMask,
		pOutputFilterResulTwoRestored[0].GMask,
		pOutputFilterResulTwoRestored[0].BMask);

	pOutputColor = ComputeColorDifference(pEthalonVectorObject[0].pEthalonColor,
		pPixelColor);

	float pColorDifferenceRed = 0.0f;
	float pColorDifferenceGreen = 0.0f;
	float pColorDifferenceBlue = 0.0f;

	pColorDifferenceRed = pOutputColor.pRedValue;
	pColorDifferenceGreen = pOutputColor.pGreenValue;
	pColorDifferenceBlue = pOutputColor.pBlueValue;

	cout << "Printing Color Differences" << endl;
	cout << "Red Difference: " << pColorDifferenceRed << endl;
	cout << "Green Difference: " << pColorDifferenceGreen << endl;
	cout << "Blue Difference: " << pColorDifferenceBlue << endl;

	pixelDataFile << "Printing Color Differences" << endl;
	pixelDataFile << "Red Difference: " << pColorDifferenceRed << endl;
	pixelDataFile << "Green Difference: " << pColorDifferenceGreen << endl;
	pixelDataFile << "Blue Difference: " << pColorDifferenceBlue << endl;


	cout << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
	cout << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;
	pixelDataFile << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
	pixelDataFile << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;

	cout << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
	pixelDataFile << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
	pixelDataFile.close();

	return hr;

}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateObjectCountingOperationOnRGBImagesForBluePixels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CountingObjectsOfCertainColorInsideImages.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	if (pEthalonVectorObject.size() > 0.0f)
	{
		pEthalonVectorObject.clear();

	}

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	vector<PixelObject> pixelObjectVectorOnePartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorOnePartTwo = vector<PixelObject>();

	vector<PixelObject> pixelObjectVectorTwoPartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoPartTwo = vector<PixelObject>();


	vector<OutputPixelObjectFiltered> pOutputFilterResultOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pOutputFilterResultTwo = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterResultOneRestored = vector<PixelObject>();
	vector<PixelObject> pOutputFilterResulTwoRestored = vector<PixelObject>();
	vector<OutputPixelBufferObjectCounting> pCountingOperationOutputVector = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelVector = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelVector = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;






	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;





	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;



	cout << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;
	pixelDataFile << "Now We are Setting up an Experiment for Validation of images using Ethalon" << endl;

	cout << "Our First Step Is To Create an Ethalon" << endl;
	pixelDataFile << "Our First Step Is To Create an Ethalon" << endl;





	cout << "Clippping image ONE FOR Y AXIS" << endl;
	pixelDataFile << "Clippping image ONE FOR Y AXIS" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorOnePartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorOnePartOne)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOnePartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorOnePartTwo)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());

	cout << "We have Succesfully Loaded Our RGB Pixels for Our Ethalon Creation" << endl;
	pixelDataFile << "We have Succesfully Loaded Our RGB Pixels for Our Ethalon Creation" << endl;


	cout << "Our Next Step Is to filter the Image for Red Pixels" << endl;
	pixelDataFile << "Our Next Step Is to filter the Image for Red Pixels" << endl;

	cout << "Filtering is an operation that takes a Pixel Vector and Marks each pixel with a boolean operator that can be true or false depending on condition" << endl;
	pixelDataFile << "Filtering is an operation that takes a Pixel Vector and Marks each pixel with a boolean operator that can be true or false depending on condition" << endl;

	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteBlueColor(hInstance,
		hWnd,
		pixelObjectVectorOnePartOne, &pOutputFilterResultOne);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	UINT pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	UINT pIndexValue = 0;

	vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


	for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultOne)
	{

		if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
		{
			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
			{
				pFinalOutputSquare.push_back(pPixelObject);
				pAmountOfFilteredPixels++;
			}



			pIndexValue++;
		}
	}



	//Восстановление результатов работы фильтра


	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


	cout << "Results Restoration converts filter output back to RGB Pixel Vector" << endl;
	pixelDataFile << "Results Restoration converts filter output back to RGB Pixel Vector" << endl;

	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResultOne, &pOutputFilterResultOneRestored);

	cout << "Printing the Results of the Output" << endl;

	vector<float> pXPositionValues = vector<float>();
	vector<float> pYPositionValues = vector<float>();

	for (PixelObject pixelObject : pOutputFilterResultOneRestored)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	int pEthalonNumber = 0;
	if (pEthalonVectorObject.empty() == true)
	{
		pEthalonVectorObject = vector<EthalonObjectPixels>();
		pEthalonNumber = 0;

	}
	else if (pEthalonVectorObject.empty() == false)
	{
		pEthalonNumber = pEthalonVectorObject.size();
	}

	cout << "Now We Will Create An Ethalon for an operation" << endl;
	PixelObject pFirstPixel = pOutputFilterResultOneRestored[0];
	EthalonObjectPixels pEthalonArrayObject = GenerateNewEthalonForAPixelVector(pEthalonNumber + 1, pOutputFilterResultOneRestored.size(), 1,
		pFirstPixel.RMask, pFirstPixel.GMask, pFirstPixel.BMask);
	pEthalonVectorObject.push_back(pEthalonArrayObject);


	cout << "Now WE WILL Validate an image Using Ethalon" << endl;;

	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwoPartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartOne)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}


	cout << "Clipping for X Position" << endl;
	pixelDataFile << "Clipping for X Position" << endl;




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorTwoPartTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorTwoPartTwo)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}




	pixelObjectVectorOnePartOne.insert(pixelObjectVectorOnePartOne.end(), pixelObjectVectorOnePartTwo.begin(), pixelObjectVectorOnePartTwo.end());
	pixelObjectVectorTwoPartOne.insert(pixelObjectVectorTwoPartOne.end(), pixelObjectVectorTwoPartTwo.begin(), pixelObjectVectorTwoPartTwo.end());









	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteBlueColor(hInstance,
		hWnd,
		pixelObjectVectorTwoPartOne, &pOutputFilterResultTwo);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;



	for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResultTwo)
	{

		if ((pPixelObject.rValue != 255.0f) || (pPixelObject.gValue != 255.0f) || (pPixelObject.bValue != 255.0f))
		{
			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
			{
				pFinalOutputSquare.push_back(pPixelObject);
				pAmountOfFilteredPixels++;
			}



			pIndexValue++;
		}
	}






	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResultTwo, &pOutputFilterResulTwoRestored);

	cout << "Printing the Results of the Output" << endl;


	for (PixelObject pixelObject : pOutputFilterResulTwoRestored)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}



	vector<OutputPixelObjectWithAngleValues> pOutputPixelObjectLocalizedOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pOutputPixelObjectLocalizedTwo = vector<OutputPixelObjectWithAngleValues>();

	cout << "Simulating Our Counting Operation on GPU" << endl;


	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd,
		pCentre.xPosition,
		pCentre.yPosition,
		pOutputFilterResultOneRestored,
		&pOutputPixelObjectLocalizedOne);


	cout << "Printing Sector Clusters Data " << endl;
	pixelDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObjectLocalizedOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}


	cout << "Simulating Our Counting Operation on GPU" << endl;


	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd,
		pCentre.xPosition,
		pCentre.yPosition,
		pOutputFilterResulTwoRestored,
		&pOutputPixelObjectLocalizedTwo);


	cout << "Printing Sector Clusters Data " << endl;
	pixelDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObjectLocalizedTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}

	vector<PixelObject> pPolarVectorOne = vector<PixelObject>();
	vector<PixelObject> pPolarVectorTwo = vector<PixelObject>();

	hr = ppStandardAlgorithmExecutor->RestorePolarNotationOfPixels(hInstance,
		hWnd, pOutputPixelObjectLocalizedOne, &pPolarVectorOne);

	for (PixelObject pixelObject : pPolarVectorOne)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}


	hr = ppStandardAlgorithmExecutor->RestorePolarNotationOfPixels(hInstance,
		hWnd, pOutputPixelObjectLocalizedTwo, &pPolarVectorTwo);

	for (PixelObject pixelObject : pPolarVectorTwo)
	{

		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	vector<OutputPixelBufferObjectCounting> pOutputArrayCounting = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelBuffer = vector<PixelObject>();
	vector<PixelObject> pDifferentlPixelBuffer = vector<PixelObject>();

	hr = ppStandardAlgorithmExecutor->CompareImagePixelsAgainstCoordianteValues(hInstance,
		hWnd, pPolarVectorOne,
		pPolarVectorTwo,
		&pOutputArrayCounting,
		&pIdenticalPixelBuffer,
		&pDifferentlPixelBuffer);









	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferObjectCounting pOutputPixelValue : pOutputArrayCounting)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		cout << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		cout << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		cout << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		cout << "X Difference = " << pOutputPixelValue.pXDifferenceValue << endl;
		cout << "Y Difference = " << pOutputPixelValue.pYDifferenceValue << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		cout << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		cout << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		cout << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		cout << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		cout << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		pixelDataFile << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		pixelDataFile << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		pixelDataFile << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		pixelDataFile << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		pixelDataFile << "X Difference = " << pOutputPixelValue.pXDifferenceValue << endl;
		pixelDataFile << "Y Difference = " << pOutputPixelValue.pYDifferenceValue << endl;
		pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		pixelDataFile << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		pixelDataFile << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		pixelDataFile << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		pixelDataFile << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		pixelDataFile << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		pixelDataFile << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		pixelDataFile << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		pixelDataFile << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing Identical Pixel Array Buffer" << endl;
	pixelDataFile << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	cout << "Printing Different Pixel Array Buffer" << endl;
	pixelDataFile << "Printing Different Pixel Array Bufffer" << endl;


	for (PixelObject pPixelObject : pDifferentlPixelBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red  Component: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green  Component: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	int pObjectCountVar = 0.0;


	pObjectCountVar = ComputeTheAmountOfObjectsAgainstEthalon(pEthalonVectorObject[0], pOutputFilterResulTwoRestored);
	ColorObject pOutputColor = ColorObject(0.0f, 0.0f, 0.0f);

	ColorObject pPixelColor = ColorObject(pOutputFilterResulTwoRestored[0].RMask,
		pOutputFilterResulTwoRestored[0].GMask,
		pOutputFilterResulTwoRestored[0].BMask);

	pOutputColor = ComputeColorDifference(pEthalonVectorObject[0].pEthalonColor,
		pPixelColor);

	float pColorDifferenceRed = 0.0f;
	float pColorDifferenceGreen = 0.0f;
	float pColorDifferenceBlue = 0.0f;

	pColorDifferenceRed = pOutputColor.pRedValue;
	pColorDifferenceGreen = pOutputColor.pGreenValue;
	pColorDifferenceBlue = pOutputColor.pBlueValue;

	cout << "Printing Color Differences" << endl;
	cout << "Red Difference: " << pColorDifferenceRed << endl;
	cout << "Green Difference: " << pColorDifferenceGreen << endl;
	cout << "Blue Difference: " << pColorDifferenceBlue << endl;

	pixelDataFile << "Printing Color Differences" << endl;
	pixelDataFile << "Red Difference: " << pColorDifferenceRed << endl;
	pixelDataFile << "Green Difference: " << pColorDifferenceGreen << endl;
	pixelDataFile << "Blue Difference: " << pColorDifferenceBlue << endl;


	cout << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
	cout << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;
	pixelDataFile << "Ethalon Area in Pixels = " << pOutputFilterResultOneRestored.size() << endl;
	pixelDataFile << "Sample Image Area in Pixels = " << pOutputFilterResulTwoRestored.size() << endl;

	cout << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
	pixelDataFile << "Your Image Contains Amount of ItEMS = " << pObjectCountVar << endl;
	pixelDataFile.close();

	return hr;

}




HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithYConstantAndXBreakpoint(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\SectorizeImagesForYConstantAndXBreakpoint.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;



	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectFiltered>  pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterResultRestored = vector<PixelObject>();
	vector<FilterPixelLabel> pOutputFilterResultsLabelled = vector<FilterPixelLabel>();
	vector<PixelObject> pSectorOneArray = vector<PixelObject>();
	vector<PixelObject> pSectorTwoArray = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();
	vector<FilterPixelLabel> pFilterPixelLabelVector = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;

	float pYConstantValue = 0.0f;
	float pXThresold = 0.0f;





	cout << "Enter the Value for Y Constant" << endl;
	cin >> pYConstantValue;
	cout << "Enter the Value for X thresold" << endl;
	cin >> pXThresold;

	cout << "Y Constant Value For Segmentation = " << pYConstantValue << endl;
	cout << "X Thresold Value for Segmentation = " << pXThresold << endl;
	pixelDataFile << "X Constant Value For Segmentation = " << pYConstantValue << endl;
	pixelDataFile << "Y Thresold Value for Segmentation = " << pXThresold << endl;



	int pClassOneLabel = 0;
	int pClassTwoLabel = 0;
	int pInvalidLabel = 0;

	cout << "Enter the Value for Sector One Label" << endl;
	cin >> pClassOneLabel;
	cout << "Enter the Value for Sector Two Label" << endl;
	cin >> pClassTwoLabel;
	cout << "Enter the Value for Invalid Label" << endl;
	cin >> pInvalidLabel;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	cout << "Vocabulary Block: " << endl;

	cout << "Y Constant: " << pYConstantValue << endl;
	cout << "X Barrier: " << pXThresold << endl;

	cout << "Sector One Label = " << pClassOneLabel << endl;
	cout << "Sector Two Label = " << pClassTwoLabel << endl;
	cout << "Invalid Label = " << pInvalidLabel << endl;


	pixelDataFile << "Vocabulary Block: " << endl;

	pixelDataFile << "Y Constant: " << pYConstantValue << endl;
	pixelDataFile << "X Barrier: " << pXThresold << endl;
	pixelDataFile << "Sector One Label = " << pClassOneLabel << endl;
	pixelDataFile << "Sector Two Label = " << pClassTwoLabel << endl;
	pixelDataFile << "Invalid Label = " << pInvalidLabel << endl;

	cout << "Y Constant: " << pYConstantValue << endl;
	cout << "X Barrier: " << pYConstantValue << endl;
	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	
	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip X" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		pixelDataFile << "New Image Clip Y" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		 pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}


		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());





		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pTopLeftX,
			pTopLeftY,
			pTopLeftX + pImageWidth,
			pTopLeftY + pImageHeight,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVectorOne, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pFinalOutputSquare, &pOutputFilterResultRestored);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pOutputFilterResultRestored)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}

	

		hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(
			hInstance,
			hWnd,
			pYConstantValue,
			pXThresold,
			pClassOneLabel,
			pClassTwoLabel,
			pInvalidLabel,
			pOutputFilterResultRestored,
			&pFilterPixelLabelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

	
		for (FilterPixelLabel pPixelObject : pFilterPixelLabelVector)
		{


			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				int pSectorNumber = pPixelObject.pSectorNumberValue;
				bool pUsedInComputations = pPixelObject.pixelNumber;

				if ((pUsedInComputations == true) || (pUsedInComputations == 255))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Sector Value: " << pSectorNumber << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Sector Value: " << pSectorNumber << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}



			pIndexValue++;
		}



	}

	int pSectorToSelect = 0;
	pSectorToSelect = pClassOneLabel;

	cout << "Restoring Pixels for Sector One" << endl;
	pixelDataFile << "Restoring Pixels for Sector One" << endl;

	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
		hWnd,
		pSectorToSelect,
		pFilterPixelLabelVector,
		&pSectorOneArray);

	for (PixelObject pixelObject : pSectorOneArray)
	{

		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Restoring Pixels for Sector two" << endl;
	pixelDataFile << "Restoring Pixels for Sector two" << endl;
	pSectorToSelect = pClassTwoLabel;

	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
		hWnd,
		pSectorToSelect,
		pFilterPixelLabelVector,
		&pSectorTwoArray);

	for (PixelObject pixelObject : pSectorTwoArray)
	{

		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}


	





	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	
	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SelectPixelsFromImageWithPredominantRedColor(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorOne);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}




		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}


		pixelObjectVectorOne.insert(pixelObjectVectorOne.end(), pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());
		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteRedColor(hInstance, hWnd,
			pixelObjectVectorOne, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{


			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;

				if ((pUsedInComputations == true) || (pUsedInComputations == 255))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}



			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}

	}





	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SelectPixelsFromImageWithPredominantGreenColor(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteGreenColor(hInstance, hWnd,
			pixelObjectVector, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{


			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;

				if ((pUsedInComputations == true) || (pUsedInComputations == 255))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}



			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}

	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SelectPixelsFromImageWithPredominantBlueColor(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBUndiscreteBlueColor(hInstance, hWnd,
			pixelObjectVector, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{


			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;

				if ((pUsedInComputations == true) || (pUsedInComputations == 255))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}



			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{
		if ((pixelObject.RMask != 255.0f) || (pixelObject.GMask != 255.0f) || (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}

	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::FilterSelectedImageForYPositionValue(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\FilterSelectedImageForYPositionValues.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	vector<FilterPixelLabel> pOutputFilterResultsLabelled = vector<FilterPixelLabel>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;




	int pClassOneLabel = 0;
	int pClassTwoLabel = 0;
	int pInvalidLabel = 0;
	float pYConstantValue0 = 0.0F;
	float pCentreX = 0.0F;

	cout << "Enter the Value for Sector One Label" << endl;
	cin >> pClassOneLabel;
	cout << "Enter the Value for Sector Two Label" << endl;
	cin >> pClassTwoLabel;
	cout << "Enter the Value for Invalid Label" << endl;
	cin >> pInvalidLabel;
	cout << "Enter the Y Value for Constant" << endl;
	cin >> pYConstantValue0;
	cout << "Enter the X Value for Thresold" << endl;
	cin >> pCentreX;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	cout << "Vocabulary Block: " << endl;
	cout << "Sector One Label = " << pClassOneLabel << endl;
	cout << "Sector Two Label = " << pClassTwoLabel << endl;
	cout << "Invalid Label = " << pInvalidLabel << endl;



	pixelDataFile << "Vocabulary Block: " << endl;
	pixelDataFile << "Sector One Label = " << pClassOneLabel << endl;
	pixelDataFile << "Sector Two Label = " << pClassTwoLabel << endl;
	pixelDataFile << "Invalid Label = " << pInvalidLabel << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}


		cout << "Clipping for X Position" << endl;
		pixelDataFile << "Clipping for X Position" << endl;




		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());





		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;







		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pTopLeftX,
			pTopLeftY,
			pTopLeftX + pImageWidth,
			pTopLeftY + pImageHeight,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVectorOne, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pFinalOutputSquare, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();
		int pSectorToRestore = 0;

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}



		vector<FilterPixelLabel> pFilterPixelLabelVector = vector<FilterPixelLabel>();
		hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(
			hInstance,
			hWnd,
			pYConstantValue0,
			pCentreX,
			pClassOneLabel,
			pClassTwoLabel,
			pInvalidLabel,
			pFilterToReverseOutput,
			&pFilterPixelLabelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;



		for (FilterPixelLabel pPixelObject : pFilterPixelLabelVector)
		{


			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				int pSectorNumber = pPixelObject.pSectorNumberValue;
				bool pUsedInComputations = pPixelObject.pIsPixelValid;

				if ((pUsedInComputations == true) || (pUsedInComputations == 255))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Sector Value: " << pSectorNumber << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Sector Value: " << pSectorNumber << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}



			pIndexValue++;
		}


		vector<PixelObject> pSectorOneArray = vector<PixelObject>();
		vector<PixelObject> pSectorTwoArray = vector<PixelObject>();

		cout << "Restoring Pixels for Sector One" << endl;
		pixelDataFile << "Restoring Pixels for Sector One" << endl;
		pSectorToRestore = pClassOneLabel;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			pSectorToRestore,
			pFilterPixelLabelVector,
			&pSectorOneArray);

		for (PixelObject pixelObject : pSectorOneArray)
		{

			
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			
		}

		cout << "Restoring Pixels for Sector Two" << endl;
		pixelDataFile << "Restoring Pixels for Sector Two" << endl;
		pSectorToRestore = pClassTwoLabel;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			pSectorToRestore,
			pFilterPixelLabelVector,
			&pSectorTwoArray);

		for (PixelObject pixelObject : pSectorTwoArray)
		{

			
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			
		}

	}

	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::FilterSelectedImageForXPositionValue(HINSTANCE hInstance, HWND hWnd)
{

		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\FilterSelectedImageForXPositionValue.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;

		Point2D pCentre;
		pCentre.xPosition = 430.0f;
		pCentre.yPosition = 410.0f;

		vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
		vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
		vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
		vector<FilterPixelLabel> pOutputFilterResultsLabelled = vector<FilterPixelLabel>();

		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;

		cout << "Enter the step to scan X Axis" << endl;
		cin >> pStepX;

		cout << "Enter the step to scan Y Axis" << endl;
		cin >> pStepY;

		float pRedValueBottom = 0.0f;
		float pRedValueTop = 0.0f;
		float pGreenValueBottom = 0.0f;
		float pGreenValueTop = 0.0f;
		float pBlueValueBottom = 0.0f;
		float pBlueValueTop = 0.0f;

		cout << "Enter the Lowest Value for Red Component" << endl;
		cin >> pRedValueBottom;

		cout << "Enter the Highest Value for Red Component" << endl;
		cin >> pRedValueTop;

		cout << "Enter the Lowest Value for Green Component" << endl;
		cin >> pGreenValueBottom;

		cout << "Enter the Lowest Value for Green Component" << endl;
		cin >> pGreenValueTop;

		cout << "Enter the Lowest Value for Blue Component" << endl;
		cin >> pBlueValueBottom;

		cout << "Enter the Lowest Value for Blue Component" << endl;
		cin >> pBlueValueTop;

	


		int pClassOneLabel = 0;
		int pClassTwoLabel = 0;
		int pInvalidLabel = 0;
		float pXConstantValue0 = 0.0F;
		float pCentreY = 0.0F;

		cout << "Enter the Value for Sector One Label" << endl;
		cin >> pClassOneLabel;
		cout << "Enter the Value for Sector Two Label" << endl;
		cin >> pClassTwoLabel;
		cout << "Enter the Value for Invalid Label" << endl;
		cin >> pInvalidLabel;
		cout << "Enter the X Value for Constant" << endl;
		cin >> pXConstantValue0;
		cout << "Enter the Y Value for Thresold" << endl;
		cin >> pCentreY;





		cout << "Top Left X Position = " << pTopLeftX << endl;
		cout << "Top Left Y Position = " << pTopLeftY << endl;
		cout << "Image Width = " << pImageWidth << endl;
		cout << "Image Height = " << pImageWidth << endl;

		pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
		pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
		pixelDataFile << "Image Width = " << pImageWidth << endl;
		pixelDataFile << "Image Height = " << pImageWidth << endl;


		cout << "Vocabulary Block: " << endl;
		cout << "Sector One Label = " << pClassOneLabel << endl;
		cout << "Sector Two Label = " << pClassTwoLabel << endl;
		cout << "Invalid Label = " << pInvalidLabel << endl;



		pixelDataFile << "Vocabulary Block: " << endl;
		pixelDataFile << "Sector One Label = " << pClassOneLabel << endl;
		pixelDataFile << "Sector Two Label = " << pClassTwoLabel << endl;
		pixelDataFile << "Invalid Label = " << pInvalidLabel << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorOne)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{
					cout << "Index: " << pIndex << endl;
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Index: " << pIndex << endl;
					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}


			cout << "Clipping for X Position" << endl;
			pixelDataFile << "Clipping for X Position" << endl;




			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorTwo)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{
					cout << "Index: " << pIndex << endl;
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Index: " << pIndex << endl;
					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
			pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());





			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();


			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;







			hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
				pTopLeftX,
				pTopLeftY,
				pTopLeftX + pImageWidth,
				pTopLeftY + pImageHeight,
				pRedValueBottom,
				pRedValueTop,
				pGreenValueBottom,
				pGreenValueTop,
				pBlueValueBottom,
				pBlueValueTop,
				pixelObjectVectorOne, &pOutputFilterResult);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;

			vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


			for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
			{

				if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
				{
					float pPixelNumber = pIndexValue;
					float pXValue = pPixelObject.xPosition;
					float pYValue = pPixelObject.yPosition;
					float pRedComponent = pPixelObject.rValue;
					float pGreenComponent = pPixelObject.gValue;
					float pBlueComponent = pPixelObject.bValue;
					bool pUsedInComputations = pPixelObject.pUsedInComputations;


					cout << "Pixel Number: " << pPixelNumber << endl;
					cout << "X Value = " << pXValue << endl;
					cout << "Y Value = " << pYValue << endl;
					cout << "Red Component = " << pRedComponent << endl;
					cout << "Green Component = " << pGreenComponent << endl;
					cout << "Blue Component = " << pBlueComponent << endl;
					cout << "Used In Computations = " << pUsedInComputations << endl;

					pixelDataFile << "Step: " << pPixelNumber << endl;
					pixelDataFile << "X Value = " << pXValue << endl;
					pixelDataFile << "Y Value = " << pYValue << endl;
					pixelDataFile << "Red Component = " << pRedComponent << endl;
					pixelDataFile << "Green Component = " << pGreenComponent << endl;
					pixelDataFile << "Blue Component = " << pBlueComponent << endl;
					pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


					if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
					{
						pFinalOutputSquare.push_back(pPixelObject);
						pAmountOfFilteredPixels++;
					}



					pIndexValue++;
				}
			}






			cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
			pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


			cout << "Restoring Image Pixel Data for Filter Output" << endl;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
				pFinalOutputSquare, &pFilterToReverseOutput);

			cout << "Printing the Results of the Output" << endl;

			vector<float> pXPositionValues = vector<float>();
			vector<float> pYPositionValues = vector<float>();
			int pSectorToRestore = 0;

			for (PixelObject pixelObject : pFilterToReverseOutput)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;


					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

					pXPositionValues.push_back(pixelObject.xPosition);
					pYPositionValues.push_back(pixelObject.yPosition);
				}
			}



			vector<FilterPixelLabel> pFilterPixelLabelVector = vector<FilterPixelLabel>();
			hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(
				hInstance,
				hWnd,
				pXConstantValue0,
				pCentreY,
				pClassOneLabel,
				pClassTwoLabel,
				pInvalidLabel,
				pFilterToReverseOutput,
				&pFilterPixelLabelVector);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			pIndexValue = 0;



			for (FilterPixelLabel pPixelObject : pFilterPixelLabelVector)
			{


				if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
				{
					float pPixelNumber = pIndexValue;
					float pXValue = pPixelObject.xPosition;
					float pYValue = pPixelObject.yPosition;
					float pRedComponent = pPixelObject.rValue;
					float pGreenComponent = pPixelObject.gValue;
					float pBlueComponent = pPixelObject.bValue;
					int pSectorNumber = pPixelObject.pSectorNumberValue;
					bool pUsedInComputations = pPixelObject.pIsPixelValid;

					if ((pUsedInComputations == true) || (pUsedInComputations == 255))
					{
						pAmountOfFilteredPixels++;
					}


					cout << "Pixel Number: " << pPixelNumber << endl;
					cout << "X Value = " << pXValue << endl;
					cout << "Y Value = " << pYValue << endl;
					cout << "Red Component = " << pRedComponent << endl;
					cout << "Green Component = " << pGreenComponent << endl;
					cout << "Blue Component = " << pBlueComponent << endl;
					cout << "Sector Value: " << pSectorNumber << endl;
					cout << "Used In Computations = " << pUsedInComputations << endl;

					pixelDataFile << "Step: " << pPixelNumber << endl;
					pixelDataFile << "X Value = " << pXValue << endl;
					pixelDataFile << "Y Value = " << pYValue << endl;
					pixelDataFile << "Red Component = " << pRedComponent << endl;
					pixelDataFile << "Green Component = " << pGreenComponent << endl;
					pixelDataFile << "Blue Component = " << pBlueComponent << endl;
					pixelDataFile << "Sector Value: " << pSectorNumber << endl;
					pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

				}



				pIndexValue++;
			}


			vector<PixelObject> pSectorOneArray = vector<PixelObject>();
			vector<PixelObject> pSectorTwoArray = vector<PixelObject>();

			cout << "Restoring Pixels for Sector One" << endl;
			pixelDataFile << "Restoring Pixels for Sector One" << endl;
			pSectorToRestore = pClassOneLabel;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
				hWnd,
				pSectorToRestore,
				pFilterPixelLabelVector,
				&pSectorOneArray);

			for (PixelObject pixelObject : pSectorOneArray)
			{

				if ((pixelObject.RMask != 777.0f) && (pixelObject.GMask != 777.0f) && (pixelObject.BMask != 777.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;


					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}
			}

			cout << "Restoring Pixels for Sector Two" << endl;
			pixelDataFile << "Restoring Pixels for Sector Two" << endl;
			pSectorToRestore = pClassTwoLabel;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
				hWnd,
				pSectorToRestore,
				pFilterPixelLabelVector,
				&pSectorTwoArray);

			for (PixelObject pixelObject : pSectorTwoArray)
			{

				if ((pixelObject.RMask != 777.0f) && (pixelObject.GMask != 777.0f) && (pixelObject.BMask != 777.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;


					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}
			}

		}

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithXConstantAndYBreakpoint(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\SectorizeImagesForXConstantAndYBreakpoint.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;

	Point2D pCentre;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	vector<FilterPixelLabel> pOutputFilterResultsLabelled = vector<FilterPixelLabel>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	vector<FilterPixelLabel> pOutputPixelFinalOutput = vector<FilterPixelLabel>();


	vector<PixelObject> pSectorOneArray = vector<PixelObject>();
	vector<PixelObject> pSectorTwoArray = vector<PixelObject>();
	vector<PixelObject> pSectorThreeArray = vector<PixelObject>();
	vector<PixelObject> pSectorFourArray = vector<PixelObject>();
	vector<PixelObject> pSectorFiveArray = vector<PixelObject>();
	vector<PixelObject> pSectorSixArray = vector<PixelObject>();
	vector<PixelObject> pSectorSevenArray = vector<PixelObject>();
	vector<PixelObject> pSectorEightArray = vector<PixelObject>();
	vector<PixelObject> pSectorNineArray = vector<PixelObject>();
	vector<PixelObject> pSectorTenArray = vector<PixelObject>();
	vector<PixelObject> pSectorElevenArray = vector<PixelObject>();
	vector<PixelObject> pSectorTwelveArray = vector<PixelObject>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;

	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;

	float pYConstantValue0 = 200.0f;
	float pYConstantValue1 = 400.0f;
	float pYConstantValue2 = 600.0f;

	float pXConstantValue0 = 200.0f;
	float pXConstantValue1 = 400.0f;
	float pXConstantValue2 = 600.0f;



	int pClassOneLabel = 0;
	int pClassTwoLabel = 0;
	int pInvalidLabel = 0;
	float pCentreX = 0.0F;
	float pCentreY = 0.0F;

	cout << "Enter the Value for Sector One Label" << endl;
	cin >> pClassOneLabel;
	cout << "Enter the Value for Sector Two Label" << endl;
	cin >> pClassTwoLabel;
	cout << "Enter the Value for Invalid Label" << endl;
	cin >> pInvalidLabel;
	cout << "Enter the X Value for Constant" << endl;
	cin >> pXConstantValue0;
	cout << "Enter the Y Value for Thresold" << endl;
	cin >> pCentreY;



	cout << "X Constant Value For Segmentation = " << pXConstantValue0 << endl;
	cout << "Y Thresold Value for Segmentation = " << pCentreY << endl;
	pixelDataFile << "X Constant Value For Segmentation = " << pXConstantValue0 << endl;
	pixelDataFile << "Y Thresold Value for Segmentation = " << pCentreY << endl;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	cout << "Vocabulary Block: " << endl;
	cout << "Sector One Label = " << pClassOneLabel << endl;
	cout << "Sector Two Label = " << pClassTwoLabel << endl;
	cout << "Invalid Label = " << pInvalidLabel << endl;



	pixelDataFile << "Vocabulary Block: " << endl;
	pixelDataFile << "Sector One Label = " << pClassOneLabel << endl;
	pixelDataFile << "Sector Two Label = " << pClassTwoLabel << endl;
	pixelDataFile << "Invalid Label = " << pInvalidLabel << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}


		cout << "Clipping for X Position" << endl;
		pixelDataFile << "Clipping for X Position" << endl;




		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		 pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());





		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
	

		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;







		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pTopLeftX,
			pTopLeftY,
			pTopLeftX + pImageWidth,
			pTopLeftY + pImageHeight,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVectorOne, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pFinalOutputSquare, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();
		int pSectorToRestore = 0;

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}



		vector<FilterPixelLabel> pFilterPixelLabelVector = vector<FilterPixelLabel>();
		hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(
			hInstance,
			hWnd,
			pXConstantValue0,
			pCentreY,
			pClassOneLabel,
			pClassTwoLabel,
			pInvalidLabel,
			pFilterToReverseOutput,
			&pFilterPixelLabelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

	

		for (FilterPixelLabel pPixelObject : pFilterPixelLabelVector)
		{


			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				int pSectorNumber = pPixelObject.pSectorNumberValue;
				bool pUsedInComputations = pPixelObject.pIsPixelValid;

					if ((pUsedInComputations == true) || (pUsedInComputations == 255))
					{
						pAmountOfFilteredPixels++;
					}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Sector Value: " << pSectorNumber << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Sector Value: " << pSectorNumber << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}



			pIndexValue++;
		}


		vector<PixelObject> pSectorOneArray = vector<PixelObject>();
		vector<PixelObject> pSectorTwoArray = vector<PixelObject>();

		cout << "Restoring Pixels for Sector One" << endl;
		pixelDataFile << "Restoring Pixels for Sector One" << endl;
	    pSectorToRestore = pClassOneLabel;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			pSectorToRestore,
			pFilterPixelLabelVector,
			&pSectorOneArray);

		for (PixelObject pixelObject : pSectorOneArray)
		{

			if ((pixelObject.RMask != 777.0f) && (pixelObject.GMask != 777.0f) && (pixelObject.BMask != 777.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Restoring Pixels for Sector Two" << endl;
		pixelDataFile << "Restoring Pixels for Sector Two" << endl;
		 pSectorToRestore = pClassTwoLabel;
		 hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			 hWnd, 
			 pSectorToRestore,
			 pFilterPixelLabelVector,
			 &pSectorTwoArray);

		for (PixelObject pixelObject : pSectorTwoArray)
		{

			if ((pixelObject.RMask != 777.0f) && (pixelObject.GMask != 777.0f) && (pixelObject.BMask != 777.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}



	}

	pixelDataFile.close();
	return hr;

}




HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToQRCodeModel(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToQRCodeFormat.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	float pRedValueBlack = 0.0f;
	float pGreenValueBlack = 0.0f;
	float pBlueValueBlack = 0.0f;

	float pRedValueWhite = 0.0f;
	float pGreenValueWhite = 0.0f;
	float pBlueValueWhite = 0.0f;

	int pBlackLabelValue = 0;
	int pWhiteLabelValue = 0;

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectBlackAndWhite> pPixelObjectToGrayScale = vector<OutputPixelObjectBlackAndWhite>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the Value for Red Value for black Component" << endl;
	cin >> pRedValueBlack;

	cout << "Enter the Value for Green Value for black Component" << endl;
	cin >> pGreenValueBlack;

	cout << "Enter the Value for Blue Value for black Component" << endl;
	cin >> pBlueValueBlack;

	cout << "Enter the Value for Red Value for White Component" << endl;
	cin >> pRedValueWhite;

	cout << "Enter the Value for Green Value for White Component" << endl;
	cin >> pGreenValueWhite;

	cout << "Enter the Value for Blue Value for White Component" << endl;
	cin >> pBlueValueWhite;

	cout << "Enter the Value for Black Label" << endl;
	cin >> pBlackLabelValue;

	cout << "Enter the Value for White Label" << endl;
	cin >> pWhiteLabelValue;

	float pThresoldValue = 0.0f;

	pixelDataFile << "We are Converting Image to Qr Code Format: " << endl;
	pixelDataFile << "Top Left X For Our Clip " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y For Our Clip " << pTopLeftY << endl;
	pixelDataFile << "Width Parameter For Our Clip " << pImageWidth << endl;
	pixelDataFile << "Width Parameter For Our Clip " << pImageHeight << endl;
	pixelDataFile << "Bottom Value Red " << pRedValueBlack << endl;
	pixelDataFile << "Bottom Value Green " << pGreenValueBlack << endl;
	pixelDataFile << "Bottom Value Blue " << pBlueValueBlack << endl;
	pixelDataFile << "Top Value Red " << pRedValueWhite << endl;
	pixelDataFile << "Top Value Green " << pGreenValueWhite << endl;
	pixelDataFile << "Top Value Blue " << pBlueValueWhite << endl;
	pixelDataFile << "Now we Will Estimate the thresold for convertion" << endl;

	pThresoldValue = pRedValueWhite / 2.0f;
	pixelDataFile << "Our Color Intensity thresold will be: " << pThresoldValue << endl;
	pixelDataFile << "Each pixel with color less than thresold will be label With a black color maarker = " << pBlackLabelValue << endl;
	pixelDataFile << "Each pixel with color greater than thresold will be label With a white color maarker = " << pWhiteLabelValue << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\QrCodeGenerator.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataFromRGBModelToQRCodeModel(hInstance, hWnd,
		pRedValueBlack, pGreenValueBlack, pBlueValueBlack,
		pRedValueWhite, pGreenValueWhite, pBlueValueWhite,
		pBlackLabelValue, pWhiteLabelValue,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;
	for (OutputPixelObjectBlackAndWhite pOutputData : pPixelObjectToGrayScale)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Value: " << pOutputData.rValue << endl;
		cout << "Green Value: " << pOutputData.gValue << endl;
		cout << "Blue Value: " << pOutputData.bValue << endl;
		cout << "Marker Code: " << pOutputData.pMarkerCode << endl;



		pixelDataFile << "Pixel №: " << pOutputData.pixelNumber << endl;
		pixelDataFile << "X Position: " << pOutputData.xPosition << endl;
		pixelDataFile << "Y Position: " << pOutputData.yPosition << endl;
		pixelDataFile << "Red Value: " << pOutputData.rValue << endl;
		pixelDataFile << "Green Value: " << pOutputData.gValue << endl;
		pixelDataFile << "Blue Value: " << pOutputData.bValue << endl;
		pixelDataFile << "Marker Code: " << pOutputData.pMarkerCode << endl;

	}

	cout << "Restoring our QR Code to RGB Pixels:" << endl;
	pixelDataFile << "Restoring our QR Code to RGB Pixels:" << endl;

	vector<PixelObject> pOutputPixelArray = vector<PixelObject>();
	hr = ppStandardAlgorithmExecutor->ConvertImageDataFromQRCodeModelToRGBModel(hInstance,
		hWnd,
		pRedValueBlack, pGreenValueBlack, pBlueValueBlack,
		pRedValueWhite, pGreenValueWhite, pBlueValueWhite,
		pBlackLabelValue, pWhiteLabelValue,
		pPixelObjectToGrayScale,
		&pOutputPixelArray);


	cout << "Printnng RGB Pixels:" << endl;
	pixelDataFile << "Printing RGB Pixels:" << endl;


	for (PixelObject pixelObject : pOutputPixelArray)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pOutputPixelArray, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);


	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToQRCodeModelWithQRGeneration(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToQRCodeFormatWithGeneration.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	float pRedValueBlack = 0.0f;
	float pGreenValueBlack = 0.0f;
	float pBlueValueBlack = 0.0f;

	float pRedValueWhite = 0.0f;
	float pGreenValueWhite = 0.0f;
	float pBlueValueWhite = 0.0f;

	int pBlackLabelValue = 0;
	int pWhiteLabelValue = 0;

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectBlackAndWhite> pPixelObjectToGrayScale = vector<OutputPixelObjectBlackAndWhite>();
	vector<OutputPixelQRCode> pPixelObjectQRCodeArray = vector<OutputPixelQRCode>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the Value for Red Value for black Component" << endl;
	cin >> pRedValueBlack;

	cout << "Enter the Value for Green Value for black Component" << endl;
	cin >> pGreenValueBlack;

	cout << "Enter the Value for Blue Value for black Component" << endl;
	cin >> pBlueValueBlack;

	cout << "Enter the Value for Red Value for White Component" << endl;
	cin >> pRedValueWhite;

	cout << "Enter the Value for Green Value for White Component" << endl;
	cin >> pGreenValueWhite;

	cout << "Enter the Value for Blue Value for White Component" << endl;
	cin >> pBlueValueWhite;

	cout << "Enter the Value for Black Label" << endl;
	cin >> pBlackLabelValue;

	cout << "Enter the Value for White Label" << endl;
	cin >> pWhiteLabelValue;

	float pThresoldValue = 0.0f;

	pixelDataFile << "We are Converting Image to Qr Code Format: " << endl;
	pixelDataFile << "Top Left X For Our Clip " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y For Our Clip " << pTopLeftY << endl;
	pixelDataFile << "Width Parameter For Our Clip " << pImageWidth << endl;
	pixelDataFile << "Width Parameter For Our Clip " << pImageHeight << endl;
	pixelDataFile << "Bottom Value Red " << pRedValueBlack << endl;
	pixelDataFile << "Bottom Value Green " << pGreenValueBlack << endl;
	pixelDataFile << "Bottom Value Blue " << pBlueValueBlack << endl;
	pixelDataFile << "Top Value Red " << pRedValueWhite << endl;
	pixelDataFile << "Top Value Green " << pGreenValueWhite << endl;
	pixelDataFile << "Top Value Blue " << pBlueValueWhite << endl;
	pixelDataFile << "Now we Will Estimate the thresold for convertion" << endl;

	pThresoldValue = pRedValueWhite / 2.0f;
	pixelDataFile << "Our Color Intensity thresold will be: " << pThresoldValue << endl;
	pixelDataFile << "Each pixel with color less than thresold will be label With a black color maarker = " << pBlackLabelValue << endl;
	pixelDataFile << "Each pixel with color greater than thresold will be label With a white color maarker = " << pWhiteLabelValue << endl;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\QrCodeGenerator.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataFromRGBModelToQRCodeModel(hInstance, hWnd,
		pRedValueBlack, pGreenValueBlack, pBlueValueBlack,
		pRedValueWhite, pGreenValueWhite, pBlueValueWhite,
		pBlackLabelValue, pWhiteLabelValue,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;
	for (OutputPixelObjectBlackAndWhite pOutputData : pPixelObjectToGrayScale)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Value: " << pOutputData.rValue << endl;
		cout << "Green Value: " << pOutputData.gValue << endl;
		cout << "Blue Value: " << pOutputData.bValue << endl;
		cout << "Marker Code: " << pOutputData.pMarkerCode << endl;



		pixelDataFile << "Pixel №: " << pOutputData.pixelNumber << endl;
		pixelDataFile << "X Position: " << pOutputData.xPosition << endl;
		pixelDataFile << "Y Position: " << pOutputData.yPosition << endl;
		pixelDataFile << "Red Value: " << pOutputData.rValue << endl;
		pixelDataFile << "Green Value: " << pOutputData.gValue << endl;
		pixelDataFile << "Blue Value: " << pOutputData.bValue << endl;
		pixelDataFile << "Marker Code: " << pOutputData.pMarkerCode << endl;

	}

	cout << "Restoring our QR Code to RGB Pixels:" << endl;
	pixelDataFile << "Restoring our QR Code to RGB Pixels:" << endl;

	vector<OutputPixelQRCode> pOutputPixelArray = vector<OutputPixelQRCode>();
	hr = ppStandardAlgorithmExecutor->ConvertImageDataFromQRCodeModelToQRObject(hInstance,
		hWnd,
		pRedValueBlack, pGreenValueBlack, pBlueValueBlack,
		pRedValueWhite, pGreenValueWhite, pBlueValueWhite,
		pBlackLabelValue, pWhiteLabelValue,
		pPixelObjectToGrayScale,
		&pOutputPixelArray);


	cout << "Printnng RGB Pixels:" << endl;
	pixelDataFile << "Printing RGB Pixels:" << endl;


	for (OutputPixelQRCode pixelObject : pOutputPixelArray)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Code Value: " << pixelObject.pQRCodeValue << endl;
		
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Code: " << pixelObject.pQRCodeValue << endl;
	

	}

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);


	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonFromVideoArchive(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;
	float pLevelOfImpurities = 0.0f;



	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerForVideoArchive.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Will Simulate the Recording Of A Video Archive " << endl;
	vector<std::string> pVideoFileNameArchieFiles = vector<std::string>();
	vector<std::string> pImageFileNameArchiveFiles = vector<std::string>();
	hr = GenerateIndexedFileNamesForVideosParametrized(hInstance, hWnd, &pVideoFileNameArchieFiles);
	hr = GenerateIndexedFileNamesForImages(hInstance, hWnd, &pImageFileNameArchiveFiles);

	UINT pAmountOfVideos = pVideoFileNameArchieFiles.size();

	cout << "Printing the Names for the File Array" << endl;
	for (std::string pVideoFileName : pVideoFileNameArchieFiles)
	{
		cout << "Video File Name: " << pVideoFileName << endl;
	}

	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	cout << "Loading Our Video Analysis System" << endl;

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);

	cout << "Recoring Our Video Archive" << endl;

	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;


	int pRecordingSize = 0;
	cout << "Enter the hour to execute the timer for session to start Recoring" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue0;

	cout << "Enter the hour to execute the timer for session to start Recoring" << endl;
	cin >> pHourValue1;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue1;

	cout << "Enter the Size Of the Recording in millisecons" << endl;
	cin >> pRecordingSize;

	LPWSTR pVideFile0 = NULL;
	LPWSTR pVideFile1 = NULL;


	int len = 0;
	int slength = (int)pVideoFileNameArchieFiles[0].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[0].c_str(), slength, 0, 0);
	wchar_t* pVideoFileName0 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[0].c_str(), slength, pVideoFileName0, len);
	std::wstring pVideoToRecord0(pVideoFileName0);

	len = 0;
	slength = (int)pVideoFileNameArchieFiles[1].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[1].c_str(), slength, 0, 0);
	wchar_t* pVideoFileName1 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[1].c_str(), slength, pVideoFileName1, len);
	std::wstring pVideoToRecord1(pVideoFileName1);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[0].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[0].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject0 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[0].c_str(), slength, pImageFileNameObject0, len);
	std::wstring pImageToRecord0(pImageFileNameObject0);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[1].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[1].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject1 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[1].c_str(), slength, pImageFileNameObject1, len);
	std::wstring pImageToRecord1(pImageFileNameObject1);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[2].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[2].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject2 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[2].c_str(), slength, pImageFileNameObject2, len);
	std::wstring pImageToRecord2(pImageFileNameObject2);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[3].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[3].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject3 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[3].c_str(), slength, pImageFileNameObject3, len);
	std::wstring pImageToRecord3(pImageFileNameObject3);



	LPWSTR pVideoFileEight = ConvertToLPWSTR(pVideoToRecord0);
	LPWSTR pVideoFileTwo = ConvertToLPWSTR(pVideoToRecord1);
	LPWSTR pImageFileEight = ConvertToLPWSTR(pImageToRecord0);
	LPWSTR pImageFileTwo = ConvertToLPWSTR(pImageToRecord1);
	LPWSTR pImageFileThree = ConvertToLPWSTR(pImageToRecord2);
	LPWSTR pImageFileFour = ConvertToLPWSTR(pImageToRecord3);


	UINT pRecordingTimeInSeconds = 0;
	UINT pWaitingIntervalInSeconds = 0;

	cout << "Enter the Lengh Of The Recoring In Seconds" << endl;
	cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulateRobotCleanerIndexed(hInstance, hWnd,
		pVideoFileEight, pVideoFileTwo, pHourValue0, pMinuteValue0, pHourValue1, pMinuteValue1, pImageFileEight, pImageFileTwo, pImageFileThree,
		pImageFileFour, pRecordingTimeInSeconds, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, pImageFileEight, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, pImageFileThree, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();

	cout << "Saving Cleaner Results" << endl;

	
	UINT pReportId = 0;
	if (pRobotCleanerObjectReportArray.size() == 0)
	{
		pReportId = 0;
	}
	else 
	{
		pReportId = pRobotCleanerObjectReportArray.size();
	}
	time_t pCurrentReportNow = time(0);
	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();
	
	cout << "Creating Visualization Diagram" << endl;
	md2dmanager->DrawRoadSign(hInstance, hWnd, pAmountOfDifferentPixels);
	cout << "Creating Visualization Diagram Completed" << endl;


	pRobotCleanerObjectReportArray.push_back(pReportObjectOfRobotCleaner);


	return hr;




	




}


HRESULT DirectXGPUDigitalLabCoreModule::SortPixelsInTheRightOrderForXPosition(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\SortPixelsForXPosition.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<FilterPixelLabel> pOutputFilterResult = vector<FilterPixelLabel>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;
	float pXConstant = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pMinimumYVar = 0.0f;
	cout << "Enter the Value for Minimum Y" << endl;
	cin >> pMinimumYVar;

	float pMaximumYVar = 0.0f;
	cout << "Enter the Value for Maximum Y" << endl;
	cin >> pMaximumYVar;
	
	cout << "Enter the Value of X " << endl;
	cin >> pXConstant;

	
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	
	cout << "Enter the Value For X THRESOLD" << endl;
	cin >> pXConstant;

	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;


	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		float pCentreY = 0.0f;
		pCentreY = (pMaximumYVar - pMinimumYVar) / 2.0f;



		hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(hInstance,
			hWnd,
			pXConstant,
			pCentreY,
			1, 2, -1,
			pixelObjectVector,
			&pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;



		for (FilterPixelLabel pPixelObject : pOutputFilterResult)
		{


			int pixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			int pPixelGroupNumber = pPixelObject.pSectorNumberValue;



			cout << "Pixel Number: " << pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Group Number = " << pPixelGroupNumber << endl;

			pixelDataFile << "Step: " << pixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Group Number = " << pPixelGroupNumber << endl;



			pIndexValue++;
		}

		cout << "Restoring Pixel Object Vector from Sorting One" << endl;
		pixelDataFile << "Restoring Pixel Object Vector from Sorting One" << endl;
		vector<PixelObject> pixelAfterRestorationOne = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			1,
			pOutputFilterResult, &pixelAfterRestorationOne);


		for (PixelObject pixelObject : pixelAfterRestorationOne)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}



		cout << "Restoring Pixel Object Vector from Sorting Two" << endl;
		pixelDataFile << "Restoring Pixel Object Vector from Sorting Two" << endl;
		vector<PixelObject> pixelAfterRestorationTwo = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			2,
			pOutputFilterResult, &pixelAfterRestorationTwo);


		for (PixelObject pixelObject : pixelAfterRestorationTwo)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

	}
	
	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SortPixelsInTheRightOrderForYPosition(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\SortPixelsForXPosition.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<FilterPixelLabel> pOutputFilterResult = vector<FilterPixelLabel>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;
	float pMinimumXVar = 0.0f;
	float pMaximumXVar = 0.0f;
	float pYConstant = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the Value for Minimum X" << endl;
	cin >> pMinimumXVar;

	cout << "Enter the Value for Maximum X" << endl;
	cin >> pMaximumXVar;

	cout << "Enter the Value of X " << endl;
	cin >> pYConstant;


	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;



	
	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;


	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;


	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		float pCentreX = 0.0f;
		pCentreX = (pMaximumXVar - pMinimumXVar) / 2.0f;



		hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(hInstance,
			hWnd,
			pYConstant,
			pCentreX,
			1, 2, -1,
			pixelObjectVector,
			&pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;



		for (FilterPixelLabel pPixelObject : pOutputFilterResult)
		{


			int pixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			int pPixelGroupNumber = pPixelObject.pSectorNumberValue;



			cout << "Pixel Number: " << pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Group Number = " << pPixelGroupNumber << endl;

			pixelDataFile << "Step: " << pixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Group Number = " << pPixelGroupNumber << endl;



			pIndexValue++;
		}

		cout << "Restoring Pixel Object Vector from Sorting One" << endl;
		pixelDataFile << "Restoring Pixel Object Vector from Sorting One" << endl;
		vector<PixelObject> pixelAfterRestorationOne = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			1,
			pOutputFilterResult, &pixelAfterRestorationOne);


		for (PixelObject pixelObject : pixelAfterRestorationOne)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}



		cout << "Restoring Pixel Object Vector from Sorting Two" << endl;
		pixelDataFile << "Restoring Pixel Object Vector from Sorting Two" << endl;
		vector<PixelObject> pixelAfterRestorationTwo = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			2,
			pOutputFilterResult, &pixelAfterRestorationTwo);


		for (PixelObject pixelObject : pixelAfterRestorationTwo)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

	}

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonFromVideoArchiveExistingFiles(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;




	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerForVideoArchive.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	
	cout << "This Function Will Simulate the Recording Of A Video Archive " << endl;
	vector<std::string> pVideoFileNameArchieFiles = vector<std::string>();
	vector<std::string> pImageFileNameArchiveFiles = vector<std::string>();
	hr = GenerateIndexedFileNamesForVideosParametrized(hInstance, hWnd, &pVideoFileNameArchieFiles);
	hr = GenerateIndexedFileNamesForImages(hInstance, hWnd, &pImageFileNameArchiveFiles);

	UINT pAmountOfVideos = pVideoFileNameArchieFiles.size();

	cout << "Printing the Names for the File Array" << endl;
	for (std::string pVideoFileName : pVideoFileNameArchieFiles)
	{
		cout << "Video File Name: " << pVideoFileName << endl;
	}

	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	cout << "Loading Our Video Analysis System" << endl;

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);

	cout << "Recoring Our Video Archive" << endl;

	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;
	float pLevelOfImpurities = 0;


	int len = 0;
	int slength = (int)pVideoFileNameArchieFiles[0].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[0].c_str(), slength, 0, 0);
	wchar_t* pVideoFileName0 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[0].c_str(), slength, pVideoFileName0, len);
	std::wstring pVideoToRecord0(pVideoFileName0);

	len = 0;
	slength = (int)pVideoFileNameArchieFiles[1].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[1].c_str(), slength, 0, 0);
	wchar_t* pVideoFileName1 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pVideoFileNameArchieFiles[1].c_str(), slength, pVideoFileName1, len);
	std::wstring pVideoToRecord1(pVideoFileName1);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[0].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[0].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject0 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[0].c_str(), slength, pImageFileNameObject0, len);
	std::wstring pImageToRecord0(pImageFileNameObject0);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[1].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[1].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject1 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[1].c_str(), slength, pImageFileNameObject1, len);
	std::wstring pImageToRecord1(pImageFileNameObject1);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[2].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[2].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject2 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[2].c_str(), slength, pImageFileNameObject2, len);
	std::wstring pImageToRecord2(pImageFileNameObject2);

	len = 0;
	slength = (int)pImageFileNameArchiveFiles[3].length() + 1;
	len = MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[3].c_str(), slength, 0, 0);
	wchar_t* pImageFileNameObject3 = new wchar_t[len];
	MultiByteToWideChar(CP_ACP, 0, pImageFileNameArchiveFiles[3].c_str(), slength, pImageFileNameObject3, len);
	std::wstring pImageToRecord3(pImageFileNameObject3);



	LPWSTR pVideoFileEight = L"C:\\RobotData\\VideoArchive\\NewVideo0.mp4";
	LPWSTR pVideoFileTwo = L"C:\\RobotData\\VideoArchive\\NewVideo1.mp4";
	LPWSTR pImageFileEight = L"C:\\RobotData\\Images\\NewImage_0.jpg";
	LPWSTR pImageFileTwo = L"C:\\RobotData\\Images\\NewImage_1.jpg";
	LPWSTR pImageFileThree = L"C:\\RobotData\\Images\\NewImage_2.jpg";
	LPWSTR pImageFileFour = L"C:\\RobotData\\Images\\NewImage_3.jpg";


	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEight, pVideoFileTwo, pImageFileEight, pImageFileTwo, pImageFileThree,
		pImageFileFour, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, pImageFileEight, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, pImageFileThree, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();
	UINT pReportId = 0;
	if (pRobotCleanerObjectReportArray.size() == 0)
	{
		pReportId = 0;
	}
	else
	{
		pReportId = pRobotCleanerObjectReportArray.size();
	}
	time_t pCurrentReportNow = time(0);
	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();

	cout << "Creating Visualization Diagram" << endl;
	if (pDifferentPixelArrayAverage >= 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 100);
	}
	else if (pDifferentPixelArrayAverage >= 33 && pDifferentPixelArrayAverage < 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 50);
	}
	else if (pDifferentPixelArrayAverage >= 0 && pDifferentPixelArrayAverage < 33)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 0);
	}

	HWND hListBox = NULL;
	hListBox = CreateWindow(L"listbox", NULL,
		WS_CHILD | WS_VISIBLE | LBS_STANDARD |
		LBS_WANTKEYBOARDINPUT,
		30, 30, 200, 100,
		hWnd, (HMENU)ID_LIST, hInstance, NULL);

	// Отменяем режим перерисовки списка
	SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
	// Добавляем в список несколько строк

	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Green - Intensity <= 33");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Red - Intensity <= 100");

	UpdateWindow(hWnd);

	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	pRobotCleanerObjectReportArray.push_back(pReportObjectOfRobotCleaner);





	return hr;





}




HRESULT DirectXGPUDigitalLabCoreModule::GenerateIndexedFileNamesForImages(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	int pAmountOfFileNames = 0;
	cout << "Enter the Amount Of FileNames to Generate" << endl;
	cin >> pAmountOfFileNames;
	vector<std::string> pRandomFileNamesArray = vector<std::string>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RandomImageFileNames.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	int Number_of_files = pAmountOfFileNames;
	string filename;


	for (int i = 0; i < Number_of_files; i++)
	{

		filename = "C:\\RobotData\\Images\\NewImage_" + IntToStr(i) + ".jpg";
		cout << filename << "  \n";
		imageSegmentationDataFile << filename << endl;
		pRandomFileNamesArray.push_back(filename);
	}

	cout << "Printing Image File Names" << endl;
	int pIndex = 0;

	for (std::string pFileName : pRandomFileNamesArray)
	{
		cout << "№: " << pIndex << "File Name: " << pFileName << endl;
	}

	imageSegmentationDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::GenerateIndexedFileNamesForImages(HINSTANCE hInstance, HWND hWnd, vector<std::string> *pOutputArrayForVideod)
{
	HRESULT hr = S_OK;
	int pAmountOfFileNames = 0;
	cout << "Enter the Amount Of FileNames to Generate" << endl;
	cin >> pAmountOfFileNames;
	vector<std::string> pRandomFileNamesArray = vector<std::string>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RandomImageFileNames.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	int Number_of_files = pAmountOfFileNames;
	string filename;


	for (int i = 0; i < Number_of_files; i++)
	{

		filename = "C:\\RobotData\\Images\\NewImage_" + IntToStr(i) + ".jpg";
		cout << filename << "  \n";
		imageSegmentationDataFile << filename << endl;
		pRandomFileNamesArray.push_back(filename);
	}

	cout << "Printing Image File Names" << endl;
	int pIndex = 0;
	for (std::string pFileName : pRandomFileNamesArray)
	{
		cout << "№: " << pIndex << "File Name: " << pFileName << endl;
	}
	imageSegmentationDataFile.close();
	*pOutputArrayForVideod = pRandomFileNamesArray;

	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::GenerateIndexedFileNamesForVideosParametrized(HINSTANCE hInstance, HWND hWnd, vector<std::string> *ppVideoFileArray)
{
	HRESULT hr = S_OK;
	int pAmountOfFileNames = 0;
	cout << "Enter the Amount Of FileNames to Generate" << endl;
	cin >> pAmountOfFileNames;
	vector<std::string> pRandomFileNamesArray = vector<std::string>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RandomVideoFileNames.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	int Number_of_files = pAmountOfFileNames;
	string filename;


	for (int i = 0; i < Number_of_files; i++)
	{

		filename = "C:\\RobotData\\VideoArchive\\NewVideo_" + IntToStr(i) + ".mp4";
		cout << filename << "  \n";
		imageSegmentationDataFile << filename << endl;
		pRandomFileNamesArray.push_back(filename);
	}

	cout << "Printing Video File Names File Names" << endl;
	int pIndex = 0;
	for (std::string pFileName : pRandomFileNamesArray)
	{
		cout << "№: " << pIndex << "File Name: " << pFileName << endl;
	}

	imageSegmentationDataFile.close();
	*ppVideoFileArray = pRandomFileNamesArray;

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::GenerateIndexedFileNamesForVideos(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	int pAmountOfFileNames = 0;
	cout << "Enter the Amount Of FileNames to Generate" << endl;
	cin >> pAmountOfFileNames;
	vector<std::string> pRandomFileNamesArray = vector<std::string>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RandomVideoFileNames.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	int Number_of_files = pAmountOfFileNames;
	string filename;


	for (int i = 0; i < Number_of_files; i++)
	{

		filename = "C:\\RobotData\\Videos\\NewVideo_" + IntToStr(i) + ".mp4";
		cout << filename << "  \n";
		imageSegmentationDataFile << filename << endl;
		pRandomFileNamesArray.push_back(filename);
	}

	cout << "Printing Video File Names File Names" << endl;
	int pIndex = 0;
	for (std::string pFileName : pRandomFileNamesArray)
	{
		cout << "№: " << pIndex << "File Name: " << pFileName << endl;
	}

	imageSegmentationDataFile.close();
	return hr;
}


void DirectXGPUDigitalLabCoreModule::CLSIDToChar(const CLSID& clsid, WCHAR* szCLSID, int length)
{
	int i;
	WCHAR* ret = szCLSID;
	szCLSID += sprintf_s((char*)szCLSID, sizeof(clsid), "%.81X-4hX-%.4Hx-");

	for (i = 0; i < sizeof(clsid.Data4); ++i)
	{
		szCLSID += sprintf_s((char*)szCLSID, sizeof(szCLSID), "%.2hhX", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4);
	}
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateUpwardFinancialTrend(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	int pCurrentSar = 0;
	int pLConstant = 0;
	int pHConstant = 0;
	int pPriceMinimum0 = 0;
	int pPriceMaximum0 = 0;
	int pPriceMinimum1 = 0;
	int pPriceMaximum1 = 0;
	
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);


	cout << "This Function Simulates Financial Output Trend" << endl;
	cout << "Enter the Value for SAR0" << endl;
	cin >> pCurrentSar;
	cout << "Enter the L Constant" << endl;
	cin >> pLConstant;
	cout << "Enter the H Constant" << endl;
	cin >> pHConstant;
	cout << "Enter the Price Minimum 0" << endl;
	cin >> pPriceMinimum0;
	cout << "Enter the Price Minimum 1" << endl;
	cin >> pPriceMinimum1;
	cout << "Enter the Price Maximum 0" << endl;
	cin >> pPriceMaximum0;
	cout << "Enter the Price Maximum 1" << endl;
	cin >> pPriceMaximum1;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\finance\\FinancialSimulationsUp.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	float pOutputValue = 0;

	cout << "SAR0 = " << pCurrentSar << endl;
	cout << "L = " << pLConstant << endl;
	cout << "H = " << pHConstant << endl;
	cout << "Price Minimum 0 = " << pPriceMinimum0 << endl;
	cout << "Price Minimum 1 = " << pPriceMinimum1 << endl;
	cout << "Price Maximum 0 = " << pPriceMaximum0 << endl;
	cout << "Price Maximum 1 = " << pPriceMaximum1 << endl;
	cout << "Computing the Output Value" << endl;


	imageSegmentationDataFile << "SAR0 = " << pCurrentSar << endl;
	imageSegmentationDataFile << "L = " << pLConstant << endl;
	imageSegmentationDataFile << "H = " << pHConstant << endl;
	imageSegmentationDataFile << "Price Minimum 0 = " << pPriceMinimum0 << endl;
	imageSegmentationDataFile << "Price Minimum 1 = " << pPriceMinimum1 << endl;
	imageSegmentationDataFile << "Price Maximum 0 = " << pPriceMaximum0 << endl;
	imageSegmentationDataFile << "Price Maximum 1 = " << pPriceMaximum0 << endl;
	imageSegmentationDataFile << "Computing the Output Value" << endl;

	
	cout << "Output Value = " << pOutputValue << endl;
	imageSegmentationDataFile << "Output Value = " << pOutputValue << endl;
	imageSegmentationDataFile.close();



	return hr;
}









HRESULT DirectXGPUDigitalLabCoreModule::SimulateCurrencyStateMachineObject(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\CurrencyRelationshipModel.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	int pXValue = 0;
	int pAverageValue = 0;
	int pAmountOfElements = 0;
	vector<CurrencyObject> pResourceObjectCollection = vector<CurrencyObject>();



	vector<CurrencyObjectRate> ppCurrencyObjectCollection0 = vector<CurrencyObjectRate>();
	vector<CurrencyRateStateMachineObject> pCurrencyStateMachineObject = vector<CurrencyRateStateMachineObject>();


	float pOpenCurrencyPrice1 = 0.0f;
	float pHighCurrencyPrice1 = 0.0f;
	float pLowCurrencyPrice1 = 0.0f;
	float pCloseCurrencyPrice1 = 0.0f;

	float pAmountOfInvestment = 0;
	cout << "How Much MEighty would you like to test" << endl;
	cin >> pAmountOfInvestment;




	cout << "How man Elements would you like to enter" << endl;
	cin >> pAmountOfElements;

	cout << "Filling Up The Data for Currencies" << endl;

	
	for (int pIndex = 0; pIndex < pAmountOfElements; ++pIndex)
	{
		int pCurrencyId = pIndex;
		float pOpenCurrencyPrice0 = 0.0f;
		float pHighCurrencyPrice0 = 0.0f;
		float pLowCurrencyPrice0 = 0.0f;
		float pCloseCurrencyPrice0 = 0.0f;

		cout << "Enter the Opening Price For The Currency" << endl;
		cin >> pOpenCurrencyPrice0;

		cout << "Enter the Moring Price For The Currency" << endl;
		cin >> pHighCurrencyPrice0;

		cout << "Enter the Afternoon Price For The Currency" << endl;
		cin >> pLowCurrencyPrice0,

		cout << "Enter the Evening Price For The Currency" << endl;
		cin >> pCloseCurrencyPrice0;


		CurrencyObjectRate pCurrencyObject1 = CurrencyObjectRate(pCurrencyId, pOpenCurrencyPrice0, pHighCurrencyPrice0, pLowCurrencyPrice0,
			pCloseCurrencyPrice0);
		pCurrencyObject1.pCurrencyId = pCurrencyId;
	

		ppCurrencyObjectCollection0.push_back(pCurrencyObject1);


	}


	for (CurrencyObjectRate pCurrencyObject0 : ppCurrencyObjectCollection0)
	{
		cout << "Currency id = " << pCurrencyObject0.pCurrencyId << endl;
		cout << "Opening Price = " << pCurrencyObject0.pOpeningPrice << endl;
		cout << "Morning Price = " << pCurrencyObject0.pMorningPrice << endl;
		cout << "Afternoon Price = " << pCurrencyObject0.pAfternoonPrice << endl;
		cout << "Evening Price = " << pCurrencyObject0.pEveningPrice << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject0.pCurrencyId << endl;
		imageSegmentationDataFile << "Opening Price = " << pCurrencyObject0.pOpeningPrice << endl;
		imageSegmentationDataFile << "Morning Price = " << pCurrencyObject0.pMorningPrice << endl;
		imageSegmentationDataFile << "Afternoon Price = " << pCurrencyObject0.pAfternoonPrice << endl;
		imageSegmentationDataFile << "Evening Price = " << pCurrencyObject0.pEveningPrice << endl;

	}




	vector<CurrencyRateStateMachineObject> ppOutputResourceObjectCollection = vector<CurrencyRateStateMachineObject>();

	int pStableSignalValue = 101;
	int pGrowthSignalValue = 202;
	int pDeclineSignalValue = 303;
	int pVolatileState = 404;
	int pUndefinedState = 505;


	cout << "101 - Currency is Stable" << endl;
	cout << "202 - Currency is Growing" << endl;
	cout << "303 - Currency is Falling" << endl;
	cout << "404 - Currency is Volatile" << endl;
	cout << "505 - Currency State Is Undefined" << endl;

	imageSegmentationDataFile << "101 - Currency is Stable" << endl;
	imageSegmentationDataFile << "202 - Currency is Growing" << endl;
	imageSegmentationDataFile << "303 - Currency is Falling" << endl;
	imageSegmentationDataFile << "404 - Currency is Volatile" << endl;
	imageSegmentationDataFile << "505 - Currency State Is Undefined" << endl;


	imageSegmentationDataFile << "Simulating Our Currency State Machine" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateCurrencyStateMachineObject(hInstance, hWnd,
		pStableSignalValue,
		pGrowthSignalValue,
		pDeclineSignalValue,
		pVolatileState,
		pUndefinedState,
		ppCurrencyObjectCollection0,
		&ppOutputResourceObjectCollection);

	for (CurrencyRateStateMachineObject pOutputObject : ppOutputResourceObjectCollection)
	{

		cout << "Currency id = " << pOutputObject.pCurrencyId << endl;
		cout << "Opening Price = " << pOutputObject.pOpeningPrice << endl;
		cout << "Morning Price = " << pOutputObject.pPriceInRoublesMorning << endl;
		cout << "Afternoon Price = " << pOutputObject.pPriceInRoublesAfternoon << endl;
		cout << "Evening Price = " << pOutputObject.pPriceInRoublesEvening << endl;
		cout << "Morning State = " << pOutputObject.pCurrencyStateMorning << endl;
		cout << "Morning State Change = " << pOutputObject.pMorningStateChange << endl;
		cout << "Afternoon State = " << pOutputObject.pCurrencyStateAfternoon << endl;
		cout << "Afternoon State Change = " << pOutputObject.pAfternoonStateChange << endl;
		cout << "Evening State = " << pOutputObject.pCurrencyStateEvening << endl;
		cout << "Evening State Change = " << pOutputObject.pEveningStateChange << endl;

		imageSegmentationDataFile << "Currency id = " << pOutputObject.pCurrencyId << endl;
		imageSegmentationDataFile << "Opening Price = " << pOutputObject.pOpeningPrice << endl;
		imageSegmentationDataFile << "Morning Price = " << pOutputObject.pPriceInRoublesMorning << endl;
		imageSegmentationDataFile << "Afternoon Price = " << pOutputObject.pPriceInRoublesAfternoon << endl;
		imageSegmentationDataFile << "Evening Price = " << pOutputObject.pPriceInRoublesEvening << endl;
		imageSegmentationDataFile << "Morning State = " << pOutputObject.pCurrencyStateMorning << endl;
		imageSegmentationDataFile << "Morning State Change = " << pOutputObject.pMorningStateChange << endl;
		imageSegmentationDataFile << "Afternoon State = " << pOutputObject.pCurrencyStateAfternoon << endl;
		imageSegmentationDataFile << "Afternoon State Change = " << pOutputObject.pAfternoonStateChange << endl;
		imageSegmentationDataFile << "Evening State = " << pOutputObject.pCurrencyStateEvening << endl;
		imageSegmentationDataFile << "Evening State Change = " << pOutputObject.pEveningStateChange << endl;
	


	
	}


	imageSegmentationDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateCurrencyMetalRelationshipModels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\CurrencyRelationshipModel.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	int pXValue = 0;
	int pAverageValue = 0;
	int pAmountOfElements = 0;
	vector<ResourceObject> pResourceObjectCollection = vector<ResourceObject>();

	cout << "Enter the Value for the X Parameter" << endl;
	cin >> pXValue;

	cout << "Enter the Value for the Average Value Parameter" << endl;
	cin >> pAverageValue;

	cout << "Enter the Amount of Elements for the Array" << endl;
	cin >> pAmountOfElements;
	int pIndex = 0;


	time_t pDateTme;
	time_t pCurrentTime;
	pCurrentTime = time(&pDateTme);
	DateDataType pDateDataType;
	pDateDataType.pYearValue = 2019;
	pDateDataType.pMonthValue = 8;
	pDateDataType.pDayValue = 29;
	pDateDataType.pWeekValue = 5;
	pDateDataType.pHourValue = 7;
	pDateDataType.pMinuteValue = 10;
	pDateDataType.pSecondValue = 0;

	vector<MetalObject> ppMetalObjectCollection = vector<MetalObject>();
	for (MetalObject pMetalObject0 : ppMetalObjectCollection)
	{
		cout << "Metal id = " << pMetalObject0.pMetalIdValue << endl;
		cout << "Record Time Second = " << pMetalObject0.pSecond << endl;
		cout << "Record Time Minute = " << pMetalObject0.pMinute << endl;
		cout << "Record Time Hour = " << pMetalObject0.pHour << endl;
		cout << "Record Time Day = " << pMetalObject0.pDay << endl;
		cout << "Record Time Month = " << pMetalObject0.pMonth << endl;
		cout << "Record Time Year = " << pMetalObject0.pYear << endl;
		cout << "Metal Price Open Value = " << pMetalObject0.pMetalPriceOpenValue << endl;
		cout << "Metal Price High Value = " << pMetalObject0.pMetalPriceHighValue << endl;
		cout << "Metal Price Low Value = " << pMetalObject0.pMetalPriceLowValue << endl;
		cout << "Metal Price Close Value = " << pMetalObject0.pMetalPriceCloseValue << endl;

		imageSegmentationDataFile << "Metal id = " << pMetalObject0.pMetalIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pMetalObject0.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pMetalObject0.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pMetalObject0.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pMetalObject0.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pMetalObject0.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pMetalObject0.pYear << endl;
		imageSegmentationDataFile << "Metal Price Open Value = " << pMetalObject0.pMetalPriceOpenValue << endl;
		imageSegmentationDataFile << "Metal Price High Value = " << pMetalObject0.pMetalPriceHighValue << endl;
		imageSegmentationDataFile << "Metal Price Low Value = " << pMetalObject0.pMetalPriceLowValue << endl;
		imageSegmentationDataFile << "Metal Price Close Value = " << pMetalObject0.pMetalPriceCloseValue << endl;
	}


	vector<CurrencyObject> ppCurrencyObjectCollection = vector<CurrencyObject>();
	for (CurrencyObject pCurrencyObject0 : ppCurrencyObjectCollection)
	{
		cout << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		cout << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		cout << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		cout << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		cout << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		cout << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		cout << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		cout << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		cout << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		cout << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		cout << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		imageSegmentationDataFile << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;
	}



	vector<CurrencyMetalPairObject> ppOutputResourceObjectCollection = vector<CurrencyMetalPairObject>();
	UINT pCurrencyId = 150;
	UINT pMetalId = 121;

	hr = ppStandardAlgorithmExecutor->SimulateMetalCurrencyRelationships(hInstance, hWnd, pCurrencyId, pMetalId, pDateDataType, pAverageValue, pXValue,
		ppMetalObjectCollection, ppCurrencyObjectCollection, &ppOutputResourceObjectCollection);

	UINT iIndex = 0;
	cout << "Printing the Results of the Simulation" << endl;
	for (CurrencyMetalPairObject pOutputObject : ppOutputResourceObjectCollection)
	{
		cout << "Index = " << iIndex << endl;
		cout << "Year: " << pOutputObject.pYear << endl;
		cout << "Month: " << pOutputObject.pMonth << endl;
		cout << "Day: " << pOutputObject.pHour << endl;
		cout << "Hour: " << pOutputObject.pMinute << endl;
		cout << "Minute: " << pOutputObject.pSecond << endl;
		cout << "Currency id " << pOutputObject.pCurrencyId << endl;
		cout << "Currency id " << pOutputObject.pMetalId << endl;
		cout << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue << endl;
		cout << "Metal Price Open: " << pOutputObject.pMetalPriceOpenValue << endl;
		cout << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue << endl;
		cout << "Metal Price High: " << pOutputObject.pMetalPriceHighValue << endl;
		cout << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue << endl;
		cout << "Metal Price Low: " << pOutputObject.pMetalPriceLowValue << endl;
		cout << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue << endl;
		cout << "Metal Price Close " << pOutputObject.pMetalPriceCloseValue << endl;
		cout << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
		cout << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
		cout << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
		cout << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;





		imageSegmentationDataFile << "Index = " << iIndex << endl;
		imageSegmentationDataFile << "Year: " << pOutputObject.pYear << endl;
		imageSegmentationDataFile << "Month: " << pOutputObject.pMonth << endl;
		imageSegmentationDataFile << "Day: " << pOutputObject.pHour << endl;
		imageSegmentationDataFile << "Hour: " << pOutputObject.pMinute << endl;
		imageSegmentationDataFile << "Minute: " << pOutputObject.pSecond << endl;
		imageSegmentationDataFile << "Currency id " << pOutputObject.pCurrencyId << endl;
		imageSegmentationDataFile << "Currency id " << pOutputObject.pMetalId << endl;
		imageSegmentationDataFile << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Metal Price Open: " << pOutputObject.pMetalPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Metal Price High: " << pOutputObject.pMetalPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Metal Price Low: " << pOutputObject.pMetalPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue << endl;
		imageSegmentationDataFile << "Metal Price Close " << pOutputObject.pMetalPriceCloseValue << endl;
		imageSegmentationDataFile << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
		imageSegmentationDataFile << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
		imageSegmentationDataFile << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
		imageSegmentationDataFile << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;



	}

	imageSegmentationDataFile.close();

	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateCurrencyCurrencyRelationshipModels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\CurrencyRelationshipModel.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	int pXValue = 0;
	int pAverageValue = 0;
	int pAmountOfElements = 0;
	vector<CurrencyObject> pResourceObjectCollection = vector<CurrencyObject>();



	vector<CurrencyObject> ppCurrencyObjectCollection0 = vector<CurrencyObject>();
	vector<CurrencyObject> ppCurrencyObjectCollection1 = vector<CurrencyObject>();


	cout << "Now You Have to Input The Values For Your Currencies" << endl;

	float pOpenCurrencyPrice0 = 0.0f;
	float pHighCurrencyPrice0 = 0.0f;
	float pLowCurrencyPrice0 = 0.0f;
	float pCloseCurrencyPrice0 = 0.0f;

	float pOpenCurrencyPrice1 = 0.0f;
	float pHighCurrencyPrice1 = 0.0f;
	float pLowCurrencyPrice1 = 0.0f;
	float pCloseCurrencyPrice1 = 0.0f;

	float pAmountOfInvestment = 0;

	cout << "Filling Up The Data for Currencies" << endl;

	cout << "Enter the Open Value for Currency Eight " << endl;
	cin >> pOpenCurrencyPrice0;

	cout << "Enter the High Value for Currency Eight " << endl;
	cin >> pHighCurrencyPrice0;

	cout << "Enter the Low Value for Currency Eight " << endl;
	cin >> pLowCurrencyPrice0;

	cout << "Enter the Close Value for Currency Eight " << endl;
	cin >> pCloseCurrencyPrice0;

	cout << "Enter the Open Value for Currency Eight " << endl;
	cin >> pOpenCurrencyPrice1;

	cout << "Enter the High Value for Currency Eight " << endl;
	cin >> pHighCurrencyPrice1;

	cout << "Enter the Low Value for Currency Eight " << endl;
	cin >> pLowCurrencyPrice1;

	cout << "Enter the Close Value for Currency Eight " << endl;
	cin >> pCloseCurrencyPrice1;

	cout << "How Much MEighty Will Be Invested" << endl;
	cin >> pAmountOfInvestment;

	SYSTEMTIME pCurrentSystemTime;
	pCurrentSystemTime.wYear = 0;
	pCurrentSystemTime.wMonth = 0;
	pCurrentSystemTime.wDay = 0;
	pCurrentSystemTime.wHour = 0;
	pCurrentSystemTime.wMinute = 0;
	pCurrentSystemTime.wSecond = 0;

	GetLocalTime(&pCurrentSystemTime);
	
	


	CurrencyObject pCurrencyObject0 = CurrencyObject(120,
		pCurrentSystemTime.wYear,
		pCurrentSystemTime.wMonth,
		pCurrentSystemTime.wDay,
		pCurrentSystemTime.wHour,
		pCurrentSystemTime.wMinute,
		pCurrentSystemTime.wSecond,
		pOpenCurrencyPrice0,
		pHighCurrencyPrice0,
		pLowCurrencyPrice0,
		pCloseCurrencyPrice0,
		pAmountOfInvestment);
	
	ppCurrencyObjectCollection0.push_back(pCurrencyObject0);

	CurrencyObject pCurrencyObject1 = CurrencyObject(122,
		pCurrentSystemTime.wYear,
		pCurrentSystemTime.wMonth,
		pCurrentSystemTime.wDay,
		pCurrentSystemTime.wHour,
		pCurrentSystemTime.wMinute,
		pCurrentSystemTime.wSecond,
		pOpenCurrencyPrice1,
		pHighCurrencyPrice1,
		pLowCurrencyPrice1,
		pCloseCurrencyPrice1,
		pAmountOfInvestment);


	ppCurrencyObjectCollection1.push_back(pCurrencyObject1);


	for (CurrencyObject pCurrencyObject0 : ppCurrencyObjectCollection0)
	{
		cout << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		cout << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		cout << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		cout << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		cout << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		cout << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		cout << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		cout << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		cout << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		cout << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		cout << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;
		cout << "Amount of Investement = " << pCurrencyObject0.pAmountOfInvestment << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		imageSegmentationDataFile << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;
		imageSegmentationDataFile << "Amount of Investement = " << pCurrencyObject0.pAmountOfInvestment << endl;


	}

	for (CurrencyObject pCurrencyObject1 : ppCurrencyObjectCollection1)
	{
		cout << "Currency id = " << pCurrencyObject1.pCurrencyIdValue << endl;
		cout << "Record Time Second = " << pCurrencyObject1.pSecond << endl;
		cout << "Record Time Minute = " << pCurrencyObject1.pMinute << endl;
		cout << "Record Time Hour = " << pCurrencyObject1.pHour << endl;
		cout << "Record Time Day = " << pCurrencyObject1.pDay << endl;
		cout << "Record Time Month = " << pCurrencyObject1.pMonth << endl;
		cout << "Record Time Year = " << pCurrencyObject1.pYear << endl;
		cout << "Currency Price Open Value = " << pCurrencyObject1.pCurrencyPriceOpenValue << endl;
		cout << "Currency Price High Value = " << pCurrencyObject1.pCurrencyPriceHighValue << endl;
		cout << "Currency Price Low Value = " << pCurrencyObject1.pCurrencyPriceLowValue << endl;
		cout << "Currency Price Close Value = " << pCurrencyObject1.pCurrencyPriceCloseValue << endl;
		cout << "Amount of Investement = " << pCurrencyObject1.pAmountOfInvestment << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject1.pCurrencyIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pCurrencyObject1.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pCurrencyObject1.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pCurrencyObject1.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pCurrencyObject1.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pCurrencyObject1.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pCurrencyObject1.pYear << endl;
		imageSegmentationDataFile << "Currency Price Open Value = " << pCurrencyObject1.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High Value = " << pCurrencyObject1.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low Value = " << pCurrencyObject1.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close Value = " << pCurrencyObject1.pCurrencyPriceCloseValue << endl;
		imageSegmentationDataFile << "Amount of Investement = " << pCurrencyObject1.pAmountOfInvestment << endl;

	}



	vector<CurrencyCurrencyPairObject> ppOutputResourceObjectCollection = vector<CurrencyCurrencyPairObject>();

	DateDataType pDateDataTypeObject;
	pDateDataTypeObject.pYearValue = pCurrentSystemTime.wYear;
	pDateDataTypeObject.pMonthValue = pCurrentSystemTime.wMonth;
	pDateDataTypeObject.pWeekValue = 3;
	pDateDataTypeObject.pDayValue = pCurrentSystemTime.wDay;
	pDateDataTypeObject.pHourValue = pCurrentSystemTime.wHour;
	pDateDataTypeObject.pMinuteValue = pCurrentSystemTime.wMinute;
	pDateDataTypeObject.pSecondValue = pCurrentSystemTime.wSecond;

	hr = ppStandardAlgorithmExecutor->SimulateCurrencyCurrencyRelationships(hInstance, hWnd, 120, 122,
		pAmountOfInvestment,
		pDateDataTypeObject,
		ppCurrencyObjectCollection0, ppCurrencyObjectCollection1, &ppOutputResourceObjectCollection);

	UINT iIndex = 0;
	cout << "Printing the Results of the Simulation" << endl;

	for (CurrencyCurrencyPairObject pOutputObject : ppOutputResourceObjectCollection)
	{
		float pPotentialProfitOpen = pAmountOfInvestment * pOutputObject.pCurrencyPriceOpenValue1 / 100;
		float pPotentialProfitHigh = pAmountOfInvestment * pOutputObject.pCurrencyPriceHighValue1 / 100;
		float pPotentialProfitLow = pAmountOfInvestment * pOutputObject.pCurrencyPriceLowValue1 / 100;
		float pPotentialProfitClose = pAmountOfInvestment * pOutputObject.pCurrencyPriceCloseValue1 / 100;



		cout << "Index = " << iIndex << endl;
		cout << "Year: " << pOutputObject.pYear << endl;
		cout << "Month: " << pOutputObject.pMonth << endl;
		cout << "Day: " << pOutputObject.pHour << endl;
		cout << "Hour: " << pOutputObject.pMinute << endl;
		cout << "Minute: " << pOutputObject.pSecond << endl;
		cout << "Currency id " << pOutputObject.pCurrencyId0 << endl;
		cout << "Currency id " << pOutputObject.pCurrencyId1 << endl;
		cout << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue0 << endl;
		cout << "Currency Price Open 2: " << pOutputObject.pCurrencyPriceOpenValue1 << endl;
		cout << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue0 << endl;
		cout << "Currency Price High 2: " << pOutputObject.pCurrencyPriceHighValue1 << endl;
		cout << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue0 << endl;
		cout << "Currency Price Low 2: " << pOutputObject.pCurrencyPriceLowValue1 << endl;
		cout << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue0 << endl;
		cout << "Currency Price Close 2: " << pOutputObject.pCurrencyPriceCloseValue1 << endl;
		cout << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
		cout << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
		cout << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
		cout << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;
		cout << "Potential Profit Open: " << pPotentialProfitOpen << endl;
		cout << "Potential Profit High: " << pPotentialProfitHigh << endl;
		cout << "Potential Profit Low: " << pPotentialProfitLow << endl;
		cout << "Potential Profit Close: " << pPotentialProfitClose << endl;





		imageSegmentationDataFile << "Index = " << iIndex << endl;
		imageSegmentationDataFile << "Year: " << pOutputObject.pYear << endl;
		imageSegmentationDataFile << "Month: " << pOutputObject.pMonth << endl;
		imageSegmentationDataFile << "Day: " << pOutputObject.pHour << endl;
		imageSegmentationDataFile << "Hour: " << pOutputObject.pMinute << endl;
		imageSegmentationDataFile << "Minute: " << pOutputObject.pSecond << endl;
		imageSegmentationDataFile << "Currency id " << pOutputObject.pCurrencyId0 << endl;
		imageSegmentationDataFile << "Currency id " << pOutputObject.pCurrencyId1 << endl;
		imageSegmentationDataFile << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue0 << endl;
		imageSegmentationDataFile << "Currency Price Open 2: " << pOutputObject.pCurrencyPriceOpenValue1 << endl;
		imageSegmentationDataFile << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue0 << endl;
		imageSegmentationDataFile << "Currency Price High 2: " << pOutputObject.pCurrencyPriceHighValue1 << endl;
		imageSegmentationDataFile << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue0 << endl;
		imageSegmentationDataFile << "Currency Price Low 2: " << pOutputObject.pCurrencyPriceLowValue1 << endl;
		imageSegmentationDataFile << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue0 << endl;
		imageSegmentationDataFile << "Currency Price Close 2: " << pOutputObject.pCurrencyPriceCloseValue1 << endl;
		imageSegmentationDataFile << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
		imageSegmentationDataFile << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
		imageSegmentationDataFile << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
		imageSegmentationDataFile << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;
		imageSegmentationDataFile << "Potential Profit Open: " << pPotentialProfitOpen << endl;
		imageSegmentationDataFile << "Potential Profit High: " << pPotentialProfitHigh << endl;
		imageSegmentationDataFile << "Potential Profit Low: " << pPotentialProfitLow << endl;
		imageSegmentationDataFile << "Potential Profit Close: " << pPotentialProfitClose << endl;

	}

	imageSegmentationDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateActivControlModule(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	float fVar = 0;
	float mVar = 0;
	float pLimit = 0.0f;
	float pMaximumDifference = 0.0f;

	cout << "This Function Simulates the Active CONTROL Law" << endl;

	cout << "Printing Initial Resource" << endl;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ActivManagementUnitCS.txt", fstream::in | fstream::out | fstream::trunc);
	vector<ObjectClassInActiv> pResourceObjectCollection = vector<ObjectClassInActiv>();
	vector<ObjectClassOutActiv>  pOutputResourceObjectCollection = vector<ObjectClassOutActiv>();


	cout << "Enter the Value For the f Constant" << endl;
	cin >> fVar;

	cout << "Enter the Value For the f Constant" << endl;
	cin >> mVar;
	bool doNeedConstantСontrolVar = true;
	bool doNeedStabilityVar = false;

	int pResult = MessageBoxA(hWnd, (LPCSTR)"Вам нужен постоянный контроль за ресурсами?", (LPCSTR)"Message", MB_YESNO);
	if (pResult == IDYES)
	{
		doNeedConstantСontrolVar = true;
	}
	else if (pResult == IDNO)
	{
		doNeedConstantСontrolVar = false;
	}

	pResult = MessageBoxA(hWnd, (LPCSTR)"Вам нужна стабилизация?", (LPCSTR)"Message", MB_YESNO);
	if (pResult == IDYES)
	{
		doNeedStabilityVar = true;
	}
	else if (pResult == IDNO)
	{
		doNeedStabilityVar = false;
	}

	

	
	float pSelectedTimeIntervals = 0.0f;
	int pObjectId = 0;
	float pActivityCoefficientVar = 0.0f;
	float pGrowthCoefficientVar = 0.0f;
	float pAverageDynamicGrowthOut = 0.0f;
	float pMassInflowValue = 0.0f;
	float pMassOutflow = 0.0f;
	float pMassGrowthCoefficient = 0.0f;
	float pMassGrowthMaximum = 0.0f;
	float pCommonPotentalValue = 0.0f;

	std::cout << "Enter the Value for the Time Interal In Seconds;" << endl;
	cin >> pSelectedTimeIntervals;

	cout << "Enter the Object Id" << endl;
	cin >> pObjectId;;

	cout << "Enter the Activity Coefficient" << endl;
	cin >> pActivityCoefficientVar;

	cout << "Enter the Growth Coefficient" << endl;
	cin >> pGrowthCoefficientVar;

	cout << "Enter the Value for Average Dynamic Growth Parameter" << endl;
	cin >> pAverageDynamicGrowthOut;

	cout << "Enter the Value for the Mass Inflow" << endl;
	cin >> pMassInflowValue;

	cout << "Enter the Value for Mass Outflow" << endl;
	cin >> pMassOutflow;

	cout << "Enter the Value for Potential Growth per time Intercval" << endl;
	cin >> pCommonPotentalValue;


	cout << "Enter the Value for Mass Growth Coefficient" << endl;
	cin >> pMassGrowthCoefficient;

	float pKValue0 = 0.0f;
	float pPreviousKValue = 0.0f;
	int pIndex = 0;
	int pObjectKind = 0;
	float pCommonPotentalValueStart = 0.0f;
	float pPotentialMassGrowthValue = 0.0f;
	for (float pTimeInterval = 0; pTimeInterval < pSelectedTimeIntervals; ++pTimeInterval)
	{

	
	


		ObjectClassInActiv pInputObjectVar;
		pInputObjectVar.pIndesValue = pIndex;
		pInputObjectVar.pObjectKindId = pObjectKind;
		pInputObjectVar.pActivityCoefficient = pActivityCoefficientVar;
		pInputObjectVar.pAverageDynamicGrowthOut = pAverageDynamicGrowthOut;
		pInputObjectVar.pTimeValue = pTimeInterval;
		pInputObjectVar.pPreviousK = pPreviousKValue;
		pInputObjectVar.pGrowthCoefficient = pGrowthCoefficientVar;
		pInputObjectVar.pPotentialMassGrowthIn = pMassGrowthCoefficient;
		pInputObjectVar.pPotentialMassGrowth = pPotentialMassGrowthValue;
		pInputObjectVar.pMassOutflowOut = pMassOutflow;
		pInputObjectVar.pMassInflowIn = pMassInflowValue;
		pInputObjectVar.pKValue = pKValue0;
		pInputObjectVar.pInputKMathGrowth = pMassGrowthCoefficient;
		pInputObjectVar.pGrowthCoefficient = pMassGrowthCoefficient;
		pInputObjectVar.pDataVaryStrongly = true;
		pInputObjectVar.pContainableGrowthCondition = false;
		pInputObjectVar.pCommonPotentialValAgainstTime = pCommonPotentalValue;
		pInputObjectVar.pLTimeValue = pTimeInterval;
		pInputObjectVar.pAverageDynamicGrowthOut = pAverageDynamicGrowthOut;

		pResourceObjectCollection.push_back(pInputObjectVar);
		pIndex = pIndex + 1;
		pObjectKind = pObjectKind + 1;
		pKValue0 = pKValue0 + 1;
		pCommonPotentalValueStart = pInputObjectVar.pCommonPotentialValAgainstTime;
		pPotentialMassGrowthValue = pPotentialMassGrowthValue + pMassGrowthCoefficient;
		pMassGrowthCoefficient++;

	}

	

	for (ObjectClassInActiv pResourceObject : pResourceObjectCollection)
	{
		cout << "Index: " << pResourceObject.pIndesValue << endl;
		cout << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
		cout << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		cout << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		cout << "Common Potential: " << pResourceObject.pCommonPotentialValAgainstTime << endl;
		cout << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		cout << "Is Cointainment of Growth Needed: " << pResourceObject.pContainableGrowthCondition << endl;
		cout << "Data Varies Strongly: " << pResourceObject.pDataVaryStrongly << endl;
		cout << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		cout << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		cout << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		cout << "Current Time: " << pResourceObject.pTimeValue << endl;
		cout << "Mass Inflow: " << pResourceObject.pMassInflowIn << endl;
		cout << "Mass Outflow: " << pResourceObject.pMassOutflowOut << endl;
		cout << "Input Mass Growth Coefficient" << pResourceObject.pInputKMathGrowth << endl;
		cout << "Previous K:  " << pResourceObject.pPreviousK << endl;
		cout << "K Value " << pResourceObject.pKValue << endl;
	
		imageSegmentationDataFile << "Index: " << pResourceObject.pIndesValue << endl;
		imageSegmentationDataFile << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
		imageSegmentationDataFile << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		imageSegmentationDataFile << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		imageSegmentationDataFile << "Common Potential: " << pResourceObject.pCommonPotentialValAgainstTime << endl;
		imageSegmentationDataFile << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		imageSegmentationDataFile << "Is Cointainment of Growth Needed: " << pResourceObject.pContainableGrowthCondition << endl;
		imageSegmentationDataFile << "Data Varies Strongly: " << pResourceObject.pDataVaryStrongly << endl;
		imageSegmentationDataFile << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		imageSegmentationDataFile << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		imageSegmentationDataFile << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		imageSegmentationDataFile << "Current Time: " << pResourceObject.pTimeValue << endl;
		imageSegmentationDataFile << "Mass Inflow: " << pResourceObject.pMassInflowIn << endl;
		imageSegmentationDataFile << "Mass Outflow: " << pResourceObject.pMassOutflowOut << endl;
		imageSegmentationDataFile << "Input Mass Growth Coefficient" << pResourceObject.pInputKMathGrowth << endl;
		imageSegmentationDataFile << "Previous K:  " << pResourceObject.pPreviousK << endl;
		imageSegmentationDataFile << "K Value " << pResourceObject.pKValue << endl;
	}
	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;


	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;
	cout << "Initializing Our Resources" << endl;


	hr = ppStandardAlgorithmExecutor->SimulateActivControlModule(hInstance, hWnd,
		fVar, mVar, true, pMaximumDifference, pLimit,
		doNeedStabilityVar,
		pResourceObjectCollection,
		&pOutputResourceObjectCollection);

	for (ObjectClassOutActiv pResourceObject : pOutputResourceObjectCollection)
	{
		cout << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
		cout << "Time: " << pResourceObject.pTimeValue << endl;
		cout << "X0: " << pResourceObject.pXOne << endl;
		cout << "X1: " << pResourceObject.pXTwo << endl;
		cout << "A0: " << pResourceObject.pAOne << endl;
		cout << "A1: " << pResourceObject.pATwo << endl;
		cout << "Regulatory Function Value: " << pResourceObject.pRegulatoryFunctionValue << endl;
		cout << "Main Equation Result: " << pResourceObject.pMainEquationResult << endl;
		cout << "Minimization Result: " << pResourceObject.pMinimizationResult << endl;
		
		imageSegmentationDataFile << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
		imageSegmentationDataFile << "Time: " << pResourceObject.pTimeValue << endl;
		imageSegmentationDataFile << "X0: " << pResourceObject.pXOne << endl;
		imageSegmentationDataFile << "X1: " << pResourceObject.pXTwo << endl;
		imageSegmentationDataFile << "A0: " << pResourceObject.pAOne << endl;
		imageSegmentationDataFile << "A1: " << pResourceObject.pATwo << endl;
		imageSegmentationDataFile << "Regulatory Function Value: " << pResourceObject.pRegulatoryFunctionValue << endl;
		imageSegmentationDataFile << "Main Equation Result: " << pResourceObject.pMainEquationResult << endl;
		imageSegmentationDataFile << "Minimization Result: " << pResourceObject.pMinimizationResult << endl;

	}
	const time_t* t;
	tm* now = std::localtime(t);
	std::cout << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;
	imageSegmentationDataFile << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;

	imageSegmentationDataFile.close();



	printf("Cleaning up...\n");



	return hr;


}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateFincancialSpaceModule(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	float fVar = 0;
	float mVar = 0;
	float pLimit = 0.0f;
	float pMaximumDifference = 0.0f;

	cout << "This Function Simulates the Active CONTROL Law" << endl;

	cout << "Printing Initial Resource" << endl;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\FinancialSpaceUnitCS.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();
	vector<InputSalesUnit> pResourceObjectCollection = vector<InputSalesUnit>();
	vector<OutputSalesUnit>  pOutputResourceObjectCollection = vector<OutputSalesUnit>();

	int pAmountOfSales = 0;
	cout << "How Many Units Of Sales Would you like to model:" << endl;
	cin >> pAmountOfSales;

	int pCounter = 0;
	int pResourceId = 0;
	float pInitialVolumeOfSales = 0.0f;
	float pTimeIntervalStart = 0.0f;
	float pTimeIntervalEnd = 0.0f;
	float pResourceMass = 0.0f;

	cout << "Enter the Initial Volume of Sales" << endl;
	cin >> pInitialVolumeOfSales;

	cout << "Enter the Beginning Time Interval Start; " << endl;
	cin >> pTimeIntervalStart;

	cout << "Enter the Beginning Time Interval End; " << endl;
	cin >> pTimeIntervalEnd;


	cout << "Enter the Value of the Mass of the Resource: " << endl;
	cin >> pResourceMass;

		

		for (float pTimeValue = pTimeIntervalStart; pTimeValue <= pTimeIntervalEnd; ++pTimeValue)
		{
			InputSalesUnit pInputSalesUnit = InputSalesUnit(pResourceId, pResourceMass, pInitialVolumeOfSales, pTimeValue);
			pResourceObjectCollection.push_back(pInputSalesUnit);
			pResourceId = pResourceId + 1;
			pInitialVolumeOfSales = pInitialVolumeOfSales + pResourceMass;
		}



	for (InputSalesUnit pSalesUnit : pResourceObjectCollection)
	{
		cout << "Resource id:" << pSalesUnit.pResourceId << endl;
		cout << "Time: " << pSalesUnit.pTimeValue << endl;
		cout << "Initial Volume: " << pSalesUnit.pInitialVolume << endl;
		cout << "Resource Mass: " << pSalesUnit.pResourceMass << endl;

		imageSegmentationDataFile << "Resource id:" << pSalesUnit.pResourceId << endl;
		imageSegmentationDataFile << "Time: " << pSalesUnit.pTimeValue << endl;
		imageSegmentationDataFile << "Initial Volume: " << pSalesUnit.pInitialVolume << endl;
		imageSegmentationDataFile << "Resource Mass: " << pSalesUnit.pResourceMass << endl;

	}


	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;


	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;
	cout << "Initializing Our Resources" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateFinancialSpaceModule(hInstance, hWnd,
		pResourceObjectCollection,
		&pOutputResourceObjectCollection);

	for (OutputSalesUnit pOutputObject : pOutputResourceObjectCollection)
	{
		cout << "Resource Id:  " << pOutputObject.pResourceId << endl;
		cout << "Time: " << pOutputObject.pTimeValue << endl;
		cout << "Current Volume: of Sales: " << pOutputObject.pCurrentVolumeOfSales << endl;
		cout << "Unit of Sales: " << pOutputObject.pScaleUnitValue << endl;
		cout << "Moment of Growth: " << pOutputObject.pMomentOfGrowth << endl;
		cout << "Weight of Growth: " << pOutputObject.pWeightGrowthMoment << endl;
		cout << "Volume of Acceleration: " << pOutputObject.pAccelerationVolume << endl;
		cout << "Fluctuation of Resource: " << pOutputObject.pFluctuationOfResource << endl;
		cout << "Sum of Fluctuations " << pOutputObject.pSumOfFluctuations << endl;

		imageSegmentationDataFile << "Resource Id:  " << pOutputObject.pResourceId << endl;
		imageSegmentationDataFile << "Time: " << pOutputObject.pTimeValue << endl;
		imageSegmentationDataFile << "Current Volume: of Sales: " << pOutputObject.pCurrentVolumeOfSales << endl;
		imageSegmentationDataFile << "Unit of Sales: " << pOutputObject.pScaleUnitValue << endl;
		imageSegmentationDataFile << "Moment of Growth: " << pOutputObject.pMomentOfGrowth << endl;
		imageSegmentationDataFile << "Weight of Growth: " << pOutputObject.pWeightGrowthMoment << endl;
		imageSegmentationDataFile << "Volume of Acceleration: " << pOutputObject.pAccelerationVolume << endl;
		imageSegmentationDataFile << "Fluctuation of Resource: " << pOutputObject.pFluctuationOfResource << endl;
		imageSegmentationDataFile << "Sum of Fluctuations " << pOutputObject.pSumOfFluctuations << endl;

		
	}


	imageSegmentationDataFile.close();



	printf("Cleaning up...\n");



	return hr;


}



HRESULT DirectXGPUDigitalLabCoreModule::LaunchImageComparisonOperationInAThread(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	HANDLE pThreadHandle = INVALID_HANDLE_VALUE;

	DirectXGPUDigitalLabCoreModule* pCoreModule = this;
	DWORD dwThreadId = 0;
	cout << "Launching Image Comparison In a thread" << endl;

	int pIntensitySum = 0;
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOperationThreadedOutput.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pCommonPixelObjectArrayEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pCommonPixelObjectArrayEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd,  pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pCommonPixelObjectArrayTwo);
	
	for (PixelObject pixelObject : pCommonPixelObjectArrayEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	pThreadHandle = CreateThread(
		NULL, // атрибуты безопасности по умолчанию 
		0, // использовать размер стека по умолчанию   
		CompareImagesThreadFunction,
		hWnd,
		0,
		&dwThreadId); // возвращает идентификатор потока  // функция потока 
	WaitForSingleObject(pThreadHandle, INFINITE);
	CloseHandle(pThreadHandle);

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : pIdenticalPixelObjectArrayGlobal)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : pDifferentPixelObjectArrayGlobal)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
	}


		for (OutputPixelBuffer ppOutputPixelValue : pOutputImageComparisonArrayGlobal)
		{
			cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
			cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
			cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
			cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
			cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

			imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
			imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
			imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
			imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
			imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
			imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
			imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
			pIndex++;

			md2dmanager->DrawRoadSign(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);


		}
		return hr;

	}





HRESULT RegisterServer(const char* szModuleName, REFCLSID clsid, const char* szFriendlyName,
	const char* szVerIndProgID, const char* szProgID, const char* szThreadingModel)
{
	char szModule[512];
	HMODULE hModule = GetModuleHandle((LPCWSTR)szModuleName);
	DWORD dwResult = GetModuleFileName(hModule, (LPWSTR)szModule, sizeof(szModule) / sizeof(char));
	char szCLSID[39];
	GuidToStr(clsid, szCLSID, sizeof(szCLSID));
	char szKey[64];
	strcpy(szKey, "CLSID\\");
	strcat(szKey, szCLSID);
	AddKey(szKey, NULL, szFriendlyName);
	if (strstr(szModuleName, ".exe") == NULL)
	{
		AddKey(szKey, "InprocServer32", szModule);
		char szInproc[64];
		strcpy(szInproc, szKey);
		strcat(szInproc, "\\InprocServer32");
		SetKey(szInproc, "ThreadingModel", szThreadingModel);
	}
	else
		AddKey(szKey, "LocalServer32", szModule);
	AddKey(szKey, "ProgID", szProgID);
	AddKey(szKey, "VersionIndependentProgID", szVerIndProgID);
	AddKey(szVerIndProgID, NULL, szFriendlyName);
	AddKey(szVerIndProgID, "CLSID", szCLSID);
	AddKey(szVerIndProgID, "CurVer", szProgID);
	AddKey(szProgID, NULL, szFriendlyName);
	AddKey(szProgID, "CLSID", szCLSID);
	return S_OK;
}






DWORD WINAPI ProcessGPUDigitalLabDataLoop(LPVOID lpParam)
{
	
	HANDLE stdOut = INVALID_HANDLE_VALUE;
	PDATAFRAME pDataArray;

	TCHAR msgBuf[BUFSIZE];
	size_t cchStringSize;
	DWORD dwChars = 0;
	DWORD result = 0;

	stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (stdOut == INVALID_HANDLE_VALUE)
	{
		pDataArray = (PDATAFRAME)lpParam;
		StringCchPrintf(msgBuf, BUFSIZE, TEXT("Parameters = %d, %d"), pDataArray->val1, pDataArray->val2);
		StringCchLength(msgBuf, BUFSIZE, &cchStringSize);
		result = 1;
		return result;
	}

	pDataArray = (PDATAFRAME)lpParam;

	StringCchPrintf(msgBuf, BUFSIZE, TEXT("Parameters = %d, %d\n"), pDataArray->val1,
		pDataArray->val2);
	StringCchLength(msgBuf, BUFSIZE, &cchStringSize);
	WriteConsole(stdOut, msgBuf, (DWORD)cchStringSize, &dwChars, NULL);
	
	return result;

}


VOID CALLBACK MyWaitCallback(
	PTP_CALLBACK_INSTANCE Instance,
	PVOID                 Parameter,
	PTP_WAIT              Wait,
	TP_WAIT_RESULT        WaitResult
	)
{
	// Instance, Parameter, Wait, and WaitResult not used in this example.
	UNREFERENCED_PARAMETER(Instance);
	UNREFERENCED_PARAMETER(Parameter);
	UNREFERENCED_PARAMETER(Wait);
	UNREFERENCED_PARAMETER(WaitResult);

	//
	// Do something when the wait is over.
	//
	_tprintf(_T("MyWaitCallback: wait is over.\n"));
}


VOID
CALLBACK
MyTimerCallback(
PTP_CALLBACK_INSTANCE Instance,
PVOID                 Parameter,
PTP_TIMER             Timer
)
{
	// Instance, Parameter, and Timer not used in this example.
	UNREFERENCED_PARAMETER(Instance);
	UNREFERENCED_PARAMETER(Parameter);
	UNREFERENCED_PARAMETER(Timer);

	//
	// Do something when the timer fires.
	//
	_tprintf(_T("MyTimerCallback: timer has fired.\n"));

}


VOID
CALLBACK
MyWorkCallback(
PTP_CALLBACK_INSTANCE Instance,
PVOID                 Parameter,
PTP_WORK              Work
)
{
	// Instance, Parameter, and Work not used in this example.
	UNREFERENCED_PARAMETER(Instance);
	UNREFERENCED_PARAMETER(Parameter);
	UNREFERENCED_PARAMETER(Work);

	BOOL bRet = FALSE;

	//
	// Do something when the work callback is invoked.
	//
	{
		_tprintf(_T("MyWorkCallback: Task performed.\n"));
	}

	return;
}

VOID
DemoCleanupPersistentWorkTimer()
{
	BOOL bRet = FALSE;
	PTP_WORK work = NULL;
	PTP_TIMER timer = NULL;
	PTP_POOL pool = NULL;
	PTP_WORK_CALLBACK workcallback = MyWorkCallback;
	PTP_TIMER_CALLBACK timercallback = MyTimerCallback;
	TP_CALLBACK_ENVIRON CallBackEnviron;
	PTP_CLEANUP_GROUP cleanupgroup = NULL;
	FILETIME FileDueTime;
	ULARGE_INTEGER ulDueTime;
	UINT rollback = 0;

	InitializeThreadpoolEnvironment(&CallBackEnviron);

	//
	// Create a custom, dedicated thread pool.
	//
	pool = CreateThreadpool(NULL);

	if (NULL == pool) {
		_tprintf(_T("CreateThreadpool failed. LastError: %u\n"),
			GetLastError());
		goto main_cleanup;
	}

	rollback = 1; // pool creation succeeded

	//
	// The thread pool is made persistent simply by setting
	// both the minimum and maximum threads to 1.
	//
	SetThreadpoolThreadMaximum(pool, 1);

	bRet = SetThreadpoolThreadMinimum(pool, 1);

	if (FALSE == bRet) {
		_tprintf(_T("SetThreadpoolThreadMinimum failed. LastError: %u\n"),
			GetLastError());
		goto main_cleanup;
	}

	//
	// Create a cleanup group for this thread pool.
	//
	cleanupgroup = CreateThreadpoolCleanupGroup();

	if (NULL == cleanupgroup) {
		_tprintf(_T("CreateThreadpoolCleanupGroup failed. LastError: %u\n"),
			GetLastError());
		goto main_cleanup;
	}

	rollback = 2;  // Cleanup group creation succeeded

	//
	// Associate the callback environment with our thread pool.
	//
	SetThreadpoolCallbackPool(&CallBackEnviron, pool);

	//
	// Associate the cleanup group with our thread pool.
	// Objects created with the same callback environment
	// as the cleanup group become members of the cleanup group.
	//
	SetThreadpoolCallbackCleanupGroup(&CallBackEnviron,
		cleanupgroup,
		NULL);

	//
	// Create work with the callback environment.
	//
	work = CreateThreadpoolWork(workcallback,
		NULL,
		&CallBackEnviron);

	if (NULL == work) {
		_tprintf(_T("CreateThreadpoolWork failed. LastError: %u\n"),
			GetLastError());
		goto main_cleanup;
	}

	rollback = 3;  // Creation of work succeeded

	//
	// Submit the work to the pool. Because this was a pre-allocated
	// work item (using CreateThreadpoolWork), it is guaranteed to execute.
	//
	SubmitThreadpoolWork(work);


	//
	// Create a timer with the same callback environment.
	//
	timer = CreateThreadpoolTimer(timercallback,
		NULL,
		&CallBackEnviron);


	if (NULL == timer) {
		_tprintf(_T("CreateThreadpoolTimer failed. LastError: %u\n"),
			GetLastError());
		goto main_cleanup;
	}

	rollback = 4;  // Timer creation succeeded

	//
	// Set the timer to fire in Eight second.
	//
	ulDueTime.QuadPart = (ULONGLONG)-(1 * 10 * 1000 * 1000);
	FileDueTime.dwHighDateTime = ulDueTime.HighPart;
	FileDueTime.dwLowDateTime = ulDueTime.LowPart;

	SetThreadpoolTimer(timer,
		&FileDueTime,
		0,
		0);

	//
	// Delay for the timer to be fired
	//
	Sleep(1500);

	//
	// Wait for all callbacks to finish.
	// CloseThreadpoolCleanupGroupMembers also releases objects
	// that are members of the cleanup group, so it is not necessary 
	// to call close functions on individual objects 
	// after calling CloseThreadpoolCleanupGroupMembers.
	//
	CloseThreadpoolCleanupGroupMembers(cleanupgroup,
		FALSE,
		NULL);

	//
	// Already cleaned up the work item with the
	// CloseThreadpoolCleanupGroupMembers, so set rollback to 2.
	//
	rollback = 2;
	goto main_cleanup;

main_cleanup:
	//
	// Clean up any individual pieces manually
	// Notice the fall-through structure of the switch.
	// Clean up in reverse order.
	//

	switch (rollback) {
	case 4:
	case 3:
		// Clean up the cleanup group members.
		CloseThreadpoolCleanupGroupMembers(cleanupgroup,
			FALSE, NULL);
	case 2:
		// Clean up the cleanup group.
		CloseThreadpoolCleanupGroup(cleanupgroup);

	case 1:
		// Clean up the pool.
		CloseThreadpool(pool);

	default:
		break;
	}

	return;
}

VOID
DemoRegisterWait()
{
	PTP_WAIT Wait = NULL;
	PTP_WAIT_CALLBACK waitcallback = MyWaitCallback;
	HANDLE hEvent = NULL;
	UINT i = 0;
	UINT rollback = 0;

	//
	// Create an auto-reset event.
	//
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	if (NULL == hEvent) {
		// Error Handling
		return;
	}

	rollback = 1; // CreateEvent succeeded

	Wait = CreateThreadpoolWait(waitcallback,
		NULL,
		NULL);

	if (NULL == Wait) {
		_tprintf(_T("CreateThreadpoolWait failed. LastError: %u\n"),
			GetLastError());
		goto new_wait_cleanup;
	}

	rollback = 2; // CreateThreadpoolWait succeeded

	//
	// Need to re-register the event with the wait object
	// each time before signaling the event to trigger the wait callback.
	//
	for (i = 0; i < 5; i++) {
		SetThreadpoolWait(Wait,
			hEvent,
			NULL);

		SetEvent(hEvent);

		//
		// Delay for the waiter thread to act if necessary.
		//
		Sleep(500);

		//
		// Block here until the callback function is dEight executing.
		//

		WaitForThreadpoolWaitCallbacks(Wait, FALSE);
	}

new_wait_cleanup:
	switch (rollback) {
	case 2:
		// Unregister the wait by setting the event to NULL.
		SetThreadpoolWait(Wait, NULL, NULL);

		// Close the wait.
		CloseThreadpoolWait(Wait);

	case 1:
		// Close the event.
		CloseHandle(hEvent);

	default:
		break;
	}
	return;
}



void DirectXGPUDigitalLabCoreModule::MainDataLoop()
{
	
}


LONG DeleteKey(HKEY hKeyParent, const char* lpszKeyChild)
{
	HKEY hKeyChild;
	LONG lRes = RegOpenKeyEx(hKeyParent, (LPCWSTR)lpszKeyChild, 0, KEY_ALL_ACCESS, &hKeyChild);
	if (lRes != ERROR_SUCCESS) return lRes;
	FILETIME time;
	char szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(hKeyChild, 0, (LPWSTR)szBuffer, &dwSize, NULL, NULL, NULL, &time) == S_OK)
	{
		lRes = DeleteKey(hKeyChild, szBuffer);
		if (lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKeyChild);
			return lRes;
		}
		dwSize = 256;
	}
	RegCloseKey(hKeyChild);
	return RegDeleteKey(hKeyParent, (LPCWSTR)lpszKeyChild);
}

VOID GetAnswerToRequest(LPPIPEINST pipe)
{
	_tprintf(TEXT("[%d] %s\n"), pipe->hPipeInst, pipe->chRequest);
	StringCchCopy(pipe->chReply, BUFSIZE, TEXT("Default answer from server"));
	pipe->cbToWrite = (lstrlen(pipe->chReply) + 1)*sizeof(TCHAR);
}


PixelObject GetPixelByXAndYPosition(vector<PixelObject> pPixelVector, float pXPosition, float pYPosition)
{
	PixelObject pNewPixel = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
	for (PixelObject pPixelObjectVar : pPixelVector)
	{
		if ((pPixelObjectVar.xPosition == pXPosition) && (pPixelObjectVar.yPosition == pYPosition))
		{
			pNewPixel = pPixelObjectVar;
		}
	}

	return pNewPixel;
}



void ProcessErrorHandling(LPTSTR lpszFunction)
{
	PVOID lpMsgBuf;
	LPVOID lpDisplayBuf;
	DWORD dw = GetLastError();

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf,
		0, NULL);

	// Display the error message.

	lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,
		(lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR));
	StringCchPrintf((LPTSTR)lpDisplayBuf,
		LocalSize(lpDisplayBuf) / sizeof(TCHAR),
		TEXT("%s failed with error %d: %s"),
		lpszFunction, dw, lpMsgBuf);
	MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);

	// Free error-handling buffer allocations.

	LocalFree(lpMsgBuf);
	LocalFree(lpDisplayBuf);
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeConnectionTo1C(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	CLSID cls77;
	IDispatch* pv77 = nullptr;

	hr = CoCreateInstance(cls77, NULL, CLSCTX_LOCAL_SERVER, IID_IDispatch, (void**)&pv77);

	if (FAILED(hr) || !pv77)
	{
		cout << "Unable to Connect to 1C APPLICATION SERVER" << endl;
		MessageBoxA(hWnd, (LPCSTR)L"Невозможно инициализировать интерфейс 1С Предприятия", (LPCSTR)"Message", 0);
		CoUninitialize();
		return FALSE;
	}

	VARIANT       vRet;
	DISPID dispIDRmTrade, dispIDInitialize;
	DISPPARAMS args = { 0, 0, 0, 0 };
	VARIANT vars[3];  // Параметры для вызова Initialize

	//Мы получим IDispatch интерфейс от RMTrade сразу в vars[2]

	BSTR rmTrade = L"RMTrade";

	hr = pv77->GetIDsOfNames(IID_NULL, &rmTrade, 1, 0, &dispIDRmTrade);

	if (FAILED(hr))
	{
		cout << "Unable to Get the ID from Trade ARM" << endl;
		MessageBoxA(hWnd, (LPCSTR)L"Невозможно получить ID от RMTrade", (LPCSTR)"Message", 0);
		if (pv77)
			pv77->Release();
		CoUninitialize();
		return FALSE;
	}

	hr = pv77->Invoke(dispIDRmTrade, IID_NULL, 0, DISPATCH_PROPERTYGET, &args,
		&vars[2], NULL, NULL);

	if (FAILED(hr))
	{
		cout << "Unable to get the interface of ARM Trade" << endl;
		MessageBoxA(hWnd, (LPCSTR)L"Невозможно получить интерфейс от RMTrade", (LPCSTR)"Message", 0);
		if (pv77)
			pv77->Release();
		CoUninitialize();
		return FALSE;
	}

	//нужно получить ID для Initialize(..);
	BSTR init = L"Initialize";
	hr = pv77->GetIDsOfNames(IID_NULL, &init, 1, 0, &dispIDInitialize);
	if (FAILED(hr))
	{
		cout << "Unable to get the ID of Initialize Method" << endl;
		MessageBoxA(hWnd, (LPCSTR)L"Не удалось получить ID от Initialize", (LPCSTR)"Message", 0);
			if (pv77)
				pv77->Release();
		CoUninitialize();
		return FALSE;
	}

	/*
	а теперь – вызвать этот самый Initialize(..),
	но сперва необходимо заполнить массив аргументов функции
	*/

	args.cArgs = 3;
	args.rgvarg = vars;
	vars[0] = _variant_t("NO_SPLASH_SHOW");
	vars[1] = _variant_t("/D D:\1S /N Denis /P Denis ");

	/*
	vars[2] – у нас уже есть, мы его получили при запросе
	интерфейса RMTrade в момент предыдущего Invoke
	*/

	hr = pv77->Invoke(dispIDInitialize, IID_NULL, 0, DISPATCH_PROPERTYGET, &args,
		&vRet, NULL, NULL);

	if (FAILED(hr) || (vRet.vt == VT_BOOL && vRet.bstrVal == 0x00))
	{
		cout << "Unable to Launch 1C Enterprise Software" << endl;
		MessageBoxA(hWnd, (LPCSTR)L"Невозможно запустить 1С Предприятие", (LPCSTR)"Message", 0);
	}
}

HRESULT DirectXGPUDigitalLabCoreModule::ConnectToAgentNamedPipeServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXConnectedApplicationLauncher* pConnectionLauncherManager = m_pConnectedApplicationLauncher;

	if (!pConnectionLauncherManager || pConnectionLauncherManager == nullptr)
	{
		pConnectionLauncherManager = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	}

	hr = pConnectionLauncherManager->ConnectToAgentPipe(hInstance, hWnd);

	return hr;


}






VOID CALLBACK TimerRoutine(PVOID lpParam, BOOLEAN TimerOrWaitFired)
{
	if (lpParam == NULL)
	{
		printf("TimerRoutine lpParam is NULL\n");
	}
	else
	{
		// lpParam points to the argument; in this case it is an int

		printf("Timer routine called. Parameter is %d.\n",
			*(int*)lpParam);
		if (TimerOrWaitFired)
		{
			printf("The wait timed out.\n");
		}
		else
		{
			printf("The wait event was signaled.\n");
		}
	}

	
}

int TestDataProcessingThread()
{
	
	PDATAFRAME pDataArray[MAX_THREADS];
	DWORD dwThreadIdArray[MAX_THREADS];
	HANDLE pThreadArray[MAX_THREADS];

	for (int iIndex = 0; iIndex < MAX_THREADS; iIndex++)
	{
		pDataArray[iIndex] = (PDATAFRAME)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
			sizeof(DATAFRAME));

		if (pDataArray[iIndex] == NULL)
		{
			return 2;
		}

		pDataArray[iIndex]->val1 = iIndex;
		pDataArray[iIndex]->val2 = iIndex + 100;
	
		pThreadArray[iIndex] = CreateThread(NULL,
			0,
			ProcessGPUDigitalLabDataLoop,
			pDataArray[iIndex],
			0,
			&dwThreadIdArray[iIndex]);

		if (pThreadArray[iIndex] == NULL)
		{
			ProcessErrorHandling(TEXT("CreateThread"));
			return 3;
		}
	}
	WaitForMultipleObjects(MAX_THREADS, pThreadArray, TRUE, INFINITE);
	for (int i = 0; i < MAX_THREADS; i++)
	{
		CloseHandle(pThreadArray[i]);
		if (pDataArray[i] != NULL)
		{
			HeapFree(GetProcessHeap(), 0, pDataArray[i]);
			pDataArray[i] = NULL;    // Ensure address is not reused.
		}
	}

	return 0;

}



HRESULT InitializeInternalProcessingEngine(HINSTANCE hInstance, HWND hWnd)
{

	BOOL fSuccess;


	HRESULT hr = S_OK;
	DWORD i, dwWait, cbRet, dwErr;

	vector<LPTSTR> pPipeInstanceObjects = vector<LPTSTR>();
	pPipeInstanceObjects.resize(13);

	pPipeInstanceObjects[0] = lpszPipenameMain;
	pPipeInstanceObjects[1] = lpszPipeAlgorithms;
	pPipeInstanceObjects[2] = lpszPipeCloud;
	pPipeInstanceObjects[3] = lpsPipeNetwork;
	pPipeInstanceObjects[4] = lpsPipeAgents;
	pPipeInstanceObjects[5] = lpsPipeAgentInstances;
	pPipeInstanceObjects[6] = lpsPipAgentController;
	pPipeInstanceObjects[7] = lpsConnectedApplications;
	pPipeInstanceObjects[8] = lpsExperiments;
	pPipeInstanceObjects[9] = lpsAnimations;
	pPipeInstanceObjects[10] = lpsJobsObject;
	pPipeInstanceObjects[11] = lpsDatabaseManager;
	pPipeInstanceObjects[12] = lpsTaskManager;




	for (int i = 0; i < INSTANCES - 1; i++)
	{
		pInternalEventsCollection[i] = CreateEvent(NULL,
			TRUE,
			TRUE,
			NULL);


		if (pInternalEventsCollection[i] == NULL)
		{
			printf("CreateEvent failed with %d.\n", GetLastError());
			hr = E_FAIL;
			return hr;
		}

		pInternalPipesCollection[i].oOverlap.hEvent = pInternalEventsCollection[i];

		pInternalPipesCollection[i].hPipeInst = CreateNamedPipe(
			pPipeInstanceObjects[i],
			PIPE_ACCESS_DUPLEX |
			PIPE_ACCESS_DUPLEX |     // read/write access 
			FILE_FLAG_OVERLAPPED,    // overlapped mode 
			PIPE_TYPE_MESSAGE |      // message-type pipe 
			PIPE_READMODE_MESSAGE |  // message-read mode 
			PIPE_WAIT,               // blocking mode 
			INSTANCES,               // number of instances 
			BUFSIZE*sizeof(TCHAR),   // output buffer size 
			BUFSIZE*sizeof(TCHAR),   // input buffer size 
			PIPE_TIMEOUT,            // client time-out 
			NULL);                   // default security attributes 

		cout << "A new Pipe Connection is Established to Our Kernel and has an id " << pPipeInstanceObjects[i] << endl;

		if (pInternalPipesCollection[i].hPipeInst == INVALID_HANDLE_VALUE)
		{
			printf("CreateNamedPipe failed with %d.\n", GetLastError());
			return 0;
		}

		// Call the subroutine to connect to the new client

		pInternalPipesCollection[i].fPendingIO = ConnectTEightwClient(
			pInternalPipesCollection[i].hPipeInst,
			&pInternalPipesCollection[i].oOverlap);

		pInternalPipesCollection[i].dwState = pInternalPipesCollection[i].fPendingIO ?
		CONNECTING_STATE : // still connecting 
						   READING_STATE;     // ready to read 

		while (1)
		{
			// Wait for the event object to be signaled, indicating 
			// completion of an overlapped read, write, or 
			// connect operation. 

			dwWait = WaitForMultipleObjects(
				INSTANCES,    // number of event objects 
				pInternalEventsCollection,      // array of event objects 
				FALSE,        // does not wait for all 
				INFINITE);    // waits indefinitely 

			// dwWait shows which pipe completed the operation. 

			i = dwWait - WAIT_OBJECT_0;  // determines which pipe 
			if (i < 0 || i >(INSTANCES - 1))
			{
				printf("Index out of range.\n");
				return 0;
			}

			// Get the result if the operation was pending. 

			if (pInternalPipesCollection[i].fPendingIO)
			{
				fSuccess = GetOverlappedResult(
					pInternalPipesCollection[i].hPipeInst, // handle to pipe 
					&pInternalPipesCollection[i].oOverlap, // OVERLAPPED structure 
					&cbRet,            // bytes transferred 
					FALSE);            // do not wait 

				switch (pInternalPipesCollection[i].dwState)
				{
					// Pending connect operation 
				case CONNECTING_STATE:
					if (!fSuccess)
					{
						printf("Error %d.\n", GetLastError());
						return 0;
					}
					pInternalPipesCollection[i].dwState = READING_STATE;
					break;

					// Pending read operation 
				case READING_STATE:
					if (!fSuccess || cbRet == 0)
					{
						DisconnectAndReconnect(i);
						continue;
					}
					pInternalPipesCollection[i].cbRead = cbRet;
					pInternalPipesCollection[i].dwState = WRITING_STATE;
					break;

					// Pending write operation 
				case WRITING_STATE:
					if (!fSuccess || cbRet != pInternalPipesCollection[i].cbToWrite)
					{
						DisconnectAndReconnect(i);
						continue;
					}
					pInternalPipesCollection[i].dwState = READING_STATE;
					break;

				default:
				{
					printf("Invalid pipe state.\n");
					return 0;
				}
				}
			}

			// The pipe state determines which operation to do next. 

			switch (pInternalPipesCollection[i].dwState)
			{
				// READING_STATE: 
				// The pipe instance is connected to the client 
				// and is ready to read a request from the client. 

			case READING_STATE:
				fSuccess = ReadFile(
					pInternalPipesCollection[i].hPipeInst,
					pInternalPipesCollection[i].chRequest,
					BUFSIZE*sizeof(TCHAR),
					&pInternalPipesCollection[i].cbRead,
					&pInternalPipesCollection[i].oOverlap);

				// The read operation completed successfully. 

				if (fSuccess && pInternalPipesCollection[i].cbRead != 0)
				{
					pInternalPipesCollection[i].fPendingIO = FALSE;
					pInternalPipesCollection[i].dwState = WRITING_STATE;
					continue;
				}

				// The read operation is still pending. 

				dwErr = GetLastError();
				if (!fSuccess && (dwErr == ERROR_IO_PENDING))
				{
					pInternalPipesCollection[i].fPendingIO = TRUE;
					continue;
				}

				// An error occurred; disconnect from the client. 

				DisconnectAndReconnect(i);
				break;

				// WRITING_STATE: 
				// The request was successfully read from the client. 
				// Get the reply data and write it to the client. 

			case WRITING_STATE:
				GetAnswerToRequest(&pInternalPipesCollection[i]);

				fSuccess = WriteFile(
					pInternalPipesCollection[i].hPipeInst,
					pInternalPipesCollection[i].chReply,
					pInternalPipesCollection[i].cbToWrite,
					&cbRet,
					&pInternalPipesCollection[i].oOverlap);

				// The write operation completed successfully. 

				if (fSuccess && cbRet == pInternalPipesCollection[i].cbToWrite)
				{
					pInternalPipesCollection[i].fPendingIO = FALSE;
					pInternalPipesCollection[i].dwState = READING_STATE;
					continue;
				}

				// The write operation is still pending. 

				dwErr = GetLastError();
				if (!fSuccess && (dwErr == ERROR_IO_PENDING))
				{
					pInternalPipesCollection[i].fPendingIO = TRUE;
					continue;
				}

				// An error occurred; disconnect from the client. 

				DisconnectAndReconnect(i);
				break;

			default:
			{
				printf("Invalid pipe state.\n");
				return 0;
			}
			}
		}

		return 0;

	}
}

void DisconnectAndReconnect(DWORD iIndex)
{
	if (!DisconnectNamedPipe(pInternalPipesCollection[iIndex].hPipeInst))
	{
		printf("DisconnectNamedPipe failed with %d.\n", GetLastError());
	}

	// Call a subroutine to connect to the new client. 

	pInternalPipesCollection[iIndex].fPendingIO = ConnectTEightwClient(
		pInternalPipesCollection[iIndex].hPipeInst,
		&pInternalPipesCollection[iIndex].oOverlap);

	pInternalPipesCollection[iIndex].dwState = pInternalPipesCollection[iIndex].fPendingIO ?
	CONNECTING_STATE : // still connecting 
					   READING_STATE;     // ready to read 
}


BOOL ConnectTEightwClient(HANDLE hPipe, LPOVERLAPPED lpo)
{
	BOOL fConnected, fPendingIO = FALSE;

	// Start an overlapped connection for this pipe instance. 
	fConnected = ConnectNamedPipe(hPipe, lpo);

	// Overlapped ConnectNamedPipe should return zero. 
	if (fConnected)
	{
		printf("ConnectNamedPipe failed with %d.\n", GetLastError());
		
	}

	switch (GetLastError())
	{
		// The overlapped connection in progress. 
	case ERROR_IO_PENDING:
		fPendingIO = TRUE;
		break;

		// Client is already connected, so signal an event. 

	case ERROR_PIPE_CONNECTED:
		if (SetEvent(lpo->hEvent))
			break;

		// If an error occurs during the connect operation... 
	default:
	{
		printf("ConnectNamedPipe failed with %d.\n", GetLastError());
		
	}
	}

	return fPendingIO;
}

void ShutdownGPUDigitalLabKernel()
{
	for (auto it = std::begin(pKernelsInMemory); it <= std::end(pKernelsInMemory); ++it)
	{
		
		SafeReleaseA(&(*it));
	}
}





HRESULT InitializeGPUDigitalLab()
{
	HRESULT hr = S_OK;
	pKernelsInMemory = vector<DirectXGPUDigitalLabCoreModule*>();
	pKernelsInMemory.resize(10);
	DirectXGPUDigitalLabCoreModule* pCoreModule = nullptr;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc;
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = DirectXGPUDigitalLabCoreModule::CreateInstance(hInstance, hWnd, hWnd, &pCoreModule);
	pKernelsInMemory.push_back(pCoreModule);
	return hr;
}

HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
	const CLSID& clsid,         // Class ID
	const char* szFriendlyName, // Friendly Name
	const char* szVerIndProgID, // Programmatic
	const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512];
	DWORD dwResult =
		::GetModuleFileName(hModule,
		(LPWSTR)szModule,
		sizeof(szModule) / sizeof(char));
	assert(dwResult != 0);

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE];
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID));

	// Build the key CLSID\\{...}
	char szKey[64];
	strcpy(szKey, "CLSID\\");
	strcat(szKey, szCLSID);

	// Add the CLSID to the registry.
	SetKey(szKey, NULL, szFriendlyName);

	// Add the server filename subkey under the CLSID key.
	SetKey(szKey, "InprocServer32", szModule);

	// Add the ProgID subkey under the CLSID key.
	SetKey(szKey, "ProgID", szProgID);

	// Add the version-independent ProgID subkey under CLSID key.
	SetKey(szKey, "VersionIndependentProgID",
		szVerIndProgID);

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	SetKey(szVerIndProgID, NULL, szFriendlyName);
	SetKey(szVerIndProgID, "CLSID", szCLSID);
	SetKey(szVerIndProgID, "CurVer", szProgID);

	// Add the versiEightd ProgID subkey under HKEY_CLASSES_ROOT.
	SetKey(szProgID, NULL, szFriendlyName);
	SetKey(szProgID, "CLSID", szCLSID);

	return S_OK;
}


STDMETHODIMP DirectXGPUDigitalLabCoreModule::CreateInstance(HINSTANCE hInstance,
	HWND hVideo,
	HWND hEvent,
	DirectXGPUDigitalLabCoreModule **m_pD3DGPUDigitalLabCoreClass)
{
	LPCLASSFACTORY pcf = NULL;

	HRESULT hr = S_OK;
	LPDWORD pdRegisterCF = 0;
	LPDWORD pdwRegisterClassObj = 0;
	HANDLE pMutexObject = NULL;
	
	ITypeLib* pTypeLib;
    hr = LoadTypeLibEx(L"DirectXGPUDigitalLabSoftware.exe", REGKIND_DEFAULT, &pTypeLib);
	SafeReleaseA(&pTypeLib);

	CLSIDFromString(L"{0523B590-2A7A-408F-80F2-8AEB1BBDEDD7}", &GPUDigitalLabObj);
	CLSIDFromString(L"{CBDDDCC5-48E6-4100-8AF7-F4509C58C4AF}", &GPUDigtitalClientObj);



	hr = RegisterServer(hInstance, CLSID_CDirectXGPUDigitalLabSoftwareKernelObject,
	 "GPUDigitalLab Data Processing Kernel", "GPUDigitalLab COM Component", "Вычислительное Ядро Системы GPUDigitalLab");
	


		pMutexObject = CreateMutex(nullptr, TRUE, L"Initialization");

		hr = OleInitialize(NULL);

		DirectXGPUDigitalLabCoreModule* md3dgpudigitalLabCore = new DirectXGPUDigitalLabCoreModule(hInstance, hVideo);

		if (SUCCEEDED(hr))
		{
			hr = md3dgpudigitalLabCore->InitializeGPUDigitalLabCore(hInstance, hVideo);
			if (SUCCEEDED(hr))
			{
				md3dgpudigitalLabCore->InitializeGPUDigitalLabServiceObject(hInstance, hVideo);
				*m_pD3DGPUDigitalLabCoreClass = md3dgpudigitalLabCore;
				(*m_pD3DGPUDigitalLabCoreClass)->AddRef();
				
			}

	
			
		}
	


	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ConnectToLocalModuleService(HINSTANCE hInstance, HWND hWnd, LPCSTR pServiceName)
{
	HRESULT hr = S_OK;
	SERVICE_STATUS_PROCESS ssp;
	DWORD dwStartTime = GetTickCount();
	DWORD dwBytesNeeded;
	DWORD dwTimeout = 30000; // 30-second time-out
	DWORD dwWaitTime;
	SC_HANDLE m_pSCMManager;
	SC_HANDLE pServiceHandle;
	// Get a handle to the SCM database. 

	m_pSCMManager = OpenSCManager(
		NULL,                    // local computer
		NULL,                    // ServicesActive database 
		SC_MANAGER_ALL_ACCESS);  // full access rights 

	if (NULL == m_pSCMManager)
	{
		printf("OpenSCManager failed (%d)\n", GetLastError());
		return hr;
	}

	// Get a handle to the service.

	pServiceHandle = OpenService(
		m_pSCMManager,         // SCM database 
		(LPCWSTR)pServiceName,            // name of service 
		SERVICE_QUERY_STATUS |
		SERVICE_ENUMERATE_DEPENDENTS);

	if (pServiceHandle == NULL)
	{
		printf("OpenService failed (%d)\n", GetLastError());
		CloseServiceHandle(pServiceHandle);
		CloseServiceHandle(m_pSCMManager);
		return hr;
	}

	// Make sure the service is not already stopped.

	if (!QueryServiceStatusEx(
		pServiceHandle,
		SC_STATUS_PROCESS_INFO,
		(LPBYTE)&ssp,
		sizeof(SERVICE_STATUS_PROCESS),
		&dwBytesNeeded))
	{
		printf("QueryServiceStatusEx failed (%d)\n", GetLastError());
		CloseServiceHandle(pServiceHandle);
		CloseServiceHandle(m_pSCMManager);
		return hr;
	}

	if (ssp.dwCurrentState == SERVICE_STOPPED)
	{
		printf("Service is already stopped.\n");
		CloseServiceHandle(pServiceHandle);
		CloseServiceHandle(m_pSCMManager);
		return hr;
	}

	// If a stop is pending, wait for it.

	while (ssp.dwCurrentState == SERVICE_STOP_PENDING)
	{
		printf("Service stop pending...\n");

		// Do not wait longer than the wait hint. A good interval is 
		// Eight-tenth of the wait hint but not less than 1 second  
		// and not more than 10 seconds. 

		dwWaitTime = ssp.dwWaitHint / 10;

		if (dwWaitTime < 1000)
			dwWaitTime = 1000;
		else if (dwWaitTime > 10000)
			dwWaitTime = 10000;

		Sleep(dwWaitTime);

		if (!QueryServiceStatusEx(
			pServiceHandle,
			SC_STATUS_PROCESS_INFO,
			(LPBYTE)&ssp,
			sizeof(SERVICE_STATUS_PROCESS),
			&dwBytesNeeded))
		{
			printf("QueryServiceStatusEx failed (%d)\n", GetLastError());
			CloseServiceHandle(pServiceHandle);
			CloseServiceHandle(m_pSCMManager);
			return hr;
		}

		if (ssp.dwCurrentState == SERVICE_STOPPED)
		{
			printf("Service stopped successfully.\n");
			goto stop_cleanup;
		}

		if (GetTickCount() - dwStartTime > dwTimeout)
		{
			printf("Service stop timed out.\n");
			CloseServiceHandle(pServiceHandle);
			CloseServiceHandle(m_pSCMManager);
			return hr;
		}
	}

	// If the service is running, dependencies must be stopped first.

	
	// Send a stop code to the service.

	if (!ControlService(
		pServiceHandle,
		SERVICE_CONTROL_STOP,
		(LPSERVICE_STATUS)&ssp))
	{
		printf("ControlService failed (%d)\n", GetLastError());
		CloseServiceHandle(pServiceHandle);
		CloseServiceHandle(m_pSCMManager);
		return hr;
	}

	// Wait for the service to stop.

	while (ssp.dwCurrentState != SERVICE_STOPPED)
	{
		Sleep(ssp.dwWaitHint);
		if (!QueryServiceStatusEx(
			pServiceHandle,
			SC_STATUS_PROCESS_INFO,
			(LPBYTE)&ssp,
			sizeof(SERVICE_STATUS_PROCESS),
			&dwBytesNeeded))
		{
			printf("QueryServiceStatusEx failed (%d)\n", GetLastError());
			CloseServiceHandle(pServiceHandle);
			CloseServiceHandle(m_pSCMManager);
			return hr;
		}

		if (ssp.dwCurrentState == SERVICE_STOPPED)
			break;

		if (GetTickCount() - dwStartTime > dwTimeout)
		{
			printf("Wait timed out\n");
			CloseServiceHandle(pServiceHandle);
			CloseServiceHandle(m_pSCMManager);
			return hr;
		}
	}
	printf("Service stopped successfully\n");

stop_cleanup:
	CloseServiceHandle(pServiceHandle);
	CloseServiceHandle(m_pSCMManager);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::PerformLocalComRegistration(HINSTANCE hInstance, HWND hWnd, IUnknown* pUnkPtr, char* pMonikerName)
{
	HRESULT hr = S_OK;

	WCHAR               wszObject[128];
	WCHAR               wszMsg[128] = { L"Your Message Here...\n" };
	IMoniker            *pmkObject = NULL;
	IUnknown           *pIUnk = NULL;
	IPersistFile        *pIPersistFile = NULL;
	IDirectXDigitalLabSoftwareKernelInterface   *pICustomInterface = NULL;
	IRunningObjectTable* pRunningObjectTable = NULL;
	DWORD regId = 0;

	StringCchVPrintf(wszObject, 128, L"%hs", pMonikerName);


	
	hr = GetRunningObjectTable(0, &pRunningObjectTable);

	if (FAILED(hr))
	{
		return hr;
	}

	hr = CreateFileMoniker(wszObject, &pmkObject);

	if (FAILED(hr))
	{
		printf("Client: CreateFileMoniker for Object failed");
		return hr;
	}

	if (SUCCEEDED(hr))
	{
		hr = pRunningObjectTable->Register(ROTFLAGS_ALLOWANYCLIENT, pIUnk, pmkObject, &regId);
	}

}



HRESULT __stdcall DirectXGPUDigitalLabCoreModule::CreateInstance(
	IUnknown *pUnkOuter,
	REFIID riid,
	void **ppvObject,
	HINSTANCE hInstance, HWND hWnd)
{

	OleInitialize(NULL);
	DWORD pdwRegisterCF = 0;
	DWORD pdwRegisterActiveObject = 0;
	HRESULT hr = S_OK;
	DWORD regId;
	HANDLE hEvent;
	IDirectXDigitalLabSoftwareKernelInterface* pObject;

	 hr = CoGetClassObject(CLSID_CDirectXGPUDigitalLabSoftwareKernelObject,
		CLSCTX_LOCAL_SERVER, 0, IID_IDirectXDigitalLabSoftwareKernelInterfaceObject, (void**)&pObject);
	 pObject->InitializeGPUDigitalLabCore(hInstance, hWnd);

	GUID guid1;
	GUID guid2;
	hr = CoCreateGuid(&guid1);
	hr = CoCreateGuid(&guid2);
	CLSIDFromString(L"{0523B590-2A7A-408F-80F2-8AEB1BBDEDD7}", &GPUDigitalLabObj);
	CLSIDFromString(L"{CBDDDCC5-48E6-4100-8AF7-F4509C58C4AF}", &GPUDigtitalClientObj);

	// Convert the GUID to a string
	RPC_WSTR  guidStr1;
	RPC_WSTR  guidStr2;

	UuidToString(&guid1, &guidStr1);
	UuidToString(&guid2, &guidStr2);


	DirectXGPUDigitalLabCoreModule* ppKernerCore = new DirectXGPUDigitalLabCoreModule();
	ppKernerCore->InitializeGPUDigitalLabCore(hInstance, hWnd);
	ppKernerCore->AddRef();


	hr = CoRegisterClassObject(CLSID_DirectXGPUDigitalLabCoreModule,
		reinterpret_cast<IUnknown*>(ppKernerCore),
		CLSCTX_LOCAL_SERVER,
		REGCLS_SUSPENDED | REGCLS_MULTIPLEUSE,
		&pdwRegisterCF);

	LPCLASSFACTORY pcf = NULL;
	pcf = new DirectXGPUDigitalLabClassFactory(hInstance, hWnd);
	pcf->AddRef();

	DirectXGPUDigitalLabClassFactory* ppGPUDigitalLabClassFactory = new DirectXGPUDigitalLabClassFactory(hInstance, hWnd);
	ppGPUDigitalLabClassFactory->AddRef();



	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Unable To Initialize GPUDigitalLab Kernel", (LPCSTR)"Message", 0);
	}

	if (SUCCEEDED(hr))
	{
		LPOLESTR stringGuid = nullptr;
		StringFromCLSID(GPUDigitalLabObj, &stringGuid);
		MessageBoxA(hWnd, (LPCSTR)"An Instance of GPUDigitalLab Kernel is Successfully Registered ANS HAS AN ID {6942E971 - 6F95 - 44BC - B3A9 - EFD270EB39C9}", (LPCSTR)"Message", 0);
	}



	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Unable To Initialize GPUDigitalLab Kernel ActiveX COM", (LPCSTR)"Message", 0);
	}


	CoAddRefServerProcess();


	IRunningObjectTable*  pObjectTable = nullptr;
	IMoniker*               pMoniker = NULL;

	hr = GetRunningObjectTable(0, &pObjectTable);

	if (FAILED(hr))
	{
		return hr;
	}
	LPCOLESTR pFileName = L"GPUDigitalLab Kernel";

	hr = CreateFileMoniker(pFileName, &pMoniker);

	if (SUCCEEDED(hr))
	{
		hr = pObjectTable->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, pUnkOuter, pMoniker, &regId);
	}

	IBindCtx* ctx;
	IRunningObjectTable* table;
	IEnumMoniker* pEnumMoniker;
	IMoniker* pMonikerObj;

	hr = CreateBindCtx(0, &ctx);
	ctx->GetRunningObjectTable(&table);
	table->EnumRunning(&pEnumMoniker);

	while (pEnumMoniker->Next(1, &pMonikerObj, 0) == 0)
	{
		LPOLESTR displayName;
		pMonikerObj->GetDisplayName(ctx, pMonikerObj, &displayName);
		printf((char*)displayName);
	}

	
	
	if (SUCCEEDED(hr))
	{
		LPOLESTR stringGuid = nullptr;
		StringFromCLSID(GPUDigitalLabObj, &stringGuid);
		cout << "We Have Successfully Registered a new COM Object"  << (char)stringGuid << endl;
		MessageBoxA(hWnd, (LPCSTR)"An Instance of GPUDigitalLab Kernel is Successfully Registered ANS HAS AN ID {6942E971 - 6F95 - 44BC - B3A9 - EFD270EB39C9} ", (LPCSTR)"Message", 0);

	
	}

	CoResumeClassObjects();
	

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::StartDataProcessingThreads(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD i, dwWait, cbRet, dwErr;
	BOOL fSuccess;
	LPTSTR lpszPipename = TEXT("\\\\.\\pipe\\mynamedpipe");

	HANDLE hDataProcessingMutex = CreateMutex(NULL, FALSE, NULL);

	for (int iIndex = 0; iIndex < INSTANCES; iIndex++)
	{
		pInternalEventsCollection[iIndex] = CreateEvent(
			NULL,    // default security attribute 
			TRUE,    // manual-reset event 
			TRUE,    // initial state = signaled 
			NULL);   // unnamed event object 
	}


	WaitForSingleObject(hDataProcessingMutex, INFINITE);
	ReleaseMutex(hDataProcessingMutex);
	return hr;
}


HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeVideoProcessingEngine()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeMolecularSimulationRenderingModule()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeRenderFarmSModule()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeRenderToTextureRenderingEngine()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT  DirectXGPUDigitalLabCoreModule::InitializeVideoProcessingEngine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownMolecularSimulationRenderingModule()
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownRenderFarmSModule()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownVideoProcessingEngine()
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownRaytracerRenderingEngine()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownDMOLSimulationAnimation()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownIndustrialSimulationAnimation()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownFluidDynamicsAnimation()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownModuleProcessingWidgets()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownApplicationDomainInstanceClass()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownAppicationDomainManagerClass()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownEventProcessingModule()
{
	HRESULT hr = S_OK;
	return hr;
}




HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ShutdownUserAccountController()
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::MyComMessage()
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ExtractPointsFromGraph(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSelectedPoints.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<Point2D> pPointArray = vector<Point2D>();
	vector<OutputPixelObjectPoint2D> ppOutputPixelVector = vector<OutputPixelObjectPoint2D>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pAmountOfPointsToDetect = 0.0f;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;


	cout << "Now you will have to enter the points for detection" << endl;

	cout << "Enter the Amount of Points you want to have" << endl;
	cin >> pAmountOfPointsToDetect;

	int pPointIndex = 0;
	for (int pCounter = 0; pCounter < pAmountOfPointsToDetect; ++pCounter)
	{
		float pXPositionVar = 0.0f;
		float pYPositionVar = 0.0f;

		cout << "Enter the X Position Of The Point" << endl;
		cin >> pXPositionVar;

		cout << "Enter the Y Position of the Point: " << endl;
		cin >> pYPositionVar;

		Point2D pPointObject;
		pPointObject.pPointNumber = pPointIndex;
		pPointObject.xPosition = pXPositionVar;
		pPointObject.yPosition = pYPositionVar;
		pPointArray.push_back(pPointObject);

	}





	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<OutputPixelObjectPoint2D> ppOutputPixelVector = vector<OutputPixelObjectPoint2D>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		hr = ppStandardAlgorithmExecutor->DetectPointsInRGBImage(hInstance, hWnd,
			pixelObjectVector,
			pPointArray,
			&ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;


		int pPixelNumberOutput = 0.0f;
		float pXValueOutput = 0.0f;
		float pYValueOutput = 0.0f;
		float pXValuePoint = 0.0f;
		float pYValuePoint = 0.0f;
		float pRedComponentOutput = 0.0f;
		float pGreenComponentOutput = 0.0f;
		float pBlueComponentOutput = 0.0f;
		bool pUsedInComputations = false;

		vector<OutputPixelObjectFiltered> pFilteredPoints = vector<OutputPixelObjectFiltered>();

		for (OutputPixelObjectPoint2D pPixelObject : ppOutputPixelVector)
		{

			pPixelNumberOutput = pPixelObject.pixelNumber;
			pXValueOutput = pPixelObject.xPosition;
			pYValueOutput = pPixelObject.yPosition;
			pXValuePoint = pPixelObject.xPositionPoint;
			pYValuePoint = pPixelObject.yPositionPoint;

			pRedComponentOutput = pPixelObject.rValue;
			pGreenComponentOutput = pPixelObject.gValue;
			pBlueComponentOutput = pPixelObject.bValue;
			pUsedInComputations = pPixelObject.pIsPixelValid;


			cout << "Pixel Number: " << pPixelNumberOutput << endl;
			cout << "X Value = " << pXValueOutput << endl;
			cout << "Y Value = " << pYValueOutput << endl;
			cout << "X Value Point: " << pXValuePoint << endl;
			cout << "Y Value Point: " << pYValuePoint << endl;
			cout << "Red Component = " << pRedComponentOutput << endl;
			cout << "Green Component = " << pGreenComponentOutput << endl;
			cout << "Blue Component = " << pBlueComponentOutput << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumberOutput << endl;
			pixelDataFile << "X Value = " << pXValueOutput << endl;
			pixelDataFile << "Y Value = " << pYValueOutput << endl;
			pixelDataFile << "X Value Point: " << pXValuePoint << endl;
			pixelDataFile << "Y Value Point: " << pYValuePoint << endl;
			pixelDataFile << "Red Component = " << pRedComponentOutput << endl;
			pixelDataFile << "Green Component = " << pGreenComponentOutput << endl;
			pixelDataFile << "Blue Component = " << pBlueComponentOutput << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			OutputPixelObjectFiltered pFilteredPixel;
			pFilteredPixel.pixelNumber = pPixelNumberOutput;
			pFilteredPixel.xPosition = pXValueOutput;
			pFilteredPixel.yPosition = pYValueOutput;
			pFilteredPixel.rValue = pRedComponentOutput;
			pFilteredPixel.gValue = pGreenComponentOutput;
			pFilteredPixel.bValue = pBlueComponentOutput;
			pFilteredPixel.pUsedInComputations = pUsedInComputations;

			pFilteredPoints.push_back(pFilteredPixel);

		
			pIndexValue++;
		}

		cout << "Printing Output of filtered Pixels " << endl;
		pixelDataFile << "Printing Output of filtered Pixels " << endl;

		
		vector<PixelObject> pOutputRGBPixels = vector<PixelObject>();

		cout << "Restoring our filter Results to RGB" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd, pFilteredPoints, &pOutputRGBPixels);


		cout << "Printing Output" << endl;
		for (PixelObject pixelObject : pOutputRGBPixels)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pOutputRGBPixels, pTopLeftX, pTopLeftX, pImageWidth, pImageHeight);


	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFont(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObject.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	vector<OutputPixelObjectFiltered> pFilteredArrayEight = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredArrayTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredArrayThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredArrayFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredArrayFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredArraySix = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorValid = vector<OutputPixelObjectClassified>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorInvalid = vector<OutputPixelObjectClassified>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the Step For X Axis: " << endl;
	cin >> pStepX;


	cout << "Enter the Step For Y Axis: " << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;



	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Maximum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Maximum Value for Y Position" << endl;
	cin >> pMaximumY;


	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;

	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;


	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;

	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;

	
	
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "Performing Horizontal Scans For Number Eight" << endl;
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance,
			hWnd,
			200.0f, 300.0f, 200.0f, 
			0.0f, 0.0f, 0.0f,
			pixelObjectVector,
			&pFilteredArrayEight);

		cout << "Performing Horizontal Scans For Number Three" << endl;
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance,
			hWnd, 200.0f, 300.0f, 300.0f,
			0.0f, 0.0f, 0.0f,
			pixelObjectVector,
			&pFilteredArrayThree);

		cout << "Performing Horizontal Scans For Number Five" << endl;
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance,
			hWnd, 200.0f, 300.0f, 400.0f, 
			0.0f, 0.0f, 0.0f,
			pixelObjectVector,
			&pFilteredArrayFive);


		cout << "Performing Vertical Scans For Number Eight" << endl;
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance,
			hWnd,
			200.0f, 300.0f, 200.0f,
			0.0f, 0.0f, 0.0f,
			pixelObjectVector,
			&pFilteredArrayTwo);

		cout << "Performing Horizontal Scans For Number Three" << endl;
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance,
			hWnd, 200.0f, 300.0f, 300.0f,
			0.0f, 0.0f, 0.0f,
			pixelObjectVector,
			&pFilteredArrayFour);

		cout << "Performing Horizontal Scans For Number Five" << endl;
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance,
			hWnd, 200.0f, 300.0f, 400.0f,
			0.0f, 0.0f, 0.0f,
			pixelObjectVector,
			&pFilteredArraySix);



	}


	cout << "Merging vectors into Eight" << endl;
	vector<OutputPixelObjectFiltered> pFilterArrayOutput = vector<OutputPixelObjectFiltered>();
	pFilterArrayOutput.insert(std::begin(pFilteredArrayEight), std::end(pFilteredArrayEight), std::end(pFilterArrayOutput));
	pFilterArrayOutput.insert(std::begin(pFilteredArrayTwo), std::end(pFilteredArrayTwo), std::end(pFilterArrayOutput));
	pFilterArrayOutput.insert(std::begin(pFilteredArrayThree), std::end(pFilteredArrayThree), std::end(pFilterArrayOutput));
	pFilterArrayOutput.insert(std::begin(pFilteredArrayFour), std::end(pFilteredArrayFour), std::end(pFilterArrayOutput));
	pFilterArrayOutput.insert(std::begin(pFilteredArrayFive), std::end(pFilteredArrayFive), std::end(pFilterArrayOutput));
	pFilterArrayOutput.insert(std::begin(pFilteredArraySix), std::end(pFilteredArraySix), std::end(pFilterArrayOutput));






	vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
	vector<PixelObject> pFilterToReverseOutputInvalidPixels = vector<PixelObject>();

	cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pFilterArrayOutput,
		 &pFilterToReverseOutputValidPixels);

	cout << "Printing the Results of the Valid Pixels" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutputValidPixels)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutputValidPixels, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;

}



HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontSecondExperiment(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObject.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVectorEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();


	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorValid = vector<OutputPixelObjectClassified>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorInvalid = vector<OutputPixelObjectClassified>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;



	
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;

	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;


	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;

	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	CBBinaryClassifierConstantBuffer  pConstantBufferStruct;
	pConstantBufferStruct.pThresholdIntensityValueR = pRedValueToSelect;
	pConstantBufferStruct.pThresholdIntensityValueG = pGreenValueToSelect;
	pConstantBufferStruct.pThresholdIntensityValueB = pBlueValueToSelect;
	pConstantBufferStruct.pValidPixelConstant = 1;
	pConstantBufferStruct.pInvalidPixelConstant = 0;

	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;



		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorEight);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorEight)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Performing the Second scan of the image" << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		 pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

	
		vector<PixelObject>::iterator pVectorEightIt = pixelObjectVectorEight.end();
		pixelObjectVectorEight.insert(pVectorEightIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());

		hr = ppStandardAlgorithmExecutor->ApplyBinaryClassifierForImagePixels(hInstance,
			hWnd,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pValidClassifierToken,
			pInvalidClassifierToken,
			pixelObjectVectorEight,
			&ppOutputPixelVectorOutput);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();

		for (OutputPixelObjectClassified pPixelObject : ppOutputPixelVectorOutput)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			cout << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			cout << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			cout << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;

			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			pixelDataFile << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			pixelDataFile << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			pixelDataFile << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;



		}



	}



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
	vector<PixelObject> pFilterToReverseOutputInvalidPixels = vector<PixelObject>();

	cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreValidRGBPixelFromClassifier(hInstance, hWnd,
		pConstantBufferStruct,
		ppOutputPixelVectorOutput, &pFilterToReverseOutputValidPixels);

	cout << "Printing the Results of the Valid Pixels" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutputValidPixels)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Restoring Image Pixel Data for Filter Output Invalid Pixels" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreInvalidRGBPixelFromClassifier(hInstance, hWnd,
		pConstantBufferStruct,
		ppOutputPixelVectorOutput, &pFilterToReverseOutputInvalidPixels);

	cout << "Printing the Results of the Valid Pixels" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutputInvalidPixels)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutputValidPixels, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontThirddExperiment(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObjectThirdExperiment.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVectorEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();

	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorEight = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pCommonOutputVector = vector<OutputPixelObjectWithAngleValues>();

	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;



	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;




	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;

	cout << "Enter the Green Component to  Select" << endl;
	cin >> pGreenValueToSelect;


	cout << "Enter the BLue Component to  Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;

	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;

	CBBinaryClassifierConstantBuffer pConstantBufferStruct;
	pConstantBufferStruct.pThresholdIntensityValueR = pRedValueToSelect;
	pConstantBufferStruct.pThresholdIntensityValueG = pGreenValueToSelect;
	pConstantBufferStruct.pThresholdIntensityValueB = pBlueValueToSelect;
	pConstantBufferStruct.pValidPixelConstant = 1;
	pConstantBufferStruct.pInvalidPixelConstant = 0;
	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;



		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorEight);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorEight)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Performing the Second scan of the image" << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<PixelObject>::iterator pVectorEightIt = pixelObjectVectorEight.end();
		pixelObjectVectorEight.insert(pVectorEightIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());


		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		pVectorEightIt = pixelObjectVectorEight.end();
		pixelObjectVectorEight.insert(pVectorEightIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());


		hr = ppStandardAlgorithmExecutor->ApplyBinaryClassifierForImagePixels(hInstance,
			hWnd,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pValidClassifierToken,
			pInvalidClassifierToken,
			pixelObjectVectorEight,
			&ppOutputPixelVectorOutput);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();

		for (OutputPixelObjectClassified pPixelObject : ppOutputPixelVectorOutput)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			cout << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			cout << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			cout << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;

			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			pixelDataFile << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			pixelDataFile << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			pixelDataFile << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;





		}







		cout << "Restoring filter Results into RGB" << endl;


		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		vector<PixelObject> pFilterToReverseOutputInvalidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreValidRGBPixelFromClassifier(hInstance, hWnd,
			pConstantBufferStruct,
			ppOutputPixelVectorOutput, &pFilterToReverseOutputValidPixels);


		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pFilterToReverseOutputValidPixels)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "Restoring Image Pixel Data for Filter Output Invalid Pixels" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreInvalidRGBPixelFromClassifier(hInstance, hWnd,
			pConstantBufferStruct,
			ppOutputPixelVectorOutput, &pFilterToReverseOutputInvalidPixels);

		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pFilterToReverseOutputInvalidPixels)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		vector<PixelObject> pCommonPixelObjectArrayEightRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreEight = PixelObject(1, 180.0f, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, 680.0f, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, 170.0f, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, 580.0f, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, 280.0f, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, 560.0f, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, 170.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCenteEight = PixelObject(8, 200.0f, 430.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, 135.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, 685.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, 135.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, 315.0f, 0.0f, 0.0f, 0.0f);

		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCenteEight);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTwelve);















		stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		duration = duration_cast<microseconds>(stop - start);

		cout << "Time taken by RGB Restoration: "
			<< duration.count() / 1000000 << "seconds" << endl;

		pixelDataFile << "Time taken by RGB  Restoration: "
			<< duration.count() / 1000000 << " seconds" << endl;


		cout << "Computing Cluster Centrers" << endl;

		Point2D pCentre;
		pCentre.pPointNumber = 1.0f;
		pCentre.xPosition = 430.0f;
		pCentre.yPosition = 410.0f;




		cout << "Computing Pixel Object Centres Tangients" << endl;
		pixelDataFile << "Computing Pixel Object Centres Tangents" << endl;

		cout << "Computing Cluster Data" << endl;
		pixelDataFile << "Computing Cluster Data" << endl;

	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayEightRGB, &pCommonOutputVector);



		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVector)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			cout << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;

			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorEight.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}



		}

		cout << "Sorting Our Vectors" << endl;

		std::sort(std::begin(pVectorPointsSectorEight), std::end(pVectorPointsSectorEight), WayToSortPixelsWihtAnglesAscending);
		std::sort(std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo), WayToSortPixelsWihtAnglesAscending);
		std::sort(std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree), WayToSortPixelsWihtAnglesDescending);
		std::sort(std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour), WayToSortPixelsWihtAnglesDescending);

		cout << "Priniting Sector Eight" << endl;
		pixelDataFile << "Priniting Sector Eight" << endl;
		imageSectorsData << "Printing Sector Eight" << endl;
		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorEight)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			cout << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


		}


		cout << "Priniting Sector Two" << endl;
		pixelDataFile << "Priniting Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;
		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			cout << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


		}


		cout << "Priniting Sector Four" << endl;
		pixelDataFile << "Priniting Sector Four" << endl;
		imageSectorsData << "Priniting Sector Four" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			cout << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Quarter Value: " << pPixelObject.pQuarterNumberVar << endl;


		}



		cout << "Priniting Sector Four" << endl;
		pixelDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			cout << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;




		}

		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorEight), std::end(pVectorPointsSectorEight));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));


		vector<PixelObject> pPointToDraw = vector<PixelObject>();

		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			PixelObject pixelObjectVar = PixelObject(pVectorItem.pixelNumber,
				pVectorItem.xPosition,
				pVectorItem.yPosition,
				pVectorItem.rValue,
				pVectorItem.gValue,
				pVectorItem.bValue);
		
			pPointToDraw.push_back(pixelObjectVar);

		}


		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);

		md2dmanager->DrawPathGeometryForGivenDataSetOfPixels(hInstance, hWnd, pPointToDraw);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		pixelDataFile.close();
	}
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SortPixelsInTheRightOrder(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\SortPixelsAccordingToTheAlgorithm.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsDataFile.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	vector<PixelObject> pCommonPixelObjectArrayEightRGB = vector<PixelObject>();
	PixelObject pPixelObjectCentreEight = PixelObject(1, 168.0f, 400.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreTwo = PixelObject(2, 182.0f, 200.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreThree = PixelObject(3, 273.0f, 600.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreFour = PixelObject(4, 561.0f, 600.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreFive = PixelObject(5, 583.0f, 400.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreSix = PixelObject(6, 693.0f, 200.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, 186.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCenteEight = PixelObject(8, 200.0f, 430.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, 135.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, 686.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, 135.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, 314.0f, 0.0f, 0.0f, 0.0f);


	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreEight);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTwo);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreThree);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreFour);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreFive);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreSix);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreSeven);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCenteEight);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreNine);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTen);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreEleven);
	pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTwelve);








	cout << "Computing Cluster Centrers" << endl;

	Point2D pCentre;
	pCentre.pPointNumber = 1.0f;
	pCentre.xPosition = 430.0f;
	pCentre.yPosition = 410.0f;

	cout << "Your Pixel Centre X Position: " << pCentre.xPosition << endl;
	cout << "Your Pixel Centre Y Position: " << pCentre.yPosition << endl;
	pixelDataFile << "Your Pixel Centre X Position: " << pCentre.xPosition << endl;
	pixelDataFile << "Your Pixel Centre Y Position: " << pCentre.yPosition << endl;




	cout << "Computing Pixel Object Centres Tangients" << endl;
	pixelDataFile << "Computing Pixel Object Centres Tangents" << endl;


	vector<OutputPixelObjectWithAngleValues> pCommonOutputVector = vector<OutputPixelObjectWithAngleValues>();
	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd, pCentre.xPosition, pCentre.yPosition,
		pCommonPixelObjectArrayEightRGB, &pCommonOutputVector);

	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();




	for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVector)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

		if (pPixelObject.pQuarterNumberVar == 1.0f)
		{
			pVectorPointsSectorOne.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 2.0f)
		{
			pVectorPointsSectorTwo.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 3.0f)
		{
			pVectorPointsSectorThree.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 4.0F)
		{
			pVectorPointsSectorFour.push_back(pPixelObject);
		}



	}

	cout << "Sorting Our Vectors" << endl;

	std::sort(std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne), WayToSortPixelsWihtAnglesAscending);
	std::sort(std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo), WayToSortPixelsWihtAnglesDescending);
	std::sort(std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree), WayToSortPixelsWihtAnglesAscending);
	std::sort(std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour), WayToSortPixelsWihtAnglesDescending);

	cout << "Priniting Sector One" << endl;
	pixelDataFile << "Priniting Sector One" << endl;
	imageSectorsData << "Printing Sector One" << endl;
	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}


	cout << "Priniting Sector Two" << endl;
	pixelDataFile << "Priniting Sector Two" << endl;
	imageSectorsData << "Printing Sector Two" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;
	}


	cout << "Priniting Sector Three" << endl;
	pixelDataFile << "Priniting Sector Three" << endl;
	imageSectorsData << "Priniting Sector Three" << endl;


	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;
	}


	cout << "Priniting Sector Four" << endl;
	pixelDataFile << "Printing Sector four" << endl;
	imageSectorsData << "Printing Sector four" << endl;


	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;
	}





	imageSectorsData.close();

	vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));




	vector<Point2D> pPointToDrawSectorCommon = vector <Point2D>();



	for (OutputPixelObjectWithAngleValues pVectorItem : pCommonOutputVector)
	{
		Point2D pPointObject;
		pPointObject.pPointNumber = pVectorItem.pixelNumber;
		pPointObject.xPosition = pVectorItem.xPosition;
		pPointObject.yPosition = pVectorItem.yPosition;
		pPointToDrawSectorCommon.push_back(pPointObject);
	}




	float pTotalAreaData = 0.0f;

	vector<Line2D> pLineVectorArray = vector<Line2D>();
	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->ConnectPointsUsingLines(hInstance,
		 hWnd,
		 pCentre.xPosition,
		 pCentre.yPosition,
		 pPointToDrawSectorCommon);

	cout << "Printing the Data About Segments of Lines" << endl;
	pixelDataFile << "Printing the Data About Segments of Lines" << endl;

	float pPerimeterValue = 0.0f;

	for (Line2D pPointObject : pLineVectorArray)
	{
		cout << "Line id: " << pPointObject.pLineNumber << endl;
		cout << "X0: " << pPointObject.pPointOne.xPosition << endl;
		cout << "Y0: " << pPointObject.pPointOne.yPosition << endl;
		cout << "X1: " << pPointObject.pPointTwo.xPosition << endl;
		cout << "Y1: " << pPointObject.pPointTwo.yPosition << endl;
		cout << "Line Magnitude: " << pPointObject.pLineWidth << endl;

		pixelDataFile << "Line id: " << pPointObject.pLineNumber << endl;
		pixelDataFile << "X0: " << pPointObject.pPointOne.xPosition << endl;
		pixelDataFile << "Y0: " << pPointObject.pPointOne.yPosition << endl;
		pixelDataFile << "X1: " << pPointObject.pPointTwo.xPosition << endl;
		pixelDataFile << "Y1: " << pPointObject.pPointTwo.yPosition << endl;
		pixelDataFile << "Line Magnitude: " << pPointObject.pLineWidth << endl;
		pPerimeterValue = pPerimeterValue + pPointObject.pLineWidth;
	}

	cout << "Figure Perimeter Value: " << pPerimeterValue << endl;
	pixelDataFile << "Figure Perimeter Value: " << pPerimeterValue << endl;



	LPWSTR pScreenImage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";
	
	pixelDataFile.close();
	imageSectorsData.close();

	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilter(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	float pStepX = 0.0f;
	float pStepY = 0.0f;

	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilter.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

float pSectionOneXMin = 180.0f;
float pSectionOneXMax = 680.0f;
float pSectionOneY = 200.0f;




vector<PixelObject> pSectorOne = vector<PixelObject>();
vector<PixelObject> pSectorTwo = vector<PixelObject>();
vector<PixelObject> pSectorThree = vector<PixelObject>();
vector<PixelObject> pSectorFour = vector<PixelObject>();
vector<PixelObject> pSectorFive = vector<PixelObject>();
vector<PixelObject> pSectorSix = vector<PixelObject>();
vector<PixelObject> pSectorSeven = vector<PixelObject>();
vector<PixelObject> pSectorEight = vector<PixelObject>();
vector<PixelObject> pSectorNine = vector<PixelObject>();
vector<PixelObject> pSectorTen = vector<PixelObject>();
vector<PixelObject> pSectorEleven = vector<PixelObject>();
vector<PixelObject> pSectorTwelve = vector<PixelObject>();




vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
UINT pImageWidth = 0;
UINT pImageHeight = 0;
ID2D1Bitmap* pBitmapData = nullptr;

float pTotalX1 = 0.0F;
float pTotalX2 = 0.0F;
float pTotalX3 = 0.0F;
float pTotalX4 = 0.0F;
float pTotalX5 = 0.0F;
float pTotalX6 = 0.0F;

float pAverageX1 = 0.0f;
float pAverageX2 = 0.0f;
float pAverageX3 = 0.0F;
float pAverageX4 = 0.0f;
float pAverageX5 = 0.0f;
float pAverageX6 = 0.0F;


float pTotalY1 = 0.0f;
float pTotalY2 = 0.0F;
float pTotalY3 = 0.0F;
float pTotalY4 = 0.0F;
float pTotalY5 = 0.0F;
float pTotalY6 = 0.0F;



float pAverageY1 = 0.0f;
float pAverageY2 = 0.0f;
float pAverageY3 = 0.0F;

float pAverageY4 = 0.0f;
float pAverageY5 = 0.0f;
float pAverageY6 = 0.0F;


UINT pTopLeftX = 0;
UINT pTopLeftY = 0;
float pMinimumX = 0.0f;
float pMinimumY = 0.0f;
float pMaximumX = 0.0f;
float pMaximumY = 0.0f;
float pRedValueToSelect = 0.0f;
float pGreenValueToSelect = 0.0f;
float pBlueValueToSelect = 0.0f;
cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
cin >> pTopLeftX;
cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
cin >> pTopLeftY;
cout << "Enter the Width of Image Sector" << endl;
cin >> pImageWidth;
cout << "Enter the Height of Image Sector" << endl;
cin >> pImageHeight;
cout << "Enter the Red Component To Select" << endl;
cin >> pRedValueToSelect;
cout << "Enter the Green Component to Select" << endl;
cin >> pGreenValueToSelect;
cout << "Enter the BLue Component to Select" << endl;
cin >> pBlueValueToSelect;
cout << "Enter the step for the X Clip " << endl;
cin >> pStepX;
cout << "Enter the step for the Y Clip " << endl;
cin >> pStepY;


float pYSortingConstant0 = pStepY;
float pYSortingConstant1 = pStepY * 2;
float pYSortingConstant2 = pStepY * 3;

float pXSortingConstant0 = pStepX;
float pXSortingConstant1 = pStepX * 2;
float pXSortingConstant2 = pStepX * 3;





	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;
			
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());

	


		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBOne);

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);
		cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
				endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
				pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << " " << endl;
		cout << " " << endl;
		cout << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		cout << "Printing Output" << endl;
		UINT pIndexValue = 0;
	

	vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	start = high_resolution_clock::now();

	SYSTEMTIME restorationStartSystem;
	SYSTEMTIME restorationStartLocal;

	GetSystemTime(&restorationStartSystem);
	GetLocalTime(&restorationStartLocal);
	cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
		restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
	cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
		restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
		restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
	imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
		restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
		hWnd,
		pFilteredObjectArrayRGBOne,
		&pFilteredObjectArrayRGBOneRestored);
	cout << "Printing the Results of the Valid Pixels" << endl;


	SYSTEMTIME restorationEndSystem;
	SYSTEMTIME restorationEndLocal;

	GetSystemTime(&restorationEndSystem);
	GetLocalTime(&restorationEndLocal);
	cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
		restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
	cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
		restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
	imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
		restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
	imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
		restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



	for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}
		
		int pClassOneNumber = 1;
		int pClassTwoNumber = 2;

	

		vector<PixelObject> pSectorOne = vector<PixelObject>();
		vector<PixelObject>	pSectorTwo = vector<PixelObject>();
		vector<PixelObject> pSectorThree = vector<PixelObject>();
		vector<PixelObject> pSectorFour = vector<PixelObject>();
		vector<PixelObject> pSectorFive = vector<PixelObject>();
		vector<PixelObject> pSectorSix = vector<PixelObject>();

		vector<PixelObject> pSectorSeven = vector<PixelObject>();
		vector<PixelObject>	pSectorEight = vector<PixelObject>();
		vector<PixelObject> pSectorNine = vector<PixelObject>();
		vector<PixelObject> pSectorTen = vector<PixelObject>();
		vector<PixelObject> pSectorEleven = vector<PixelObject>();
		vector<PixelObject> pSectorTwelve = vector<PixelObject>();


		SplitPixelVectorsBasedUponYPosition(pFilteredObjectArrayRGBOneRestored,
			pCentre.xPosition, pYSortingConstant0,
			&pSectorOne, &pSectorTwo);

		SplitPixelVectorsBasedUponYPosition(pFilteredObjectArrayRGBOneRestored,
			pCentre.xPosition, pYSortingConstant1,
			&pSectorThree, &pSectorFour);


		SplitPixelVectorsBasedUponYPosition(pFilteredObjectArrayRGBOneRestored,
			pCentre.xPosition, pYSortingConstant2,
			&pSectorFive, &pSectorSix);


		SplitPixelVectorsBasedUponXPosition(pFilteredObjectArrayRGBOneRestored,
			pXSortingConstant0, pCentre.yPosition,
			&pSectorSeven, &pSectorEight);

		SplitPixelVectorsBasedUponXPosition(pFilteredObjectArrayRGBOneRestored,
			pXSortingConstant1, pCentre.yPosition,
			&pSectorNine, &pSectorTen);


		SplitPixelVectorsBasedUponXPosition(pFilteredObjectArrayRGBOneRestored,
			pXSortingConstant2, 200.0f,
			&pSectorEleven, &pSectorTwelve);





	cout << "Printing Sector One Values" << endl;
	imageSegmentationDataFile << "Printing Sector One Values" << endl;
	imageSectorsData << "Printing Sector One Values" << endl;
	vector<float> pXArrayOne = vector<float>();


	for (PixelObject pixelObject : pSectorOne)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;
	
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;
	}



	cout << "Printing Sector Two Values" << endl;
	imageSegmentationDataFile << "Printing Sector Two Values" << endl;

	for (PixelObject pixelObject : pSectorTwo)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;
		
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

	}


	cout << "Printing Sector 3 Values" << endl;
	imageSegmentationDataFile	 << "Printing Sector 3 Values" << endl;

	for (PixelObject pixelObject : pSectorThree)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

	}




	cout << "Sector Four" << endl;
	imageSegmentationDataFile << "Sector Four" << endl;
	imageSectorsData << "Sector Four" << endl;

	for (PixelObject pixelObject : pSectorFour)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

	}


	cout << "Sector Five" << endl;
	imageSegmentationDataFile << "Sector Five" << endl;
	imageSectorsData << "Sector Five" << endl;

	for (PixelObject pixelObject : pSectorFive)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

	}

	imageSectorsData << "Sector End" << endl;





	cout << "Sector Six" << endl;
	imageSegmentationDataFile << "Sector Six" << endl;
	imageSectorsData << "Sector Six" << endl;


	for (PixelObject pixelObject : pSectorSix)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

	}

	imageSectorsData << "Sector End" << endl;


	cout << "Sector Seven" << endl;
	imageSegmentationDataFile << "Sector Seven" << endl;
	imageSectorsData << "Sector Seven: " << endl;


	for (PixelObject pixelObject : pSectorSeven)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;


	}

	imageSectorsData << "Sector End" << endl;


	cout << "Printing Sector Eight" << endl;
	imageSegmentationDataFile << "Printing Sector Eight" << endl;
	imageSectorsData << "Sector Eight: " << endl;

	for (PixelObject pixelObject : pSectorEight)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



	}

	imageSectorsData << "Sector End" << endl;



	cout << "Printing Sector Nine" << endl;
	imageSegmentationDataFile << "Printing Sector Nine" << endl;
	imageSectorsData << "Sector Nine: " << endl;

	for each (PixelObject pixelObject in pSectorNine)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



	}

	imageSectorsData << "Sector End" << endl;


	cout << "Printing Sector Ten" << endl;
	imageSegmentationDataFile << "Printing Sector Ten" << endl;
	imageSectorsData << "Printing Sector Ten" << endl;


	for each (PixelObject pixelObject in pSectorTen)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing Sector Eleven" << endl;
	imageSegmentationDataFile << "Printing Sector Eleven" << endl;
	imageSectorsData << "Printing Sector Eleven" << endl;

	for (PixelObject pixelObject : pSectorEleven)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing Sector Twelve" << endl;
	imageSegmentationDataFile << "Printing Sector Twelve" << endl;
	imageSectorsData << "Printing Sector Twelve" << endl;


	for (PixelObject pixelObject : pSectorTwelve)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
		imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
		imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
		imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



	}



	float pXPositionAverage0 = 0.0f;
	float pXPositionAverage1 = 0.0f;
	float pXPositionAverage2 = 0.0f;
	float pXPositionAverage3 = 0.0f;
	float pXPositionAverage4 = 0.0f;
	float pXPositionAverage5 = 0.0f;


	float pYPositionAverage0 = 0.0f;
	float pYPositionAverage1 = 0.0f;
	float pYPositionAverage2 = 0.0f;
	float pYPositionAverage3 = 0.0f;
	float pYPositionAverage4 = 0.0f;
	float pYPositionAverage5 = 0.0f;


	float pXPositionAverageWhole0 = 0.0f;
	float pXPositionAverageWhole1 = 0.0f;
	float pXPositionAverageWhole2 = 0.0f;
	float pXPositionAverageWhole3 = 0.0f;
	float pXPositionAverageWhole4 = 0.0f;
	float pXPositionAverageWhole5 = 0.0f;


	float pYPositionAverageWhole0 = 0.0f;
	float pYPositionAverageWhole1 = 0.0f;
	float pYPositionAverageWhole2 = 0.0f;
	float pYPositionAverageWhole3 = 0.0f;
	float pYPositionAverageWhole4 = 0.0f;
	float pYPositionAverageWhole5 = 0.0f;


	cout << "Computing Median X for Sectors 1-6" << endl;
	imageSegmentationDataFile << "Computing Median X for Sectors 1-6" << endl;

	pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
	pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
	pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
	pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
	pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
	pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

	cout << "Computing Median Y for Sectors 7-12" << endl;
	imageSegmentationDataFile << "Computing Median Y for Sectors 7-12" << endl;

	pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
	pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
	pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
	pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
	pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
	pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

	pXPositionAverageWhole0 = round(pXPositionAverage0);
	pXPositionAverageWhole1 = round(pXPositionAverage1);
	pXPositionAverageWhole2 = round(pXPositionAverage2);
	pXPositionAverageWhole3 = round(pXPositionAverage3);
	pXPositionAverageWhole4 = round(pXPositionAverage4);
	pXPositionAverageWhole5 = round(pXPositionAverage5);

	pYPositionAverageWhole0 = round(pYPositionAverage0);
	pYPositionAverageWhole1 = round(pYPositionAverage1);
	pYPositionAverageWhole2 = round(pYPositionAverage2);
	pYPositionAverageWhole3 = round(pYPositionAverage3);
	pYPositionAverageWhole4 = round(pYPositionAverage4);
	pYPositionAverageWhole5 = round(pYPositionAverage5);








	cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
	cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
	cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
	cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
	cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
	cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

	cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
	cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
	cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
	cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
	cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
	cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;


	imageSegmentationDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
	imageSegmentationDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
	imageSegmentationDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
	imageSegmentationDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
	imageSegmentationDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
	imageSegmentationDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

	imageSegmentationDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
	imageSegmentationDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
	imageSegmentationDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
	imageSegmentationDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
	imageSegmentationDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
	imageSegmentationDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;




	vector<float> pXValueaArray = vector<float>();
	vector<float> pYValueaArray = vector<float>();
	pXValueaArray.push_back(pXPositionAverageWhole0);
	pXValueaArray.push_back(pXPositionAverageWhole1);
	pXValueaArray.push_back(pXPositionAverageWhole2);
	pXValueaArray.push_back(pXPositionAverageWhole3);
	pXValueaArray.push_back(pXPositionAverageWhole4);
	pXValueaArray.push_back(pXPositionAverageWhole5);

	pYValueaArray.push_back(pYPositionAverageWhole0);
	pYValueaArray.push_back(pYPositionAverageWhole1);
	pYValueaArray.push_back(pYPositionAverageWhole2);
	pYValueaArray.push_back(pYPositionAverageWhole3);
	pYValueaArray.push_back(pYPositionAverageWhole4);
	pYValueaArray.push_back(pYPositionAverageWhole5);

	float pCentreX = 0.0f;
	float pCentreY = 0.0F;
	sort(pXValueaArray.begin(), pXValueaArray.end(), SortingFloatsAscending);
	sort(pYValueaArray.begin(), pYValueaArray.end(), SortingFloatsAscending);

	pCentreX = (pXValueaArray[pXValueaArray.size() - 1] - pXValueaArray[0]) / 2.0f + pXValueaArray[0] - 0.5f;
	pCentreY = (pYValueaArray[pYValueaArray.size() - 1] - pYValueaArray[0]) / 2.0f + pYValueaArray[0] - 0.5f;

	cout << "Computed X for Centre = " << pCentreX << endl;
	cout << "Computed Y for Centre = " << pCentreY << endl;
	imageSegmentationDataFile << "Computed X for Centre = " << pCentreX << endl;
	imageSegmentationDataFile << "Computed Y for Centre = " << pCentreY << endl;




	vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
	PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2,  0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, 0.0f, 0.0f, 0.0f);
	PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, 0.0f, 0.0f, 0.0f);


	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
	pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

	cout << "Computing Pixel Object Centres Tangients" << endl;
	imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


	SYSTEMTIME computeDeltaStartSystem;
	SYSTEMTIME computeDeltaStartLocal;

	GetSystemTime(&computeDeltaStartSystem);
	GetLocalTime(&computeDeltaStartLocal);
	cout << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
		restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
	cout << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
		restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
		restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
	imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
		restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;



	vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
		hWnd, pCentre.xPosition, pCentre.yPosition,
		pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);

	SYSTEMTIME computeDeltaEndSystem;
	SYSTEMTIME computeDeltaEndLocal;

	GetSystemTime(&computeDeltaEndSystem);
	GetLocalTime(&computeDeltaEndLocal);
	cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
		restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
	cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
		restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
	imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
		restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
	imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
		restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

	imageSectorsData << "Printing Tangent Data " << endl;
	imageSegmentationDataFile << "Printing Tangent Data " << endl;

	std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

	for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		if (pPixelObject.pQuarterNumberVar == 1.0f)
		{
			pVectorPointsSectorOne.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 2.0f)
		{
			pVectorPointsSectorTwo.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 3.0f)
		{
			pVectorPointsSectorThree.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 4.0f)
		{
			pVectorPointsSectorFour.push_back(pPixelObject);
		}







	}
	imageSectorsData << "Tangent One " << endl;

	cout << "Sorting Our Vectors" << endl;

	std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
	std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
	std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
	std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


	cout << "Printing Sector One" << endl;
	imageSegmentationDataFile << "Printing Sector One" << endl; 
	imageSectorsData << "Printing Sector One" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





	}
	imageSegmentationDataFile << "Sector End" << endl;
	imageSectorsData << "Sector End" << endl;



	cout << "Printing Sector Two" << endl;
	imageSegmentationDataFile << "Printing Sector Two" << endl;
	imageSectorsData << "Printing Sector Two" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




	}
	imageSegmentationDataFile << "Sector End" << endl;

	imageSectorsData << "Sector End" << endl;


	cout << "Printing Sector Three" << endl;
	imageSegmentationDataFile << "Printing Sector Three" << endl;
	imageSectorsData << "Printing Sector Three" << endl;


	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




	}
	imageSegmentationDataFile << "Sector End" << endl;
	imageSectorsData << "Sector End" << endl;


	cout << "Printing Sector Four" << endl;
	imageSegmentationDataFile << "Printing Sector four" << endl;
	imageSectorsData << "Printing Sector four" << endl;


	for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

		imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
		imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
		imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
		imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
		imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
		imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





	}
	imageSegmentationDataFile << "Sector End" << endl;
	imageSectorsData << "Sector End" << endl;
	imageSectorsData.close();

	vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
	pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





	vector<Point2D> pPointArrayToDrawOne = vector<Point2D>();
	vector<Point2D> pPointArrayToDrawTwo = vector<Point2D>();
	vector<Point2D> pPointArrayToDrawThree = vector<Point2D>();
	vector<Point2D> pPointArrayToDrawFour = vector<Point2D>();
	vector<Point2D> pPointArrayToDraw = vector<Point2D>();


	for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
	{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointArrayToDrawOne.push_back(pPointObject);
			pPointArrayToDraw.push_back(pPointObject);
	}



	for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
	{
		if (pVectorItem.pQuarterNumberVar == 1)
		{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointObject.pSectorNumber = 1;
			pPointArrayToDraw.push_back(pPointObject);
		}
	}


	for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
	{
		if (pVectorItem.pQuarterNumberVar == 2)
		{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointObject.pSectorNumber = 2;
			pPointArrayToDraw.push_back(pPointObject);
		}
	}


	for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
	{
		if (pVectorItem.pQuarterNumberVar == 3)
		{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointObject.pSectorNumber = 3;
			pPointArrayToDraw.push_back(pPointObject);
		}
	}


	for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
	{
		if (pVectorItem.pQuarterNumberVar == 4)
		{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointObject.pSectorNumber = 4;
			pPointArrayToDraw.push_back(pPointObject);
		}
	}

	vector<Line2D> pLineArrayValues = vector<Line2D>();
	float pTotalArea = 0.0f;
	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointArrayToDraw);




	float pSectorLength12 = 0.0f;
	float pSectorLength23 = 0.0f;
	float pSectorLength34 = 0.0f;
	float pSectorLength45 = 0.0f;
	float pSectorLength56 = 0.0f;
	float pSectorLength67 = 0.0f;
	float pSectorLength78 = 0.0f;
	float pSectorLength89 = 0.0f;
	float pSectorLength910 = 0.0f;
	float pSectorLength1011 = 0.0f;
	float pSectorLength1112 = 0.0f;
	float pSectorLength1201 = 0.0f;

	float pSectorLength1Centre = 0.0f;
	float pSectorLength2Centre = 0.0f;
	float pSectorLength3Centre = 0.0f;
	float pSectorLength4Centre = 0.0f;
	float pSectorLength5Centre = 0.0f;
	float pSectorLength6Centre = 0.0f;
	float pSectorLength7Centre = 0.0f;
	float pSectorLength8Centre = 0.0f;
	float pSectorLength9Centre = 0.0f;
	float pSectorLength10Centre = 0.0f;
	float pSectorLength11Centre = 0.0f;
	float pSectorLength12Centre = 0.0f;


	Point2D pPointOne = pPointArrayToDraw[0];
	Point2D pPointTwo = pPointArrayToDraw[1];
	Point2D pPointThree = pPointArrayToDraw[2];

	Point2D pPointFour = pPointArrayToDraw[3];
	Point2D pPointFive = pPointArrayToDraw[4];
	Point2D pPointSix = pPointArrayToDraw[5];
	Point2D pPointSeven = pPointArrayToDraw[6];
	Point2D pPointEight = pPointArrayToDraw[7];
	Point2D pPointNine = pPointArrayToDraw[8];
	Point2D pPointTen = pPointArrayToDraw[9];
	Point2D pPointEleven = pPointArrayToDraw[10];
	Point2D pPointTwelve = pPointArrayToDraw[11];




	pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
	pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
	pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
	pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
	pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
	pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
	pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
	pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
	pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
	pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
	pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
	pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

	pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
	pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
	pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
	pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
	pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
	pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
	pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
	pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
	pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
	pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
	pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
	pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



	Line2D pLine12;
	pLine12.pLineNumber = 1;
	pLine12.pPointOne = pPointOne;
	pLine12.pPointTwo = pPointTwo;
	pLine12.pLineWidth = pSectorLength12;



	Line2D pLine23;
	pLine23.pLineNumber = 2;
	pLine23.pPointOne = pPointTwo;
	pLine23.pPointTwo = pPointThree;
	pLine23.pLineWidth = pSectorLength23;


	Line2D pLine34;
	pLine34.pLineNumber = 3;
	pLine34.pPointOne = pPointThree;
	pLine34.pPointTwo = pPointFour;
	pLine34.pLineWidth = pSectorLength34;


	Line2D pLine45;
	pLine45.pLineNumber = 4;
	pLine45.pPointOne = pPointFour;
	pLine45.pPointTwo = pPointFive;
	pLine45.pLineWidth = pSectorLength45;


	Line2D pLine56;
	pLine56.pLineNumber = 5;
	pLine56.pPointOne = pPointFive;
	pLine56.pPointTwo = pPointSix;
	pLine56.pLineWidth = pSectorLength56;


	Line2D pLine67;
	pLine67.pLineNumber = 6;
	pLine67.pPointOne = pPointSix;
	pLine67.pPointTwo = pPointSeven;
	pLine67.pLineWidth = pSectorLength67;


	Line2D pLine78;
	pLine78.pLineNumber = 7;
	pLine78.pPointOne = pPointSeven;
	pLine78.pPointTwo = pPointEight;
	pLine78.pLineWidth = pSectorLength78;

	Line2D pLine89;
	pLine89.pLineNumber = 8;
	pLine89.pPointOne = pPointEight;
	pLine89.pPointTwo = pPointNine;
	pLine89.pLineWidth = pSectorLength89;


	Line2D pLine910;
	pLine910.pLineNumber = 9;
	pLine910.pPointOne = pPointNine;
	pLine910.pPointTwo = pPointTen;
	pLine910.pLineWidth = pSectorLength910;


	Line2D pLine1011;
	pLine1011.pLineNumber = 10;
	pLine1011.pPointOne = pPointTen;
	pLine1011.pPointTwo = pPointEleven;
	pLine1011.pLineWidth = pSectorLength1011;


	Line2D pLine1112;
	pLine1112.pLineNumber = 11;
	pLine1112.pPointOne = pPointEleven;
	pLine1112.pPointTwo = pPointTwelve;
	pLine1112.pLineWidth = pSectorLength1112;


	Line2D pLine1201;
	pLine1201.pLineNumber = 12;
	pLine1201.pPointOne = pPointTwelve;
	pLine1201.pPointTwo = pPointOne;
	pLine1201.pLineWidth = pSectorLength1201;

	Line2D pLineOneCentre;
	pLineOneCentre.pLineNumber = 13;
	pLineOneCentre.pPointOne = pPointOne;
	pLineOneCentre.pPointTwo = pCentre;
	pLineOneCentre.pLineWidth = pSectorLength1Centre;

	Line2D pLineTwoCentre;
	pLineTwoCentre.pLineNumber = 15;
	pLineTwoCentre.pPointOne = pPointTwo;
	pLineTwoCentre.pPointTwo = pCentre;
	pLineTwoCentre.pLineWidth = pSectorLength2Centre;

	Line2D pLineThreeCentre;
	pLineThreeCentre.pLineNumber = 16;
	pLineThreeCentre.pPointOne = pPointThree;
	pLineThreeCentre.pPointTwo = pCentre;
	pLineThreeCentre.pLineWidth = pSectorLength3Centre;


	Line2D pLineFourCentre;
	pLineFourCentre.pLineNumber = 16;
	pLineFourCentre.pPointOne = pPointFour;
	pLineFourCentre.pPointTwo = pCentre;
	pLineFourCentre.pLineWidth = pSectorLength4Centre;


	Line2D pLineFiveCentre;
	pLineFiveCentre.pLineNumber = 17;
	pLineFiveCentre.pPointOne = pPointFive;
	pLineFiveCentre.pPointTwo = pCentre;
	pLineFiveCentre.pLineWidth = pSectorLength5Centre;


	Line2D pLineSixCentre;
	pLineSixCentre.pLineNumber = 18;
	pLineSixCentre.pPointOne = pPointSix;
	pLineSixCentre.pPointTwo = pCentre;
	pLineSixCentre.pLineWidth = pSectorLength6Centre;


	Line2D pLineSevenCentre;
	pLineSevenCentre.pLineNumber = 19;
	pLineSevenCentre.pPointOne = pPointSeven;
	pLineSevenCentre.pPointTwo = pCentre;
	pLineSevenCentre.pLineWidth = pSectorLength7Centre;


	Line2D pLineEightCentre;
	pLineEightCentre.pLineNumber = 20;
	pLineEightCentre.pPointOne = pPointEight;
	pLineEightCentre.pPointTwo = pCentre;
	pLineEightCentre.pLineWidth = pSectorLength8Centre;


	Line2D pLineNineCentre;
	pLineNineCentre.pLineNumber = 21;
	pLineNineCentre.pPointOne = pPointNine;
	pLineNineCentre.pPointTwo = pCentre;
	pLineNineCentre.pLineWidth = pSectorLength9Centre;


	Line2D pLineTenCentre;
	pLineTenCentre.pLineNumber = 22;
	pLineTenCentre.pPointOne = pPointTen;
	pLineTenCentre.pPointTwo = pCentre;
	pLineTenCentre.pLineWidth = pSectorLength10Centre;


	Line2D pLineElevenCentre;
	pLineElevenCentre.pLineNumber = 23;
	pLineElevenCentre.pPointOne = pPointEleven;
	pLineElevenCentre.pPointTwo = pCentre;
	pLineElevenCentre.pLineWidth = pSectorLength11Centre;


	Line2D pLineTwelveCentre;
	pLineTwelveCentre.pLineNumber = 24;
	pLineTwelveCentre.pPointOne = pPointTwelve;
	pLineTwelveCentre.pPointTwo = pCentre;
	pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








	float pTriangleOneArea = 0.0f;
	float pTriangleTwoArea = 0.0f;
	float pTriangleThreeArea = 0.0f;
	float pTriangleFourArea = 0.0f;
	float pTriangleFiveArea = 0.0f;
	float pTriangleSixArea = 0.0f;
	float pTriangleSevenArea = 0.0f;
	float pTriangleEightArea = 0.0f;
	float pTriangleNineArea = 0.0f;
	float pTriangleTenArea = 0.0f;
	float pTriangleElevenArea = 0.0f;
	float pTriangleTwelveArea = 0.0f;





	float pTriangleAreaTotal = 0.0f;
	pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
	pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
	pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
	pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
	pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
	pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
	pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
	pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
	pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
	pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
	pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
	pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
	pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

	cout << "Triangle One Area: " << pTriangleOneArea << endl;
	cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
	cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
	cout << "Triangle Four Area: " << pTriangleFourArea << endl;
	cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
	cout << "Triangle Six Area: " << pTriangleSixArea << endl;
	cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
	cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
	cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
	cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
	cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
	cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

	imageSegmentationDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
	imageSegmentationDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
	imageSegmentationDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
	imageSegmentationDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
	imageSegmentationDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
	imageSegmentationDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
	imageSegmentationDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
	imageSegmentationDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
	imageSegmentationDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
	imageSegmentationDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
	imageSegmentationDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
	imageSegmentationDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


	cout << "Constructing Triangle Structures" << endl;
	TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
		pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
	TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
		pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
	TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
		pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
	TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
		pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
	TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
		pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
	TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
		pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
	TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
		pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
	TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
		pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
	TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
		pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
	TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
		pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
	TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
		pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
	TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
		pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

	cout << "Storing Our Triangle Data into A Vector" << endl;
	imageSegmentationDataFile << "Storing Our Triangle Data into A Vector" << endl;

	vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
	pTriangleObjectVector.push_back(pTriangleObjectOne);
	pTriangleObjectVector.push_back(pTriangleObjectTwo);
	pTriangleObjectVector.push_back(pTriangleObjectThree);
	pTriangleObjectVector.push_back(pTriangleObjectFour);
	pTriangleObjectVector.push_back(pTriangleObjectFive);
	pTriangleObjectVector.push_back(pTriangleObjectSix);
	pTriangleObjectVector.push_back(pTriangleObjectSeven);
	pTriangleObjectVector.push_back(pTriangleObjectEight);
	pTriangleObjectVector.push_back(pTriangleObjectNine);
	pTriangleObjectVector.push_back(pTriangleObjectTen);
	pTriangleObjectVector.push_back(pTriangleObjectEleven);
	pTriangleObjectVector.push_back(pTriangleObjectTwelve);

	for (TriangleObject pTriangleObject : pTriangleObjectVector)
	{
		cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
		cout << "Point A:" << endl;
		cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
		cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
		cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
		cout << "Point B:" << endl;
		cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
		cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
		cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
		cout << "Point C:" << endl;
		cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
		cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
		cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
		cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
		cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
		cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
		cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
		cout << "Area = " << pTriangleObject.pTriangleArea << endl;

		imageSegmentationDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
		imageSegmentationDataFile << "Point A:" << endl;
		imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
		imageSegmentationDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
		imageSegmentationDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
		imageSegmentationDataFile << "Point B:" << endl;
		imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
		imageSegmentationDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
		imageSegmentationDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
		imageSegmentationDataFile << "Point C:" << endl;
		imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
		imageSegmentationDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
		imageSegmentationDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
		imageSegmentationDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
		imageSegmentationDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
		imageSegmentationDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
		imageSegmentationDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
		imageSegmentationDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
	}




	cout << "Computing Perimeter for the Shape" << endl;
	float pShapePerimeter = 0.0f;
	pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


	cout << "Perimeter Value: " << pShapePerimeter << endl;
	imageSegmentationDataFile << "Perimeter Value: " << pShapePerimeter << endl;






	cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
	imageSegmentationDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






	LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


	SYSTEMTIME endTimeSystem;
	SYSTEMTIME endTimeLocal;


	fstream pReportFileForSelectedExperiment;
	pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
	pReportFileForSelectedExperiment.clear();

	pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
	pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
	pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
	pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
	pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
	pReportFileForSelectedExperiment.close();














	GetSystemTime(&endTimeSystem);
	GetLocalTime(&endTimeLocal);
	cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
		endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
	cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
		endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
	imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
		endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
	imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
		endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

		}
		imageSegmentationDataFile.close();
		imageSectorsData.close();

		return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ComputeAverageXForPixelArrayOnAGPU(HINSTANCE hInstance, HWND hWnd,
	float pYValue,
	float pXThresold,
	int pSectorOne,
	int pSectorTwo,
	int pInvalidSector,
	vector<PixelObject> pInputArrayObject,
	vector<PixelObject> *ppSectorOutputA,
	vector<PixelObject> *ppSectorOutputB,
	float* ppAverageX0, float *ppAverageX1)
{
	HRESULT hr = S_OK;

	int pClassOneLabel = 1;
	int pClassTwoLabel = 2;
	int pInvalidLabel = -1;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ComputeAverageXfORPixelArrayObhect.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "Prinitng Array Data: " << endl;

	for (PixelObject pixelObject : pInputArrayObject)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Filtering the Initial Pixel Array Against Y Position Value" << endl;
	imageSegmentationDataFile << "Filtering the Initial Pixel Array Against Y Position Value" << endl;
	vector<FilterPixelLabel> pOutputFilterVector = vector<FilterPixelLabel>();
	pOutputFilterVector.clear();

	hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(hInstance,
		hWnd,
		pYValue,
		pXThresold,
		pSectorOne, pSectorTwo, pInvalidSector,
		pInputArrayObject,
		&pOutputFilterVector);



	for (FilterPixelLabel pPixelObject : pOutputFilterVector)
	{

		if (pPixelObject.pIsPixelValid = true)
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.gValue;
			int pSectorNumber = pPixelObject.pSectorNumberValue;
			bool pIsPixelValid = pPixelObject.pIsPixelValid;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Value = " << pRedComponent << endl;
			cout << "Green Value = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Sector Number = " << pSectorNumber << endl;
			cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Value = " << pXValue << endl;
			imageSegmentationDataFile << "Y Value = " << pYValue << endl;
			imageSegmentationDataFile << "Red Value = " << pRedComponent << endl;
			imageSegmentationDataFile << "Green Value = " << pGreenComponent << endl;
			imageSegmentationDataFile << "Blue Component = " << pBlueComponent << endl;
			imageSegmentationDataFile << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	vector<PixelObject> pPartAVector = vector<PixelObject>();
	vector<PixelObject> pPartBVector = vector<PixelObject>();
	pPartAVector.clear();
	pPartBVector.clear();

	cout << "Restoring Pixel Array for the First Part of the Sector" << endl;
	imageSegmentationDataFile << "Restoring Pixel Array for the First Part of the Sector" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
		hWnd,
		pSectorOne,
		pOutputFilterVector,
		&pPartAVector);

	cout << "Prinitng Output Vector: " << endl;
	imageSegmentationDataFile << "Prinitng Output Vector:" << endl;

	for (PixelObject pixelObject : pPartAVector)
	{
		if ((pixelObject.RMask != 777) && (pixelObject.GMask != 777) && (pixelObject.BMask != 777))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Restoring Pixel Array for the Second Part of the Vectorector" << endl;
	imageSegmentationDataFile << "Restoring Pixel Array for the First Part of the Sector" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
		hWnd,
		pSectorTwo,
		pOutputFilterVector,
		&pPartBVector);

	cout << "Prinitng Output Vector Sector First Half: " << endl;
	imageSegmentationDataFile << "Prinitng Output Vector Sector First Half:" << endl;

	for (PixelObject pixelObject : pPartAVector)
	{
		if ((pixelObject.RMask != 777) && (pixelObject.GMask != 777) && (pixelObject.BMask != 777))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Printng Output Vector Sector Second Half: " << endl;
	imageSegmentationDataFile << "Printng Output Vector Sector Second Half:" << endl;

	for (PixelObject pixelObject : pPartBVector)
	{
		if ((pixelObject.RMask != 777) && (pixelObject.GMask != 777) && (pixelObject.BMask != 777))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Computing Average Value of X" << endl;
	imageSegmentationDataFile << "Computing Average Value of X" << endl;
	std::sort(std::begin(pPartAVector), std::end(pPartAVector), WayToSortPixelsForXPositionAscending);
	std::sort(std::begin(pPartBVector), std::end(pPartBVector), WayToSortPixelsForXPositionAscending);

	float pAverageX0 = 0.0f;
	float pAverageX1 = 0.0f;

	if (pPartAVector.size() > 0)
	{
		pAverageX0 = (pPartAVector[pPartAVector.size() - 1].xPosition - pPartAVector[0].xPosition) / 2.0f + pPartAVector[0].xPosition;

	}
	else
	{
		pAverageX0 = 0.0f;
	}
	if (pPartBVector.size() > 0)
	{
		pAverageX1 = (pPartBVector[pPartBVector.size() - 1].xPosition - pPartBVector[0].xPosition) / 2.0f + pPartBVector[0].xPosition;

	}
	else
	{
		pAverageX1 = 0.0f;
	}

	float pAverageX0Whole = round(pAverageX0);
	float pAverageX1Whole = round(pAverageX1);
	*ppSectorOutputA = pPartAVector;
	*ppSectorOutputB = pPartBVector;
	*ppAverageX0 = pAverageX0Whole;
	*ppAverageX1 = pAverageX1Whole;

	return hr;

}





HRESULT DirectXGPUDigitalLabCoreModule::ComputeAverageYForPixelArrayOnAGPU(HINSTANCE hInstance, HWND hWnd,
	float pXValue,
	float pYThresold,
	int pSectorOne,
	int pSectorTwo,
	int pInvalidSector,
	vector<PixelObject> pInputArrayObject,
	vector<PixelObject> *ppPartAVectorObject,
	vector<PixelObject> *ppPartBVectorObject,
	float* ppAverageY0, float *ppAverageY1)
{
	HRESULT hr = S_OK;

	int pClassOneLabel = 1;
	int pClassTwoLabel = 2;
	int pInvalidLabel = -1;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ComputeAverageXfORPixelArrayObhect.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "Prinitng Array Data: " << endl;

	for (PixelObject pixelObject : pInputArrayObject)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Filtering the Initial Pixel Array Against Y Position Value" << endl;
	imageSegmentationDataFile << "Filtering the Initial Pixel Array Against Y Position Value" << endl;
	vector<FilterPixelLabel> pOutputFilterVector = vector<FilterPixelLabel>();
	pOutputFilterVector.clear();

	hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(hInstance,
		hWnd,
		pXValue,
		pYThresold,
		pSectorOne, pSectorTwo, pInvalidSector,
		pInputArrayObject,
		&pOutputFilterVector);



	for (FilterPixelLabel pPixelObject : pOutputFilterVector)
	{

		if (pPixelObject.pIsPixelValid = true)
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.gValue;
			int pSectorNumber = pPixelObject.pSectorNumberValue;
			bool pIsPixelValid = pPixelObject.pIsPixelValid;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Value = " << pRedComponent << endl;
			cout << "Green Value = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Sector Number = " << pSectorNumber << endl;
			cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Value = " << pXValue << endl;
			imageSegmentationDataFile << "Y Value = " << pYValue << endl;
			imageSegmentationDataFile << "Red Value = " << pRedComponent << endl;
			imageSegmentationDataFile << "Green Value = " << pGreenComponent << endl;
			imageSegmentationDataFile << "Blue Component = " << pBlueComponent << endl;
			imageSegmentationDataFile << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	vector<PixelObject> pPartAVector = vector<PixelObject>();
	vector<PixelObject> pPartBVector = vector<PixelObject>();
	pPartAVector.clear();
	pPartBVector.clear();

	cout << "Restoring Pixel Array for the First Part of the Sector" << endl;
	imageSegmentationDataFile << "Restoring Pixel Array for the First Part of the Sector" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
		hWnd,
		pSectorOne,
		pOutputFilterVector,
		&pPartAVector);

	cout << "Prinitng Output Vector: " << endl;
	imageSegmentationDataFile << "Prinitng Output Vector:" << endl;

	for (PixelObject pixelObject : pPartAVector)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Restoring Pixel Array for the Second Part of the Vectorector" << endl;
	imageSegmentationDataFile << "Restoring Pixel Array for the First Part of the Sector" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
		hWnd,
		pSectorTwo,
		pOutputFilterVector,
		&pPartBVector);

	cout << "Prinitng Output Vector Sector First Half: " << endl;
	imageSegmentationDataFile << "Prinitng Output Vector Sector First Half:" << endl;

	for (PixelObject pixelObject : pPartAVector)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Printing Output Vector Sector Second Half: " << endl;
	imageSegmentationDataFile << "Printng Output Vector Sector Second Half:" << endl;

	for (PixelObject pixelObject : pPartBVector)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}

	cout << "Computing Average Value of X" << endl;
	imageSegmentationDataFile << "Computing Average Value of X" << endl;
	std::sort(std::begin(pPartAVector), std::end(pPartAVector), WayToSortPixelsForYPositionAscending);
	std::sort(std::begin(pPartBVector), std::end(pPartBVector), WayToSortPixelsForYPositionAscending);

	float pAverageY0 = 0.0f;
	float pAverageY1 = 0.0f;

	if (pPartAVector.size() > 0)
	{
		pAverageY0 = (pPartAVector[pPartAVector.size() - 1].yPosition - pPartAVector[0].yPosition) / 2.0f + pPartAVector[0].yPosition;

	}
	else
	{
		pAverageY0 = 0.0f;
	}
	if (pPartBVector.size() > 0)
	{
		pAverageY1 = (pPartBVector[pPartBVector.size() - 1].yPosition - pPartBVector[0].yPosition) / 2.0f + pPartBVector[0].yPosition;

	}
	else
	{
		pAverageY1 = 0.0f;
	}

	float pAverageY0Whole = round(pAverageY0);
	float pAverageY1Whole = round(pAverageY1);

	*ppPartAVectorObject = pPartAVector;
	*ppPartBVectorObject = pPartBVector;
	*ppAverageY0 = pAverageY0Whole;
	*ppAverageY1 = pAverageY1Whole;

	return hr;

}





HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPU(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	float pStepX = 0.0f;
	float pStepY = 0.0f;

	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPU.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);



	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<PixelObject> pSectorOne = vector < PixelObject>();
	vector<PixelObject> pSectorTwo = vector < PixelObject>();
	vector<PixelObject> pSectorThree = vector < PixelObject>();
	vector<PixelObject> pSectorFour = vector < PixelObject>();
	vector<PixelObject> pSectorFive = vector < PixelObject>();
	vector<PixelObject> pSectorSix = vector < PixelObject>();
	vector<PixelObject> pSectorSeven = vector < PixelObject>();
	vector<PixelObject> pSectorEight = vector < PixelObject>();
	vector<PixelObject> pSectorNine = vector < PixelObject>();
	vector<PixelObject> pSectorTen = vector < PixelObject>();
	vector<PixelObject> pSectorEleven = vector < PixelObject>();
	vector<PixelObject> pSectorTwelve = vector <PixelObject>();

	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;






	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	float pYSortingConstant0 = pStepY;
	float pYSortingConstant1 = pStepY * 2;
	float pYSortingConstant2 = pStepY * 3;

	float pXSortingConstant0 = pStepX;
	float pXSortingConstant1 = pStepX * 2;
	float pXSortingConstant2 = pStepX * 3;





	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
			pXValuesArray.push_back(pixelObject.xPosition);
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

			pYValuesArray.push_back(pixelObject.yPosition);
		}

		std::sort(std::begin(pXValuesArray), std::end(pXValuesArray));
		std::sort(std::begin(pYValuesArray), std::end(pYValuesArray));

		float pCentreX = 0.0f;
		float pCentreY = 0.0f;
		pCentreX = (pXValuesArray[pXValuesArray.size() - 1] - pXValuesArray[0]) / 2.0f;
		pCentreY = (pYValuesArray[pYValuesArray.size() - 1] - pYValuesArray[0]) / 2.0f;


		cout << "Your Centre Point Is: " << endl;
		cout << "X Position: " << pCentreX << endl; 
		cout << "Y Position: " << pCentreY << endl;


		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());




		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBOne);

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);
		cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
				endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
				pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << " " << endl;
		cout << " " << endl;
		cout << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		cout << "Printing Output" << endl;
		UINT pIndexValue = 0;


		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		SYSTEMTIME restorationStartSystem;
		SYSTEMTIME restorationStartLocal;

		GetSystemTime(&restorationStartSystem);
		GetLocalTime(&restorationStartLocal);
		cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBOne,
			&pFilteredObjectArrayRGBOneRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;


		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}


		vector<FilterPixelLabel> pFilterPixelLabelOneY = vector<FilterPixelLabel>();
		vector<FilterPixelLabel> pFilterPixelLabelTwoY = vector<FilterPixelLabel>();
		vector<FilterPixelLabel> pFilterPixelLabelThreeY = vector<FilterPixelLabel>();
		vector<FilterPixelLabel> pFilterPixelLabelOneX = vector<FilterPixelLabel>();
		vector<FilterPixelLabel> pFilterPixelLabelTwoX = vector<FilterPixelLabel>();
		vector<FilterPixelLabel> pFilterPixelLabelThreeX = vector<FilterPixelLabel>();

		vector<vector<FilterPixelLabel>> pYSectorValues = vector<vector<FilterPixelLabel>>();
		vector<vector<FilterPixelLabel>> pXSectorValues = vector<vector<FilterPixelLabel>>();

	
		hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(hInstance,
			hWnd,
			pYSortingConstant0,
			pCentreX, 1, 2, -1,
			pFilteredObjectArrayRGBOneRestored,
			&pFilterPixelLabelOneY);

		hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(hInstance,
			hWnd,
			pYSortingConstant1,
			pCentreX, 1, 2, -1,
			pFilteredObjectArrayRGBOneRestored,
			&pFilterPixelLabelTwoY);
		
		hr = ppStandardAlgorithmExecutor->FilterPixelsForYPositionConstantAndXBreakpoint(hInstance,
			hWnd,
			pYSortingConstant2,
			pCentreX, 1, 2, -1,
			pFilteredObjectArrayRGBOneRestored,
			&pFilterPixelLabelThreeY);


		hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(hInstance,
			hWnd,
			pXSortingConstant0,
			pCentreY, 1, 2, -1,
			pFilteredObjectArrayRGBOneRestored,
			&pFilterPixelLabelOneX);

		hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(hInstance,
			hWnd,
			pXSortingConstant1,
			pCentreY, 1, 2, -1,
			pFilteredObjectArrayRGBOneRestored,
			&pFilterPixelLabelTwoX);

		pCentreY = 200.0f;

		

		hr = ppStandardAlgorithmExecutor->FilterPixelsForXPositionConstantAndYBreakpoint(hInstance,
			hWnd,
			pXSortingConstant2,
			pCentreY, 1, 2, -1,
			pFilteredObjectArrayRGBOneRestored,
			&pFilterPixelLabelThreeX);

		cout << "Restoring Pixels for Sector 1" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Secor 2" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			1,
			pFilterPixelLabelOneY,
			&pSectorOne);






		cout << "Restoring Pixels for Sector 2" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector two" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			2,
			pFilterPixelLabelOneY,
			&pSectorTwo);


		cout << "Restoring Pixels for Sector 3" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Secor 2" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			1,
			pFilterPixelLabelTwoY,
			&pSectorThree);


		cout << "Restoring Pixels for Sector 4" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector two" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			2,
			pFilterPixelLabelTwoY,
			&pSectorFour);

		cout << "Restoring Pixels for Sector 5" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 5" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			1,
			pFilterPixelLabelThreeY,
			&pSectorFive);


		cout << "Restoring Pixels for Sector 6" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 6" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd,
			2,
			pFilterPixelLabelThreeY,
			&pSectorSix);


		cout << "Restoring Pixels for Sector 7" << endl;
		imageSegmentationDataFile << "Restoring Pixels for SecTor 7" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			1,
			pFilterPixelLabelOneX,
			&pSectorSeven);


		cout << "Restoring Pixels for Sector 8" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 8" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			2,
			pFilterPixelLabelOneX,
			&pSectorEight);


		cout << "Restoring Pixels for Sector 9" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 9" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			1,
			pFilterPixelLabelTwoX,
			&pSectorNine);


		cout << "Restoring Pixels for Sector 10" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 10" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			2,
			pFilterPixelLabelTwoX,
			&pSectorTen);

		cout << "Restoring Pixels for Sector 11" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 11" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			1,
			pFilterPixelLabelThreeX,
			&pSectorEleven);


		cout << "Restoring Pixels for Sector 12" << endl;
		imageSegmentationDataFile << "Restoring Pixels for Sector 12" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd,
			2,
			pFilterPixelLabelThreeX,
			&pSectorTwelve);



	

		cout << "Printing Sector One Values" << endl;
		imageSegmentationDataFile << "Printing Sector One Values" << endl;
		imageSectorsData << "Printing Sector One Values" << endl;
		vector<float> pXArrayOne = vector<float>();


		for (PixelObject pixelObject : pSectorOne)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;
		}



		cout << "Printing Sector Two Values" << endl;
		imageSegmentationDataFile << "Printing Sector Two Values" << endl;

		for (PixelObject pixelObject : pSectorTwo)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Printing Sector 3 Values" << endl;
		imageSegmentationDataFile << "Printing Sector 3 Values" << endl;

		for (PixelObject pixelObject : pSectorThree)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}




		cout << "Sector Four" << endl;
		imageSegmentationDataFile << "Sector Four" << endl;
		imageSectorsData << "Sector Four" << endl;

		for (PixelObject pixelObject : pSectorFour)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Sector Five" << endl;
		imageSegmentationDataFile << "Sector Five" << endl;
		imageSectorsData << "Sector Five" << endl;

		for (PixelObject pixelObject : pSectorFive)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;





		cout << "Sector Six" << endl;
		imageSegmentationDataFile << "Sector Six" << endl;
		imageSectorsData << "Sector Six" << endl;


		for (PixelObject pixelObject : pSectorSix)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;


		cout << "Sector Seven" << endl;
		imageSegmentationDataFile << "Sector Seven" << endl;
		imageSectorsData << "Sector Seven: " << endl;


		for (PixelObject pixelObject : pSectorSeven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;


		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Eight" << endl;
		imageSegmentationDataFile << "Printing Sector Eight" << endl;
		imageSectorsData << "Sector Eight: " << endl;

		for (PixelObject pixelObject : pSectorEight)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Nine" << endl;
		imageSegmentationDataFile << "Printing Sector Nine" << endl;
		imageSectorsData << "Sector Nine: " << endl;

		for each (PixelObject pixelObject in pSectorNine)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Ten" << endl;
		imageSegmentationDataFile << "Printing Sector Ten" << endl;
		imageSectorsData << "Printing Sector Ten" << endl;


		for each (PixelObject pixelObject in pSectorTen)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Eleven" << endl;
		imageSegmentationDataFile << "Printing Sector Eleven" << endl;
		imageSectorsData << "Printing Sector Eleven" << endl;

		for (PixelObject pixelObject : pSectorEleven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Twelve" << endl;
		imageSegmentationDataFile << "Printing Sector Twelve" << endl;
		imageSectorsData << "Printing Sector Twelve" << endl;


		for (PixelObject pixelObject : pSectorTwelve)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}



		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;


		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;


		cout << "Computing Median X for Sectors 1-6" << endl;
		imageSegmentationDataFile << "Computing Median X for Sectors 1-6" << endl;

		pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
		pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
		pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
		pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
		pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
		pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

		cout << "Computing Median Y for Sectors 7-12" << endl;
		imageSegmentationDataFile << "Computing Median Y for Sectors 7-12" << endl;

		pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
		pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
		pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
		pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
		pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
		pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

		pXPositionAverageWhole0 = round(pXPositionAverage0);
		pXPositionAverageWhole1 = round(pXPositionAverage1);
		pXPositionAverageWhole2 = round(pXPositionAverage2);
		pXPositionAverageWhole3 = round(pXPositionAverage3);
		pXPositionAverageWhole4 = round(pXPositionAverage4);
		pXPositionAverageWhole5 = round(pXPositionAverage5);

		pYPositionAverageWhole0 = round(pYPositionAverage0);
		pYPositionAverageWhole1 = round(pYPositionAverage1);
		pYPositionAverageWhole2 = round(pYPositionAverage2);
		pYPositionAverageWhole3 = round(pYPositionAverage3);
		pYPositionAverageWhole4 = round(pYPositionAverage4);
		pYPositionAverageWhole5 = round(pYPositionAverage5);








		cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;


		imageSegmentationDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		imageSegmentationDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;




		vector<float> pXValueaArray = vector<float>();
		vector<float> pYValueaArray = vector<float>();
		pXValueaArray.push_back(pXPositionAverageWhole0);
		pXValueaArray.push_back(pXPositionAverageWhole1);
		pXValueaArray.push_back(pXPositionAverageWhole2);
		pXValueaArray.push_back(pXPositionAverageWhole3);
		pXValueaArray.push_back(pXPositionAverageWhole4);
		pXValueaArray.push_back(pXPositionAverageWhole5);

		pYValueaArray.push_back(pYPositionAverageWhole0);
		pYValueaArray.push_back(pYPositionAverageWhole1);
		pYValueaArray.push_back(pYPositionAverageWhole2);
		pYValueaArray.push_back(pYPositionAverageWhole3);
		pYValueaArray.push_back(pYPositionAverageWhole4);
		pYValueaArray.push_back(pYPositionAverageWhole5);

		sort(pXValueaArray.begin(), pXValueaArray.end(), SortingFloatsAscending);
		sort(pYValueaArray.begin(), pYValueaArray.end(), SortingFloatsAscending);

		pCentreX = (pXValueaArray[pXValueaArray.size() - 1] - pXValueaArray[0]) / 2.0f + pXValueaArray[0] - 0.5f;
		pCentreY = (pYValueaArray[pYValueaArray.size() - 1] - pYValueaArray[0]) / 2.0f + pYValueaArray[0] - 0.5f;

		cout << "Computed X for Centre = " << pCentreX << endl;
		cout << "Computed Y for Centre = " << pCentreY << endl;
		imageSegmentationDataFile << "Computed X for Centre = " << pCentreX << endl;
		imageSegmentationDataFile << "Computed Y for Centre = " << pCentreY << endl;




		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, 0.0f, 0.0f, 0.0f);


		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;

		GetSystemTime(&computeDeltaStartSystem);
		GetLocalTime(&computeDeltaStartLocal);
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentreX, pCentreY,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);

		SYSTEMTIME computeDeltaEndSystem;
		SYSTEMTIME computeDeltaEndLocal;

		GetSystemTime(&computeDeltaEndSystem);
		GetLocalTime(&computeDeltaEndLocal);
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





		vector<Point2D> pPointArrayToDrawOne = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawTwo = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawThree = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawFour = vector<Point2D>();
		vector<Point2D> pPointArrayToDraw = vector<Point2D>();



		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointObject.pSectorNumber = 1;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointObject.pSectorNumber = 2;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointObject.pSectorNumber = 3;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointObject.pSectorNumber = 4;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}

		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
	
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd, pCentreX, pCentreY, pPointArrayToDraw);





		float pSectorLength12 = 0.0f;
		float pSectorLength23 = 0.0f;
		float pSectorLength34 = 0.0f;
		float pSectorLength45 = 0.0f;
		float pSectorLength56 = 0.0f;
		float pSectorLength67 = 0.0f;
		float pSectorLength78 = 0.0f;
		float pSectorLength89 = 0.0f;
		float pSectorLength910 = 0.0f;
		float pSectorLength1011 = 0.0f;
		float pSectorLength1112 = 0.0f;
		float pSectorLength1201 = 0.0f;

		float pSectorLength1Centre = 0.0f;
		float pSectorLength2Centre = 0.0f;
		float pSectorLength3Centre = 0.0f;
		float pSectorLength4Centre = 0.0f;
		float pSectorLength5Centre = 0.0f;
		float pSectorLength6Centre = 0.0f;
		float pSectorLength7Centre = 0.0f;
		float pSectorLength8Centre = 0.0f;
		float pSectorLength9Centre = 0.0f;
		float pSectorLength10Centre = 0.0f;
		float pSectorLength11Centre = 0.0f;
		float pSectorLength12Centre = 0.0f;


		Point2D pPointOne = pPointArrayToDraw[0];
		Point2D pPointTwo = pPointArrayToDraw[1];
		Point2D pPointThree = pPointArrayToDraw[2];

		Point2D pPointFour = pPointArrayToDraw[3];
		Point2D pPointFive = pPointArrayToDraw[4];
		Point2D pPointSix = pPointArrayToDraw[5];
		Point2D pPointSeven = pPointArrayToDraw[6];
		Point2D pPointEight = pPointArrayToDraw[7];
		Point2D pPointNine = pPointArrayToDraw[8];
		Point2D pPointTen = pPointArrayToDraw[9];
		Point2D pPointEleven = pPointArrayToDraw[10];
		Point2D pPointTwelve = pPointArrayToDraw[11];




		pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
		pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
		pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
		pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
		pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
		pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
		pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
		pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
		pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
		pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
		pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
		pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

		pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
		pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
		pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
		pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
		pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
		pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
		pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
		pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
		pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
		pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
		pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
		pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



		Line2D pLine12;
		pLine12.pLineNumber = 1;
		pLine12.pPointOne = pPointOne;
		pLine12.pPointTwo = pPointTwo;
		pLine12.pLineWidth = pSectorLength12;



		Line2D pLine23;
		pLine23.pLineNumber = 2;
		pLine23.pPointOne = pPointTwo;
		pLine23.pPointTwo = pPointThree;
		pLine23.pLineWidth = pSectorLength23;


		Line2D pLine34;
		pLine34.pLineNumber = 3;
		pLine34.pPointOne = pPointThree;
		pLine34.pPointTwo = pPointFour;
		pLine34.pLineWidth = pSectorLength34;


		Line2D pLine45;
		pLine45.pLineNumber = 4;
		pLine45.pPointOne = pPointFour;
		pLine45.pPointTwo = pPointFive;
		pLine45.pLineWidth = pSectorLength45;


		Line2D pLine56;
		pLine56.pLineNumber = 5;
		pLine56.pPointOne = pPointFive;
		pLine56.pPointTwo = pPointSix;
		pLine56.pLineWidth = pSectorLength56;


		Line2D pLine67;
		pLine67.pLineNumber = 6;
		pLine67.pPointOne = pPointSix;
		pLine67.pPointTwo = pPointSeven;
		pLine67.pLineWidth = pSectorLength67;


		Line2D pLine78;
		pLine78.pLineNumber = 7;
		pLine78.pPointOne = pPointSeven;
		pLine78.pPointTwo = pPointEight;
		pLine78.pLineWidth = pSectorLength78;

		Line2D pLine89;
		pLine89.pLineNumber = 8;
		pLine89.pPointOne = pPointEight;
		pLine89.pPointTwo = pPointNine;
		pLine89.pLineWidth = pSectorLength89;


		Line2D pLine910;
		pLine910.pLineNumber = 9;
		pLine910.pPointOne = pPointNine;
		pLine910.pPointTwo = pPointTen;
		pLine910.pLineWidth = pSectorLength910;


		Line2D pLine1011;
		pLine1011.pLineNumber = 10;
		pLine1011.pPointOne = pPointTen;
		pLine1011.pPointTwo = pPointEleven;
		pLine1011.pLineWidth = pSectorLength1011;


		Line2D pLine1112;
		pLine1112.pLineNumber = 11;
		pLine1112.pPointOne = pPointEleven;
		pLine1112.pPointTwo = pPointTwelve;
		pLine1112.pLineWidth = pSectorLength1112;


		Line2D pLine1201;
		pLine1201.pLineNumber = 12;
		pLine1201.pPointOne = pPointTwelve;
		pLine1201.pPointTwo = pPointOne;
		pLine1201.pLineWidth = pSectorLength1201;

		Line2D pLineOneCentre;
		pLineOneCentre.pLineNumber = 13;
		pLineOneCentre.pPointOne = pPointOne;
		pLineOneCentre.pPointTwo = pCentre;
		pLineOneCentre.pLineWidth = pSectorLength1Centre;

		Line2D pLineTwoCentre;
		pLineTwoCentre.pLineNumber = 15;
		pLineTwoCentre.pPointOne = pPointTwo;
		pLineTwoCentre.pPointTwo = pCentre;
		pLineTwoCentre.pLineWidth = pSectorLength2Centre;

		Line2D pLineThreeCentre;
		pLineThreeCentre.pLineNumber = 16;
		pLineThreeCentre.pPointOne = pPointThree;
		pLineThreeCentre.pPointTwo = pCentre;
		pLineThreeCentre.pLineWidth = pSectorLength3Centre;


		Line2D pLineFourCentre;
		pLineFourCentre.pLineNumber = 16;
		pLineFourCentre.pPointOne = pPointFour;
		pLineFourCentre.pPointTwo = pCentre;
		pLineFourCentre.pLineWidth = pSectorLength4Centre;


		Line2D pLineFiveCentre;
		pLineFiveCentre.pLineNumber = 17;
		pLineFiveCentre.pPointOne = pPointFive;
		pLineFiveCentre.pPointTwo = pCentre;
		pLineFiveCentre.pLineWidth = pSectorLength5Centre;


		Line2D pLineSixCentre;
		pLineSixCentre.pLineNumber = 18;
		pLineSixCentre.pPointOne = pPointSix;
		pLineSixCentre.pPointTwo = pCentre;
		pLineSixCentre.pLineWidth = pSectorLength6Centre;


		Line2D pLineSevenCentre;
		pLineSevenCentre.pLineNumber = 19;
		pLineSevenCentre.pPointOne = pPointSeven;
		pLineSevenCentre.pPointTwo = pCentre;
		pLineSevenCentre.pLineWidth = pSectorLength7Centre;


		Line2D pLineEightCentre;
		pLineEightCentre.pLineNumber = 20;
		pLineEightCentre.pPointOne = pPointEight;
		pLineEightCentre.pPointTwo = pCentre;
		pLineEightCentre.pLineWidth = pSectorLength8Centre;


		Line2D pLineNineCentre;
		pLineNineCentre.pLineNumber = 21;
		pLineNineCentre.pPointOne = pPointNine;
		pLineNineCentre.pPointTwo = pCentre;
		pLineNineCentre.pLineWidth = pSectorLength9Centre;


		Line2D pLineTenCentre;
		pLineTenCentre.pLineNumber = 22;
		pLineTenCentre.pPointOne = pPointTen;
		pLineTenCentre.pPointTwo = pCentre;
		pLineTenCentre.pLineWidth = pSectorLength10Centre;


		Line2D pLineElevenCentre;
		pLineElevenCentre.pLineNumber = 23;
		pLineElevenCentre.pPointOne = pPointEleven;
		pLineElevenCentre.pPointTwo = pCentre;
		pLineElevenCentre.pLineWidth = pSectorLength11Centre;


		Line2D pLineTwelveCentre;
		pLineTwelveCentre.pLineNumber = 24;
		pLineTwelveCentre.pPointOne = pPointTwelve;
		pLineTwelveCentre.pPointTwo = pCentre;
		pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








		float pTriangleOneArea = 0.0f;
		float pTriangleTwoArea = 0.0f;
		float pTriangleThreeArea = 0.0f;
		float pTriangleFourArea = 0.0f;
		float pTriangleFiveArea = 0.0f;
		float pTriangleSixArea = 0.0f;
		float pTriangleSevenArea = 0.0f;
		float pTriangleEightArea = 0.0f;
		float pTriangleNineArea = 0.0f;
		float pTriangleTenArea = 0.0f;
		float pTriangleElevenArea = 0.0f;
		float pTriangleTwelveArea = 0.0f;





		float pTriangleAreaTotal = 0.0f;
		pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
		pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
		pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
		pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
		pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
		pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
		pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
		pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
		pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
		pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
		pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
		pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
		pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

		cout << "Triangle One Area: " << pTriangleOneArea << endl;
		cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
		cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
		cout << "Triangle Four Area: " << pTriangleFourArea << endl;
		cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
		cout << "Triangle Six Area: " << pTriangleSixArea << endl;
		cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
		cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
		cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
		cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

		imageSegmentationDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
		imageSegmentationDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
		imageSegmentationDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
		imageSegmentationDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
		imageSegmentationDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
		imageSegmentationDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
		imageSegmentationDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		imageSegmentationDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
		imageSegmentationDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
		imageSegmentationDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
		imageSegmentationDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		imageSegmentationDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


		cout << "Constructing Triangle Structures" << endl;
		TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
			pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
		TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
			pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
		TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
			pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
		TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
			pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
		TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
			pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
		TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
			pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
		TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
			pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
		TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
			pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
		TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
			pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
		TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
			pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
		TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
			pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
		TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
			pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

		cout << "Storing Our Triangle Data into A Vector" << endl;
		imageSegmentationDataFile << "Storing Our Triangle Data into A Vector" << endl;

		vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
		pTriangleObjectVector.push_back(pTriangleObjectOne);
		pTriangleObjectVector.push_back(pTriangleObjectTwo);
		pTriangleObjectVector.push_back(pTriangleObjectThree);
		pTriangleObjectVector.push_back(pTriangleObjectFour);
		pTriangleObjectVector.push_back(pTriangleObjectFive);
		pTriangleObjectVector.push_back(pTriangleObjectSix);
		pTriangleObjectVector.push_back(pTriangleObjectSeven);
		pTriangleObjectVector.push_back(pTriangleObjectEight);
		pTriangleObjectVector.push_back(pTriangleObjectNine);
		pTriangleObjectVector.push_back(pTriangleObjectTen);
		pTriangleObjectVector.push_back(pTriangleObjectEleven);
		pTriangleObjectVector.push_back(pTriangleObjectTwelve);

		for (TriangleObject pTriangleObject : pTriangleObjectVector)
		{
			cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			cout << "Point A:" << endl;
			cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			cout << "Point B:" << endl;
			cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			cout << "Point C:" << endl;
			cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			cout << "Area = " << pTriangleObject.pTriangleArea << endl;

			imageSegmentationDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			imageSegmentationDataFile << "Point A:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			imageSegmentationDataFile << "Point B:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			imageSegmentationDataFile << "Point C:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			imageSegmentationDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			imageSegmentationDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			imageSegmentationDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
		}




		cout << "Computing Perimeter for the Shape" << endl;
		float pShapePerimeter = 0.0f;
		pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


		cout << "Perimeter Value: " << pShapePerimeter << endl;
		imageSegmentationDataFile << "Perimeter Value: " << pShapePerimeter << endl;






		cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
		imageSegmentationDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}
	imageSegmentationDataFile.close();
	imageSectorsData.close();

	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamic(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	float pStepX = 0.0f;
	float pStepY = 0.0f;

	
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamic.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);



	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;






	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	float pYSortingConstant0 = pStepY;
	float pYSortingConstant1 = pStepY * 2;
	float pYSortingConstant2 = pStepY * 3;

	float pXSortingConstant0 = pStepX;
	float pXSortingConstant1 = pStepX * 2;
	float pXSortingConstant2 = pStepX * 3;





	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
		}

		cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

		}
		float pCentreX = 0.0f;
		float pCentreY = 0.0f;
		float pYDelta = 0.0f;

		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
	

		imageSegmentationDataFile << "Your Centre Point Is: " << endl;
		imageSegmentationDataFile << "X Position: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Position: " << pCentreY << endl;





		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());




		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBOne);

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);
		cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
				endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
				pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << " " << endl;
		cout << " " << endl;
		cout << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		cout << "Printing Output" << endl;
		UINT pIndexValue = 0;


		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		SYSTEMTIME restorationStartSystem;
		SYSTEMTIME restorationStartLocal;

		GetSystemTime(&restorationStartSystem);
		GetLocalTime(&restorationStartLocal);
		cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBOne,
			&pFilteredObjectArrayRGBOneRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;


		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
			pXValuesArray.push_back(pixelObject.xPosition);
			pYValuesArray.push_back(pixelObject.yPosition);
		}


		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;



		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;

		sort(pXValuesArray.begin(), pXValuesArray.end(), WayToSortFloatsAscending);
		sort(pYValuesArray.begin(), pYValuesArray.end(), WayToSortFloatsAscending);

		pCentreX = round((pXValuesArray[pXValuesArray.size() - 1] - pXValuesArray[0]) / 2.0f + pXValuesArray[0]);
		pCentreY = round((pYValuesArray[pYValuesArray.size() - 1] - pYValuesArray[0]) / 2.0f + pYValuesArray[0]);


		cout << "Centre Pixel: " << endl;
		cout << "X Value: " << pCentreX << endl;
		cout << "Y Value" << pCentreY << endl;


		imageSegmentationDataFile << "Centre Pixel: " << endl;
		imageSegmentationDataFile << "X Value: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Value" << pCentreY << endl;


		int pPixelCounter = 0;
		vector<PixelObject> pSectorAObject = vector<PixelObject>();
		vector<PixelObject> pSectorBObject = vector<PixelObject>();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For X Axis Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For X Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		for (float pYValue = 0; pYValue < pImageHeight; pYValue += pStepY)
		{
			if (pYValue > 0)
			{
				pSectorAObject.clear();
				pSectorBObject.clear();

				hr = ComputeAverageXForPixelArrayOnAGPU(hInstance, hWnd, pYValue, pCentreX, 1, 2, -1,
					pFilteredObjectArrayRGBOneRestored,
					&pSectorAObject,
					&pSectorBObject,
					&pXPositionAverageWhole0,
					&pXPositionAverageWhole1);

				cout << "Printing Sector First Part" << endl;
				imageSegmentationDataFile << "Priniting Sector First Part" << endl;

				for (PixelObject pixelObject : pSectorAObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}
					
				}

				cout << "Printing Sector Second Part" << endl;
				imageSegmentationDataFile << "Priniting Sector Second Part" << endl;

				for (PixelObject pixelObject : pSectorBObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}



				if ((pXPositionAverageWhole0 > 0) && (pXPositionAverageWhole1 > 0))
				{
					PixelObject pNewPixelValue0 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXPositionAverageWhole0, pYValue);
					pPixelCounter = pPixelCounter + 1;
					PixelObject pNewPixelValue1 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXPositionAverageWhole1, pYValue);
					if ((pNewPixelValue0.pixelNumber != 0) && (pNewPixelValue1.pixelNumber != 0))
					{
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue0);
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue1);
					}
				
					pPixelCounter++;

				}
	
			}

		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "Sectoring For X Axis End System Time\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << "Sectoring For X Axis Started System Local\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For X Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		 pPixelCounter = 0;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For Y Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For Y Axis Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For Y Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For Y Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		for (float pXValue = 0; pXValue < pImageWidth; pXValue += pStepX)
		{
			if (pXValue > 0)
			{
				if (pXValue == 600.0f)
				{
					pYDelta = 200.0f;
				}
				else
				{
					pYDelta = pCentreY;
				}
			

				hr = ComputeAverageYForPixelArrayOnAGPU(hInstance, hWnd, pXValue, pYDelta, 1, 2, -1,
					pFilteredObjectArrayRGBOneRestored,
					&pSectorAObject,
					&pSectorBObject,
					&pYPositionAverageWhole0,
					&pYPositionAverageWhole1);


				cout << "Printing Sector First Part" << endl;
				imageSegmentationDataFile << "Printing Sector First Part" << endl;

				for (PixelObject pixelObject : pSectorAObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}

				cout << "Printing Sector Second Part" << endl;
				imageSegmentationDataFile << "Printing Sector Second Part" << endl;

				for (PixelObject pixelObject : pSectorBObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}


				if ((pYPositionAverageWhole0 > 0) && (pYPositionAverageWhole1 > 0))
				{
					PixelObject pNewPixelValue0 = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
					PixelObject pNewPixelValue1 = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);

				
					pNewPixelValue0 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXValue, pYPositionAverageWhole0);
					pPixelCounter = pPixelCounter + 1;
					pNewPixelValue1 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXValue, pYPositionAverageWhole1);
					pPixelCounter = pPixelCounter + 1;
					if ((pNewPixelValue0.pixelNumber != 0) && (pNewPixelValue1.pixelNumber != 0))
					{
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue0);
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue1);
					}
				}
			}
		}

	
		 pPixelCounter = 0;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For Y Axis End System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For Y Axis End  System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For Y Axis End  System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For Y Axis End  System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;

		GetSystemTime(&computeDeltaStartSystem);
		GetLocalTime(&computeDeltaStartLocal);
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentreX, pCentreY,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);



		SYSTEMTIME computeDeltaEndSystem;
		SYSTEMTIME computeDeltaEndLocal;

		GetSystemTime(&computeDeltaEndSystem);
		GetLocalTime(&computeDeltaEndLocal);
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);
		vector<OutputPixelObjectWithAngleValues> pInvalidSectors = vector<OutputPixelObjectWithAngleValues>();
		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}
		





		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);


	

	


		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

	

		vector<Point2D> pPointArrayToDraw = vector<Point2D>();

		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorOne)
		{

			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorTwo)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorThree)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorFour)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}





		vector<Point2D> pPointArrayToDrawOne = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawTwo = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawThree = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawFour = vector<Point2D>();

	



	

		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentreX,
			pCentreY,
			pPointArrayToDraw);

		cout << "Saving Data About our Segments " << endl;

		vector<Line2D> pLineArray = vector<Line2D>();
		float pPermimeterValue = 0.0f;
		for (UINT pIndex = 0; pIndex <= pPointArrayToDraw.size() - 2; pIndex++)
		{
			Point2D pPointOneObject = pPointArrayToDraw[pIndex];
			Point2D pPointTwoObject = pPointArrayToDraw[pIndex + 1];

			float pLineMagnitude = 0.0f;
			pLineMagnitude = ComputeLineLengthBetweenPoint(pPointOneObject, pPointTwoObject);
			Line2D pNewLineValue;
			pNewLineValue.pLineNumber = pIndex;
			pNewLineValue.pPointOne = pPointOneObject;
			pNewLineValue.pPointTwo = pPointTwoObject;
			pNewLineValue.pLineWidth = pLineMagnitude;
			pLineArray.push_back(pNewLineValue);
			pPermimeterValue = pPermimeterValue + pNewLineValue.pLineWidth;
		}

		Line2D pLastLineValue;
		pLastLineValue.pLineNumber = pIndex + 1;
		Point2D pPointOneObject = pPointArrayToDraw[pPointArrayToDraw.size() - 1];
		Point2D pPointTwoObject = pPointArrayToDraw[0];
		pLastLineValue.pPointOne = pPointOneObject;
		pLastLineValue.pPointTwo = pPointTwoObject;
		float pLineMagnitude = 0.0f;
		pLineMagnitude = ComputeLineLengthBetweenPoint(pPointOneObject, pPointTwoObject);

		pLastLineValue.pLineWidth = pLineMagnitude;
		pLineArray.push_back(pLastLineValue);
		pPermimeterValue = pPermimeterValue + pLastLineValue.pLineWidth;


		cout << "Printing Out Line Segments: " << endl;
		imageSegmentationDataFile << "Printing Out Line Segments: " << endl;

		for (Line2D pLineObject : pLineArray)
		{
			cout << "Line Number: " << pLineObject.pLineNumber << endl;
			cout << "Point One: " << endl;;
			cout << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			cout << "Point Two: " << endl;;
			cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

			imageSegmentationDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
			imageSegmentationDataFile << "Point One: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			imageSegmentationDataFile << "Point Two: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			imageSegmentationDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;


		}

		cout << "The Perimeter of the Shape: " << pPermimeterValue << endl;
		imageSegmentationDataFile << "The Perimeter of the Shape: " << pPermimeterValue << endl;





		cout << "Now we will Compute the area of Our Polygon " << endl;
		
		float pAreaValue = 0.0f;
		pAreaValue = ComputePolygonAreaUsingShoelaceFormula(pPointArrayToDraw, pPointArrayToDraw.size());
		cout << "Polygon Area = " << pAreaValue << endl;
		imageSegmentationDataFile << "Polygon Area = " << pAreaValue << endl;


		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}
	imageSegmentationDataFile.close();
	imageSectorsData.close();

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicUsingDescriptors(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	float pStepX = 0.0f;
	float pStepY = 0.0f;


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamicDescriptors.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);



	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;






	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	float pRedValueClassTwo = 0.0f;
	float pGreenValueClassTwo = 0.0f;
	float pBlueValueClassTwo = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component for Class 1" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component for Class 1" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component for Class 1" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the Red Component Component for Class 2" << endl;
	cin >> pRedValueClassTwo;
	cout << "Enter the Green Component Component for Class 2" << endl;
	cin >> pGreenValueClassTwo;
	cout << "Enter the BLue Component for Class 2" << endl;
	cin >> pBlueValueClassTwo;

	cout << "Enter the Value for Thresold Parameter" << endl;
	cin >> pThresoldValue;


	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	float pYSortingConstant0 = pStepY;
	float pYSortingConstant1 = pStepY * 2;
	float pYSortingConstant2 = pStepY * 3;

	float pXSortingConstant0 = pStepX;
	float pXSortingConstant1 = pStepX * 2;
	float pXSortingConstant2 = pStepX * 3;

	int pClassOneLabel = 1;
	int pClassTwoLabel = 2;
	int pClassThreeLabel = 3;




	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY,
			&pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
		}

		cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		start = high_resolution_clock::now();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1,
			&pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

		}
		float pCentreX = 0.0f;
		float pCentreY = 0.0f;
		float pYDelta = 0.0f;

		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();


		imageSegmentationDataFile << "Your Centre Point Is: " << endl;
		imageSegmentationDataFile << "X Position: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Position: " << pCentreY << endl;





		 stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		 duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());




		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();

		vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();


		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance, hWnd,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pRedValueClassTwo,
			pGreenValueClassTwo,
			pBlueValueClassTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorOne, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;

		}

		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		imageSegmentationDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;


		float pColorSum = 0.0f;
		for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
		{

			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


				imageSegmentationDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pValidationItem.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pValidationItem.yPosition << endl;
				imageSegmentationDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageSegmentationDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageSegmentationDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageSegmentationDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;
			}



		}

		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		imageSegmentationDataFile << "Restoring Class 1 RGB Pixels Data" << endl;




		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassOneLabel,
			pOutputFilterResult,
			&pFilteredObjectArrayRGBOneRestored);

		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.GMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}


		}


		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
			pXValuesArray.push_back(pixelObject.xPosition);
			pYValuesArray.push_back(pixelObject.yPosition);
		}


		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;



		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;

		sort(pXValuesArray.begin(), pXValuesArray.end(), WayToSortFloatsAscending);
		sort(pYValuesArray.begin(), pYValuesArray.end(), WayToSortFloatsAscending);

		pCentreX = round((pXValuesArray[pXValuesArray.size() - 1] - pXValuesArray[0]) / 2.0f + pXValuesArray[0]);
		pCentreY = round((pYValuesArray[pYValuesArray.size() - 1] - pYValuesArray[0]) / 2.0f + pYValuesArray[0]);


		cout << "Centre Pixel: " << endl;
		cout << "X Value: " << pCentreX << endl;
		cout << "Y Value" << pCentreY << endl;


		imageSegmentationDataFile << "Centre Pixel: " << endl;
		imageSegmentationDataFile << "X Value: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Value" << pCentreY << endl;


		int pPixelCounter = 0;
		vector<PixelObject> pSectorAObject = vector<PixelObject>();
		vector<PixelObject> pSectorBObject = vector<PixelObject>();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For X Axis Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For X Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		for (float pYValue = 0; pYValue < pImageHeight; pYValue += pStepY)
		{
			if (pYValue > 0)
			{
				pSectorAObject.clear();
				pSectorBObject.clear();

				hr = ComputeAverageXForPixelArrayOnAGPU(hInstance, hWnd, pYValue, pCentreX, 1, 2, -1,
					pFilteredObjectArrayRGBOneRestored,
					&pSectorAObject,
					&pSectorBObject,
					&pXPositionAverageWhole0,
					&pXPositionAverageWhole1);

				cout << "Printing Sector First Part" << endl;
				imageSegmentationDataFile << "Priniting Sector First Part" << endl;

				for (PixelObject pixelObject : pSectorAObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}

				cout << "Printing Sector Second Part" << endl;
				imageSegmentationDataFile << "Priniting Sector Second Part" << endl;

				for (PixelObject pixelObject : pSectorBObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}



				if ((pXPositionAverageWhole0 > 0) && (pXPositionAverageWhole1 > 0))
				{
					PixelObject pNewPixelValue0 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXPositionAverageWhole0, pYValue);
					pPixelCounter = pPixelCounter + 1;
					PixelObject pNewPixelValue1 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXPositionAverageWhole1, pYValue);
					if ((pNewPixelValue0.pixelNumber != 0) && (pNewPixelValue1.pixelNumber != 0))
					{
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue0);
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue1);
					}

					pPixelCounter++;

				}

			}

		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "Sectoring For X Axis End System Time\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << "Sectoring For X Axis Started System Local\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For X Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		pPixelCounter = 0;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For Y Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For Y Axis Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For Y Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For Y Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		for (float pXValue = 0; pXValue < pImageWidth; pXValue += pStepX)
		{
			if (pXValue > 0)
			{
				if (pXValue == 600.0f)
				{
					pYDelta = 200.0f;
				}
				else
				{
					pYDelta = pCentreY;
				}


				hr = ComputeAverageYForPixelArrayOnAGPU(hInstance, hWnd, pXValue, pYDelta, 1, 2, -1,
					pFilteredObjectArrayRGBOneRestored,
					&pSectorAObject,
					&pSectorBObject,
					&pYPositionAverageWhole0,
					&pYPositionAverageWhole1);


				cout << "Printing Sector First Part" << endl;
				imageSegmentationDataFile << "Printing Sector First Part" << endl;

				for (PixelObject pixelObject : pSectorAObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}

				cout << "Printing Sector Second Part" << endl;
				imageSegmentationDataFile << "Printing Sector Second Part" << endl;

				for (PixelObject pixelObject : pSectorBObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}


				if ((pYPositionAverageWhole0 > 0) && (pYPositionAverageWhole1 > 0))
				{
					PixelObject pNewPixelValue0 = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
					PixelObject pNewPixelValue1 = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);


					pNewPixelValue0 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXValue, pYPositionAverageWhole0);
					pPixelCounter = pPixelCounter + 1;
					pNewPixelValue1 = GetPixelByXAndYPosition(pFilteredObjectArrayRGBOneRestored, pXValue, pYPositionAverageWhole1);
					pPixelCounter = pPixelCounter + 1;
					if ((pNewPixelValue0.pixelNumber != 0) && (pNewPixelValue1.pixelNumber != 0))
					{
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue0);
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue1);
					}
				}
			}
		}


		pPixelCounter = 0;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For Y Axis End System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For Y Axis End  System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For Y Axis End  System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For Y Axis End  System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;

		GetSystemTime(&computeDeltaStartSystem);
		GetLocalTime(&computeDeltaStartLocal);
		cout << "Compute Delta Started: %02d:%02d\n" << computeDeltaStartSystem.wHour << ":" <<
			computeDeltaStartSystem.wMinute << ":" << computeDeltaStartSystem.wSecond << endl;
		cout << "Compute Delta Started: %02d:%02d\n" << computeDeltaStartLocal.wHour << ":" <<
			computeDeltaStartLocal.wMinute << ":" << computeDeltaStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << computeDeltaStartSystem.wHour << ":" <<
			computeDeltaStartSystem.wMinute << ":" << computeDeltaStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << computeDeltaStartLocal.wHour << ":" <<
			computeDeltaStartLocal.wMinute << ":" << computeDeltaStartLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentreX, pCentreY,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);



		SYSTEMTIME computeDeltaEndSystem;
		SYSTEMTIME computeDeltaEndLocal;

		GetSystemTime(&computeDeltaEndSystem);
		GetLocalTime(&computeDeltaEndLocal);
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);
		vector<OutputPixelObjectWithAngleValues> pInvalidSectors = vector<OutputPixelObjectWithAngleValues>();
		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}






		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);







		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();



		vector<Point2D> pPointArrayToDraw = vector<Point2D>();

		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorOne)
		{

			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorTwo)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorThree)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorFour)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}





		vector<Point2D> pPointArrayToDrawOne = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawTwo = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawThree = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawFour = vector<Point2D>();







		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentreX,
			pCentreY,
			pPointArrayToDraw);

		cout << "Saving Data About our Segments " << endl;

		vector<Line2D> pLineArray = vector<Line2D>();
		float pPermimeterValue = 0.0f;
		for (UINT pIndex = 0; pIndex <= pPointArrayToDraw.size() - 2; pIndex++)
		{
			Point2D pPointOneObject = pPointArrayToDraw[pIndex];
			Point2D pPointTwoObject = pPointArrayToDraw[pIndex + 1];

			float pLineMagnitude = 0.0f;
			pLineMagnitude = ComputeLineLengthBetweenPoint(pPointOneObject, pPointTwoObject);
			Line2D pNewLineValue;
			pNewLineValue.pLineNumber = pIndex;
			pNewLineValue.pPointOne = pPointOneObject;
			pNewLineValue.pPointTwo = pPointTwoObject;
			pNewLineValue.pLineWidth = pLineMagnitude;
			pLineArray.push_back(pNewLineValue);
			pPermimeterValue = pPermimeterValue + pNewLineValue.pLineWidth;
		}

		Line2D pLastLineValue;
		pLastLineValue.pLineNumber = pIndex + 1;
		Point2D pPointOneObject = pPointArrayToDraw[pPointArrayToDraw.size() - 1];
		Point2D pPointTwoObject = pPointArrayToDraw[0];
		pLastLineValue.pPointOne = pPointOneObject;
		pLastLineValue.pPointTwo = pPointTwoObject;
		float pLineMagnitude = 0.0f;
		pLineMagnitude = ComputeLineLengthBetweenPoint(pPointOneObject, pPointTwoObject);

		pLastLineValue.pLineWidth = pLineMagnitude;
		pLineArray.push_back(pLastLineValue);
		pPermimeterValue = pPermimeterValue + pLastLineValue.pLineWidth;


		cout << "Printing Out Line Segments: " << endl;
		imageSegmentationDataFile << "Printing Out Line Segments: " << endl;

		for (Line2D pLineObject : pLineArray)
		{
			cout << "Line Number: " << pLineObject.pLineNumber << endl;
			cout << "Point One: " << endl;;
			cout << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			cout << "Point Two: " << endl;;
			cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

			imageSegmentationDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
			imageSegmentationDataFile << "Point One: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			imageSegmentationDataFile << "Point Two: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			imageSegmentationDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;


		}

		cout << "The Perimeter of the Shape: " << pPermimeterValue << endl;
		imageSegmentationDataFile << "The Perimeter of the Shape: " << pPermimeterValue << endl;





		cout << "Now we will Compute the area of Our Polygon " << endl;

		float pAreaValue = 0.0f;
		pAreaValue = ComputePolygonAreaUsingShoelaceFormula(pPointArrayToDraw, pPointArrayToDraw.size());
		cout << "Polygon Area = " << pAreaValue << endl;
		imageSegmentationDataFile << "Polygon Area = " << pAreaValue << endl;


		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
		endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile.close();
		imageSectorsData.close();

		return hr;

	}
	

	


HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicUsingAPI(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;

	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pImageWidth = 0.0f;
	float pImageHeight = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	float pYSortingConstant0 = pStepY;
	float pYSortingConstant1 = pStepY * 2;
	float pYSortingConstant2 = pStepY * 3;

	float pXSortingConstant0 = pStepX;
	float pXSortingConstant1 = pStepX * 2;
	float pXSortingConstant2 = pStepX * 3;


	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputPixelObjectFiltered = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputPixelObjectRestored = vector<PixelObject>();
	vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pCommonArrayWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFourData = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPointArrayVector = vector<Point2D>();
	vector<Point2D> pLineArrayVector = vector<Point2D>();






	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamicAPI.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();




	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
		}

		cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

		}
		float pCentreX = 0.0f;
		float pCentreY = 0.0f;
		float pYDelta = 0.0f;

		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();


		imageSegmentationDataFile << "Your Centre Point Is: " << endl;
		imageSegmentationDataFile << "X Position: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Position: " << pCentreY << endl;





		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());


		vector<OutputPixelObjectFiltered> pFilterContainerObject = vector <OutputPixelObjectFiltered>();
		vector<PixelObject> pFilterContainerObjectRestored = vector <PixelObject>();
		vector<PixelObject> pPixelObjectSectored = vector<PixelObject>();
		vector<OutputPixelObjectWithAngleValues> pCommonArrayOutput = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorOneVector = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorTwoVector = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorThreeVector = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorFourVector = vector<OutputPixelObjectWithAngleValues>();
		vector<Point2D> pPointArrayVector = vector<Point2D>();
		vector<Line2D> pLineArrayVector = vector<Line2D>();
		float pPerimeterValue = 0.0f;
		float pAreaValue = 0.0f;


		hr = DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicWithPreprocessedPixels(hInstance,
			hWnd,
			pTopLeftX, pTopLeftY, pImageWidth,
			pImageHeight, pStepX,
			pStepY, pRedValueToSelect, pGreenValueToSelect,
			pBlueValueToSelect, pixelObjectVectorOne,
			&pFilterContainerObject,
			&pFilterContainerObjectRestored,
			&pPixelObjectSectored,
			&pCommonArrayOutput,
			&pSectorOneVector,
			&pSectorTwoVector,
			&pSectorThreeVector,
			&pSectorFourVector,
			&pPointArrayVector,
			&pLineArrayVector,
			&pPerimeterValue,
			&pAreaValue);

		cout << "Prinitng Image Parameters" << endl;
		imageSegmentationDataFile << "Prinitng Image Parameters" << endl;


		cout << "X0 = " << pTopLeftX << endl;
		cout << "Y0 = " << pTopLeftY << endl;
		cout << "Image Width = " << pImageWidth << endl;
		cout << "Image Height = " << pImageWidth << endl;
		cout << "Step for X Axis = " << pStepX << endl;
		cout << "Step for Y Axis = " << pStepY << endl;
		cout << "Red Color Value: " << pRedValueToSelect << endl;
		cout << "Green Color Value: " << pGreenValueToSelect << endl;
		cout << "Blue Color Value: " << pGreenValueToSelect << endl;


		imageSegmentationDataFile << "X0 = " << pTopLeftX << endl;
		imageSegmentationDataFile << "Y0 = " << pTopLeftY << endl;
		imageSegmentationDataFile << "Image Width = " << pImageWidth << endl;
		imageSegmentationDataFile << "Image Height = " << pImageWidth << endl;
		imageSegmentationDataFile << "Step for X Axis = " << pStepX << endl;
		imageSegmentationDataFile << "Step for Y Axis = " << pStepY << endl;
		imageSegmentationDataFile << "Red Color Value: " << pRedValueToSelect << endl;
		imageSegmentationDataFile << "Green Color Value: " << pGreenValueToSelect << endl;
		imageSegmentationDataFile << "Blue Color Value: " << pGreenValueToSelect << endl;


		cout << "RGB Filter Output Value" << endl;
		imageSegmentationDataFile << "RGB Filter Output Value" << endl;


		for (PixelObject pixelObject : pFilterContainerObjectRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}


		cout << "Result of Averaging" << endl;
		imageSegmentationDataFile << "Result of Averaging" << endl;


		for (PixelObject pixelObject : pPixelObjectSectored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}



		cout << "Printing Sector Clusters Data " << endl;
		imageSegmentationDataFile << "Printing Sector Clusters Data " << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonArrayOutput)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



		}

		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorOneVector)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorTwoVector)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






		}
		imageSegmentationDataFile << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorThreeVector)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorFourVector)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		cout << "Printing Out Line Segments: " << endl;
		imageSegmentationDataFile << "Printing Out Line Segments: " << endl;

		for (Line2D pLineObject : pLineArrayVector)
		{
			cout << "Line Number: " << pLineObject.pLineNumber << endl;
			cout << "Point One: " << endl;;
			cout << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			cout << "Point Two: " << endl;;
			cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

			imageSegmentationDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
			imageSegmentationDataFile << "Point One: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			imageSegmentationDataFile << "Point Two: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			imageSegmentationDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;


		}

		cout << "The Perimeter of the Shape: " << pPerimeterValue << endl;
		imageSegmentationDataFile << "The Perimeter of the Shape: " << pPerimeterValue << endl;

		cout << "The Area of the Shape: " << pAreaValue << endl;
		imageSegmentationDataFile << "The Area of the Shape: " << pAreaValue << endl;


		



		imageSegmentationDataFile.close();

	}
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::PerformSpatialShapeAnalysisForMultipleStepsOption(HINSTANCE hInstance,
	HWND hWnd)
{
	HRESULT hr = S_OK;

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;

	float pTopLeftX = 0;
	float pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pImageWidth = 0.0f;
	float pImageHeight = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	vector<float> pStepXValues = vector<float>();
	vector<float> pStepYValues = vector<float>();

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamicAPIMultipleClipping.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;


	cout << "X Position Top: " << pTopLeftX << endl;
	cout << "Y Position Top: " << pTopLeftY << endl;
	cout << "Image Width: " << pImageWidth << endl;
	cout << "Image Height: " << pImageHeight << endl;




	
//	pStepXValues.push_back(25.0f);
//	pStepXValues.push_back(50.0f);
//	pStepXValues.push_back(100.0f);
	pStepXValues.push_back(200.0f);

//	pStepYValues.push_back(25.0f);
//	pStepYValues.push_back(50.0f);
//	pStepYValues.push_back(100.0f);
	pStepYValues.push_back(200.0f);
	
	vector<ModelObject> pModelVectorObject = vector<ModelObject>();


	cout << "Generating a set of Modellics Parameters for Spatial Shape Analysis" << endl;

	for (int pStepIndex = 0; pStepIndex < pStepXValues.size(); ++pStepIndex)
	{
		ModelObject pModelObject = ModelObject(pStepIndex, pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pStepXValues[pStepIndex],
			pStepYValues[pStepIndex],
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect);

		pModelVectorObject.push_back(pModelObject);
	}

	cout << "Executing A Set Of Models for the Spatial Shape Analysis" << endl;
	for each (ModelObject var in pModelVectorObject)
	{
		ModelObject pModelObject = ModelObject(var.pModelId, var.pTopLeftX, var.pTopLeftY, var.pImageWidth, var.pImageWidth, var.pStepValueX,
			var.pStepValueY, var.pRedValue, var.pGreenValue, var.pBlueValue);




		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;
		vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
		pixelObjectVectorOne.clear();
		pixelObjectVectorTwo.clear();


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, var.pTopLeftX, var.pTopLeftY, var.pImageWidth, var.pImageHeight, 1, var.pStepValueY, &pixelObjectVectorOne);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}




		cout << "Clipping for X Position" << endl;
		pixelDataFile << "Clipping for X Position" << endl;




		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, var.pTopLeftX, var.pTopLeftY, var.pImageWidth, var.pImageHeight, var.pStepValueX, 1, &pixelObjectVectorTwo);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());

		pModelObject.SetPixelArrayXScan(pixelObjectVectorOne);
		pModelObject.SetPixelArrayYScan(pixelObjectVectorTwo);
		
		pModelVectorObject.push_back(pModelObject);

	

	}

	vector<ModelObject> pOutputVector = vector<ModelObject>();

	for (ModelObject pModelItem : pModelVectorObject)
	{
		ModelObject pOutputItem = ModelObject(pModelItem.pModelId,
			pModelItem.pTopLeftX,
			pModelItem.pTopLeftY,
			pModelItem.pImageWidth,
			pModelItem.pImageHeight,
			pModelItem.pStepValueX,
			pModelItem.pStepValueY,
			pModelItem.pRedValue,
			pModelItem.pGreenValue,
			pModelItem.pBlueValue);

		hr = ExecuteSpatialShapeObjectOnSelectedImageForAModelObject(hInstance,
			hWnd,
			pModelItem,
			&pOutputItem);
		pOutputVector.push_back(pOutputItem);
	}


	

	for (ModelObject pModelObjectVar : pOutputVector)
	{


		vector<PixelObject> pRestorationBlock = vector<PixelObject>();
		vector<PixelObject> pAveragingBlock = vector<PixelObject>();
		vector<OutputPixelObjectWithAngleValues> pTrigonometryBlock = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorOneBlock = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorTwoBlock = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorThreeBlock = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pSectorFourBlock = vector<OutputPixelObjectWithAngleValues>();
		vector<Point2D> pPointVector = vector<Point2D>();
		vector<Line2D> pLineVector = vector<Line2D>();


		pRestorationBlock = pModelObjectVar.GetRestoredPixelArray();
		pAveragingBlock = pModelObjectVar.GetSectorAverageArrays();
		pTrigonometryBlock = pModelObjectVar.GetLocalizedPixelArray();
		pSectorOneBlock = pModelObjectVar.GetSectorOneVector();
		pSectorTwoBlock = pModelObjectVar.GetSectorTwoVector();
		pSectorThreeBlock = pModelObjectVar.GetSectorThreeVector();
		pSectorFourBlock = pModelObjectVar.GetSectorFourVector();
		pPointVector = pModelObjectVar.GetPointArrayData();
		pLineVector = pModelObjectVar.GetLineArrayData();

		cout << "Initial Data Block: " << endl;
		cout << "Model Id: " << pModelObjectVar.pModelId << endl;
		cout << "Top Left X = " << pModelObjectVar.pTopLeftX << endl;
		cout << "Top Left y = " << pModelObjectVar.pTopLeftY << endl;
		cout << "Image Width = " << pModelObjectVar.pImageWidth << endl;
		cout << "Image Height = " << pModelObjectVar.pImageHeight << endl;
		cout << "Step X = " << pModelObjectVar.pStepValueX << endl;
		cout << "Step Y = " << pModelObjectVar.pStepValueY << endl;
		
		pixelDataFile << "Initial Data Block: " << endl;
		pixelDataFile << "Model Id: " << pModelObjectVar.pModelId << endl;
		pixelDataFile << "Top Left X = " << pModelObjectVar.pTopLeftX << endl;
		pixelDataFile << "Top Left y = " << pModelObjectVar.pTopLeftY << endl;
		pixelDataFile << "Image Width = " << pModelObjectVar.pImageWidth << endl;
		pixelDataFile << "Image Height = " << pModelObjectVar.pImageHeight << endl;
		pixelDataFile << "Step X = " << pModelObjectVar.pStepValueX << endl;
		pixelDataFile << "Step Y = " << pModelObjectVar.pStepValueY << endl;

		vector<PixelObject> pXPositionScan = vector<PixelObject>();
		vector<PixelObject> pYPositionScan = vector<PixelObject>();
		vector<PixelObject> pRestoredFilterOutput = vector<PixelObject>();


		cout << "RGB X Block" << endl;
		pixelDataFile << "RGB X Block" << endl;



		
		pXPositionScan = pModelObjectVar.GetPixelArrayXScal();
		for (PixelObject pixelObject : pXPositionScan)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "Size of X Block = " << pXPositionScan.size() << endl;
		pixelDataFile << "Size of X Block = " << pXPositionScan.size() << endl;

		cout << "RGB X Block End" << endl;
		pixelDataFile << "RGB X Block End" << endl;


		cout << "RGB Y Block" << endl;
		pixelDataFile << "RGB Y Block" << endl;




		pXPositionScan = pModelObjectVar.GetPixelArrayYScan();
		for (PixelObject pixelObject : pYPositionScan)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "Size of Y Block = " << pYPositionScan.size() << endl;
		pixelDataFile << "Size of Y Block = " << pYPositionScan.size() << endl;


		cout << "RGB Y Block End" << endl;
		pixelDataFile << "RGB Y Block End" << endl;

		cout << "Filter Restoration Block" << endl;
		pixelDataFile << "Filter Restoration Block" << endl;

		
		int pRestorationArraySize = pModelObjectVar.GetRestoredPixelArraySize();
		for (PixelObject pixelObject : pRestorationBlock)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}
		
		cout << "Size of Restoration Block = " << pRestorationBlock.size() << endl;
		pixelDataFile << "Size of Restoration Block = " << pRestorationBlock.size() << endl;

		cout << "Restoration Block End" << endl;
		pixelDataFile << "Restoration block End " << endl;


		cout << "Averaging Block" << endl;
		pixelDataFile << "Averaging Block" << endl;


		int pAveragingBlockArraySize = pModelObjectVar.GetSectorAverageArraySize();
		for (PixelObject pixelObject : pAveragingBlock)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "Size of Averaging Block = " << pAveragingBlockArraySize << endl;
		pixelDataFile << "Size of Averaginf Block = " << pAveragingBlockArraySize << endl;

		cout << "Averaging Block End" << endl;
		pixelDataFile << "Averaging block End " << endl;

		cout << "Trigonometry Block" << endl;
		pixelDataFile << "Trigonometry Block" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pTrigonometryBlock)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



		}

		cout << "Printing Sector One" << endl;
		pixelDataFile << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorOneBlock)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		pixelDataFile << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		pixelDataFile << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorTwoBlock)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






		}
		pixelDataFile << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		pixelDataFile << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorThreeBlock)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		pixelDataFile << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		pixelDataFile << "Printing Sector four" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pSectorFourBlock)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		pixelDataFile << "Sector End" << endl;

		cout << "Prinitng Out Point Vector" << endl;
		pixelDataFile << "Prinitng Out Point Vector: " << endl;


		for (Point2D pPointVar : pPointVector)
		{
			cout << "Point Number: " << pPointVar.pPointNumber << endl;
			cout << "X Position: " << pPointVar.xPosition << endl;
			cout << "Y Position: " << pPointVar.yPosition << endl;
			cout << "Point Section: " << pPointVar.pSectorNumber << endl;

			pixelDataFile << "Point Number: " << pPointVar.pPointNumber << endl;
			pixelDataFile << "X Position: " << pPointVar.xPosition << endl;
			pixelDataFile << "Y Position: " << pPointVar.yPosition << endl;
			pixelDataFile << "Point Section: " << pPointVar.pSectorNumber << endl;


		}


		cout << "Printing Out Line Segments: " << endl;
		pixelDataFile << "Printing Out Line Segments: " << endl;


		for (Line2D pLineObject : pLineVector)
		{
			cout << "Line Number: " << pLineObject.pLineNumber << endl;
			cout << "Point One: " << endl;;
			cout << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			cout << "Point Two: " << endl;;
			cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

			pixelDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
			pixelDataFile << "Point One: " << endl;;
			pixelDataFile << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			pixelDataFile << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			pixelDataFile << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			pixelDataFile << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			pixelDataFile << "Point Two: " << endl;;
			pixelDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			pixelDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			pixelDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			pixelDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			pixelDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;


		}

		float pPerimeterValue = pModelObjectVar.GetPerimeterValue();
		float pAreaValue = pModelObjectVar.GetAreaValue();

		cout << "The Perimeter of the Shape: " << pPerimeterValue << endl;
		pixelDataFile << "The Perimeter of the Shape: " << pPerimeterValue << endl;

		cout << "The Area of the Shape: " << pAreaValue << endl;
		pixelDataFile << "The Area of the Shape: " << pAreaValue << endl;
		
		pixelDataFile << "Experiment end" << endl;



	}



	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ExecuteSpatialShapeObjectOnSelectedImageForAModelObject(HINSTANCE hInstance, HWND hWnd,
	ModelObject pModelObject, ModelObject* pModelOutput)
{
	HRESULT hr = S_OK;
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamicWithPreprossessingModelObject.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "Executing A New Spatial Shape Experimet" << endl;
	imageSegmentationDataFile << "Executing A New Spatial Shape Experimet" << endl;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	cout << "First We Will Filter Our Image for the Color Components" << endl;

	vector<PixelObject> pPixelArryaToProcess = vector<PixelObject>();
	pPixelArryaToProcess = pModelObject.GetCommonArrayForProcessing();

	

	vector<OutputPixelObjectFiltered> pOutputPixelObjectFiltered = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputPixelObjectRestored = vector<PixelObject>();
	vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
	vector<PixelObject> pAveragingVector = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pCommonArrayWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFourData = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPoint2DVector = vector<Point2D>();
	vector<Line2D> pLine2DVector = vector<Line2D>();

	pOutputPixelObjectFiltered.clear();
	pOutputPixelObjectRestored.clear();
	pCommonPixelObjectArrayOneRGB.clear();
	pCommonArrayWithAngleValues.clear();
	pSectorOneData.clear();
	pCommonArrayWithAngleValues.clear();
	pSectorOneData.clear();
	pSectorTwoData.clear();
	pSectorThreeData.clear();
	pSectorFourData.clear();


	float pPermeterValue = 0.0f;
	float pAreaValue = 0.0f;


	hr = DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicWithPreprocessedPixels(hInstance,
		hWnd, pModelObject.pTopLeftX,
		pModelObject.pTopLeftY,
		pModelObject.pImageWidth,
		pModelObject.pImageHeight,
		pModelObject.pStepValueX,
		pModelObject.pStepValueY,
		pModelObject.pRedValue,
		pModelObject.pGreenValue,
		pModelObject.pBlueValue,
		pPixelArryaToProcess,
		&pOutputPixelObjectFiltered,
		&pOutputPixelObjectRestored,
		&pAveragingVector,
		&pCommonArrayWithAngleValues,
		&pSectorOneData,
		&pSectorTwoData,
		&pSectorThreeData,
		&pSectorFourData,
		&pPoint2DVector,
		&pLine2DVector,
		&pPermeterValue,
		&pAreaValue);
	
	pModelObject.SetFilteredArrayObject(pOutputPixelObjectFiltered);
	pModelObject.SetRestoredPixelArray(pOutputPixelObjectRestored);
	pModelObject.SetSectorAverageArrays(pAveragingVector);
	pModelObject.SetLocalizedPixelArray(pCommonArrayWithAngleValues);
	pModelObject.SetSectorOneVector(pSectorOneData);
	pModelObject.SetSectorTwoVector(pSectorTwoData);
	pModelObject.SetSectorThreeVector(pSectorThreeData);
	pModelObject.SetSectorFourVector(pSectorFourData);
	pModelObject.SetGeneratedPointVector(pPoint2DVector);
	pModelObject.SetGeneratedLineVector(pLine2DVector);
	pModelObject.SetPerimeterValue(pPermeterValue);
	pModelObject.SetAreaValue(pAreaValue);


	*pModelOutput = pModelObject;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicWithPreprocessedPixels(HINSTANCE hInstance, HWND hWnd,
	float pTopLeftX, float pTopLeftY,
	float pImageWidth, float pImageHeight,
	float pStepXValue, float pStepYValue,
	float pRedValueToSelect, float pGreenValueToSelect,
	float pBlueValueToSelect,
	vector<PixelObject> pPixelArrayToProcess,
	vector<OutputPixelObjectFiltered> *ppOutputFilterOperationData,
	vector<PixelObject> *ppOutputFilterOperationDataRestored,
	vector<PixelObject> *ppPixelObjectSectored,
	vector<OutputPixelObjectWithAngleValues> *ppCommonPixelArrayObject,
	vector<OutputPixelObjectWithAngleValues> *ppSectorOneVector,
	vector<OutputPixelObjectWithAngleValues> *ppSectorTwoVector,
	vector<OutputPixelObjectWithAngleValues> *ppSectorThreeVector,
	vector<OutputPixelObjectWithAngleValues> *ppSectorFourVector, 
	vector<Point2D> *ppPoinstArray,
	vector<Line2D> *ppLineArray,
	float* ppPeriemerValue, float* ppAreaValue)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	float pYDelta = 0.0f;
	float pStepX = 0.0f;
	float pStepY = 0.0f;
	vector<float> pXValuesArray = vector<float>();
	vector<float> pYValuesArray = vector<float>();
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamicWithPreprossessing.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();

	vector<OutputPixelObjectFiltered> pOutputPixelObjectFiltered = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputPixelObjectRestored = vector<PixelObject>();
	vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pCommonArrayWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeData = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFourData = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPointArrayVector = vector<Point2D>();
	vector<Point2D> pLineArrayVector = vector<Point2D>();
	float pPermimeterValue = 0.0f;
	float pCentreX = 0.0f;
	float pCentreY = 0.0f;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;

	
	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
		hWnd,
		pTopLeftX,
		pTopLeftY,
		pImageWidth,
		pImageHeight,
		pRedValueToSelect,
		pRedValueToSelect,
		pGreenValueToSelect,
		pGreenValueToSelect,
		pBlueValueToSelect,
		pBlueValueToSelect,
		pPixelArrayToProcess,
		&pOutputPixelObjectFiltered);

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);
	cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
		filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
		filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
		filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
		filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

	imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
			endl;
		imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
			pLastError << endl;
		imageSegmentationDataFile.close();
		return hr;
	}
	stop = high_resolution_clock::now();
	// Get duration. Substart timepoints to
	// get durarion. To cast it to proper unit
	// use duration cast method
	duration = duration_cast<microseconds>(stop - start);
	cout << "Time taken by RGB Filter: "
		<< duration.count() / 1000000 << "seconds" << endl;
	cout << "Time taken by RGB Filter: "
		<< duration.count() / 1000000 << " seconds" << endl;
	cout << " " << endl;
	cout << " " << endl;
	cout << "New Operation Begin" << endl;
	UINT pOperationNumber = 0;
	cout << "Printing Output" << endl;
	cout << "Printing Output" << endl;
	UINT pIndexValue = 0;


	vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	start = high_resolution_clock::now();

	SYSTEMTIME restorationStartSystem;
	SYSTEMTIME restorationStartLocal;

	GetSystemTime(&restorationStartSystem);
	GetLocalTime(&restorationStartLocal);
	cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
		restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
	cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
		restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
		restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
	imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
		restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
		hWnd,
		pOutputPixelObjectFiltered,
		&pOutputPixelObjectRestored);
	cout << "Printing the Results of the Valid Pixels" << endl;


	SYSTEMTIME restorationEndSystem;
	SYSTEMTIME restorationEndLocal;

	GetSystemTime(&restorationEndSystem);
	GetLocalTime(&restorationEndLocal);
	cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
		restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
	cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
		restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
	imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
		restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
	imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
		restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



	for (PixelObject pixelObject : pOutputPixelObjectRestored)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
		pXValuesArray.push_back(pixelObject.xPosition);
		pYValuesArray.push_back(pixelObject.yPosition);
	}





		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;



		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;

		sort(pXValuesArray.begin(), pXValuesArray.end(), WayToSortFloatsAscending);
		sort(pYValuesArray.begin(), pYValuesArray.end(), WayToSortFloatsAscending);

		pCentreX = round((pXValuesArray[pXValuesArray.size() - 1] - pXValuesArray[0]) / 2.0f + pXValuesArray[0]);
		pCentreY = round((pYValuesArray[pYValuesArray.size() - 1] - pYValuesArray[0]) / 2.0f + pYValuesArray[0]);


		cout << "Centre Pixel: " << endl;
		cout << "X Value: " << pCentreX << endl;
		cout << "Y Value" << pCentreY << endl;


		imageSegmentationDataFile << "Centre Pixel: " << endl;
		imageSegmentationDataFile << "X Value: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Value" << pCentreY << endl;


		int pPixelCounter = 0;
		vector<PixelObject> pSectorAObject = vector<PixelObject>();
		vector<PixelObject> pSectorBObject = vector<PixelObject>();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For X Axis Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For X Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		for (float pYValue = 0; pYValue < pImageHeight; pYValue += pStepYValue)
		{
			if (pYValue > 0)
			{
				pSectorAObject.clear();
				pSectorBObject.clear();

				hr = ComputeAverageXForPixelArrayOnAGPU(hInstance, hWnd, pYValue, pCentreX, 1, 2, -1,
					pOutputPixelObjectRestored,
					&pSectorAObject,
					&pSectorBObject,
					&pXPositionAverageWhole0,
					&pXPositionAverageWhole1);

				cout << "Printing Sector First Part" << endl;
				imageSegmentationDataFile << "Priniting Sector First Part" << endl;

				for (PixelObject pixelObject : pSectorAObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}

				cout << "Printing Sector Second Part" << endl;
				imageSegmentationDataFile << "Priniting Sector Second Part" << endl;

				for (PixelObject pixelObject : pSectorBObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}



				if ((pXPositionAverageWhole0 > 0) && (pXPositionAverageWhole1 > 0))
				{
					PixelObject pNewPixelValue0 = GetPixelByXAndYPosition(pPixelArrayToProcess, pXPositionAverageWhole0, pYValue);
					pPixelCounter = pPixelCounter + 1;
					PixelObject pNewPixelValue1 = GetPixelByXAndYPosition(pPixelArrayToProcess, pXPositionAverageWhole1, pYValue);
					if ((pNewPixelValue0.pixelNumber != 0) && (pNewPixelValue1.pixelNumber != 0))
					{
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue0);
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue1);
					}

					pPixelCounter++;

				}

			}

		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "Sectoring For X Axis End System Time\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << "Sectoring For X Axis Started System Local\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For X Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For X Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		pPixelCounter = 0;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For Y Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For Y Axis Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For Y Axis Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For Y Axis Started System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		for (float pXValue = 0; pXValue < pImageWidth; pXValue += pStepXValue)
		{
			if (pXValue > 0)
			{
				if (pXValue == 600.0f)
				{
					pYDelta = 200.0f;
				}
				else
				{
					pYDelta = pCentreY;
				}


				hr = ComputeAverageYForPixelArrayOnAGPU(hInstance, hWnd, pXValue, pYDelta, 1, 2, -1,
					pOutputPixelObjectRestored,
					&pSectorAObject,
					&pSectorBObject,
					&pYPositionAverageWhole0,
					&pYPositionAverageWhole1);


				cout << "Printing Sector First Part" << endl;
				imageSegmentationDataFile << "Printing Sector First Part" << endl;

				for (PixelObject pixelObject : pSectorAObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}

				cout << "Printing Sector Second Part" << endl;
				imageSegmentationDataFile << "Printing Sector Second Part" << endl;

				for (PixelObject pixelObject : pSectorBObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}

				}


				if ((pYPositionAverageWhole0 > 0) && (pYPositionAverageWhole1 > 0))
				{
					PixelObject pNewPixelValue0 = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
					PixelObject pNewPixelValue1 = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);


					pNewPixelValue0 = GetPixelByXAndYPosition(pPixelArrayToProcess, pXValue, pYPositionAverageWhole0);
					pPixelCounter = pPixelCounter + 1;
					pNewPixelValue1 = GetPixelByXAndYPosition(pPixelArrayToProcess, pXValue, pYPositionAverageWhole1);
					pPixelCounter = pPixelCounter + 1;
					if ((pNewPixelValue0.pixelNumber != 0) && (pNewPixelValue1.pixelNumber != 0))
					{
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue0);
						pCommonPixelObjectArrayOneRGB.push_back(pNewPixelValue1);
					}
				}
			}
		}


		pPixelCounter = 0;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Sectoring For Y Axis End System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << "Sectoring For Y Axis End  System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Sectoring For Y Axis End  System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Sectoring For Y Axis End  System Loca\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;

		GetSystemTime(&computeDeltaStartSystem);
		GetLocalTime(&computeDeltaStartLocal);
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentreX, pCentreY,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);



		SYSTEMTIME computeDeltaEndSystem;
		SYSTEMTIME computeDeltaEndLocal;

		GetSystemTime(&computeDeltaEndSystem);
		GetLocalTime(&computeDeltaEndLocal);
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);
		vector<OutputPixelObjectWithAngleValues> pInvalidSectors = vector<OutputPixelObjectWithAngleValues>();
		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}






		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;
		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);


		//	std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesYDescending);
		//	std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesYAscending);
		//	std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesYAscending);
		//	std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesYDescending);



		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();



		vector<Point2D> pPointArrayToDraw = vector<Point2D>();

		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorOne)
		{

			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorTwo)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorThree)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorFour)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}





		vector<Point2D> pPointArrayToDrawOne = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawTwo = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawThree = vector<Point2D>();
		vector<Point2D> pPointArrayToDrawFour = vector<Point2D>();







		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLinesSectors(hInstance,
			hWnd,
			pCentreX,
			pCentreY,
			pPointArrayToDraw,
			&pLineArrayValues,
			&pTotalArea);

		cout << "Saving Data About our Segments " << endl;
		UINT pIndex = 0;
		vector<Line2D> pLineArray = vector<Line2D>();
		float pPerimeterValue = 0.0f;
		for ( pIndex = 0; pIndex <= pPointArrayToDraw.size() - 2; pIndex++)
		{
			Point2D pPointOneObject = pPointArrayToDraw[pIndex];
			Point2D pPointTwoObject = pPointArrayToDraw[pIndex + 1];

			float pLineMagnitude = 0.0f;
			pLineMagnitude = ComputeLineLengthBetweenPoint(pPointOneObject, pPointTwoObject);
			Line2D pNewLineValue;
			pNewLineValue.pLineNumber = pIndex;
			pNewLineValue.pPointOne = pPointOneObject;
			pNewLineValue.pPointTwo = pPointTwoObject;
			pNewLineValue.pLineWidth = pLineMagnitude;
			pLineArray.push_back(pNewLineValue);
			pPermimeterValue = pPermimeterValue + pNewLineValue.pLineWidth;
		}

		Line2D pLastLineValue;
		pLastLineValue.pLineNumber = pIndex + 1;
		Point2D pPointOneObject = pPointArrayToDraw[pPointArrayToDraw.size() - 1];
		Point2D pPointTwoObject = pPointArrayToDraw[0];
		pLastLineValue.pPointOne = pPointOneObject;
		pLastLineValue.pPointTwo = pPointTwoObject;
		float pLineMagnitude = 0.0f;
		pLineMagnitude = ComputeLineLengthBetweenPoint(pPointOneObject, pPointTwoObject);

		pLastLineValue.pLineWidth = pLineMagnitude;
		pLineArray.push_back(pLastLineValue);
		pPermimeterValue = pPermimeterValue + pLastLineValue.pLineWidth;


		cout << "Printing Out Line Segments: " << endl;
		imageSegmentationDataFile << "Printing Out Line Segments: " << endl;

		for (Line2D pLineObject : pLineArray)
		{
			cout << "Line Number: " << pLineObject.pLineNumber << endl;
			cout << "Point One: " << endl;;
			cout << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			cout << "Point Two: " << endl;;
			cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

			imageSegmentationDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
			imageSegmentationDataFile << "Point One: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointOne.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
			imageSegmentationDataFile << "Point Two: " << endl;;
			imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
			imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
			imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
			imageSegmentationDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;

			pPerimeterValue += pLineObject.pLineWidth;
		}

		cout << "The Perimeter of the Shape: " << pPerimeterValue << endl;
		imageSegmentationDataFile << "The Perimeter of the Shape: " << pPerimeterValue << endl;





		cout << "Now we will Compute the area of Our Polygon " << endl;

		float pAreaValue = 0.0f;
		pAreaValue = ComputePolygonAreaUsingShoelaceFormula(pPointArrayToDraw, pPointArrayToDraw.size());
		cout << "Polygon Area = " << pAreaValue << endl;
		imageSegmentationDataFile << "Polygon Area = " << pAreaValue << endl;


		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;












		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" << endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

		imageSegmentationDataFile.close();
		imageSectorsData.close();

		

		*ppOutputFilterOperationData = pOutputPixelObjectFiltered;
		*ppOutputFilterOperationDataRestored = pOutputPixelObjectRestored;
		*ppPixelObjectSectored = pCommonPixelObjectArrayOneRGB;
		*ppCommonPixelArrayObject = pCommonOutputVectorTrig;
		*ppSectorOneVector = pVectorPointsSectorOne;
		*ppSectorTwoVector = pVectorPointsSectorTwo;
		*ppSectorThreeVector = pVectorPointsSectorThree;
		*ppSectorFourVector = pVectorPointsSectorFour;
		*ppPoinstArray = pPointArrayToDraw;
		*ppLineArray = pLineArray;
		*ppPeriemerValue = pPerimeterValue;
		*ppAreaValue = pAreaValue;
		return hr;
	}
	




float DirectXGPUDigitalLabCoreModule::ComputePolygonAreaUsingShoelaceFormula(vector<Point2D> pPointArray, int pArraySize)
{
	float pAreaValue = 0.0f;
	float pFinalArea = 0.0f;
	int j = pArraySize - 1;
	int n = pArraySize - 1;

	for (int i = 0; i < n; i++)
	{
		pAreaValue += (pPointArray[j].xPosition + pPointArray[i].xPosition) * (pPointArray[j].yPosition - pPointArray[i].yPosition);
		j = i;  // j is previous vertex to i 
	}

	pFinalArea = pAreaValue / 2.0f;
	return pFinalArea;


}





HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterViaPixelSubrtractionIdenticalPixels(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";


	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterViaPixelDataSubtractionIdenticalPixels.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();


	float pStepX = 0.0f;
	float pStepY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();


	float pCentreX = 430.0;
	float pCentreY = 410.0f;

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;




	vector<PixelObject> pSectorOne = vector<PixelObject>();
	vector<PixelObject> pSectorTwo = vector<PixelObject>();
	vector<PixelObject> pSectorThree = vector<PixelObject>();
	vector<PixelObject> pSectorFour = vector<PixelObject>();
	vector<PixelObject> pSectorFive = vector<PixelObject>();
	vector<PixelObject> pSectorSix = vector<PixelObject>();
	vector<PixelObject> pSectorSeven = vector<PixelObject>();
	vector<PixelObject> pSectorEight = vector<PixelObject>();
	vector<PixelObject> pSectorNine = vector<PixelObject>();
	vector<PixelObject> pSectorTen = vector<PixelObject>();
	vector<PixelObject> pSectorEleven = vector<PixelObject>();
	vector<PixelObject> pSectorTwelve = vector<PixelObject>();




	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());


		vector<OutputPixelBufferRGB> pOutputDataBuffer = vector<OutputPixelBufferRGB>();
		vector<PixelObject> pIdenticalDataBuffer = vector<PixelObject>();
		vector<PixelObject> pDifferentDataBuffer = vector<PixelObject>();


		vector<float> pXArrayObject = vector<float>();
		vector<float> pYArrayObject = vector<float>();





		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();






		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImageIdentical(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVectorOne,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			&pAmountOfIdenticalPixels,
			&pAmountOfDifferentPixels,
			&pOutputDataBuffer,
			&pIdenticalDataBuffer,
			&pDifferentDataBuffer,
			&pImageOneIntensitySumRedVar,
			&pImageOneIntensitySumGreenVar,
			&pImageOneIntensitySumBlueVar,
			&pOutputArrayIntensitySumRedVar,
			&pOutputArrayIntensitySumGreenVar,
			&pOutputArrayIntensitySumBlueVar,
			&pIdenticalArrayIntensitySumRedVar,
			&pIdenticalArrayIntensitySumGreenVar,
			&pIdenticalArrayIntensitySumBlueVar,
			&pDifferentArrayIntensitySumRedVar,
			&pDifferentArrayIntensitySumGreenVar,
			&pDifferentArrayIntensitySumBlueVar,
			&pImageOneIntensityAverageRedVar,
			&pImageOneIntensityAverageGreenVar,
			&pImageOneIntensityAverageBlueVar,
			&pOutputArrayIntensityAverageRedVar,
			&pOutputArrayIntensityAverageGreenVar,
			&pOutputArrayIntensityAverageBlueVar,
			&pIdenticalArrayIntensityAverageRedVar,
			&pIdenticalArrayIntensityAverageGreenVar,
			&pIdenticalArrayIntensityAverageBlueVar,
			&pDifferentArrayIntensityAverageRedVar,
			&pDifferentArrayIntensityAverageGreenVar,
			&pDifferentArrayIntensityAverageBlueVar,
			&pAreImagesIdentical);


		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		pIndex = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();

		float pColorSum = 0.0f;
		for (OutputPixelBufferRGB pOutputPixelValue : pOutputDataBuffer)
		{


			if ((pOutputPixelValue.pOutputComparisonValueRed != 255.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 255.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 255.0f))
			{

				cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




				imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
			}



			pIndex++;
		}






		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreZeroRGBPixelsFromImageCompation(hInstance, hWnd,
			pOutputDataBuffer, &pOutputImage);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pOutputImage)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}





		

		for (PixelObject pixelObject : pOutputImage)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			



				if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorOne.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorTwo.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorThree.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorFour.push_back(pixelObject);
				}
				if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorFive.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorSix.push_back(pixelObject);
				}

				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorSeven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorEight.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorNine.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorTen.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition <= 200.0f))
				{
					pSectorEleven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition > 200.0f))
				{
					pSectorTwelve.push_back(pixelObject);
				}
			}
		}





		cout << "Printing Sector One Values" << endl;
		imageSegmentationDataFile << "Printing Sector One Values" << endl;
		imageSectorsData << "Printing Sector One Values" << endl;
		vector<float> pXArrayOne = vector<float>();


		for (PixelObject pixelObject : pSectorOne)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;
		}



		cout << "Printing Sector Two Values" << endl;
		imageSegmentationDataFile << "Printing Sector Two Values" << endl;

		for (PixelObject pixelObject : pSectorTwo)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Printing Sector 3 Values" << endl;
		imageSegmentationDataFile << "Printing Sector 3 Values" << endl;

		for (PixelObject pixelObject : pSectorThree)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}




		cout << "Sector Four" << endl;
		imageSegmentationDataFile << "Sector Four" << endl;
		imageSectorsData << "Sector Four" << endl;

		for (PixelObject pixelObject : pSectorFour)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Sector Five" << endl;
		imageSegmentationDataFile << "Sector Five" << endl;
		imageSectorsData << "Sector Five" << endl;

		for (PixelObject pixelObject : pSectorFive)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;





		cout << "Sector Six" << endl;
		imageSegmentationDataFile << "Sector Six" << endl;
		imageSectorsData << "Sector Six" << endl;


		for (PixelObject pixelObject : pSectorSix)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;


		cout << "Sector Seven" << endl;
		imageSegmentationDataFile << "Sector Seven" << endl;
		imageSectorsData << "Sector Seven: " << endl;


		for (PixelObject pixelObject : pSectorSeven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;


		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Eight" << endl;
		imageSegmentationDataFile << "Printing Sector Eight" << endl;
		imageSectorsData << "Sector Eight: " << endl;

		for (PixelObject pixelObject : pSectorEight)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Nine" << endl;
		imageSegmentationDataFile << "Printing Sector Nine" << endl;
		imageSectorsData << "Sector Nine: " << endl;

		for each (PixelObject pixelObject in pSectorNine)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Ten" << endl;
		imageSegmentationDataFile << "Printing Sector Ten" << endl;
		imageSectorsData << "Printing Sector Ten" << endl;


		for each (PixelObject pixelObject in pSectorTen)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Eleven" << endl;
		imageSegmentationDataFile << "Printing Sector Eleven" << endl;
		imageSectorsData << "Printing Sector Eleven" << endl;

		for (PixelObject pixelObject : pSectorEleven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Twelve" << endl;
		imageSegmentationDataFile << "Printing Sector Twelve" << endl;
		imageSectorsData << "Printing Sector Twelve" << endl;


		for (PixelObject pixelObject : pSectorTwelve)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}



		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;


		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;


		cout << "Computing Median X for Sectors 1-6" << endl;
		imageSegmentationDataFile << "Computing Median X for Sectors 1-6" << endl;

		pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
		pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
		pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
		pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
		pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
		pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

		cout << "Computing Median Y for Sectors 7-12" << endl;
		imageSegmentationDataFile << "Computing Median Y for Sectors 7-12" << endl;

		pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
		pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
		pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
		pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
		pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
		pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

		pXPositionAverageWhole0 = round(pXPositionAverage0);
		pXPositionAverageWhole1 = round(pXPositionAverage1);
		pXPositionAverageWhole2 = round(pXPositionAverage2);
		pXPositionAverageWhole3 = round(pXPositionAverage3);
		pXPositionAverageWhole4 = round(pXPositionAverage4);
		pXPositionAverageWhole5 = round(pXPositionAverage5);

		pYPositionAverageWhole0 = round(pYPositionAverage0);
		pYPositionAverageWhole1 = round(pYPositionAverage1);
		pYPositionAverageWhole2 = round(pYPositionAverage2);
		pYPositionAverageWhole3 = round(pYPositionAverage3);
		pYPositionAverageWhole4 = round(pYPositionAverage4);
		pYPositionAverageWhole5 = round(pYPositionAverage5);








		cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;


		imageSegmentationDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		imageSegmentationDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;






		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, 0.0f, 0.0f, 0.0f);


		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);


		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





		vector<Point2D> pPointArrayToDraw = vector<Point2D>();



		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{	

			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}

	

		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointArrayToDraw);




		float pSectorLength12 = 0.0f;
		float pSectorLength23 = 0.0f;
		float pSectorLength34 = 0.0f;
		float pSectorLength45 = 0.0f;
		float pSectorLength56 = 0.0f;
		float pSectorLength67 = 0.0f;
		float pSectorLength78 = 0.0f;
		float pSectorLength89 = 0.0f;
		float pSectorLength910 = 0.0f;
		float pSectorLength1011 = 0.0f;
		float pSectorLength1112 = 0.0f;
		float pSectorLength1201 = 0.0f;

		float pSectorLength1Centre = 0.0f;
		float pSectorLength2Centre = 0.0f;
		float pSectorLength3Centre = 0.0f;
		float pSectorLength4Centre = 0.0f;
		float pSectorLength5Centre = 0.0f;
		float pSectorLength6Centre = 0.0f;
		float pSectorLength7Centre = 0.0f;
		float pSectorLength8Centre = 0.0f;
		float pSectorLength9Centre = 0.0f;
		float pSectorLength10Centre = 0.0f;
		float pSectorLength11Centre = 0.0f;
		float pSectorLength12Centre = 0.0f;


		Point2D pPointOne = pPointArrayToDraw[0];
		Point2D pPointTwo = pPointArrayToDraw[1];
		Point2D pPointThree = pPointArrayToDraw[2];

		Point2D pPointFour = pPointArrayToDraw[3];
		Point2D pPointFive = pPointArrayToDraw[4];
		Point2D pPointSix = pPointArrayToDraw[5];
		Point2D pPointSeven = pPointArrayToDraw[6];
		Point2D pPointEight = pPointArrayToDraw[7];
		Point2D pPointNine = pPointArrayToDraw[8];
		Point2D pPointTen = pPointArrayToDraw[9];
		Point2D pPointEleven = pPointArrayToDraw[10];
		Point2D pPointTwelve = pPointArrayToDraw[11];




		pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
		pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
		pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
		pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
		pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
		pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
		pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
		pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
		pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
		pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
		pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
		pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

		pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
		pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
		pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
		pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
		pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
		pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
		pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
		pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
		pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
		pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
		pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
		pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



		Line2D pLine12;
		pLine12.pLineNumber = 1;
		pLine12.pPointOne = pPointOne;
		pLine12.pPointTwo = pPointTwo;
		pLine12.pLineWidth = pSectorLength12;



		Line2D pLine23;
		pLine23.pLineNumber = 2;
		pLine23.pPointOne = pPointTwo;
		pLine23.pPointTwo = pPointThree;
		pLine23.pLineWidth = pSectorLength23;


		Line2D pLine34;
		pLine34.pLineNumber = 3;
		pLine34.pPointOne = pPointThree;
		pLine34.pPointTwo = pPointFour;
		pLine34.pLineWidth = pSectorLength34;


		Line2D pLine45;
		pLine45.pLineNumber = 4;
		pLine45.pPointOne = pPointFour;
		pLine45.pPointTwo = pPointFive;
		pLine45.pLineWidth = pSectorLength45;


		Line2D pLine56;
		pLine56.pLineNumber = 5;
		pLine56.pPointOne = pPointFive;
		pLine56.pPointTwo = pPointSix;
		pLine56.pLineWidth = pSectorLength56;


		Line2D pLine67;
		pLine67.pLineNumber = 6;
		pLine67.pPointOne = pPointSix;
		pLine67.pPointTwo = pPointSeven;
		pLine67.pLineWidth = pSectorLength67;


		Line2D pLine78;
		pLine78.pLineNumber = 7;
		pLine78.pPointOne = pPointSeven;
		pLine78.pPointTwo = pPointEight;
		pLine78.pLineWidth = pSectorLength78;

		Line2D pLine89;
		pLine89.pLineNumber = 8;
		pLine89.pPointOne = pPointEight;
		pLine89.pPointTwo = pPointNine;
		pLine89.pLineWidth = pSectorLength89;


		Line2D pLine910;
		pLine910.pLineNumber = 9;
		pLine910.pPointOne = pPointNine;
		pLine910.pPointTwo = pPointTen;
		pLine910.pLineWidth = pSectorLength910;


		Line2D pLine1011;
		pLine1011.pLineNumber = 10;
		pLine1011.pPointOne = pPointTen;
		pLine1011.pPointTwo = pPointEleven;
		pLine1011.pLineWidth = pSectorLength1011;


		Line2D pLine1112;
		pLine1112.pLineNumber = 11;
		pLine1112.pPointOne = pPointEleven;
		pLine1112.pPointTwo = pPointTwelve;
		pLine1112.pLineWidth = pSectorLength1112;


		Line2D pLine1201;
		pLine1201.pLineNumber = 12;
		pLine1201.pPointOne = pPointTwelve;
		pLine1201.pPointTwo = pPointOne;
		pLine1201.pLineWidth = pSectorLength1201;

		Line2D pLineOneCentre;
		pLineOneCentre.pLineNumber = 13;
		pLineOneCentre.pPointOne = pPointOne;
		pLineOneCentre.pPointTwo = pCentre;
		pLineOneCentre.pLineWidth = pSectorLength1Centre;

		Line2D pLineTwoCentre;
		pLineTwoCentre.pLineNumber = 15;
		pLineTwoCentre.pPointOne = pPointTwo;
		pLineTwoCentre.pPointTwo = pCentre;
		pLineTwoCentre.pLineWidth = pSectorLength2Centre;

		Line2D pLineThreeCentre;
		pLineThreeCentre.pLineNumber = 16;
		pLineThreeCentre.pPointOne = pPointThree;
		pLineThreeCentre.pPointTwo = pCentre;
		pLineThreeCentre.pLineWidth = pSectorLength3Centre;


		Line2D pLineFourCentre;
		pLineFourCentre.pLineNumber = 16;
		pLineFourCentre.pPointOne = pPointFour;
		pLineFourCentre.pPointTwo = pCentre;
		pLineFourCentre.pLineWidth = pSectorLength4Centre;


		Line2D pLineFiveCentre;
		pLineFiveCentre.pLineNumber = 17;
		pLineFiveCentre.pPointOne = pPointFive;
		pLineFiveCentre.pPointTwo = pCentre;
		pLineFiveCentre.pLineWidth = pSectorLength5Centre;


		Line2D pLineSixCentre;
		pLineSixCentre.pLineNumber = 18;
		pLineSixCentre.pPointOne = pPointSix;
		pLineSixCentre.pPointTwo = pCentre;
		pLineSixCentre.pLineWidth = pSectorLength6Centre;


		Line2D pLineSevenCentre;
		pLineSevenCentre.pLineNumber = 19;
		pLineSevenCentre.pPointOne = pPointSeven;
		pLineSevenCentre.pPointTwo = pCentre;
		pLineSevenCentre.pLineWidth = pSectorLength7Centre;


		Line2D pLineEightCentre;
		pLineEightCentre.pLineNumber = 20;
		pLineEightCentre.pPointOne = pPointEight;
		pLineEightCentre.pPointTwo = pCentre;
		pLineEightCentre.pLineWidth = pSectorLength8Centre;


		Line2D pLineNineCentre;
		pLineNineCentre.pLineNumber = 21;
		pLineNineCentre.pPointOne = pPointNine;
		pLineNineCentre.pPointTwo = pCentre;
		pLineNineCentre.pLineWidth = pSectorLength9Centre;


		Line2D pLineTenCentre;
		pLineTenCentre.pLineNumber = 22;
		pLineTenCentre.pPointOne = pPointTen;
		pLineTenCentre.pPointTwo = pCentre;
		pLineTenCentre.pLineWidth = pSectorLength10Centre;


		Line2D pLineElevenCentre;
		pLineElevenCentre.pLineNumber = 23;
		pLineElevenCentre.pPointOne = pPointEleven;
		pLineElevenCentre.pPointTwo = pCentre;
		pLineElevenCentre.pLineWidth = pSectorLength11Centre;


		Line2D pLineTwelveCentre;
		pLineTwelveCentre.pLineNumber = 24;
		pLineTwelveCentre.pPointOne = pPointTwelve;
		pLineTwelveCentre.pPointTwo = pCentre;
		pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








		float pTriangleOneArea = 0.0f;
		float pTriangleTwoArea = 0.0f;
		float pTriangleThreeArea = 0.0f;
		float pTriangleFourArea = 0.0f;
		float pTriangleFiveArea = 0.0f;
		float pTriangleSixArea = 0.0f;
		float pTriangleSevenArea = 0.0f;
		float pTriangleEightArea = 0.0f;
		float pTriangleNineArea = 0.0f;
		float pTriangleTenArea = 0.0f;
		float pTriangleElevenArea = 0.0f;
		float pTriangleTwelveArea = 0.0f;





		float pTriangleAreaTotal = 0.0f;
		pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
		pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
		pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
		pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
		pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
		pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
		pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
		pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
		pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
		pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
		pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
		pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
		pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

		cout << "Triangle One Area: " << pTriangleOneArea << endl;
		cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
		cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
		cout << "Triangle Four Area: " << pTriangleFourArea << endl;
		cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
		cout << "Triangle Six Area: " << pTriangleSixArea << endl;
		cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
		cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
		cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
		cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

		imageSegmentationDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
		imageSegmentationDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
		imageSegmentationDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
		imageSegmentationDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
		imageSegmentationDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
		imageSegmentationDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
		imageSegmentationDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		imageSegmentationDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
		imageSegmentationDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
		imageSegmentationDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
		imageSegmentationDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		imageSegmentationDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


		cout << "Constructing Triangle Structures" << endl;
		TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
			pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
		TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
			pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
		TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
			pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
		TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
			pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
		TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
			pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
		TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
			pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
		TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
			pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
		TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
			pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
		TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
			pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
		TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
			pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
		TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
			pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
		TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
			pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

		cout << "Storing Our Triangle Data into A Vector" << endl;
		imageSegmentationDataFile << "Storing Our Triangle Data into A Vector" << endl;

		vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
		pTriangleObjectVector.push_back(pTriangleObjectOne);
		pTriangleObjectVector.push_back(pTriangleObjectTwo);
		pTriangleObjectVector.push_back(pTriangleObjectThree);
		pTriangleObjectVector.push_back(pTriangleObjectFour);
		pTriangleObjectVector.push_back(pTriangleObjectFive);
		pTriangleObjectVector.push_back(pTriangleObjectSix);
		pTriangleObjectVector.push_back(pTriangleObjectSeven);
		pTriangleObjectVector.push_back(pTriangleObjectEight);
		pTriangleObjectVector.push_back(pTriangleObjectNine);
		pTriangleObjectVector.push_back(pTriangleObjectTen);
		pTriangleObjectVector.push_back(pTriangleObjectEleven);
		pTriangleObjectVector.push_back(pTriangleObjectTwelve);

		for (TriangleObject pTriangleObject : pTriangleObjectVector)
		{
			cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			cout << "Point A:" << endl;
			cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			cout << "Point B:" << endl;
			cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			cout << "Point C:" << endl;
			cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			cout << "Area = " << pTriangleObject.pTriangleArea << endl;

			imageSegmentationDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			imageSegmentationDataFile << "Point A:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			imageSegmentationDataFile << "Point B:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			imageSegmentationDataFile << "Point C:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			imageSegmentationDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			imageSegmentationDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			imageSegmentationDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
		}




		cout << "Computing Perimeter for the Shape" << endl;
		float pShapePerimeter = 0.0f;
		pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


		cout << "Perimeter Value: " << pShapePerimeter << endl;
		imageSegmentationDataFile << "Perimeter Value: " << pShapePerimeter << endl;






		cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
		imageSegmentationDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}

	imageSegmentationDataFile.close();
	imageSectorsData.close();

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterViaPixelSubrtraction(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";


	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterViaPixelDataSubtractionDifferentParts.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();


	float pStepX = 0.0f;
	float pStepY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();


	float pCentreX = 430.0;
	float pCentreY = 410.0f;

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;




	vector<PixelObject> pSectorOne = vector<PixelObject>();
	vector<PixelObject> pSectorTwo = vector<PixelObject>();
	vector<PixelObject> pSectorThree = vector<PixelObject>();
	vector<PixelObject> pSectorFour = vector<PixelObject>();
	vector<PixelObject> pSectorFive = vector<PixelObject>();
	vector<PixelObject> pSectorSix = vector<PixelObject>();
	vector<PixelObject> pSectorSeven = vector<PixelObject>();
	vector<PixelObject> pSectorEight = vector<PixelObject>();
	vector<PixelObject> pSectorNine = vector<PixelObject>();
	vector<PixelObject> pSectorTen = vector<PixelObject>();
	vector<PixelObject> pSectorEleven = vector<PixelObject>();
	vector<PixelObject> pSectorTwelve = vector<PixelObject>();




	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;




	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());


		vector<OutputPixelBufferRGB> pOutputDataBuffer = vector<OutputPixelBufferRGB>();
		vector<PixelObject> pIdenticalDataBuffer = vector<PixelObject>();
		vector<PixelObject> pDifferentDataBuffer = vector<PixelObject>();



		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();






		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImage(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVectorOne,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			&pAmountOfIdenticalPixels,
			&pAmountOfDifferentPixels,
			&pOutputDataBuffer,
			&pIdenticalDataBuffer,
			&pDifferentDataBuffer,
			&pImageOneIntensitySumRedVar,
			&pImageOneIntensitySumGreenVar,
			&pImageOneIntensitySumBlueVar,
			&pOutputArrayIntensitySumRedVar,
			&pOutputArrayIntensitySumGreenVar,
			&pOutputArrayIntensitySumBlueVar,
			&pIdenticalArrayIntensitySumRedVar,
			&pIdenticalArrayIntensitySumGreenVar,
			&pIdenticalArrayIntensitySumBlueVar,
			&pDifferentArrayIntensitySumRedVar,
			&pDifferentArrayIntensitySumGreenVar,
			&pDifferentArrayIntensitySumBlueVar,
			&pImageOneIntensityAverageRedVar,
			&pImageOneIntensityAverageGreenVar,
			&pImageOneIntensityAverageBlueVar,
			&pOutputArrayIntensityAverageRedVar,
			&pOutputArrayIntensityAverageGreenVar,
			&pOutputArrayIntensityAverageBlueVar,
			&pIdenticalArrayIntensityAverageRedVar,
			&pIdenticalArrayIntensityAverageGreenVar,
			&pIdenticalArrayIntensityAverageBlueVar,
			&pDifferentArrayIntensityAverageRedVar,
			&pDifferentArrayIntensityAverageGreenVar,
			&pDifferentArrayIntensityAverageBlueVar,
			&pAreImagesIdentical);


		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		pIndex = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();

		float pColorSum = 0.0f;
		for (OutputPixelBufferRGB pOutputPixelValue : pOutputDataBuffer)
		{

			
			if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
			{

				cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




				imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
			}

		

			pIndex++;
		}




	
		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompation(hInstance, hWnd,
			pOutputDataBuffer, &pOutputImage);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pOutputImage)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}

		


		for (PixelObject pixelObject : pOutputImage)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



				if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorOne.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorTwo.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorThree.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorFour.push_back(pixelObject);
				}
				if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorFive.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorSix.push_back(pixelObject);
				}

				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorSeven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorEight.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorNine.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorTen.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition <= 200.0f))
				{
					pSectorEleven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition > 200.0f))
				{
					pSectorTwelve.push_back(pixelObject);
				}
			}
		}


		



		cout << "Printing Sector One Values" << endl;
		imageSegmentationDataFile << "Printing Sector One Values" << endl;
		imageSectorsData << "Printing Sector One Values" << endl;
		vector<float> pXArrayOne = vector<float>();


		for (PixelObject pixelObject : pSectorOne)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;
		}



		cout << "Printing Sector Two Values" << endl;
		imageSegmentationDataFile << "Printing Sector Two Values" << endl;

		for (PixelObject pixelObject : pSectorTwo)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Printing Sector 3 Values" << endl;
		imageSegmentationDataFile << "Printing Sector 3 Values" << endl;

		for (PixelObject pixelObject : pSectorThree)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}




		cout << "Sector Four" << endl;
		imageSegmentationDataFile << "Sector Four" << endl;
		imageSectorsData << "Sector Four" << endl;

		for (PixelObject pixelObject : pSectorFour)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Sector Five" << endl;
		imageSegmentationDataFile << "Sector Five" << endl;
		imageSectorsData << "Sector Five" << endl;

		for (PixelObject pixelObject : pSectorFive)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;





		cout << "Sector Six" << endl;
		imageSegmentationDataFile << "Sector Six" << endl;
		imageSectorsData << "Sector Six" << endl;


		for (PixelObject pixelObject : pSectorSix)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;


		cout << "Sector Seven" << endl;
		imageSegmentationDataFile << "Sector Seven" << endl;
		imageSectorsData << "Sector Seven: " << endl;


		for (PixelObject pixelObject : pSectorSeven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;


		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Eight" << endl;
		imageSegmentationDataFile << "Printing Sector Eight" << endl;
		imageSectorsData << "Sector Eight: " << endl;

		for (PixelObject pixelObject : pSectorEight)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Nine" << endl;
		imageSegmentationDataFile << "Printing Sector Nine" << endl;
		imageSectorsData << "Sector Nine: " << endl;

		for each (PixelObject pixelObject in pSectorNine)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Ten" << endl;
		imageSegmentationDataFile << "Printing Sector Ten" << endl;
		imageSectorsData << "Printing Sector Ten" << endl;


		for each (PixelObject pixelObject in pSectorTen)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Eleven" << endl;
		imageSegmentationDataFile << "Printing Sector Eleven" << endl;
		imageSectorsData << "Printing Sector Eleven" << endl;

		for (PixelObject pixelObject : pSectorEleven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Twelve" << endl;
		imageSegmentationDataFile << "Printing Sector Twelve" << endl;
		imageSectorsData << "Printing Sector Twelve" << endl;


		for (PixelObject pixelObject : pSectorTwelve)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}



		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;


		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;


		cout << "Computing Median X for Sectors 1-6" << endl;
		imageSegmentationDataFile << "Computing Median X for Sectors 1-6" << endl;

		pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
		pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
		pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
		pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
		pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
		pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

		cout << "Computing Median Y for Sectors 7-12" << endl;
		imageSegmentationDataFile << "Computing Median Y for Sectors 7-12" << endl;

		pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
		pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
		pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
		pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
		pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
		pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

		pXPositionAverageWhole0 = round(pXPositionAverage0);
		pXPositionAverageWhole1 = round(pXPositionAverage1);
		pXPositionAverageWhole2 = round(pXPositionAverage2);
		pXPositionAverageWhole3 = round(pXPositionAverage3);
		pXPositionAverageWhole4 = round(pXPositionAverage4);
		pXPositionAverageWhole5 = round(pXPositionAverage5);

		pYPositionAverageWhole0 = round(pYPositionAverage0);
		pYPositionAverageWhole1 = round(pYPositionAverage1);
		pYPositionAverageWhole2 = round(pYPositionAverage2);
		pYPositionAverageWhole3 = round(pYPositionAverage3);
		pYPositionAverageWhole4 = round(pYPositionAverage4);
		pYPositionAverageWhole5 = round(pYPositionAverage5);








		cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;


		imageSegmentationDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		imageSegmentationDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;






		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, 0.0f, 0.0f, 0.0f);


		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);


		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





		vector<Point2D> pPointArrayToDraw = vector<Point2D>();





		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{

			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}



		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointArrayToDraw);

		



		float pSectorLength12 = 0.0f;
		float pSectorLength23 = 0.0f;
		float pSectorLength34 = 0.0f;
		float pSectorLength45 = 0.0f;
		float pSectorLength56 = 0.0f;
		float pSectorLength67 = 0.0f;
		float pSectorLength78 = 0.0f;
		float pSectorLength89 = 0.0f;
		float pSectorLength910 = 0.0f;
		float pSectorLength1011 = 0.0f;
		float pSectorLength1112 = 0.0f;
		float pSectorLength1201 = 0.0f;

		float pSectorLength1Centre = 0.0f;
		float pSectorLength2Centre = 0.0f;
		float pSectorLength3Centre = 0.0f;
		float pSectorLength4Centre = 0.0f;
		float pSectorLength5Centre = 0.0f;
		float pSectorLength6Centre = 0.0f;
		float pSectorLength7Centre = 0.0f;
		float pSectorLength8Centre = 0.0f;
		float pSectorLength9Centre = 0.0f;
		float pSectorLength10Centre = 0.0f;
		float pSectorLength11Centre = 0.0f;
		float pSectorLength12Centre = 0.0f;


		Point2D pPointOne = pPointArrayToDraw[0];
		Point2D pPointTwo = pPointArrayToDraw[1];
		Point2D pPointThree = pPointArrayToDraw[2];

		Point2D pPointFour = pPointArrayToDraw[3];
		Point2D pPointFive = pPointArrayToDraw[4];
		Point2D pPointSix = pPointArrayToDraw[5];
		Point2D pPointSeven = pPointArrayToDraw[6];
		Point2D pPointEight = pPointArrayToDraw[7];
		Point2D pPointNine = pPointArrayToDraw[8];
		Point2D pPointTen = pPointArrayToDraw[9];
		Point2D pPointEleven = pPointArrayToDraw[10];
		Point2D pPointTwelve = pPointArrayToDraw[11];




		pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
		pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
		pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
		pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
		pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
		pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
		pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
		pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
		pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
		pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
		pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
		pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

		pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
		pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
		pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
		pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
		pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
		pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
		pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
		pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
		pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
		pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
		pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
		pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



		Line2D pLine12;
		pLine12.pLineNumber = 1;
		pLine12.pPointOne = pPointOne;
		pLine12.pPointTwo = pPointTwo;
		pLine12.pLineWidth = pSectorLength12;



		Line2D pLine23;
		pLine23.pLineNumber = 2;
		pLine23.pPointOne = pPointTwo;
		pLine23.pPointTwo = pPointThree;
		pLine23.pLineWidth = pSectorLength23;


		Line2D pLine34;
		pLine34.pLineNumber = 3;
		pLine34.pPointOne = pPointThree;
		pLine34.pPointTwo = pPointFour;
		pLine34.pLineWidth = pSectorLength34;


		Line2D pLine45;
		pLine45.pLineNumber = 4;
		pLine45.pPointOne = pPointFour;
		pLine45.pPointTwo = pPointFive;
		pLine45.pLineWidth = pSectorLength45;


		Line2D pLine56;
		pLine56.pLineNumber = 5;
		pLine56.pPointOne = pPointFive;
		pLine56.pPointTwo = pPointSix;
		pLine56.pLineWidth = pSectorLength56;


		Line2D pLine67;
		pLine67.pLineNumber = 6;
		pLine67.pPointOne = pPointSix;
		pLine67.pPointTwo = pPointSeven;
		pLine67.pLineWidth = pSectorLength67;


		Line2D pLine78;
		pLine78.pLineNumber = 7;
		pLine78.pPointOne = pPointSeven;
		pLine78.pPointTwo = pPointEight;
		pLine78.pLineWidth = pSectorLength78;

		Line2D pLine89;
		pLine89.pLineNumber = 8;
		pLine89.pPointOne = pPointEight;
		pLine89.pPointTwo = pPointNine;
		pLine89.pLineWidth = pSectorLength89;


		Line2D pLine910;
		pLine910.pLineNumber = 9;
		pLine910.pPointOne = pPointNine;
		pLine910.pPointTwo = pPointTen;
		pLine910.pLineWidth = pSectorLength910;


		Line2D pLine1011;
		pLine1011.pLineNumber = 10;
		pLine1011.pPointOne = pPointTen;
		pLine1011.pPointTwo = pPointEleven;
		pLine1011.pLineWidth = pSectorLength1011;


		Line2D pLine1112;
		pLine1112.pLineNumber = 11;
		pLine1112.pPointOne = pPointEleven;
		pLine1112.pPointTwo = pPointTwelve;
		pLine1112.pLineWidth = pSectorLength1112;


		Line2D pLine1201;
		pLine1201.pLineNumber = 12;
		pLine1201.pPointOne = pPointTwelve;
		pLine1201.pPointTwo = pPointOne;
		pLine1201.pLineWidth = pSectorLength1201;

		Line2D pLineOneCentre;
		pLineOneCentre.pLineNumber = 13;
		pLineOneCentre.pPointOne = pPointOne;
		pLineOneCentre.pPointTwo = pCentre;
		pLineOneCentre.pLineWidth = pSectorLength1Centre;

		Line2D pLineTwoCentre;
		pLineTwoCentre.pLineNumber = 15;
		pLineTwoCentre.pPointOne = pPointTwo;
		pLineTwoCentre.pPointTwo = pCentre;
		pLineTwoCentre.pLineWidth = pSectorLength2Centre;

		Line2D pLineThreeCentre;
		pLineThreeCentre.pLineNumber = 16;
		pLineThreeCentre.pPointOne = pPointThree;
		pLineThreeCentre.pPointTwo = pCentre;
		pLineThreeCentre.pLineWidth = pSectorLength3Centre;


		Line2D pLineFourCentre;
		pLineFourCentre.pLineNumber = 16;
		pLineFourCentre.pPointOne = pPointFour;
		pLineFourCentre.pPointTwo = pCentre;
		pLineFourCentre.pLineWidth = pSectorLength4Centre;


		Line2D pLineFiveCentre;
		pLineFiveCentre.pLineNumber = 17;
		pLineFiveCentre.pPointOne = pPointFive;
		pLineFiveCentre.pPointTwo = pCentre;
		pLineFiveCentre.pLineWidth = pSectorLength5Centre;


		Line2D pLineSixCentre;
		pLineSixCentre.pLineNumber = 18;
		pLineSixCentre.pPointOne = pPointSix;
		pLineSixCentre.pPointTwo = pCentre;
		pLineSixCentre.pLineWidth = pSectorLength6Centre;


		Line2D pLineSevenCentre;
		pLineSevenCentre.pLineNumber = 19;
		pLineSevenCentre.pPointOne = pPointSeven;
		pLineSevenCentre.pPointTwo = pCentre;
		pLineSevenCentre.pLineWidth = pSectorLength7Centre;


		Line2D pLineEightCentre;
		pLineEightCentre.pLineNumber = 20;
		pLineEightCentre.pPointOne = pPointEight;
		pLineEightCentre.pPointTwo = pCentre;
		pLineEightCentre.pLineWidth = pSectorLength8Centre;


		Line2D pLineNineCentre;
		pLineNineCentre.pLineNumber = 21;
		pLineNineCentre.pPointOne = pPointNine;
		pLineNineCentre.pPointTwo = pCentre;
		pLineNineCentre.pLineWidth = pSectorLength9Centre;


		Line2D pLineTenCentre;
		pLineTenCentre.pLineNumber = 22;
		pLineTenCentre.pPointOne = pPointTen;
		pLineTenCentre.pPointTwo = pCentre;
		pLineTenCentre.pLineWidth = pSectorLength10Centre;


		Line2D pLineElevenCentre;
		pLineElevenCentre.pLineNumber = 23;
		pLineElevenCentre.pPointOne = pPointEleven;
		pLineElevenCentre.pPointTwo = pCentre;
		pLineElevenCentre.pLineWidth = pSectorLength11Centre;


		Line2D pLineTwelveCentre;
		pLineTwelveCentre.pLineNumber = 24;
		pLineTwelveCentre.pPointOne = pPointTwelve;
		pLineTwelveCentre.pPointTwo = pCentre;
		pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








		float pTriangleOneArea = 0.0f;
		float pTriangleTwoArea = 0.0f;
		float pTriangleThreeArea = 0.0f;
		float pTriangleFourArea = 0.0f;
		float pTriangleFiveArea = 0.0f;
		float pTriangleSixArea = 0.0f;
		float pTriangleSevenArea = 0.0f;
		float pTriangleEightArea = 0.0f;
		float pTriangleNineArea = 0.0f;
		float pTriangleTenArea = 0.0f;
		float pTriangleElevenArea = 0.0f;
		float pTriangleTwelveArea = 0.0f;





		float pTriangleAreaTotal = 0.0f;
		pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
		pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
		pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
		pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
		pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
		pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
		pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
		pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
		pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
		pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
		pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
		pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
		pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

		cout << "Triangle One Area: " << pTriangleOneArea << endl;
		cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
		cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
		cout << "Triangle Four Area: " << pTriangleFourArea << endl;
		cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
		cout << "Triangle Six Area: " << pTriangleSixArea << endl;
		cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
		cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
		cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
		cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

		imageSegmentationDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
		imageSegmentationDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
		imageSegmentationDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
		imageSegmentationDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
		imageSegmentationDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
		imageSegmentationDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
		imageSegmentationDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		imageSegmentationDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
		imageSegmentationDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
		imageSegmentationDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
		imageSegmentationDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		imageSegmentationDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


		cout << "Constructing Triangle Structures" << endl;
		TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
			pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
		TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
			pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
		TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
			pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
		TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
			pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
		TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
			pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
		TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
			pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
		TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
			pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
		TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
			pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
		TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
			pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
		TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
			pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
		TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
			pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
		TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
			pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

		cout << "Storing Our Triangle Data into A Vector" << endl;
		imageSegmentationDataFile << "Storing Our Triangle Data into A Vector" << endl;

		vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
		pTriangleObjectVector.push_back(pTriangleObjectOne);
		pTriangleObjectVector.push_back(pTriangleObjectTwo);
		pTriangleObjectVector.push_back(pTriangleObjectThree);
		pTriangleObjectVector.push_back(pTriangleObjectFour);
		pTriangleObjectVector.push_back(pTriangleObjectFive);
		pTriangleObjectVector.push_back(pTriangleObjectSix);
		pTriangleObjectVector.push_back(pTriangleObjectSeven);
		pTriangleObjectVector.push_back(pTriangleObjectEight);
		pTriangleObjectVector.push_back(pTriangleObjectNine);
		pTriangleObjectVector.push_back(pTriangleObjectTen);
		pTriangleObjectVector.push_back(pTriangleObjectEleven);
		pTriangleObjectVector.push_back(pTriangleObjectTwelve);

		for (TriangleObject pTriangleObject : pTriangleObjectVector)
		{
			cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			cout << "Point A:" << endl;
			cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			cout << "Point B:" << endl;
			cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			cout << "Point C:" << endl;
			cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			cout << "Area = " << pTriangleObject.pTriangleArea << endl;

			imageSegmentationDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			imageSegmentationDataFile << "Point A:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			imageSegmentationDataFile << "Point B:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			imageSegmentationDataFile << "Point C:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			imageSegmentationDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			imageSegmentationDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			imageSegmentationDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
		}




		cout << "Computing Perimeter for the Shape" << endl;
		float pShapePerimeter = 0.0f;
		pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


		cout << "Perimeter Value: " << pShapePerimeter << endl;
		imageSegmentationDataFile << "Perimeter Value: " << pShapePerimeter << endl;






		cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
		imageSegmentationDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}

	imageSegmentationDataFile.close();
	imageSectorsData.close();

	return hr;
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::LocalizePixelsOfAnImageAgainstSelectedCentre(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\LocalizeImagePixelsPositions.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();


	float pStepX = 0.0f;
	float pStepY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;

	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<OutputPixelObjectCircularData> pCommonOutputVectorTrig = vector<OutputPixelObjectCircularData>();
	
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();

	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;





	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	float pCentreX = 0.0f;
	float pCentreY = 0.0f;
	float pDistanceThresold = 0.0f;
	float pAngleThresold = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	cout << "Enter the Value for for X Centre" << endl;
	cin >> pCentreX;
	cout << "Enter the Value for for Y Centre" << endl;
	cin >> pCentreY;

	cout << "Enter the Value for Distance Barrier" << endl;
	cin >> pDistanceThresold;

	cout << "Enter the Value for Angle Barrier" << endl;
	cin >> pAngleThresold;



	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
		}

		cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());



		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();




		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBOne);

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);
		cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
				endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
				pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << " " << endl;
		cout << " " << endl;
		cout << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		cout << "Printing Output" << endl;
		UINT pIndexValue = 0;


		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		SYSTEMTIME restorationStartSystem;
		SYSTEMTIME restorationStartLocal;

		GetSystemTime(&restorationStartSystem);
		GetLocalTime(&restorationStartLocal);
		cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBOne,
			&pFilteredObjectArrayRGBOneRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;


		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
			pXValuesArray.push_back(pixelObject.xPosition);
			pYValuesArray.push_back(pixelObject.yPosition);

		}


		sort(pXValuesArray.begin(), pXValuesArray.end(), WayToSortFloatsAscending);
		sort(pYValuesArray.begin(), pYValuesArray.end(), WayToSortFloatsAscending);

		pCentreX = round((pXValuesArray[pXValuesArray.size() - 1] - pXValuesArray[0]) / 2.0f + pXValuesArray[0]);
		pCentreY = round((pYValuesArray[pYValuesArray.size() - 1] - pYValuesArray[0]) / 2.0f + pYValuesArray[0]);

		int pOnTheLineXParam = 0.0f;
		int pOnTheLineYParam = 0.0f;
		int pBelowTheLineXParam = 0.0f;
		int pBelowTheLineYParam = 0.0f;
		int pAboveTheTheLineXParam = 0.0f;
		int pAboveTheTheLineYParam = 0.0f;
		int pSectorOneLabel = 0.0f;
		int pSectorTwoLabel = 0.0f;
		int pSectorThreeLabel = 0.0f;
		int pSectorFourLabvel = 0.0f;
		int pAxisLabel = 0.0f;



		int pQuarterOneValue = 1;
		int pQuarterTwoValue = 2;
		int pQuarterThreeValue = 3;
		int pQuarterFourValue = 4;
		pAxisLabel = 5;
		float pi_var = DirectX::XM_PI;
		
		int pPointLiesInsideCircle = 1;
		int pPointLiesOnTheCircle = 2;
		int pPointLiesOutsideOfTheCircle = 3;



		hr = ppStandardAlgorithmExecutor->LocalizePixelsUsingCircleEquatuion(hInstance,
			hWnd, pCentreX,
			pCentreY,
			pi_var,
			pDistanceThresold,
			pPointLiesInsideCircle,
			pPointLiesOnTheCircle,
			pPointLiesOutsideOfTheCircle,
			pFilteredObjectArrayRGBOneRestored,
			&pCommonOutputVectorTrig);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;

		}



		for (OutputPixelObjectCircularData pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Centre X Oriented Coordinate = " << pPixelObject.pCentreXValue  << endl;
			cout << "Centre Y Oriented Coordinate =  " << pPixelObject.pCentreYValue << endl;
			cout << "Distance To Point = " << pPixelObject.pDistanceToCentre << endl;
			cout << "Angle Tangent =  " << pPixelObject.pAngleToPixelTangent << endl;
			cout << "Angle Sine Value = " << pPixelObject.pAngleToPixelSine << endl;
			cout << "Angle Cosine Value = " << pPixelObject.pAngleToPixelCosine << endl;
			cout << "Angle To Pixel Data Radians = " << pPixelObject.pAngleValueRadians << endl;
			cout << "Angle To Pixel Data Degreed = " << pPixelObject.pAngleValueDegrees << endl;
			cout << "Class of Pixel Value = " << pPixelObject.pClassOfPixel << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "Centre X Oriented Coordinate = " << pPixelObject.pCentreXValue << endl;
			imageSegmentationDataFile << "Centre Y Oriented Coordinate =  " << pPixelObject.pCentreYValue << endl;
			imageSegmentationDataFile << "Distance To Point = " << pPixelObject.pDistanceToCentre << endl;
			imageSegmentationDataFile << "Angle Tangent =  " << pPixelObject.pAngleToPixelTangent << endl;
			imageSegmentationDataFile << "Angle Sine Value = " << pPixelObject.pAngleToPixelSine << endl;
			imageSegmentationDataFile << "Angle Cosine Value = " << pPixelObject.pAngleToPixelCosine << endl;
			imageSegmentationDataFile << "Angle To Pixel Data Radians = " << pPixelObject.pAngleValueRadians << endl;
			imageSegmentationDataFile << "Angle To Pixel Data Degreed = " << pPixelObject.pAngleValueDegrees << endl;
			imageSegmentationDataFile << "Class of Pixel Value = " << pPixelObject.pClassOfPixel << endl;


		}

		vector<PixelObject> pPointsThatLieInsideCircle = vector<PixelObject>();
		vector<PixelObject> pPointsThatLieOnTheCircle = vector<PixelObject>();
		vector<PixelObject> pPointsThatLieOutsideOfTheCircle = vector<PixelObject>();


		cout << "Restoring Pixels for that Lie Inside the Circle" << endl;
		imageSegmentationDataFile << "Restoring Pixels for that Lie Inside the Circle" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromCircularDescriptorForAGivenClass(hInstance,
			hWnd, pPointLiesInsideCircle,
			pCommonOutputVectorTrig,
			&pPointsThatLieInsideCircle);


		for (PixelObject pixelObject : pPointsThatLieInsideCircle)
		{
			
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			
		}

		cout << "Restoring Pixels for that Lie On the Circle" << endl;
		imageSegmentationDataFile << "Restoring Pixels for that Lie On the Circle" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromCircularDescriptorForAGivenClass(hInstance,
			hWnd, pPointLiesOnTheCircle,
			pCommonOutputVectorTrig,
			&pPointsThatLieOnTheCircle);



		for (PixelObject pixelObject : pPointsThatLieOnTheCircle)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		}


		cout << "Restoring Pixels for that Lie On the Circle" << endl;
		imageSegmentationDataFile << "Restoring Pixels for that Lie On the Circle" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromCircularDescriptorForAGivenClass(hInstance,
			hWnd, pPointLiesOutsideOfTheCircle,
			pCommonOutputVectorTrig,
			&pPointsThatLieOutsideOfTheCircle);



		for (PixelObject pixelObject : pPointsThatLieOutsideOfTheCircle)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		}

		cout << "Computing the Area of the Field" << endl;
		float pPlateArea = 0.0f;
		pPlateArea = pImageWidth * pImageHeight;

		cout << "Total Clip Area = " << pPlateArea << endl;
		imageSegmentationDataFile << "Total Clip Area = " << pPlateArea << endl;

		cout << "Amount Of Pixels Inside Circle = " << pPointsThatLieInsideCircle.size() << endl;
		imageSegmentationDataFile << "Amount Of Pixels Inside Circle = " << pPointsThatLieInsideCircle.size() << endl;

		cout << "Amount Of Pixels On The Circle = " << pPointsThatLieOnTheCircle.size() << endl;
		imageSegmentationDataFile << "Amount Of Pixels On The Circle = " << pPointsThatLieOnTheCircle.size() << endl;

		cout << "Amount Of Pixels Outside of The Circle = " << pPointsThatLieOutsideOfTheCircle.size() << endl;
		imageSegmentationDataFile << "Amount Of Pixels Outside of The Circle = " << pPointsThatLieOutsideOfTheCircle.size() << endl;

		cout << "Subtracting the Area of the Outside Vector from total Area" << endl;
		imageSegmentationDataFile << "Subtracting the Area of the Outside Vector from total Area" << endl;

		float pAreaValue = pPlateArea - pPointsThatLieOutsideOfTheCircle.size();
		cout << "Object Area = " << pAreaValue << endl;
		imageSegmentationDataFile << "Object Area = " << pAreaValue << endl;



		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		imageSegmentationDataFile.close();

	}

		
		return hr;

}


		










HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterViaPixelAddition(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";


	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterViaPixelDataAddition.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();


	float pStepX = 0.0f;
	float pStepY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();


	float pCentreX = 430.0;
	float pCentreY = 410.0f;

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;




	vector<PixelObject> pSectorOne = vector<PixelObject>();
	vector<PixelObject> pSectorTwo = vector<PixelObject>();
	vector<PixelObject> pSectorThree = vector<PixelObject>();
	vector<PixelObject> pSectorFour = vector<PixelObject>();
	vector<PixelObject> pSectorFive = vector<PixelObject>();
	vector<PixelObject> pSectorSix = vector<PixelObject>();
	vector<PixelObject> pSectorSeven = vector<PixelObject>();
	vector<PixelObject> pSectorEight = vector<PixelObject>();
	vector<PixelObject> pSectorNine = vector<PixelObject>();
	vector<PixelObject> pSectorTen = vector<PixelObject>();
	vector<PixelObject> pSectorEleven = vector<PixelObject>();
	vector<PixelObject> pSectorTwelve = vector<PixelObject>();




	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;




	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());


		vector<OutputPixelBufferRGB> pOutputDataBuffer = vector<OutputPixelBufferRGB>();
		vector<PixelObject> pIdenticalDataBuffer = vector<PixelObject>();
		vector<PixelObject> pDifferentDataBuffer = vector<PixelObject>();



		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();






		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->AddColorToImagePixelsFromRGBImage(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVectorOne,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			&pOutputDataBuffer);


		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		pIndex = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();

		float pColorSum = 0.0f;
		for (OutputPixelBufferRGB pOutputPixelValue : pOutputDataBuffer)
		{

			pColorSum = pOutputPixelValue.pOutputComparisonValueRed + pOutputPixelValue.pOutputComparisonValueGreen + pOutputPixelValue.pOutputComparisonValueBlue;

			if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
			{


				cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




				imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
			}



			pIndex++;
		}


		cout << "Restoration Data buffer Array" << endl;
		imageSegmentationDataFile << "Restoration Data buffer Array" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompation(hInstance,
			hWnd, pOutputDataBuffer,
			&pFilteredObjectArrayRGBOneRestored);

		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

				if (pixelObject.RMask < 0.0f)
				{
					pixelObject.RMask = 0.0f;
				}
				if (pixelObject.GMask < 0.0f)
				{
					pixelObject.GMask = 0.0f;
				}
				if (pixelObject.BMask < 0.0f)
				{
					pixelObject.BMask = 0.0f;
				}

				if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorOne.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorTwo.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorThree.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorFour.push_back(pixelObject);
				}
				if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorFive.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorSix.push_back(pixelObject);
				}

				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorSeven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorEight.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorNine.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorTen.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition <= 200.0f))
				{
					pSectorEleven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition > 200.0f))
				{
					pSectorTwelve.push_back(pixelObject);
				}
			}
		}






		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;


		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;


		cout << "Computing Median X for Sectors 1-6" << endl;
		imageSegmentationDataFile << "Computing Median X for Sectors 1-6" << endl;

		pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
		pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
		pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
		pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
		pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
		pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

		cout << "Computing Median Y for Sectors 7-12" << endl;
		imageSegmentationDataFile << "Computing Median Y for Sectors 7-12" << endl;

		pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
		pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
		pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
		pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
		pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
		pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

		pXPositionAverageWhole0 = round(pXPositionAverage0);
		pXPositionAverageWhole1 = round(pXPositionAverage1);
		pXPositionAverageWhole2 = round(pXPositionAverage2);
		pXPositionAverageWhole3 = round(pXPositionAverage3);
		pXPositionAverageWhole4 = round(pXPositionAverage4);
		pXPositionAverageWhole5 = round(pXPositionAverage5);

		pYPositionAverageWhole0 = round(pYPositionAverage0);
		pYPositionAverageWhole1 = round(pYPositionAverage1);
		pYPositionAverageWhole2 = round(pYPositionAverage2);
		pYPositionAverageWhole3 = round(pYPositionAverage3);
		pYPositionAverageWhole4 = round(pYPositionAverage4);
		pYPositionAverageWhole5 = round(pYPositionAverage5);








		cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;


		imageSegmentationDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		imageSegmentationDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;






		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, 0.0f, 0.0f, 0.0f);


		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);


		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





		vector<Point2D> pPointArrayToDraw = vector<Point2D>();



		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}

		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointArrayToDraw);




		float pSectorLength12 = 0.0f;
		float pSectorLength23 = 0.0f;
		float pSectorLength34 = 0.0f;
		float pSectorLength45 = 0.0f;
		float pSectorLength56 = 0.0f;
		float pSectorLength67 = 0.0f;
		float pSectorLength78 = 0.0f;
		float pSectorLength89 = 0.0f;
		float pSectorLength910 = 0.0f;
		float pSectorLength1011 = 0.0f;
		float pSectorLength1112 = 0.0f;
		float pSectorLength1201 = 0.0f;

		float pSectorLength1Centre = 0.0f;
		float pSectorLength2Centre = 0.0f;
		float pSectorLength3Centre = 0.0f;
		float pSectorLength4Centre = 0.0f;
		float pSectorLength5Centre = 0.0f;
		float pSectorLength6Centre = 0.0f;
		float pSectorLength7Centre = 0.0f;
		float pSectorLength8Centre = 0.0f;
		float pSectorLength9Centre = 0.0f;
		float pSectorLength10Centre = 0.0f;
		float pSectorLength11Centre = 0.0f;
		float pSectorLength12Centre = 0.0f;


		Point2D pPointOne = pPointArrayToDraw[0];
		Point2D pPointTwo = pPointArrayToDraw[1];
		Point2D pPointThree = pPointArrayToDraw[2];

		Point2D pPointFour = pPointArrayToDraw[3];
		Point2D pPointFive = pPointArrayToDraw[4];
		Point2D pPointSix = pPointArrayToDraw[5];
		Point2D pPointSeven = pPointArrayToDraw[6];
		Point2D pPointEight = pPointArrayToDraw[7];
		Point2D pPointNine = pPointArrayToDraw[8];
		Point2D pPointTen = pPointArrayToDraw[9];
		Point2D pPointEleven = pPointArrayToDraw[10];
		Point2D pPointTwelve = pPointArrayToDraw[11];




		pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
		pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
		pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
		pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
		pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
		pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
		pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
		pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
		pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
		pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
		pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
		pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

		pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
		pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
		pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
		pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
		pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
		pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
		pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
		pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
		pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
		pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
		pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
		pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



		Line2D pLine12;
		pLine12.pLineNumber = 1;
		pLine12.pPointOne = pPointOne;
		pLine12.pPointTwo = pPointTwo;
		pLine12.pLineWidth = pSectorLength12;



		Line2D pLine23;
		pLine23.pLineNumber = 2;
		pLine23.pPointOne = pPointTwo;
		pLine23.pPointTwo = pPointThree;
		pLine23.pLineWidth = pSectorLength23;


		Line2D pLine34;
		pLine34.pLineNumber = 3;
		pLine34.pPointOne = pPointThree;
		pLine34.pPointTwo = pPointFour;
		pLine34.pLineWidth = pSectorLength34;


		Line2D pLine45;
		pLine45.pLineNumber = 4;
		pLine45.pPointOne = pPointFour;
		pLine45.pPointTwo = pPointFive;
		pLine45.pLineWidth = pSectorLength45;


		Line2D pLine56;
		pLine56.pLineNumber = 5;
		pLine56.pPointOne = pPointFive;
		pLine56.pPointTwo = pPointSix;
		pLine56.pLineWidth = pSectorLength56;


		Line2D pLine67;
		pLine67.pLineNumber = 6;
		pLine67.pPointOne = pPointSix;
		pLine67.pPointTwo = pPointSeven;
		pLine67.pLineWidth = pSectorLength67;


		Line2D pLine78;
		pLine78.pLineNumber = 7;
		pLine78.pPointOne = pPointSeven;
		pLine78.pPointTwo = pPointEight;
		pLine78.pLineWidth = pSectorLength78;

		Line2D pLine89;
		pLine89.pLineNumber = 8;
		pLine89.pPointOne = pPointEight;
		pLine89.pPointTwo = pPointNine;
		pLine89.pLineWidth = pSectorLength89;


		Line2D pLine910;
		pLine910.pLineNumber = 9;
		pLine910.pPointOne = pPointNine;
		pLine910.pPointTwo = pPointTen;
		pLine910.pLineWidth = pSectorLength910;


		Line2D pLine1011;
		pLine1011.pLineNumber = 10;
		pLine1011.pPointOne = pPointTen;
		pLine1011.pPointTwo = pPointEleven;
		pLine1011.pLineWidth = pSectorLength1011;


		Line2D pLine1112;
		pLine1112.pLineNumber = 11;
		pLine1112.pPointOne = pPointEleven;
		pLine1112.pPointTwo = pPointTwelve;
		pLine1112.pLineWidth = pSectorLength1112;


		Line2D pLine1201;
		pLine1201.pLineNumber = 12;
		pLine1201.pPointOne = pPointTwelve;
		pLine1201.pPointTwo = pPointOne;
		pLine1201.pLineWidth = pSectorLength1201;

		Line2D pLineOneCentre;
		pLineOneCentre.pLineNumber = 13;
		pLineOneCentre.pPointOne = pPointOne;
		pLineOneCentre.pPointTwo = pCentre;
		pLineOneCentre.pLineWidth = pSectorLength1Centre;

		Line2D pLineTwoCentre;
		pLineTwoCentre.pLineNumber = 15;
		pLineTwoCentre.pPointOne = pPointTwo;
		pLineTwoCentre.pPointTwo = pCentre;
		pLineTwoCentre.pLineWidth = pSectorLength2Centre;

		Line2D pLineThreeCentre;
		pLineThreeCentre.pLineNumber = 16;
		pLineThreeCentre.pPointOne = pPointThree;
		pLineThreeCentre.pPointTwo = pCentre;
		pLineThreeCentre.pLineWidth = pSectorLength3Centre;


		Line2D pLineFourCentre;
		pLineFourCentre.pLineNumber = 16;
		pLineFourCentre.pPointOne = pPointFour;
		pLineFourCentre.pPointTwo = pCentre;
		pLineFourCentre.pLineWidth = pSectorLength4Centre;


		Line2D pLineFiveCentre;
		pLineFiveCentre.pLineNumber = 17;
		pLineFiveCentre.pPointOne = pPointFive;
		pLineFiveCentre.pPointTwo = pCentre;
		pLineFiveCentre.pLineWidth = pSectorLength5Centre;


		Line2D pLineSixCentre;
		pLineSixCentre.pLineNumber = 18;
		pLineSixCentre.pPointOne = pPointSix;
		pLineSixCentre.pPointTwo = pCentre;
		pLineSixCentre.pLineWidth = pSectorLength6Centre;


		Line2D pLineSevenCentre;
		pLineSevenCentre.pLineNumber = 19;
		pLineSevenCentre.pPointOne = pPointSeven;
		pLineSevenCentre.pPointTwo = pCentre;
		pLineSevenCentre.pLineWidth = pSectorLength7Centre;


		Line2D pLineEightCentre;
		pLineEightCentre.pLineNumber = 20;
		pLineEightCentre.pPointOne = pPointEight;
		pLineEightCentre.pPointTwo = pCentre;
		pLineEightCentre.pLineWidth = pSectorLength8Centre;


		Line2D pLineNineCentre;
		pLineNineCentre.pLineNumber = 21;
		pLineNineCentre.pPointOne = pPointNine;
		pLineNineCentre.pPointTwo = pCentre;
		pLineNineCentre.pLineWidth = pSectorLength9Centre;


		Line2D pLineTenCentre;
		pLineTenCentre.pLineNumber = 22;
		pLineTenCentre.pPointOne = pPointTen;
		pLineTenCentre.pPointTwo = pCentre;
		pLineTenCentre.pLineWidth = pSectorLength10Centre;


		Line2D pLineElevenCentre;
		pLineElevenCentre.pLineNumber = 23;
		pLineElevenCentre.pPointOne = pPointEleven;
		pLineElevenCentre.pPointTwo = pCentre;
		pLineElevenCentre.pLineWidth = pSectorLength11Centre;


		Line2D pLineTwelveCentre;
		pLineTwelveCentre.pLineNumber = 24;
		pLineTwelveCentre.pPointOne = pPointTwelve;
		pLineTwelveCentre.pPointTwo = pCentre;
		pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








		float pTriangleOneArea = 0.0f;
		float pTriangleTwoArea = 0.0f;
		float pTriangleThreeArea = 0.0f;
		float pTriangleFourArea = 0.0f;
		float pTriangleFiveArea = 0.0f;
		float pTriangleSixArea = 0.0f;
		float pTriangleSevenArea = 0.0f;
		float pTriangleEightArea = 0.0f;
		float pTriangleNineArea = 0.0f;
		float pTriangleTenArea = 0.0f;
		float pTriangleElevenArea = 0.0f;
		float pTriangleTwelveArea = 0.0f;





		float pTriangleAreaTotal = 0.0f;
		pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
		pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
		pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
		pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
		pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
		pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
		pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
		pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
		pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
		pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
		pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
		pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
		pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

		cout << "Triangle One Area: " << pTriangleOneArea << endl;
		cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
		cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
		cout << "Triangle Four Area: " << pTriangleFourArea << endl;
		cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
		cout << "Triangle Six Area: " << pTriangleSixArea << endl;
		cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
		cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
		cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
		cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

		imageSegmentationDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
		imageSegmentationDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
		imageSegmentationDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
		imageSegmentationDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
		imageSegmentationDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
		imageSegmentationDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
		imageSegmentationDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		imageSegmentationDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
		imageSegmentationDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
		imageSegmentationDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
		imageSegmentationDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		imageSegmentationDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


		cout << "Constructing Triangle Structures" << endl;
		TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
			pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
		TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
			pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
		TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
			pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
		TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
			pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
		TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
			pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
		TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
			pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
		TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
			pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
		TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
			pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
		TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
			pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
		TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
			pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
		TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
			pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
		TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
			pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

		cout << "Storing Our Triangle Data into A Vector" << endl;
		imageSegmentationDataFile << "Storing Our Triangle Data into A Vector" << endl;

		vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
		pTriangleObjectVector.push_back(pTriangleObjectOne);
		pTriangleObjectVector.push_back(pTriangleObjectTwo);
		pTriangleObjectVector.push_back(pTriangleObjectThree);
		pTriangleObjectVector.push_back(pTriangleObjectFour);
		pTriangleObjectVector.push_back(pTriangleObjectFive);
		pTriangleObjectVector.push_back(pTriangleObjectSix);
		pTriangleObjectVector.push_back(pTriangleObjectSeven);
		pTriangleObjectVector.push_back(pTriangleObjectEight);
		pTriangleObjectVector.push_back(pTriangleObjectNine);
		pTriangleObjectVector.push_back(pTriangleObjectTen);
		pTriangleObjectVector.push_back(pTriangleObjectEleven);
		pTriangleObjectVector.push_back(pTriangleObjectTwelve);

		for (TriangleObject pTriangleObject : pTriangleObjectVector)
		{
			cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			cout << "Point A:" << endl;
			cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			cout << "Point B:" << endl;
			cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			cout << "Point C:" << endl;
			cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			cout << "Area = " << pTriangleObject.pTriangleArea << endl;

			imageSegmentationDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			imageSegmentationDataFile << "Point A:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			imageSegmentationDataFile << "Point B:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			imageSegmentationDataFile << "Point C:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			imageSegmentationDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			imageSegmentationDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			imageSegmentationDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
		}




		cout << "Computing Perimeter for the Shape" << endl;
		float pShapePerimeter = 0.0f;
		pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


		cout << "Perimeter Value: " << pShapePerimeter << endl;
		imageSegmentationDataFile << "Perimeter Value: " << pShapePerimeter << endl;






		cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
		imageSegmentationDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}

	imageSegmentationDataFile.close();
	imageSectorsData.close();

	return hr;
	return hr;
}









	HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSorting(HINSTANCE hInstance, HWND hWnd)
	{

		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
			Instance(hInstance, hWnd);

		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterWithSorting.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		fstream imageSectorsData;
		imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
		imageSectorsData.clear();
		float pStepX = 0.0f;
		float pStepY = 0.0f;
		int pValidClassifierToken = 1;
		int pInvalidClassifierToken = 0;
		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
		vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
		vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;

		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pMinimumX = 0.0f;
		float pMinimumY = 0.0f;
		float pMaximumX = 0.0f;
		float pMaximumY = 0.0f;
		float pRedValueToSelect = 0.0f;
		float pGreenValueToSelect = 0.0f;
		float pBlueValueToSelect = 0.0f;
		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;
		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;
		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;
		cout << "Enter the Red Component To Select" << endl;
		cin >> pRedValueToSelect;
		cout << "Enter the Green Component to Select" << endl;
		cin >> pGreenValueToSelect;
		cout << "Enter the BLue Component to Select" << endl;
		cin >> pBlueValueToSelect;
		cout << "Enter the step for the X Clip " << endl;
		cin >> pStepX;
		cout << "Enter the step for the Y Clip " << endl;
		cin >> pStepY;
		LPWSTR path = nullptr;
		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		std::chrono::system_clock::time_point start;
		std::chrono::system_clock::time_point stop;
		std::chrono::system_clock::duration duration;
		if (GetOpenFileNameW(&ofn))
		{
			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
			pixelDataFile << "New Image Clip" << endl;
			// Get starting timepoint
			start = high_resolution_clock::now();
			// Call the function, here sort()
			// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;
			for (PixelObject pixelObject : pixelObjectVectorOne)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;
				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
			stop = high_resolution_clock::now();
			// Get duration. Substart timepoints to
			// get durarion. To cast it to proper unit
			// use duration cast method
			duration = duration_cast<microseconds>(stop - start);
			cout << "Time taken by Clip One: "
				<< duration.count() << " microseconds" << endl;
			pixelDataFile << "Time taken by Clip One: "
				<< duration.count() / 10000000 << " seconds" << endl;
			cout << "Performing the Second scan of the image" << endl;
			auto start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;
			for (PixelObject pixelObject : pixelObjectVectorTwo)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;
				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

			auto stop = high_resolution_clock::now();
			// Get duration. Substart timepoints to
			// get durarion. To cast it to proper unit
			// use duration cast method
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Time taken by Clip Two: "
				<< duration.count() / 1000000 << "seconds" << endl;
			pixelDataFile << "Time taken by Clip Two: "
				<< duration.count() / 1000000 << " seconds" << endl;
			cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
				clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
				clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
				clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
				clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;
			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);
			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
			pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());
			cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
				clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
				clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
				clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
				clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;
			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);
			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pVectorOneIt = pixelObjectVectorOne.end();
			pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());
			start = high_resolution_clock::now();

			float pSectionOneXMin = 180.0f;
			float pSectionOneXMax = 680.0f;
			float pSectionOneY = 200.0f;
			hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
				hWnd,
				pSectionOneXMin,
				pSectionOneY,
				pSectionOneXMax,
				pSectionOneY,
				pRedValueToSelect,
				pRedValueToSelect,
				pGreenValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pBlueValueToSelect,
				pixelObjectVectorOne,
				&pFilteredObjectArrayRGBOne);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
					endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
					pLastError << endl;
				pixelDataFile.close();
				return hr;
			}
			stop = high_resolution_clock::now();
			// Get duration. Substart timepoints to
			// get durarion. To cast it to proper unit
			// use duration cast method
			duration = duration_cast<microseconds>(stop - start);
			cout << "Time taken by RGB Filter: "
				<< duration.count() / 1000000 << "seconds" << endl;
			pixelDataFile << "Time taken by RGB Filter: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;
			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;
			UINT pIndexValue = 0;
			for (OutputPixelObjectFiltered pPixelObject : pFilteredObjectArrayRGBOne)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
				pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
				pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
				pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
				if (pIndexValue == 10)
				{
					break;
				}
				else
				{
					pIndexValue = pIndexValue + 1;
				}
			}
		}
		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBOne,
			&pFilteredObjectArrayRGBOneRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
		}
		float pSectionTwoXMin = 170.0f;
		float pSectionTwoXMax = 580.0f;
		float pSectionTwoY = 400.0f;

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pSectionTwoXMin,
			pSectionTwoY,
			pSectionTwoXMax,
			pSectionTwoY,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBTwo);
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		pixelDataFile << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;
		UINT pIndexValue = 0;
		for (OutputPixelObjectFiltered pPixelObject : pFilteredObjectArrayRGBOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			if (pIndexValue == 10)
			{
				break;
			}
			else
			{
				pIndexValue = pIndexValue + 1;
			}
		}
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBTwo,
			&pFilteredObjectArrayRGBTwoRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pFilteredObjectArrayRGBTwoRestored)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
		}
		float pSectionThreeXMin = 280.0f;
		float pSectionThreeXMax = 580.0f;
		float pSectionThreeY = 600.0f;
		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pSectionThreeXMin,
			pSectionThreeY,
			pSectionThreeXMax,
			pSectionThreeY,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBThree);
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << endl;
			pixelDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		pixelDataFile << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;
		pIndexValue = 0;
		for (OutputPixelObjectFiltered pPixelObject : pFilteredObjectArrayRGBOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			if (pIndexValue == 10)
			{
				break;
			}
			else
			{
				pIndexValue = pIndexValue + 1;
			}
		}
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBThree,
			&pFilteredObjectArrayRGBThreeRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;

		for (PixelObject pixelObject : pFilteredObjectArrayRGBTwoRestored)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
		}
		float pSectionFourYMin = 170.0f;
		float pSectionFourYMax = 430.0f;
		float pSectionFourX = 200.0f;
		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pSectionFourX,
			pSectionFourYMin,
			pSectionFourX,
			pSectionFourYMax,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBFour);
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		pixelDataFile << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;
		pIndexValue = 0;
		for (OutputPixelObjectFiltered pPixelObject : pFilteredObjectArrayRGBFour)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			if (pIndexValue == 10)
			{
				break;
			}
			else
			{
				pIndexValue = pIndexValue + 1;
			}
		}
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBFour,
			&pFilteredObjectArrayRGBFourRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pFilteredObjectArrayRGBFourRestored)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
		}
		float pSectionFiveX = 135.0f;
		float pSectionFiveYMax = 685.0f;
		float pSectionFiveYMin = 400.0f;
		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pSectionFiveX,
			pSectionFiveYMin,
			pSectionFiveX,
			pSectionFiveYMax,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBFive);
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		pixelDataFile << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;
		pIndexValue = 0;

		for (OutputPixelObjectFiltered pPixelObject : pFilteredObjectArrayRGBFive)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			if (pIndexValue == 10)
			{
				break;
			}
			else
			{
				pIndexValue = pIndexValue + 1;
			}
		}
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBFive,
			&pFilteredObjectArrayRGBFiveRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;

		for (PixelObject pixelObject : pFilteredObjectArrayRGBFiveRestored)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
		}
		float pXPositionScanSix = 600.0f;
		float pYPositionScanSixStart = 135.0f;
		float pYPositionScanSixEnd = 315.0f;

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pXPositionScanSix,
			pYPositionScanSixStart,
			pXPositionScanSix,
			pYPositionScanSixEnd,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBSix);
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		pixelDataFile << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		for (OutputPixelObjectFiltered pPixelObject : pFilteredObjectArrayRGBSix)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;
			if (pIndexValue == 10)
			{
				break;
			}
			else
			{
				pIndexValue = pIndexValue + 1;
			}
		}
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBSix,
			&pFilteredObjectArrayRGBSixRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;

		for (PixelObject pixelObject : pFilteredObjectArrayRGBSixRestored)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
		}



		vector<PixelObject> pCommonVectorObject = vector<PixelObject>();
		
		if (pFilteredObjectArrayRGBOneRestored.size() > 0)
		{
			pCommonVectorObject.insert(pCommonVectorObject.end(), pFilteredObjectArrayRGBOneRestored.begin(), pFilteredObjectArrayRGBOneRestored.end());
		}
		if (pFilteredObjectArrayRGBTwoRestored.size() > 0)
		{
			pCommonVectorObject.insert(pCommonVectorObject.end(), pFilteredObjectArrayRGBTwoRestored.begin(), pFilteredObjectArrayRGBTwoRestored.end());
		}
		if (pFilteredObjectArrayRGBThreeRestored.size() > 0)
		{
			pCommonVectorObject.insert(pCommonVectorObject.end(), pFilteredObjectArrayRGBThreeRestored.begin(), pFilteredObjectArrayRGBThreeRestored.end());
		}
		if (pFilteredObjectArrayRGBFourRestored.size() > 0)
		{
			pCommonVectorObject.insert(pCommonVectorObject.end(), pFilteredObjectArrayRGBFourRestored.begin(), pFilteredObjectArrayRGBFourRestored.end());
		}
		if (pFilteredObjectArrayRGBThreeRestored.size() > 0)
		{
			pCommonVectorObject.insert(pCommonVectorObject.end(), pFilteredObjectArrayRGBFiveRestored.begin(), pFilteredObjectArrayRGBFiveRestored.end());
		}
		if (pFilteredObjectArrayRGBThreeRestored.size() > 0)
		{
			pCommonVectorObject.insert(pCommonVectorObject.end(), pFilteredObjectArrayRGBSixRestored.begin(), pFilteredObjectArrayRGBSixRestored.end());
		}
		vector<SortedPixelOutput> pSortedVectorOne = vector<SortedPixelOutput>();
		vector<SortedPixelOutput> pSortedVectorTwo = vector<SortedPixelOutput>();
		vector<SortedPixelOutput> pSortedVectorThree = vector<SortedPixelOutput>();
		vector<SortedPixelOutput> pSortedVectorFour = vector<SortedPixelOutput>();
		vector<SortedPixelOutput> pSortedVectorFive = vector<SortedPixelOutput>();
		vector<SortedPixelOutput> pSortedVectorSix = vector<SortedPixelOutput>();

		hr = ppStandardAlgorithmExecutor->SortPixelsForXPosition(hInstance,
			hWnd, 200.0f, 1, 2, pCommonVectorObject,
			&pSortedVectorOne);

		hr = ppStandardAlgorithmExecutor->SortPixelsForXPosition(hInstance,
			hWnd, 400.0f, 1, 2, pCommonVectorObject,
			&pSortedVectorTwo);

		hr = ppStandardAlgorithmExecutor->SortPixelsForXPosition(hInstance,
			hWnd, 600.0f,  1, 2, pCommonVectorObject,
			&pSortedVectorThree);

		hr = ppStandardAlgorithmExecutor->SortPixelsForYPosition(hInstance,
			hWnd,  200.0f, 1, 2, pCommonVectorObject,
			&pSortedVectorFour);


		hr = ppStandardAlgorithmExecutor->SortPixelsForYPosition(hInstance,
			hWnd,  400.0f, 1, 2, pCommonVectorObject,
			&pSortedVectorFive);


		hr = ppStandardAlgorithmExecutor->SortPixelsForYPosition(hInstance,
			hWnd, 600.0f, 1, 2, pCommonVectorObject,
			&pSortedVectorSix);

		
		vector<PixelObject> pSortedVectorOnePartA = vector<PixelObject>();
		vector<PixelObject> pSortedVectorOnePartB = vector<PixelObject>();

		vector<PixelObject> pSortedVectorTwoPartA = vector<PixelObject>();
		vector<PixelObject> pSortedVectorTwoPartB = vector<PixelObject>();

		vector<PixelObject> pSortedVectorThreePartA = vector<PixelObject>();
		vector<PixelObject> pSortedVectorThreePartB = vector<PixelObject>();

		vector<PixelObject> pSortedVectorFourPartA = vector<PixelObject>();
		vector<PixelObject> pSortedVectorFourPartB = vector<PixelObject>();

		vector<PixelObject> pSortedVectorFivePartA = vector<PixelObject>();
		vector<PixelObject> pSortedVectorFivePartB = vector<PixelObject>();

		vector<PixelObject> pSortedVectorSixPartA = vector<PixelObject>();
		vector<PixelObject> pSortedVectorSixPartB = vector<PixelObject>();



		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupOne(hInstance,
			hWnd,  pSortedVectorOne,
			&pSortedVectorOnePartA);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupTwo(hInstance,
			hWnd,  pSortedVectorOne,
			&pSortedVectorOnePartB);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupOne(hInstance,
			hWnd,  pSortedVectorTwo,
			&pSortedVectorTwoPartA);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupTwo(hInstance,
			hWnd,  pSortedVectorTwo,
			&pSortedVectorTwoPartB);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupOne(hInstance,
			hWnd, pSortedVectorThree,
			&pSortedVectorThreePartA);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupTwo(hInstance,
			hWnd,  pSortedVectorThree,
			&pSortedVectorThreePartB);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupOne(hInstance,
			hWnd, pSortedVectorFour,
			&pSortedVectorFourPartA);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupTwo(hInstance,
			hWnd, pSortedVectorFour,
			&pSortedVectorFourPartB);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupOne(hInstance,
			hWnd, pSortedVectorFive,
			&pSortedVectorFivePartA);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupTwo(hInstance,
			hWnd, pSortedVectorFive,
			&pSortedVectorFivePartB);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupOne(hInstance,
			hWnd,  pSortedVectorSix,
			&pSortedVectorSixPartA);

		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromsFromSortingGroupTwo(hInstance,
			hWnd,  pSortedVectorSix,
			&pSortedVectorSixPartB);




		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		
		int pIndex0 = pSortedVectorOnePartA.size() / 2;
		int pIndex1 = pSortedVectorOnePartB.size() / 2;
		int pIndex2 = pSortedVectorTwoPartA.size() / 2;
		int pIndex3 = pSortedVectorTwoPartB.size() / 2;
		int pIndex4 = pSortedVectorThreePartA.size() / 2;
		int pIndex5 = pSortedVectorThreePartB.size() / 2;
		int pIndex6 = pSortedVectorFourPartA.size() / 2;
		int pIndex7 = pSortedVectorFourPartB.size() / 2;
		int pIndex8 = pSortedVectorFivePartA.size() / 2;
		int pIndex9 = pSortedVectorFivePartB.size() / 2;
		int pIndex10 = pSortedVectorSixPartA.size() / 2;
		int pIndex11 = pSortedVectorSixPartB.size() / 2;




		PixelObject pPixelObjectCentreOne = pSortedVectorOnePartA[pIndex0];
		PixelObject pPixelObjectCentreTwo = pSortedVectorOnePartB[pIndex1];
		PixelObject pPixelObjectCentreThree = pSortedVectorTwoPartA[pIndex2];
		PixelObject pPixelObjectCentreFour = pSortedVectorTwoPartB[pIndex3];
		PixelObject pPixelObjectCentreFive = pSortedVectorThreePartA[pIndex4];
		PixelObject pPixelObjectCentreSix = pSortedVectorThreePartB[pIndex5];;
		PixelObject pPixelObjectCentreSeven = pSortedVectorFourPartA[pIndex6];
		PixelObject pPixelObjectCenteEight = pSortedVectorFourPartB[pIndex7];
		PixelObject pPixelObjectCentreNine = pSortedVectorFivePartA[pIndex8];;
		PixelObject pPixelObjectCentreTen = pSortedVectorFivePartB[pIndex9];
		PixelObject pPixelObjectCentreEleven = pSortedVectorSixPartA[pIndex10];;
		PixelObject pPixelObjectCentreTwelve = pSortedVectorSixPartB[pIndex11];

		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCenteEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

		cout << "Computing Pixel Object Centres Tangients" << endl;
		pixelDataFile << "Computing Pixel Object Centres Tangents" << endl;

		Point2D pCentre;
		pCentre.xPosition = 430;
		pCentre.yPosition = 410;

		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);

		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();



		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}

		cout << "Sorting Our Vectors" << endl;

		std::sort(std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne), WayToSortPixelsWihtAnglesAscending);
		std::sort(std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo), WayToSortPixelsWihtAnglesDescending);
		std::sort(std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree), WayToSortPixelsWihtAnglesAscending);
		std::sort(std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour), WayToSortPixelsWihtAnglesDescending);

		cout << "Priniting Sector Eight" << endl;
		pixelDataFile << "Priniting Sector Eight" << endl;
		imageSectorsData << "Printing Sector Eight" << endl;
		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



		}


		cout << "Priniting Sector Two" << endl;
		pixelDataFile << "Priniting Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;
		}


		cout << "Priniting Sector Three" << endl;
		pixelDataFile << "Priniting Sector Three" << endl;
		imageSectorsData << "Priniting Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;
		}


		cout << "Priniting Sector Four" << endl;
		pixelDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;
		}


		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscending);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescending);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesAscending);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescending);




		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));




		vector<Point2D> pPointToDrawSectorCommon = vector <Point2D>();



		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointToDrawSectorCommon.push_back(pPointObject);
		}





		float pTotalArea = 0.0f;
		vector<Line2D> pLineVectorData = vector<Line2D>();
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointToDrawSectorCommon);

		cout << "Image Area Data: " << pTotalArea << endl;
		pixelDataFile << "Image Area Data: " << pTotalArea << endl;

		LPWSTR pScreenImage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";
		
		pixelDataFile.close();
		imageSectorsData.close();

		return hr;
	}




HRESULT DirectXGPUDigitalLabCoreModule::ComputePixelDeltaForImage(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\PixelDeltaFunctionTest.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();

	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();



	vector<OutputPixelBufferRGB> pOutputPixelObjectArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pFinalOutputArrayPixelIdentical = vector<PixelObject>();
	vector<PixelObject> pFinalOutputArrayPixelsDifferent = vector<PixelObject>();



	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	float pCentreX = 0.0f;
	float pCentreY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> ppOutputDataBufferRestored = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the Centre Point X Coordinate" << endl;
	cin >> pCentreX;

	cout << "Enter the Centre Point Y Coordinate" << endl;
	cin >> pCentreY;


	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;

	float pRedValueToSubtract = 0.0f;
	float pGreenValueToSubtract = 0.0f;
	float pBlueValueToSubtract = 0.0f;

	cout << "Enter the Value of the Red Component to Subtract" << endl;
	cin >> pRedValueToSubtract;

	cout << "Enter the Value of the Green Component to Subtract" << endl;
	cin >> pGreenValueToSubtract;

	cout << "Enter the Value of the Blue Component to Subtract" << endl;
	cin >> pBlueValueToSubtract;




	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());



		cout << "Filtering Image Pixels By Subtraction of Values" << endl;
		imageSegmentationDataFile << "Filtering Image Pixels By Subtraction of Values" << endl;

		

		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pTopLeftX + pImageWidth,
			pTopLeftY + pImageHeight,
			pRedValueToSubtract,
			pRedValueToSubtract,
			pGreenValueToSubtract,
			pGreenValueToSubtract,
			pBlueValueToSubtract,
			pBlueValueToSubtract,
			pixelObjectVectorOne,
			&ppOutputDataBuffer);

		if (SUCCEEDED(hr))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
				ppOutputDataBuffer,
				&ppOutputDataBufferRestored);
		}




		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();


		for (PixelObject pixelObject : ppOutputDataBufferRestored)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}


		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;

		}

		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;




	




	vector<OutputPixelObjectWithAngleValues> pOutputPixelsWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance, hWnd, pCentreX,
		pCentreY, ppOutputDataBufferRestored,
		&pOutputPixelsWithAngleValues);

	cout << "Printing the Results of the Simulation " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelsWithAngleValues)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		cout << "Angle Tangent Value: " << pPixelObject.pTangentValue << endl;
		cout << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		cout << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		cout << "Quarter Value:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Quarter Value:" << pPixelObject.pQuarterNumberVar << endl;



		if (pPixelObject.pQuarterNumberVar == 1.0f)
		{
			pVectorPointsSectorOne.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 2.0f)
		{
			pVectorPointsSectorTwo.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 3.0f)
		{
			pVectorPointsSectorThree.push_back(pPixelObject);
		}
		else if (pPixelObject.pQuarterNumberVar == 4.0f)
		{
			pVectorPointsSectorFour.push_back(pPixelObject);
		}

	}







	}








	

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);







		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();



		vector<Point2D> pPointArrayToDraw = vector<Point2D>();

		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorOne)
		{

			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorTwo)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorThree)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorPointsSectorFour)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject = ConvertPixelToPoint2D(pVectorItem);
				pPointArrayToDraw.push_back(pPointObject);
			}
		}





	





		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentreX,
			pCentreY,
			pPointArrayToDraw);

		cout << "Saving Data About our Segments " << endl;

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	imageSegmentationDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ComputePixelDeltaForImageDirect(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\PixelDeltaFunctionTestDirectFunction.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	float pCentreX = 0.0f;
	float pCentreY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVectorEight = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the Centre Point X Coordinate" << endl;
	cin >> pCentreX;

	cout << "Enter the Centre Point Y Coordinate" << endl;
	cin >> pCentreY;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorEight);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorEight)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}



	vector<OutputPixelObjectWithAngleValues> pOutputPixelsWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
	hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentreDirect(hInstance, hWnd, pCentreX,
		pCentreY, pixelObjectVectorEight,
		&pOutputPixelsWithAngleValues);

	cout << "Printing the Results of the Simulation " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelsWithAngleValues)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		cout << "Angle Tangent Value: " << pPixelObject.pTangentValue << endl;
		cout << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		cout << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		cout << "Quarter Value:" << pPixelObject.pQuarterNumberVar << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
		pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
		pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		pixelDataFile << "Radius Value: " << pPixelObject.pRadiusValue << endl;
		pixelDataFile << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
		pixelDataFile << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
		pixelDataFile << "Quarter Value:" << pPixelObject.pQuarterNumberVar << endl;





	}
	pixelDataFile.close();
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::DrawPixelArrayOnTheScreen(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelObjectVector = vector<PixelObject>();
	int pSquareSide = 0;
	int pArea = 0;
	float pRedValue = 0.0f;
	float pGreenValue = 0.0f;
	float pBlueValue = 0.0f;
	cout << "ENter the Side of the Square" << endl;
	cin >> pSquareSide;
	cout << "Enter the R Parameter for the Color" << endl;
	cin >> pRedValue;
	cout << "Enter the G Parameter for the Color" << endl;
	cin >> pGreenValue;
	cout << "Enter the B Parameter for the Color" << endl;
	cin >> pBlueValue;
	pArea = pSquareSide * pSquareSide;

	int pPixelNumber = 0;
	for (float pXValue = 0; pXValue < pSquareSide; ++pXValue)
	{
		for (float pYValue = 0; pYValue < pSquareSide; ++pYValue)
		{
			PixelObject pMyPixelObject = PixelObject(pPixelNumber, pXValue, pYValue, pRedValue, pGreenValue, pBlueValue);
			pPixelObjectVector.push_back(pMyPixelObject);
			pPixelNumber++;
		}
	}
	

	hr = md2dmanager->DrawPixelBuffer(hInstance, hWnd, pPixelObjectVector, 0, 0, pSquareSide, pSquareSide);

	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::DrawSomethingUsingGDIInterop(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelObjectVector = vector<PixelObject>();
	
	hr = md2dmanager->DrawSomeThingUsingGDIInterop(hInstance, hWnd);


	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ComputeDeltaFunctionForImages(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObjectFifthExperimentRGBFilter.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pPixelObjectToProcess = vector<PixelObject>();


	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pImageWidth = 0.0f;
	float pImageHeight = 0.0f;
	LPWSTR path = nullptr;

	

	float pStepX = 0.0f;
	float pStepY = 0.0f;


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamicObjectLocalization.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;






	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	float pYSortingConstant0 = pStepY;
	float pYSortingConstant1 = pStepY * 2;
	float pYSortingConstant2 = pStepY * 3;

	float pXSortingConstant0 = pStepX;
	float pXSortingConstant1 = pStepX * 2;
	float pXSortingConstant2 = pStepX * 3;





	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}
		}

		cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}

		}
		float pCentreX = 0.0f;
		float pCentreY = 0.0f;
		float pYDelta = 0.0f;

		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		pCentreX = pImageWidth / 2.0f;
		pCentreY = pImageHeight / 2.0f;

		imageSegmentationDataFile << "Your Centre Point Is: " << endl;
		imageSegmentationDataFile << "X Position: " << pCentreX << endl;
		imageSegmentationDataFile << "Y Position: " << pCentreY << endl;





		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());




		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBOne);

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);
		cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
				endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
				pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << " " << endl;
		cout << " " << endl;
		cout << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		cout << "Printing Output" << endl;
		UINT pIndexValue = 0;


		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		SYSTEMTIME restorationStartSystem;
		SYSTEMTIME restorationStartLocal;

		GetSystemTime(&restorationStartSystem);
		GetLocalTime(&restorationStartLocal);
		cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBOne,
			&pFilteredObjectArrayRGBOneRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;


		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
			pXValuesArray.push_back(pixelObject.xPosition);
			pYValuesArray.push_back(pixelObject.yPosition);
		}


		std::sort(pXValuesArray.begin(), pXValuesArray.end(), WayToSortFloatsAscending);
		std::sort(pYValuesArray.begin(), pYValuesArray.end(), WayToSortFloatsAscending);

		cout << "Centre Pixel: " << endl;
		cout << "X Value: " << pCentreX << endl;
		cout << "Y Value" << pCentreY << endl;




		cout << "Sending the output array for validations" << endl;
		vector<OutputPixelObjectWithAngleValues> pOutputPixelsWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance, hWnd, pCentreX,
			pCentreY, pPixelObjectToProcess,
			&pOutputPixelsWithAngleValues);

		cout << "Printing the Results of the Simulation " << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelsWithAngleValues)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Cos Value: " << pPixelObject.pAngleCosValue << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Sin Value: " << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Cos Value: " << pPixelObject.pAngleCosValue << endl;


		}

	}

	imageSegmentationDataFile.close();
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::DetectMultiColorPixelsInsideImagesWithRecovery(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\MultiColorImageDetector.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilterToReverse = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Maximum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Maximum Value for Y Position" << endl;
	cin >> pMaximumY;






	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;

		// Get starting timepoint 
		auto start = high_resolution_clock::now();

		// Call the function, here sort() 

		// Get ending timepoint 

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		pixelDataFile << "New Image Clip" << endl;

		cout << "Performing Image Scan Eight Cliing X" << endl;
		pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorX);

		cout << "Clip for Image X Position" << endl;
		pixelDataFile << "Clip for Image X Position" << endl;

		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorX)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "Clip for Image X Position End" << endl;
		pixelDataFile << "Clip for Image X Position End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		auto stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For X End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;

		pixelDataFile << "Clipping Session For X End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Performing Image Scan Two" << endl;
		start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorY);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		cout << "Clip for Image Y Position" << endl;
		pixelDataFile << "Clip for Image Y Position" << endl;


		for (PixelObject pixelObject : pixelObjectVectorY)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}


		}

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For Y End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << "Clipping Session For Y End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		vector<PixelObject> pCommonPixelArray = vector<PixelObject>();
		pCommonPixelArray.clear();
		pCommonPixelArray.insert(pCommonPixelArray.end(), pixelObjectVectorX.begin(), pixelObjectVectorX.end());
		pCommonPixelArray.insert(pCommonPixelArray.end(), pixelObjectVectorY.begin(), pixelObjectVectorY.end());



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Filter Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "Filtering Started " << endl;
		pixelDataFile << "Filtering Started " << endl;
		start = high_resolution_clock::now();

		vector<OutputPixelObjectFiltered> pFilteredArray = vector<OutputPixelObjectFiltered>();
		pFilteredArray.clear();



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;

		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->DetectMultiColorPixelsInImage(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pCommonPixelArray, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pFinalOutputSquare, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}


		pixelDataFile.close();

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);





	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontFifthExperimentRGBFilter(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObjectFifthExperimentRGBFilter.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream pixelDataFilePixels;
	pixelDataFilePixels.open("C:\\pixels\\PixelsBank.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFilePixels.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVectorEightSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorEightSectorY = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoSectorY = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorThreeSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorThreeSectorY = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorFourSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorFourSectorY = vector<PixelObject>();

	vector<PixelObject> pCommonVectorForFiltering = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	



	ID2D1Bitmap* pBitmapData = nullptr;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGB = vector<OutputPixelObjectFiltered>();

	vector<OutputPixelObjectFiltered> pCollectionForPixels = vector<OutputPixelObjectFiltered>();

	vector<PixelObject> pPixelObjectToProcess = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pSectorEight = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThree = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFour = vector<OutputPixelObjectWithAngleValues>();




	cout << "Enter the X Value for Top Left Position of the Image Sector Eight" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector Eight" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width Of the Image" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height Of the Image" << endl;
	cin >> pImageHeight;


	pMaximumX = pImageWidth;
	pMaximumY = pImageHeight;

	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;

	cout << "Enter the Green Component to  Select" << endl;
	cin >> pGreenValueToSelect;


	cout << "Enter the BLue Component to  Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;

	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;

	cout << "Computing the Delta Function Values" << endl;
	pixelDataFile << "Computing the Delta Function Values" << endl;
	float pCentreXValue = 0.0f;
	float pCentreYValue = 0.0f;

	cout << "Enter the X Value of the Centre Pixels: " << endl;
	cin >> pCentreXValue;

	cout << "Enter the Y Value of the Centre Pixels: " << endl;
	cin >> pCentreYValue;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	
	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		cout << "Analyzing Data For Sector Eight" << endl;

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorEightSectorX);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorEightSectorX)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,

			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorEightSectorY);

		for (PixelObject pixelObject : pixelObjectVectorEightSectorY)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}



		pCommonVectorForFiltering.insert(pCommonVectorForFiltering.end(), pixelObjectVectorEightSectorX.begin(), pixelObjectVectorEightSectorX.end());
		pCommonVectorForFiltering.insert(pCommonVectorForFiltering.end(), pixelObjectVectorEightSectorY.begin(), pixelObjectVectorEightSectorY.end());

		//Cечение 1-1
		float pXPositionScanEightStart = 180.0f;
		float pXPositionScanEightEnd = 680.0f;
		float pYPositionScanEight = 200;

		float pXPositionScanTwoStart = 170.0f;
		float pXPositionScanTwoEnd = 580.0f;
		float pYPositionScanTwo = 400;

		float pXPositionScanThreeStart = 280.0f;
		float pXPositionScanThreeEnd = 560.0f;
		float pYPositionScanThree = 600.0f;

		float pXPositionScanFour = 200.0f;
		float pYPositionScanFourStart = 170.0f;
		float pYPositionScanFourEnd = 430.0f;


		float pXPositionScanFive = 135.0f;
		float pYPositionScanFiveStart = 685.0f;
		float pYPositionScanFiveEnd = 400.0f;


		float pXPositionScanSix = 600.0f;
		float pYPositionScanSixStart = 135.0f;
		float pYPositionScanSixEnd = 315.0f;






		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		vector<OutputPixelObjectFiltered> pOutputVectorHorizontalEight = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pOutputVectorHorizontalTwo = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pOutputVectorHorizontalThree = vector<OutputPixelObjectFiltered>();

		vector<OutputPixelObjectFiltered> pOutputVectorVerticalEight = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pOutputVectorVerticalTwo = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pOutputVectorVerticalThree = vector<OutputPixelObjectFiltered>();


		vector<PixelObject> pOutputVectorHorizontalEightRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorHorizontalTwoRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorHorizontalThreeRestored = vector<PixelObject>();

		vector<PixelObject> pOutputVectorVerticalEightRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorVerticalTwoRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorVerticalThreeRestored = vector<PixelObject>();





		cout << "Detecting Line Eight Horizontal" << endl;

		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance,
			hWnd, pXPositionScanEightStart, pXPositionScanEightEnd, pYPositionScanEight,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pCommonVectorForFiltering,
			&pOutputVectorHorizontalEight);

		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pOutputVectorHorizontalEight,
				&pOutputVectorHorizontalEightRestored);


		}





		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance,
			hWnd, pXPositionScanTwoStart,
			pXPositionScanTwoEnd,
			pYPositionScanTwo,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pCommonVectorForFiltering,
			&pOutputVectorHorizontalTwo);



		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pOutputVectorHorizontalTwo,
				&pOutputVectorHorizontalTwoRestored);


		}





		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance,
			hWnd, pXPositionScanThreeStart,
			pXPositionScanThreeEnd,
			pYPositionScanThree,
			pRedValueToSelect, pRedValueToSelect,
			pGreenValueToSelect,
			pCommonVectorForFiltering, &pOutputVectorHorizontalThree);


		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pOutputVectorHorizontalThree,
				&pOutputVectorHorizontalThreeRestored);
		}

		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance,
			hWnd,
			pYPositionScanFourStart,
			pYPositionScanFourEnd,
			pXPositionScanFour,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pCommonVectorForFiltering, &pOutputVectorVerticalEight);

		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pOutputVectorVerticalEight,
				&pOutputVectorVerticalEightRestored);


		}
		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance,
			hWnd,
			pYPositionScanFiveStart,
			pYPositionScanFiveEnd,
			pXPositionScanFive,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pCommonVectorForFiltering, &pOutputVectorVerticalTwo);


		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pOutputVectorVerticalTwo,
				&pOutputVectorVerticalTwoRestored);


		}


		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance,
			hWnd, pYPositionScanSixStart,
			pYPositionScanSixEnd,
			pXPositionScanSix,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pCommonVectorForFiltering, &pOutputVectorVerticalThree);

		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pOutputVectorVerticalThree,
				&pOutputVectorVerticalThreeRestored);


		}


		vector<PixelObject> pCollectionForPixels = vector<PixelObject>();
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorHorizontalEightRestored.begin(), pOutputVectorHorizontalEightRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorHorizontalTwoRestored.begin(), pOutputVectorHorizontalTwoRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorHorizontalThreeRestored.begin(), pOutputVectorHorizontalThreeRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorVerticalEightRestored.begin(), pOutputVectorVerticalEightRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorVerticalTwoRestored.begin(), pOutputVectorVerticalTwoRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorVerticalThreeRestored.begin(), pOutputVectorVerticalThreeRestored.end());






		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pCollectionForPixels)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		UINT pYValue = 410.0f;
		cout << "Applying Binary Classfier to Image Pixels" << endl;
		vector<OutputPixelObjectFiltered> pOutputPixelArray = vector<OutputPixelObjectFiltered>();
		hr = ppStandardAlgorithmExecutor->SelectPixelsOfColorFromImage(hInstance,
			hWnd, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect, pCollectionForPixels,
			&pOutputPixelArray);

		pIndex = 0;
		for (OutputPixelObjectFiltered pPixelObject : pOutputPixelArray)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;

			if (pIndex == 10)
			{
				break;
			}
			else
			{
				pIndex = pIndex + 1;

			}


		}


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, pOutputPixelArray, &pPixelObjectToProcess);
		for (PixelObject pixelObject : pPixelObjectToProcess)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		vector<PixelObject> pPixelObjectRestoreFinal = vector<PixelObject>();



		cout << "Sending the output array for validations" << endl;
		vector<OutputPixelObjectWithAngleValues> pOutputPixelsWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance, hWnd, pCentreXValue,
			pCentreYValue, pPixelObjectToProcess,
			&pOutputPixelsWithAngleValues);

		cout << "Printing the Results of the Simulation " << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelsWithAngleValues)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			cout << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
			cout << "Sector Number: " << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Sector Number: " << pPixelObject.pQuarterNumberVar << endl;




		}


		vector<OutputPixelObjectWithAngleValues> pClusterEight = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pClusterTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pClusterThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pClusterFour = vector<OutputPixelObjectWithAngleValues>();


		for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelsWithAngleValues)
		{

			if (pPixelObject.pQuarterNumberVar == 1)
			{
				pClusterEight.push_back(pPixelObject);
			}
			if (pPixelObject.pQuarterNumberVar == 2)
			{
				pClusterTwo.push_back(pPixelObject);
			}
			if (pPixelObject.pQuarterNumberVar == 3)
			{
				pClusterThree.push_back(pPixelObject);
			}
			if (pPixelObject.pQuarterNumberVar == 4)
			{
				pClusterFour.push_back(pPixelObject);
			}
		}



		std::sort(std::begin(pClusterEight), std::end(pClusterEight), WayToSortPixelsWihtAnglesAscending);
		std::sort(std::begin(pClusterTwo), std::end(pClusterTwo), WayToSortPixelsWihtAnglesAscending);
		std::sort(std::begin(pClusterThree), std::end(pClusterThree), WayToSortPixelsWihtAnglesDescending);
		std::sort(std::begin(pClusterFour), std::end(pClusterFour), WayToSortPixelsWihtAnglesDescending);




		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);




		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		vector<OutputPixelObjectWithAngleValues> pOutputPixelObject = vector<OutputPixelObjectWithAngleValues>();
		pOutputPixelObject.insert(pOutputPixelObject.end(), pClusterEight.begin(), pClusterEight.end());
		pOutputPixelObject.insert(pOutputPixelObject.end(), pClusterTwo.begin(), pClusterTwo.end());
		pOutputPixelObject.insert(pOutputPixelObject.end(), pClusterThree.begin(), pClusterThree.end());
		pOutputPixelObject.insert(pOutputPixelObject.end(), pClusterFour.begin(), pClusterFour.end());


		vector<PixelObject> pVectorForOutput = vector<PixelObject>();

		for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelObject)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			cout << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Centre Difference: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Centre Difference: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Angle Sin Value: " << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cos Value: " << pPixelObject.pAngleCosValue << endl;





			PixelObject pD2DPixelItem = PixelObject(pPixelObject.pixelNumber,
				pPixelObject.xPosition, pPixelObject.yPosition, pPixelObject.rValue,
				pPixelObject.gValue, pPixelObject.bValue);

			pVectorForOutput.push_back(pD2DPixelItem);

		}

		vector<Point2D> pVectorPoints = vector<Point2D>();
		for (PixelObject pPixelObjectVar : pVectorForOutput)
		{
			Point2D pPoint2D;
			pPoint2D.pPointNumber = pPixelObjectVar.pixelNumber;
			pPoint2D.xPosition = pPixelObjectVar.xPosition; 
			pPoint2D.yPosition = pPixelObjectVar.yPosition;
			pVectorPoints.push_back(pPoint2D);
		}

		float pTotalArea = 0.0f;

		vector<Line2D> pLineVectorArray = vector<Line2D>();
		hr = md2dmanager->ConnectPointsUsingLines(hInstance, hWnd,
			pCentreXValue,
			pCentreYValue,
			pVectorPoints);



	}





	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;


	
	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFilePixels.close();

	pixelDataFile.close();
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontSixthExperimentRGBFilter(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObjectFifthExperimentRGBFilterFunctionMethod.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();
	
	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();

	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;


	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();



	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pixelObjectVectorEightSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorEightSectorY = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwoSectorY = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorThreeSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorThreeSectorY = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorFourSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorFourSectorY = vector<PixelObject>();

	vector<PixelObject> pCommonVectorForFiltering = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;



	float pCentreX = 430.0;
	float pCentreY = 410.0f;



	ID2D1Bitmap* pBitmapData = nullptr;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGB = vector<OutputPixelObjectFiltered>();

	vector<OutputPixelObjectFiltered> pCollectionForPixels = vector<OutputPixelObjectFiltered>();

	vector<PixelObject> pPixelObjectToProcess = vector<PixelObject>();



	cout << "Enter the X Value for Top Left Position of the Image Sector Eight" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector Eight" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width Of the Image" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height Of the Image" << endl;
	cin >> pImageHeight;


	pMaximumX = pImageWidth;
	pMaximumY = pImageHeight;

	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;

	cout << "Enter the Green Component to  Select" << endl;
	cin >> pGreenValueToSelect;


	cout << "Enter the BLue Component to  Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;

	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;

	cout << "Computing the Delta Function Values" << endl;
	pixelDataFile << "Computing the Delta Function Values" << endl;
	float pCentreXValue = 0.0f;
	float pCentreYValue = 0.0f;

	cout << "Enter the X Value of the Centre Pixels: " << endl;
	cin >> pCentreXValue;

	cout << "Enter the Y Value of the Centre Pixels: " << endl;
	cin >> pCentreYValue;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	vector<PixelObject> pSectorOne = vector<PixelObject>();
	vector<PixelObject> pSectorTwo = vector<PixelObject>();
	vector<PixelObject> pSectorThree = vector<PixelObject>();
	vector<PixelObject> pSectorFour = vector<PixelObject>();
	vector<PixelObject> pSectorFive = vector<PixelObject>();
	vector<PixelObject> pSectorSix = vector<PixelObject>();
	vector<PixelObject> pSectorSeven = vector<PixelObject>();
	vector<PixelObject> pSectorEight = vector<PixelObject>();
	vector<PixelObject> pSectorNine = vector<PixelObject>();
	vector<PixelObject> pSectorTen = vector<PixelObject>();
	vector<PixelObject> pSectorEleven = vector<PixelObject>();
	vector<PixelObject> pSectorTwelve = vector<PixelObject>();



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		cout << "Analyzing Data For Sector Eight" << endl;


	
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorEightSectorX);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorEightSectorX)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}


		}

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,

			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorEightSectorY);

		for (PixelObject pixelObject : pixelObjectVectorEightSectorY)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}


		}



		pCommonVectorForFiltering.insert(pCommonVectorForFiltering.end(), pixelObjectVectorEightSectorX.begin(), pixelObjectVectorEightSectorX.end());
		pCommonVectorForFiltering.insert(pCommonVectorForFiltering.end(), pixelObjectVectorEightSectorY.begin(), pixelObjectVectorEightSectorY.end());

		//Cечение 1-1
		float pXPositionScanEightStart = 180.0f;
		float pXPositionScanEightEnd = 680.0f;
		float pYPositionScanEight = 200;

		float pXPositionScanTwoStart = 170.0f;
		float pXPositionScanTwoEnd = 580.0f;
		float pYPositionScanTwo = 400;

		float pXPositionScanThreeStart = 280.0f;
		float pXPositionScanThreeEnd = 560.0f;
		float pYPositionScanThree = 600.0f;

		float pXPositionScanFour = 200.0f;
		float pYPositionScanFourStart = 170.0f;
		float pYPositionScanFourEnd = 430.0f;


		float pXPositionScanFive = 135.0f;
		float pYPositionScanFiveStart = 685.0f;
		float pYPositionScanFiveEnd = 400.0f;


		float pXPositionScanSix = 600.0f;
		float pYPositionScanSixStart = 135.0f;
		float pYPositionScanSixEnd = 315.0f;

		int pOnTheLineLabel = 1;
		int pAboveTheLineLabel = 0;
		int pBelowTheLineLabel = -1;
		int pOnTheLineLabelX = 1;
		int pLeftOfTheLineLabelX = 0;
		int pRightOfTheLineLabelX = -1;






		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputVectorHorizontalEight = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputVectorHorizontalTwo = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputVectorHorizontalThree = vector<OutputPixelObjectCorrespondenceLinearFunction>();

		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputVectorVerticalEight = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputVectorVerticalTwo = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputVectorVerticalThree = vector<OutputPixelObjectCorrespondenceLinearFunction>();


		vector<PixelObject> pOutputVectorHorizontalEightRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorHorizontalTwoRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorHorizontalThreeRestored = vector<PixelObject>();

		vector<PixelObject> pOutputVectorVerticalEightRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorVerticalTwoRestored = vector<PixelObject>();
		vector<PixelObject> pOutputVectorVerticalThreeRestored = vector<PixelObject>();





		cout << "Detecting Line Eight Horizontal" << endl;

		hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstXPosition(hInstance,
			hWnd, pXPositionScanFour,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pAboveTheLineLabel,
			pOnTheLineLabel,
			pBelowTheLineLabel,
			pCommonVectorForFiltering,
			&pOutputVectorVerticalEight);

		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance,
				hWnd, pXPositionScanFour,
				pRedValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pOnTheLineLabel,
				pBelowTheLineLabel,
				pAboveTheLineLabel,
				pOutputVectorVerticalEight,
				&pOutputVectorVerticalEightRestored);


		}





		hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstXPosition(hInstance,
			hWnd, pXPositionScanFive,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pAboveTheLineLabel,
			pOnTheLineLabel,
			pBelowTheLineLabel,
			pCommonVectorForFiltering,
			&pOutputVectorVerticalTwo);


		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance,
				hWnd, pXPositionScanFive,
				pRedValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pOnTheLineLabel,
				pBelowTheLineLabel,
				pAboveTheLineLabel,
				pOutputVectorVerticalTwo,
				&pOutputVectorVerticalTwoRestored);


		}



		hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstXPosition(hInstance,
			hWnd, pXPositionScanSix,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pAboveTheLineLabel,
			pOnTheLineLabel,
			pBelowTheLineLabel,
			pCommonVectorForFiltering,
			&pOutputVectorVerticalThree);


		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance,
				hWnd,
				pXPositionScanSix,
				pRedValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pOnTheLineLabel,
				pBelowTheLineLabel,
				pAboveTheLineLabel,
				pOutputVectorVerticalThree,
				&pOutputVectorVerticalThreeRestored);
		}

		hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstYPosition(hInstance,
			hWnd,
			pYPositionScanEight,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pOnTheLineLabel,
			pLeftOfTheLineLabelX,
			pRightOfTheLineLabelX,
			pCommonVectorForFiltering, &pOutputVectorHorizontalEight);

		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineYPosition(hInstance,
				hWnd, pYPositionScanEight,
				pRedValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pOnTheLineLabel,
				pLeftOfTheLineLabelX,
				pRightOfTheLineLabelX, 
				pOutputVectorHorizontalEight,
				&pOutputVectorHorizontalEightRestored);


		}
		hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstYPosition(hInstance,
			hWnd,
			pYPositionScanTwo,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pOnTheLineLabel,
			pLeftOfTheLineLabelX,
			pRightOfTheLineLabelX,
			pCommonVectorForFiltering,
			&pOutputVectorHorizontalTwo);


		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;




			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance,
				hWnd, pYPositionScanTwo,
				pRedValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pOnTheLineLabel,
				pLeftOfTheLineLabelX,
				pRightOfTheLineLabelX,
				pOutputVectorHorizontalTwo,
				&pOutputVectorHorizontalTwoRestored);


		}


		hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstXPosition(hInstance,
			hWnd, pYPositionScanThree,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pOnTheLineLabel,
			pLeftOfTheLineLabelX,
			pRightOfTheLineLabelX,
			pCommonVectorForFiltering, &pOutputVectorHorizontalThree);

		if (SUCCEEDED(hr))
		{
			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;

			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance,
				hWnd, pYPositionScanThree,
				pRedValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pOnTheLineLabel,
				pLeftOfTheLineLabelX,
				pRightOfTheLineLabelX,
				pOutputVectorHorizontalThree,
				&pOutputVectorHorizontalThreeRestored);


		}


		vector<PixelObject> pCollectionForPixels = vector<PixelObject>();
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorHorizontalEightRestored.begin(), pOutputVectorHorizontalEightRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorHorizontalTwoRestored.begin(), pOutputVectorHorizontalTwoRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorHorizontalThreeRestored.begin(), pOutputVectorHorizontalThreeRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorVerticalEightRestored.begin(), pOutputVectorVerticalEightRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorVerticalTwoRestored.begin(), pOutputVectorVerticalTwoRestored.end());
		pCollectionForPixels.insert(pCollectionForPixels.begin(), pOutputVectorVerticalThreeRestored.begin(), pOutputVectorVerticalThreeRestored.end());






		cout << "Printing the Results of the Valid Pixels" << endl;
		for (PixelObject pixelObject : pCollectionForPixels)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}


		}


		UINT pYValue = 410.0f;
		cout << "Applying Binary Classfier to Image Pixels" << endl;
		vector<OutputPixelObjectFiltered> pOutputPixelArray = vector<OutputPixelObjectFiltered>();
		hr = ppStandardAlgorithmExecutor->SelectPixelsOfColorFromImage(hInstance,
			hWnd, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect, pCollectionForPixels,
			&pOutputPixelArray);

		pIndex = 0;
		for (OutputPixelObjectFiltered pPixelObject : pOutputPixelArray)
		{
			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;

				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
				pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
				pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
				pixelDataFile << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;

				if (pIndex == 10)
				{
					break;
				}
				else
				{
					pIndex = pIndex + 1;

				}

			}
		}

		


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, pOutputPixelArray, &pPixelObjectToProcess);
		for (PixelObject pixelObject : pPixelObjectToProcess)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
			}



			if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition <= pCentreX))
			{
				pSectorOne.push_back(pixelObject);
			}
			else if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition > pCentreX))
			{
				pSectorTwo.push_back(pixelObject);
			}
			else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition <= pCentreX))
			{
				pSectorThree.push_back(pixelObject);
			}
			else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition > pCentreX))
			{
				pSectorFour.push_back(pixelObject);
			}
			if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition <= pCentreX))
			{
				pSectorFive.push_back(pixelObject);
			}
			else if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition > pCentreX))
			{
				pSectorSix.push_back(pixelObject);
			}

			else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition <= pCentreY))
			{
				pSectorSeven.push_back(pixelObject);
			}
			else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition > pCentreY))
			{
				pSectorEight.push_back(pixelObject);
			}
			else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition <= pCentreY))
			{
				pSectorNine.push_back(pixelObject);
			}
			else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition > pCentreY))
			{
				pSectorTen.push_back(pixelObject);
			}
			else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition <= 200.0f))
			{
				pSectorEleven.push_back(pixelObject);
			}
			else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition > 200.0f))
			{
				pSectorTwelve.push_back(pixelObject);
			}

		}



		








		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;


		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;


		cout << "Computing Median X for Sectors 1-6" << endl;
		pixelDataFile << "Computing Median X for Sectors 1-6" << endl;

		pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
		pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
		pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
		pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
		pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
		pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

		cout << "Computing Median Y for Sectors 7-12" << endl;
		pixelDataFile << "Computing Median Y for Sectors 7-12" << endl;

		pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
		pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
		pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
		pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
		pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
		pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

		pXPositionAverageWhole0 = round(pXPositionAverage0);
		pXPositionAverageWhole1 = round(pXPositionAverage1);
		pXPositionAverageWhole2 = round(pXPositionAverage2);
		pXPositionAverageWhole3 = round(pXPositionAverage3);
		pXPositionAverageWhole4 = round(pXPositionAverage4);
		pXPositionAverageWhole5 = round(pXPositionAverage5);

		pYPositionAverageWhole0 = round(pYPositionAverage0);
		pYPositionAverageWhole1 = round(pYPositionAverage1);
		pYPositionAverageWhole2 = round(pYPositionAverage2);
		pYPositionAverageWhole3 = round(pYPositionAverage3);
		pYPositionAverageWhole4 = round(pYPositionAverage4);
		pYPositionAverageWhole5 = round(pYPositionAverage5);








		cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;

		pixelDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		pixelDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		pixelDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		pixelDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		pixelDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		pixelDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		pixelDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		pixelDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		pixelDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		pixelDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		pixelDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		pixelDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;






		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, 0.0f, 0.0f, 0.0f);


		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);



		cout << "Sending the output array for validations" << endl;
		vector<OutputPixelObjectWithAngleValues> pOutputPixelsWithAngleValues = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance, hWnd, pCentreXValue,
			pCentreYValue, pCommonPixelObjectArrayOneRGB,
			&pOutputPixelsWithAngleValues);

		cout << "Printing the Results of the Simulation " << endl;



		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		pixelDataFile << "Printing Tangent Data " << endl;

		std::sort(pOutputPixelsWithAngleValues.begin(), pOutputPixelsWithAngleValues.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

		for (OutputPixelObjectWithAngleValues pPixelObject : pOutputPixelsWithAngleValues)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


		cout << "Printing Sector One" << endl;
		pixelDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		pixelDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		pixelDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		pixelDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		pixelDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		pixelDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		pixelDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		pixelDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





		vector<Point2D> pPointArrayToDraw = vector<Point2D>();



		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}

		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointArrayToDraw);




		float pSectorLength12 = 0.0f;
		float pSectorLength23 = 0.0f;
		float pSectorLength34 = 0.0f;
		float pSectorLength45 = 0.0f;
		float pSectorLength56 = 0.0f;
		float pSectorLength67 = 0.0f;
		float pSectorLength78 = 0.0f;
		float pSectorLength89 = 0.0f;
		float pSectorLength910 = 0.0f;
		float pSectorLength1011 = 0.0f;
		float pSectorLength1112 = 0.0f;
		float pSectorLength1201 = 0.0f;

		float pSectorLength1Centre = 0.0f;
		float pSectorLength2Centre = 0.0f;
		float pSectorLength3Centre = 0.0f;
		float pSectorLength4Centre = 0.0f;
		float pSectorLength5Centre = 0.0f;
		float pSectorLength6Centre = 0.0f;
		float pSectorLength7Centre = 0.0f;
		float pSectorLength8Centre = 0.0f;
		float pSectorLength9Centre = 0.0f;
		float pSectorLength10Centre = 0.0f;
		float pSectorLength11Centre = 0.0f;
		float pSectorLength12Centre = 0.0f;


		Point2D pPointOne = pPointArrayToDraw[0];
		Point2D pPointTwo = pPointArrayToDraw[1];
		Point2D pPointThree = pPointArrayToDraw[2];

		Point2D pPointFour = pPointArrayToDraw[3];
		Point2D pPointFive = pPointArrayToDraw[4];
		Point2D pPointSix = pPointArrayToDraw[5];
		Point2D pPointSeven = pPointArrayToDraw[6];
		Point2D pPointEight = pPointArrayToDraw[7];
		Point2D pPointNine = pPointArrayToDraw[8];
		Point2D pPointTen = pPointArrayToDraw[9];
		Point2D pPointEleven = pPointArrayToDraw[10];
		Point2D pPointTwelve = pPointArrayToDraw[11];




		pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
		pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
		pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
		pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
		pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
		pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
		pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
		pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
		pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
		pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
		pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
		pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

		pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
		pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
		pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
		pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
		pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
		pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
		pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
		pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
		pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
		pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
		pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
		pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



		Line2D pLine12;
		pLine12.pLineNumber = 1;
		pLine12.pPointOne = pPointOne;
		pLine12.pPointTwo = pPointTwo;
		pLine12.pLineWidth = pSectorLength12;



		Line2D pLine23;
		pLine23.pLineNumber = 2;
		pLine23.pPointOne = pPointTwo;
		pLine23.pPointTwo = pPointThree;
		pLine23.pLineWidth = pSectorLength23;


		Line2D pLine34;
		pLine34.pLineNumber = 3;
		pLine34.pPointOne = pPointThree;
		pLine34.pPointTwo = pPointFour;
		pLine34.pLineWidth = pSectorLength34;


		Line2D pLine45;
		pLine45.pLineNumber = 4;
		pLine45.pPointOne = pPointFour;
		pLine45.pPointTwo = pPointFive;
		pLine45.pLineWidth = pSectorLength45;


		Line2D pLine56;
		pLine56.pLineNumber = 5;
		pLine56.pPointOne = pPointFive;
		pLine56.pPointTwo = pPointSix;
		pLine56.pLineWidth = pSectorLength56;


		Line2D pLine67;
		pLine67.pLineNumber = 6;
		pLine67.pPointOne = pPointSix;
		pLine67.pPointTwo = pPointSeven;
		pLine67.pLineWidth = pSectorLength67;


		Line2D pLine78;
		pLine78.pLineNumber = 7;
		pLine78.pPointOne = pPointSeven;
		pLine78.pPointTwo = pPointEight;
		pLine78.pLineWidth = pSectorLength78;

		Line2D pLine89;
		pLine89.pLineNumber = 8;
		pLine89.pPointOne = pPointEight;
		pLine89.pPointTwo = pPointNine;
		pLine89.pLineWidth = pSectorLength89;


		Line2D pLine910;
		pLine910.pLineNumber = 9;
		pLine910.pPointOne = pPointNine;
		pLine910.pPointTwo = pPointTen;
		pLine910.pLineWidth = pSectorLength910;


		Line2D pLine1011;
		pLine1011.pLineNumber = 10;
		pLine1011.pPointOne = pPointTen;
		pLine1011.pPointTwo = pPointEleven;
		pLine1011.pLineWidth = pSectorLength1011;


		Line2D pLine1112;
		pLine1112.pLineNumber = 11;
		pLine1112.pPointOne = pPointEleven;
		pLine1112.pPointTwo = pPointTwelve;
		pLine1112.pLineWidth = pSectorLength1112;


		Line2D pLine1201;
		pLine1201.pLineNumber = 12;
		pLine1201.pPointOne = pPointTwelve;
		pLine1201.pPointTwo = pPointOne;
		pLine1201.pLineWidth = pSectorLength1201;

		Line2D pLineOneCentre;
		pLineOneCentre.pLineNumber = 13;
		pLineOneCentre.pPointOne = pPointOne;
		pLineOneCentre.pPointTwo = pCentre;
		pLineOneCentre.pLineWidth = pSectorLength1Centre;

		Line2D pLineTwoCentre;
		pLineTwoCentre.pLineNumber = 15;
		pLineTwoCentre.pPointOne = pPointTwo;
		pLineTwoCentre.pPointTwo = pCentre;
		pLineTwoCentre.pLineWidth = pSectorLength2Centre;

		Line2D pLineThreeCentre;
		pLineThreeCentre.pLineNumber = 16;
		pLineThreeCentre.pPointOne = pPointThree;
		pLineThreeCentre.pPointTwo = pCentre;
		pLineThreeCentre.pLineWidth = pSectorLength3Centre;


		Line2D pLineFourCentre;
		pLineFourCentre.pLineNumber = 16;
		pLineFourCentre.pPointOne = pPointFour;
		pLineFourCentre.pPointTwo = pCentre;
		pLineFourCentre.pLineWidth = pSectorLength4Centre;


		Line2D pLineFiveCentre;
		pLineFiveCentre.pLineNumber = 17;
		pLineFiveCentre.pPointOne = pPointFive;
		pLineFiveCentre.pPointTwo = pCentre;
		pLineFiveCentre.pLineWidth = pSectorLength5Centre;


		Line2D pLineSixCentre;
		pLineSixCentre.pLineNumber = 18;
		pLineSixCentre.pPointOne = pPointSix;
		pLineSixCentre.pPointTwo = pCentre;
		pLineSixCentre.pLineWidth = pSectorLength6Centre;


		Line2D pLineSevenCentre;
		pLineSevenCentre.pLineNumber = 19;
		pLineSevenCentre.pPointOne = pPointSeven;
		pLineSevenCentre.pPointTwo = pCentre;
		pLineSevenCentre.pLineWidth = pSectorLength7Centre;


		Line2D pLineEightCentre;
		pLineEightCentre.pLineNumber = 20;
		pLineEightCentre.pPointOne = pPointEight;
		pLineEightCentre.pPointTwo = pCentre;
		pLineEightCentre.pLineWidth = pSectorLength8Centre;


		Line2D pLineNineCentre;
		pLineNineCentre.pLineNumber = 21;
		pLineNineCentre.pPointOne = pPointNine;
		pLineNineCentre.pPointTwo = pCentre;
		pLineNineCentre.pLineWidth = pSectorLength9Centre;


		Line2D pLineTenCentre;
		pLineTenCentre.pLineNumber = 22;
		pLineTenCentre.pPointOne = pPointTen;
		pLineTenCentre.pPointTwo = pCentre;
		pLineTenCentre.pLineWidth = pSectorLength10Centre;


		Line2D pLineElevenCentre;
		pLineElevenCentre.pLineNumber = 23;
		pLineElevenCentre.pPointOne = pPointEleven;
		pLineElevenCentre.pPointTwo = pCentre;
		pLineElevenCentre.pLineWidth = pSectorLength11Centre;


		Line2D pLineTwelveCentre;
		pLineTwelveCentre.pLineNumber = 24;
		pLineTwelveCentre.pPointOne = pPointTwelve;
		pLineTwelveCentre.pPointTwo = pCentre;
		pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








		float pTriangleOneArea = 0.0f;
		float pTriangleTwoArea = 0.0f;
		float pTriangleThreeArea = 0.0f;
		float pTriangleFourArea = 0.0f;
		float pTriangleFiveArea = 0.0f;
		float pTriangleSixArea = 0.0f;
		float pTriangleSevenArea = 0.0f;
		float pTriangleEightArea = 0.0f;
		float pTriangleNineArea = 0.0f;
		float pTriangleTenArea = 0.0f;
		float pTriangleElevenArea = 0.0f;
		float pTriangleTwelveArea = 0.0f;





		float pTriangleAreaTotal = 0.0f;
		pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
		pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
		pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
		pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
		pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
		pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
		pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
		pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
		pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
		pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
		pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
		pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
		pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

		cout << "Triangle One Area: " << pTriangleOneArea << endl;
		cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
		cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
		cout << "Triangle Four Area: " << pTriangleFourArea << endl;
		cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
		cout << "Triangle Six Area: " << pTriangleSixArea << endl;
		cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
		cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
		cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
		cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

		pixelDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
		pixelDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
		pixelDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
		pixelDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
		pixelDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
		pixelDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
		pixelDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		pixelDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
		pixelDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
		pixelDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
		pixelDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		pixelDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


		cout << "Constructing Triangle Structures" << endl;
		TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
			pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
		TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
			pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
		TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
			pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
		TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
			pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
		TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
			pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
		TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
			pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
		TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
			pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
		TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
			pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
		TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
			pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
		TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
			pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
		TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
			pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
		TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
			pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

		cout << "Storing Our Triangle Data into A Vector" << endl;
		pixelDataFile << "Storing Our Triangle Data into A Vector" << endl;

		vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
		pTriangleObjectVector.push_back(pTriangleObjectOne);
		pTriangleObjectVector.push_back(pTriangleObjectTwo);
		pTriangleObjectVector.push_back(pTriangleObjectThree);
		pTriangleObjectVector.push_back(pTriangleObjectFour);
		pTriangleObjectVector.push_back(pTriangleObjectFive);
		pTriangleObjectVector.push_back(pTriangleObjectSix);
		pTriangleObjectVector.push_back(pTriangleObjectSeven);
		pTriangleObjectVector.push_back(pTriangleObjectEight);
		pTriangleObjectVector.push_back(pTriangleObjectNine);
		pTriangleObjectVector.push_back(pTriangleObjectTen);
		pTriangleObjectVector.push_back(pTriangleObjectEleven);
		pTriangleObjectVector.push_back(pTriangleObjectTwelve);

		for (TriangleObject pTriangleObject : pTriangleObjectVector)
		{
			cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			cout << "Point A:" << endl;
			cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			cout << "Point B:" << endl;
			cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			cout << "Point C:" << endl;
			cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			cout << "Area = " << pTriangleObject.pTriangleArea << endl;

			pixelDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			pixelDataFile << "Point A:" << endl;
			pixelDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			pixelDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
			pixelDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			pixelDataFile << "Point B:" << endl;
			pixelDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			pixelDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
			pixelDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			pixelDataFile << "Point C:" << endl;
			pixelDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			pixelDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
			pixelDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			pixelDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			pixelDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			pixelDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			pixelDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			pixelDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
		}




		cout << "Computing Perimeter for the Shape" << endl;
		float pShapePerimeter = 0.0f;
		pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


		cout << "Perimeter Value: " << pShapePerimeter << endl;
		pixelDataFile << "Perimeter Value: " << pShapePerimeter << endl;






		cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
		pixelDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorEightSectorX.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorEightSectorY.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		pixelDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		pixelDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}

	pixelDataFile.close();
	imageSectorsData.close();

	return hr;

	}








HRESULT DirectXGPUDigitalLabCoreModule::ComputeHypotenuseValues(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ComputeHypotenuseValuesForImages.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream pixelDataFilePixels;
	pixelDataFilePixels.open("C:\\pixels\\PixelsBank.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFilePixels.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;


	vector<PixelObject> pCommonVectorForFiltering = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorEightSectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorEightSectorY = vector<PixelObject>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;




	ID2D1Bitmap* pBitmapData = nullptr;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;



	cout << "Enter the X Value for Top Left Position of the Image Sector Eight" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector Eight" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width Of the Image" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height Of the Image" << endl;
	cin >> pImageHeight;


	pMaximumX = pImageWidth;
	pMaximumY = pImageHeight;

	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;

	cout << "Enter the Green Component to  Select" << endl;
	cin >> pGreenValueToSelect;


	cout << "Enter the BLue Component to  Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;

	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;

	cout << "Computing the Delta Function Values" << endl;
	pixelDataFile << "Computing the Delta Function Values" << endl;
	float pCentreXValue = 0.0f;
	float pCentreYValue = 0.0f;

	cout << "Enter the X Value of the Centre Pixels: " << endl;
	cin >> pCentreXValue;

	cout << "Enter the Y Value of the Centre Pixels: " << endl;
	cin >> pCentreYValue;


	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		cout << "Analyzing Data For Sector Eight" << endl;



		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorEightSectorX);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorEightSectorX)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorEightSectorY);

		for (PixelObject pixelObject : pixelObjectVectorEightSectorY)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		float pPointEightXPosition = 0.0f;
		float pPointEightYPosition = 0.0f;

		float pPointTwoXPosition = 0.0f;
		float pPointTwoYPosition = 0.0f;

		float pPointThreeXPosition = 0.0f;
		float pPointThreeYPosition = 0.0f;

		cout << "Enter the X Position Of Point Eight" << endl;
		cin >> pPointEightXPosition;

		cout << "Enter the Y Position Of Point Eight" << endl;
		cin >> pPointEightYPosition;


		cout << "Enter the X Position Of Point Two" << endl;
		cin >> pPointTwoXPosition;

		cout << "Enter the Y Position Of Point Two" << endl;
		cin >> pPointTwoYPosition;


		cout << "Enter the X Position Of Point Three" << endl;
		cin >> pPointThreeXPosition;

		cout << "Enter the Y Position Of Point Three" << endl;
		cin >> pPointThreeYPosition;


		cout << "Point A" << endl;
		cout << "X Position: " << pPointEightXPosition << endl;
		cout << "Y Position: " << pPointEightYPosition << endl;

		cout << "Point B" << endl;
		cout << "X Position: " << pPointTwoXPosition << endl;
		cout << "Y Position: " << pPointTwoYPosition << endl;


		cout << "Point C" << endl;
		cout << "X Position: " << pPointThreeXPosition << endl;
		cout << "Y Position: " << pPointThreeYPosition << endl;


		pixelDataFile << "Point A" << endl;
		pixelDataFile << "X Position: " << pPointEightXPosition << endl;
		cout << "Y Position: " << pPointEightYPosition << endl;

		pixelDataFile << "Point B" << endl;
		pixelDataFile << "X Position: " << pPointTwoXPosition << endl;
		pixelDataFile << "Y Position: " << pPointTwoYPosition << endl;


		pixelDataFile << "Point C" << endl;
		pixelDataFile << "X Position: " << pPointThreeXPosition << endl;
		pixelDataFile << "Y Position: " << pPointThreeYPosition << endl;


		cout << "Computing Lengths Of Our Vectors" << endl;
		pixelDataFile << "Computing Lengths Of Our Vectors" << endl;


		float pABLength = 0.0f;
		float pBCLength = 0.0f;
		float pACLength = 0.0f;

		pABLength = sqrtf(pow((pPointTwoXPosition - pPointEightXPosition), 2.0f) + pow((pPointTwoYPosition - pPointEightYPosition), 2));
		pBCLength = sqrtf(pow((pPointThreeXPosition - pPointTwoXPosition), 2.0f) + pow((pPointThreeYPosition - pPointTwoYPosition), 2));
		pACLength = sqrtf(pow((pPointThreeXPosition - pPointEightXPosition), 2.0f) + pow((pPointThreeYPosition - pPointEightYPosition), 2));


		cout << "Computing the Slopes of Our Vector - the K Coefficients" << endl;
		float pABSlope = 0.0f;
		float pBCSlope = 0.0f;
		float pACSlope = 0.0f;

		pABSlope = (pPointTwoYPosition - pPointEightYPosition) / (pPointTwoXPosition - pPointEightXPosition);
		pBCSlope = (pPointThreeYPosition - pPointTwoYPosition) / (pPointThreeXPosition - pPointTwoXPosition);
		pACSlope = (pPointThreeYPosition - pPointEightYPosition) / (pPointThreeXPosition - pPointEightXPosition);



		cout << "Computing Coefficients" << endl;
		float pCoefficient0 = 0.0f;
		float pCoefficient1 = 0.0f;
		float pCoefficient2 = 0.0f;



		pCoefficient0 = pPointEightYPosition - pABSlope * pPointEightXPosition;
		pCoefficient1 = pPointTwoYPosition - pBCSlope * pPointTwoXPosition;
		pCoefficient2 = pPointThreeYPosition - pACSlope * pPointThreeXPosition;


		cout << "Vector AB has a form of y = a*x +b Where " << endl;
		cout << "A = " << pABSlope << endl;
		cout << "B =" << pCoefficient0 << endl;

		cout << "Vector BC has a form of y = a*x +b Where " << endl;
		cout << "A = " << pBCSlope << endl;
		cout << "B =" << pCoefficient1 << endl;

		cout << "Vector AC has a form of y = a*x +b Where " << endl;
		cout << "A = " << pACSlope << endl;
		cout << "B =" << pCoefficient2 << endl;


		pixelDataFile << "Vector AB has a form of y = a*x +b Where " << endl;
		pixelDataFile << "A = " << pABSlope << endl;
		pixelDataFile << "B =" << pCoefficient0 << endl;

		pixelDataFile << "Vector BC has a form of y = a*x +b Where " << endl;
		pixelDataFile << "A = " << pBCSlope << endl;
		pixelDataFile << "B =" << pCoefficient1 << endl;

		pixelDataFile << "Vector AC has a form of y = a*x +b Where " << endl;
		pixelDataFile << "A = " << pACSlope << endl;
		pixelDataFile << "B =" << pCoefficient2 << endl;


		cout << "Slope of AB Vector K0: " << pABSlope << endl;
		pixelDataFile << "Slope of AB Vector K1: " << pABSlope << endl;

		cout << "Slope of BC Vector K1: " << pBCSlope << endl;
		pixelDataFile << "sPOE of K1 Vector: " << pBCSlope << endl;

		cout << "SLope of AC Vector: " << pACSlope << endl;
		pixelDataFile << "Slope of AC Vector: " << pACSlope << endl;




		cout << "Length of AB Vector: " << pABLength << endl;
		pixelDataFile << "Length of AB Vector: " << pABLength << endl;

		cout << "Length of BC Vector: " << pBCLength << endl;
		pixelDataFile << "Length of AB Vector: " << pBCLength << endl;

		cout << "Length of AC Vector: " << pACLength << endl;
		pixelDataFile << "Length of AC Vector: " << pACLength << endl;


	}
	

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFilePixels.close();

		pixelDataFile.close();
		return hr;

	}





HRESULT DirectXGPUDigitalLabCoreModule::DestroyWhiteFontFromGraph(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DestroyWhiteCol.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;



	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToIgnore = 0.0f;
	float pGreenValueToIgnore = 0.0f;
	float pBlueValueToIgnore = 0.0f;


	cout << "Enter the Red Component To Ignore" << endl;
	cin >> pRedValueToIgnore;

	cout << "Enter the Green Component to Ignore" << endl;
	cin >> pGreenValueToIgnore;


	cout << "Enter the BLue Component to Ignore" << endl;
	cin >> pBlueValueToIgnore;



	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();

		hr = ppStandardAlgorithmExecutor->DestroyWhiteFontFromGraph(hInstance, hWnd,
			pRedValueToIgnore,
			pGreenValueToIgnore,
			pBlueValueToIgnore,
			pixelObjectVector,
			&ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;


		int pPixelNumberOutput = 0.0f;
		float pXValueOutput = 0.0f;
		float pYValueOutput = 0.0f;
		float pRedComponentOutput = 0.0f;
		float pGreenComponentOutput = 0.0f;
		float pBlueComponentOutput = 0.0f;
		bool pUsedInComputations = false;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputPixelVector)
		{

			pPixelNumberOutput = pPixelObject.pixelNumber;
			pXValueOutput = pPixelObject.xPosition;
			pYValueOutput = pPixelObject.yPosition;
			pRedComponentOutput = pPixelObject.rValue;
			pGreenComponentOutput = pPixelObject.gValue;
			pBlueComponentOutput = pPixelObject.bValue;
			pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumberOutput << endl;
			cout << "X Value = " << pXValueOutput << endl;
			cout << "Y Value = " << pYValueOutput << endl;
			cout << "Red Component = " << pRedComponentOutput << endl;
			cout << "Green Component = " << pGreenComponentOutput << endl;
			cout << "Blue Component = " << pBlueComponentOutput << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumberOutput << endl;
			pixelDataFile << "X Value = " << pXValueOutput << endl;
			pixelDataFile << "Y Value = " << pYValueOutput << endl;
			pixelDataFile << "Red Component = " << pRedComponentOutput << endl;
			pixelDataFile << "Green Component = " << pGreenComponentOutput << endl;
			pixelDataFile << "Blue Component = " << pBlueComponentOutput << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			pIndexValue++;
		}

		vector<PixelObject> ppRecoveredPixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, ppOutputPixelVector, &ppRecoveredPixelArray);

		for (PixelObject pixelObject : ppRecoveredPixelArray)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		LPCWSTR pImageFIle = L"C:\\RobotData\\CompressedImageFromFilter.jpg";

		int pImageWidthVar = sqrt(ppRecoveredPixelArray.size());
		int pImageHeighthVar = sqrt(ppRecoveredPixelArray.size());




		cout << "Drawing Our Square on the screen" << endl;
		hr = md2dmanager->DrawPixelBuffer(hInstance, hWnd, ppRecoveredPixelArray, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);


	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::DetectObjectOfSpatialShapeOnWhiteFontSeventhExperiment(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";


	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectSeventhExperimentRGBFilterColors.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();


	float pStepX = 0.0f;
	float pStepY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();


	float pCentreX = 430.0;
	float pCentreY = 410.0f;

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;




	vector<PixelObject> pSectorOne = vector<PixelObject>();
	vector<PixelObject> pSectorTwo = vector<PixelObject>();
	vector<PixelObject> pSectorThree = vector<PixelObject>();
	vector<PixelObject> pSectorFour = vector<PixelObject>();
	vector<PixelObject> pSectorFive = vector<PixelObject>();
	vector<PixelObject> pSectorSix = vector<PixelObject>();
	vector<PixelObject> pSectorSeven = vector<PixelObject>();
	vector<PixelObject> pSectorEight = vector<PixelObject>();
	vector<PixelObject> pSectorNine = vector<PixelObject>();
	vector<PixelObject> pSectorTen = vector<PixelObject>();
	vector<PixelObject> pSectorEleven = vector<PixelObject>();
	vector<PixelObject> pSectorTwelve = vector<PixelObject>();




	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;




	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());




		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		cout << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		start = high_resolution_clock::now();

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGBWithColors(hInstance,
			hWnd,
			pTopLeftX,
			pTopLeftY,
			pImageWidth,
			pImageHeight,
			pRedValueToSelect,
			pRedValueToSelect,
			pGreenValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&pFilteredObjectArrayRGBOne);

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);
		cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
				endl;
			imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
				pLastError << endl;
			imageSegmentationDataFile.close();
			return hr;
		}
		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by RGB Filter: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << " " << endl;
		cout << " " << endl;
		cout << "New Operation Begin" << endl;
		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		cout << "Printing Output" << endl;
		UINT pIndexValue = 0;


		vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		start = high_resolution_clock::now();

		SYSTEMTIME restorationStartSystem;
		SYSTEMTIME restorationStartLocal;

		GetSystemTime(&restorationStartSystem);
		GetLocalTime(&restorationStartLocal);
		cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
			hWnd,
			pFilteredObjectArrayRGBOne,
			&pFilteredObjectArrayRGBOneRestored);
		cout << "Printing the Results of the Valid Pixels" << endl;


		SYSTEMTIME restorationEndSystem;
		SYSTEMTIME restorationEndLocal;

		GetSystemTime(&restorationEndSystem);
		GetLocalTime(&restorationEndLocal);
		cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
		{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



				if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorOne.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 200.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorTwo.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorThree.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 400.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorFour.push_back(pixelObject);
				}
				if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition <= pCentreX))
				{
					pSectorFive.push_back(pixelObject);
				}
				else if ((pixelObject.yPosition == 600.0f) && (pixelObject.xPosition > pCentreX))
				{
					pSectorSix.push_back(pixelObject);
				}

				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorSeven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 200.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorEight.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition <= pCentreY))
				{
					pSectorNine.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 400.0f) && (pixelObject.yPosition > pCentreY))
				{
					pSectorTen.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition <= 200.0f))
				{
					pSectorEleven.push_back(pixelObject);
				}
				else if ((pixelObject.xPosition == 600.0f) && (pixelObject.yPosition > 200.0f))
				{
					pSectorTwelve.push_back(pixelObject);
				}
			
		}





		cout << "Printing Sector One Values" << endl;
		imageSegmentationDataFile << "Printing Sector One Values" << endl;
		imageSectorsData << "Printing Sector One Values" << endl;
		vector<float> pXArrayOne = vector<float>();


		for (PixelObject pixelObject : pSectorOne)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;
		}



		cout << "Printing Sector Two Values" << endl;
		imageSegmentationDataFile << "Printing Sector Two Values" << endl;

		for (PixelObject pixelObject : pSectorTwo)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Printing Sector 3 Values" << endl;
		imageSegmentationDataFile << "Printing Sector 3 Values" << endl;

		for (PixelObject pixelObject : pSectorThree)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}




		cout << "Sector Four" << endl;
		imageSegmentationDataFile << "Sector Four" << endl;
		imageSectorsData << "Sector Four" << endl;

		for (PixelObject pixelObject : pSectorFour)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}


		cout << "Sector Five" << endl;
		imageSegmentationDataFile << "Sector Five" << endl;
		imageSectorsData << "Sector Five" << endl;

		for (PixelObject pixelObject : pSectorFive)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;





		cout << "Sector Six" << endl;
		imageSegmentationDataFile << "Sector Six" << endl;
		imageSectorsData << "Sector Six" << endl;


		for (PixelObject pixelObject : pSectorSix)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;

		}

		imageSectorsData << "Sector End" << endl;


		cout << "Sector Seven" << endl;
		imageSegmentationDataFile << "Sector Seven" << endl;
		imageSectorsData << "Sector Seven: " << endl;


		for (PixelObject pixelObject : pSectorSeven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;


		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Eight" << endl;
		imageSegmentationDataFile << "Printing Sector Eight" << endl;
		imageSectorsData << "Sector Eight: " << endl;

		for (PixelObject pixelObject : pSectorEight)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Nine" << endl;
		imageSegmentationDataFile << "Printing Sector Nine" << endl;
		imageSectorsData << "Sector Nine: " << endl;

		for each (PixelObject pixelObject in pSectorNine)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Ten" << endl;
		imageSegmentationDataFile << "Printing Sector Ten" << endl;
		imageSectorsData << "Printing Sector Ten" << endl;


		for each (PixelObject pixelObject in pSectorTen)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Eleven" << endl;
		imageSegmentationDataFile << "Printing Sector Eleven" << endl;
		imageSectorsData << "Printing Sector Eleven" << endl;

		for (PixelObject pixelObject : pSectorEleven)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Printing Sector Twelve" << endl;
		imageSegmentationDataFile << "Printing Sector Twelve" << endl;
		imageSectorsData << "Printing Sector Twelve" << endl;


		for (PixelObject pixelObject : pSectorTwelve)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			imageSectorsData << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pixelObject.yPosition << endl;
			imageSectorsData << "Red Value: " << pixelObject.RMask << endl;
			imageSectorsData << "Green Value: " << pixelObject.GMask << endl;
			imageSectorsData << "Blue Value: " << pixelObject.BMask << endl;



		}



		float pXPositionAverage0 = 0.0f;
		float pXPositionAverage1 = 0.0f;
		float pXPositionAverage2 = 0.0f;
		float pXPositionAverage3 = 0.0f;
		float pXPositionAverage4 = 0.0f;
		float pXPositionAverage5 = 0.0f;


		float pYPositionAverage0 = 0.0f;
		float pYPositionAverage1 = 0.0f;
		float pYPositionAverage2 = 0.0f;
		float pYPositionAverage3 = 0.0f;
		float pYPositionAverage4 = 0.0f;
		float pYPositionAverage5 = 0.0f;


		float pXPositionAverageWhole0 = 0.0f;
		float pXPositionAverageWhole1 = 0.0f;
		float pXPositionAverageWhole2 = 0.0f;
		float pXPositionAverageWhole3 = 0.0f;
		float pXPositionAverageWhole4 = 0.0f;
		float pXPositionAverageWhole5 = 0.0f;


		float pYPositionAverageWhole0 = 0.0f;
		float pYPositionAverageWhole1 = 0.0f;
		float pYPositionAverageWhole2 = 0.0f;
		float pYPositionAverageWhole3 = 0.0f;
		float pYPositionAverageWhole4 = 0.0f;
		float pYPositionAverageWhole5 = 0.0f;


		cout << "Computing Median X for Sectors 1-6" << endl;
		imageSegmentationDataFile << "Computing Median X for Sectors 1-6" << endl;

		pXPositionAverage0 = ComputeMedianForPixelArrayForXValue(pSectorOne);
		pXPositionAverage1 = ComputeMedianForPixelArrayForXValue(pSectorTwo);
		pXPositionAverage2 = ComputeMedianForPixelArrayForXValue(pSectorThree);
		pXPositionAverage3 = ComputeMedianForPixelArrayForXValue(pSectorFour);
		pXPositionAverage4 = ComputeMedianForPixelArrayForXValue(pSectorFive);
		pXPositionAverage5 = ComputeMedianForPixelArrayForXValue(pSectorSix);

		cout << "Computing Median Y for Sectors 7-12" << endl;
		imageSegmentationDataFile << "Computing Median Y for Sectors 7-12" << endl;

		pYPositionAverage0 = ComputeMedianForPixelArrayForYValue(pSectorSeven);
		pYPositionAverage1 = ComputeMedianForPixelArrayForYValue(pSectorEight);
		pYPositionAverage2 = ComputeMedianForPixelArrayForYValue(pSectorNine);
		pYPositionAverage3 = ComputeMedianForPixelArrayForYValue(pSectorTen);
		pYPositionAverage4 = ComputeMedianForPixelArrayForYValue(pSectorEleven);
		pYPositionAverage5 = ComputeMedianForPixelArrayForYValue(pSectorTwelve);

		pXPositionAverageWhole0 = round(pXPositionAverage0);
		pXPositionAverageWhole1 = round(pXPositionAverage1);
		pXPositionAverageWhole2 = round(pXPositionAverage2);
		pXPositionAverageWhole3 = round(pXPositionAverage3);
		pXPositionAverageWhole4 = round(pXPositionAverage4);
		pXPositionAverageWhole5 = round(pXPositionAverage5);

		pYPositionAverageWhole0 = round(pYPositionAverage0);
		pYPositionAverageWhole1 = round(pYPositionAverage1);
		pYPositionAverageWhole2 = round(pYPositionAverage2);
		pYPositionAverageWhole3 = round(pYPositionAverage3);
		pYPositionAverageWhole4 = round(pYPositionAverage4);
		pYPositionAverageWhole5 = round(pYPositionAverage5);








		cout << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		cout << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		cout << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		cout << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		cout << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		cout << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		cout << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		cout << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		cout << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		cout << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		cout << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		cout << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;


		imageSegmentationDataFile << "Average X for Sector 1 = " << pXPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average X for Sector 2 = " << pXPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average X for Sector 3 = " << pXPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average X for Sector 4 = " << pXPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average X for Sector 5 = " << pXPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average X for Sector 6 = " << pXPositionAverageWhole5 << endl;

		imageSegmentationDataFile << "Average Y for Sector 7 = " << pYPositionAverageWhole0 << endl;
		imageSegmentationDataFile << "Average Y for Sector 8 = " << pYPositionAverageWhole1 << endl;
		imageSegmentationDataFile << "Average Y for Sector 9 = " << pYPositionAverageWhole2 << endl;
		imageSegmentationDataFile << "Average Y for Sector 10 = " << pYPositionAverageWhole3 << endl;
		imageSegmentationDataFile << "Average Y for Sector 11 = " << pYPositionAverageWhole4 << endl;
		imageSegmentationDataFile << "Average Y for Sector 12 = " << pYPositionAverageWhole5 << endl;






		vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreOne = PixelObject(1, pXPositionAverageWhole0, 200.0f, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, pXPositionAverageWhole1, 200.0f, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreThree = PixelObject(3, pXPositionAverageWhole2, 400.0f, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreFour = PixelObject(4, pXPositionAverageWhole3, 400.0f, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreFive = PixelObject(5, pXPositionAverageWhole4, 600.0f, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreSix = PixelObject(6, pXPositionAverageWhole5, 600.0f, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, pYPositionAverageWhole0, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreEight = PixelObject(8, 200, pYPositionAverageWhole1, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, pYPositionAverageWhole2, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, pYPositionAverageWhole3, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, pYPositionAverageWhole4, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, pYPositionAverageWhole5, pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect);


		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreOne);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayOneRGB.push_back(pPixelObjectCentreTwelve);

		cout << "Computing Pixel Object Centres Tangients" << endl;
		imageSectorsData << "Computing Pixel Object Centres Tangents" << endl;


		SYSTEMTIME computeDeltaStartSystem;
		SYSTEMTIME computeDeltaStartLocal;

		GetSystemTime(&computeDeltaStartSystem);
		GetLocalTime(&computeDeltaStartLocal);
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		cout << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
			restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Started: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
			restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pCommonOutputVectorTrig = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayOneRGB, &pCommonOutputVectorTrig);

		SYSTEMTIME computeDeltaEndSystem;
		SYSTEMTIME computeDeltaEndLocal;

		GetSystemTime(&computeDeltaEndSystem);
		GetLocalTime(&computeDeltaEndLocal);
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		cout << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
			restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
		imageSegmentationDataFile << "Compute Delta Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
			restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorOne = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();

		imageSectorsData << "Printing Tangent Data " << endl;
		imageSegmentationDataFile << "Printing Tangent Data " << endl;

		std::sort(pCommonOutputVectorTrig.begin(), pCommonOutputVectorTrig.end(), WayToSortPixelsWihtAnglesAscendingAgainstQuarters);

		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVectorTrig)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			if (pPixelObject.pQuarterNumberVar == 1.0f)
			{
				pVectorPointsSectorOne.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 2.0f)
			{
				pVectorPointsSectorTwo.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 3.0f)
			{
				pVectorPointsSectorThree.push_back(pPixelObject);
			}
			else if (pPixelObject.pQuarterNumberVar == 4.0f)
			{
				pVectorPointsSectorFour.push_back(pPixelObject);
			}







		}
		imageSectorsData << "Tangent One " << endl;

		cout << "Sorting Our Vectors" << endl;

		std::sort(pVectorPointsSectorOne.begin(), pVectorPointsSectorOne.end(), WayToSortPixelsWihtAnglesAscendingAgainstSines);
		std::sort(pVectorPointsSectorTwo.begin(), pVectorPointsSectorTwo.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorThree.begin(), pVectorPointsSectorThree.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);
		std::sort(pVectorPointsSectorFour.begin(), pVectorPointsSectorFour.end(), WayToSortPixelsWihtAnglesDescendingAgainstSines);


		cout << "Printing Sector One" << endl;
		imageSegmentationDataFile << "Printing Sector One" << endl;
		imageSectorsData << "Printing Sector One" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;



		cout << "Printing Sector Two" << endl;
		imageSegmentationDataFile << "Printing Sector Two" << endl;
		imageSectorsData << "Printing Sector Two" << endl;

		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorTwo)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;

		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Three" << endl;
		imageSegmentationDataFile << "Printing Sector Three" << endl;
		imageSectorsData << "Printing Sector Three" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorThree)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;


		cout << "Printing Sector Four" << endl;
		imageSegmentationDataFile << "Printing Sector four" << endl;
		imageSectorsData << "Printing Sector four" << endl;


		for (OutputPixelObjectWithAngleValues pPixelObject : pVectorPointsSectorFour)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;

			imageSectorsData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSectorsData << "X Position: " << pPixelObject.xPosition << endl;
			imageSectorsData << "Y Position: " << pPixelObject.yPosition << endl;
			imageSectorsData << "Red Component: " << pPixelObject.rValue << endl;
			imageSectorsData << "Green Component: " << pPixelObject.gValue << endl;
			imageSectorsData << "Blue Component: " << pPixelObject.bValue << endl;
			imageSectorsData << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			imageSectorsData << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			imageSectorsData << "Radius: " << pPixelObject.pRadiusValue << endl;
			imageSectorsData << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			imageSectorsData << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			imageSectorsData << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			imageSectorsData << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





		}
		imageSegmentationDataFile << "Sector End" << endl;
		imageSectorsData << "Sector End" << endl;
		imageSectorsData.close();

		vector<OutputPixelObjectWithAngleValues> pVectorOutputCommon = vector<OutputPixelObjectWithAngleValues>();
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorOne), std::end(pVectorPointsSectorOne));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorTwo), std::end(pVectorPointsSectorTwo));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorThree), std::end(pVectorPointsSectorThree));
		pVectorOutputCommon.insert(std::end(pVectorOutputCommon), std::begin(pVectorPointsSectorFour), std::end(pVectorPointsSectorFour));





		vector<Point2D> pPointArrayToDraw = vector<Point2D>();



		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 1)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 2)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 3)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}


		for (OutputPixelObjectWithAngleValues pVectorItem : pVectorOutputCommon)
		{
			if (pVectorItem.pQuarterNumberVar == 4)
			{
				Point2D pPointObject;
				pPointObject.pPointNumber = pVectorItem.pixelNumber;
				pPointObject.xPosition = pVectorItem.xPosition;
				pPointObject.yPosition = pVectorItem.yPosition;
				pPointArrayToDraw.push_back(pPointObject);
			}
		}

		vector<Line2D> pLineArrayValues = vector<Line2D>();
		float pTotalArea = 0.0f;
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLines(hInstance,
			hWnd,
			pCentre.xPosition,
			pCentre.yPosition,
			pPointArrayToDraw);




		float pSectorLength12 = 0.0f;
		float pSectorLength23 = 0.0f;
		float pSectorLength34 = 0.0f;
		float pSectorLength45 = 0.0f;
		float pSectorLength56 = 0.0f;
		float pSectorLength67 = 0.0f;
		float pSectorLength78 = 0.0f;
		float pSectorLength89 = 0.0f;
		float pSectorLength910 = 0.0f;
		float pSectorLength1011 = 0.0f;
		float pSectorLength1112 = 0.0f;
		float pSectorLength1201 = 0.0f;

		float pSectorLength1Centre = 0.0f;
		float pSectorLength2Centre = 0.0f;
		float pSectorLength3Centre = 0.0f;
		float pSectorLength4Centre = 0.0f;
		float pSectorLength5Centre = 0.0f;
		float pSectorLength6Centre = 0.0f;
		float pSectorLength7Centre = 0.0f;
		float pSectorLength8Centre = 0.0f;
		float pSectorLength9Centre = 0.0f;
		float pSectorLength10Centre = 0.0f;
		float pSectorLength11Centre = 0.0f;
		float pSectorLength12Centre = 0.0f;


		Point2D pPointOne = pPointArrayToDraw[0];
		Point2D pPointTwo = pPointArrayToDraw[1];
		Point2D pPointThree = pPointArrayToDraw[2];

		Point2D pPointFour = pPointArrayToDraw[3];
		Point2D pPointFive = pPointArrayToDraw[4];
		Point2D pPointSix = pPointArrayToDraw[5];
		Point2D pPointSeven = pPointArrayToDraw[6];
		Point2D pPointEight = pPointArrayToDraw[7];
		Point2D pPointNine = pPointArrayToDraw[8];
		Point2D pPointTen = pPointArrayToDraw[9];
		Point2D pPointEleven = pPointArrayToDraw[10];
		Point2D pPointTwelve = pPointArrayToDraw[11];




		pSectorLength1Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[0], pCentre);
		pSectorLength2Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[1], pCentre);
		pSectorLength3Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[2], pCentre);
		pSectorLength4Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[3], pCentre);
		pSectorLength5Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[4], pCentre);
		pSectorLength6Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[5], pCentre);
		pSectorLength7Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[6], pCentre);
		pSectorLength8Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[7], pCentre);
		pSectorLength9Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[8], pCentre);
		pSectorLength10Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[9], pCentre);
		pSectorLength11Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[10], pCentre);
		pSectorLength12Centre = ComputeLineLengthBetweenPoint(pPointArrayToDraw[11], pCentre);

		pSectorLength12 = ComputeLineLengthBetweenPoint(pPointOne, pPointTwo);
		pSectorLength23 = ComputeLineLengthBetweenPoint(pPointTwo, pPointThree);
		pSectorLength34 = ComputeLineLengthBetweenPoint(pPointThree, pPointFour);
		pSectorLength45 = ComputeLineLengthBetweenPoint(pPointFour, pPointFive);
		pSectorLength56 = ComputeLineLengthBetweenPoint(pPointFive, pPointSix);
		pSectorLength67 = ComputeLineLengthBetweenPoint(pPointSix, pPointSeven);
		pSectorLength78 = ComputeLineLengthBetweenPoint(pPointSeven, pPointEight);
		pSectorLength89 = ComputeLineLengthBetweenPoint(pPointEight, pPointNine);
		pSectorLength910 = ComputeLineLengthBetweenPoint(pPointNine, pPointTen);
		pSectorLength1011 = ComputeLineLengthBetweenPoint(pPointTen, pPointEleven);
		pSectorLength1112 = ComputeLineLengthBetweenPoint(pPointEleven, pPointTwelve);
		pSectorLength1201 = ComputeLineLengthBetweenPoint(pPointTwelve, pPointOne);



		Line2D pLine12;
		pLine12.pLineNumber = 1;
		pLine12.pPointOne = pPointOne;
		pLine12.pPointTwo = pPointTwo;
		pLine12.pLineWidth = pSectorLength12;



		Line2D pLine23;
		pLine23.pLineNumber = 2;
		pLine23.pPointOne = pPointTwo;
		pLine23.pPointTwo = pPointThree;
		pLine23.pLineWidth = pSectorLength23;


		Line2D pLine34;
		pLine34.pLineNumber = 3;
		pLine34.pPointOne = pPointThree;
		pLine34.pPointTwo = pPointFour;
		pLine34.pLineWidth = pSectorLength34;


		Line2D pLine45;
		pLine45.pLineNumber = 4;
		pLine45.pPointOne = pPointFour;
		pLine45.pPointTwo = pPointFive;
		pLine45.pLineWidth = pSectorLength45;


		Line2D pLine56;
		pLine56.pLineNumber = 5;
		pLine56.pPointOne = pPointFive;
		pLine56.pPointTwo = pPointSix;
		pLine56.pLineWidth = pSectorLength56;


		Line2D pLine67;
		pLine67.pLineNumber = 6;
		pLine67.pPointOne = pPointSix;
		pLine67.pPointTwo = pPointSeven;
		pLine67.pLineWidth = pSectorLength67;


		Line2D pLine78;
		pLine78.pLineNumber = 7;
		pLine78.pPointOne = pPointSeven;
		pLine78.pPointTwo = pPointEight;
		pLine78.pLineWidth = pSectorLength78;

		Line2D pLine89;
		pLine89.pLineNumber = 8;
		pLine89.pPointOne = pPointEight;
		pLine89.pPointTwo = pPointNine;
		pLine89.pLineWidth = pSectorLength89;


		Line2D pLine910;
		pLine910.pLineNumber = 9;
		pLine910.pPointOne = pPointNine;
		pLine910.pPointTwo = pPointTen;
		pLine910.pLineWidth = pSectorLength910;


		Line2D pLine1011;
		pLine1011.pLineNumber = 10;
		pLine1011.pPointOne = pPointTen;
		pLine1011.pPointTwo = pPointEleven;
		pLine1011.pLineWidth = pSectorLength1011;


		Line2D pLine1112;
		pLine1112.pLineNumber = 11;
		pLine1112.pPointOne = pPointEleven;
		pLine1112.pPointTwo = pPointTwelve;
		pLine1112.pLineWidth = pSectorLength1112;


		Line2D pLine1201;
		pLine1201.pLineNumber = 12;
		pLine1201.pPointOne = pPointTwelve;
		pLine1201.pPointTwo = pPointOne;
		pLine1201.pLineWidth = pSectorLength1201;

		Line2D pLineOneCentre;
		pLineOneCentre.pLineNumber = 13;
		pLineOneCentre.pPointOne = pPointOne;
		pLineOneCentre.pPointTwo = pCentre;
		pLineOneCentre.pLineWidth = pSectorLength1Centre;

		Line2D pLineTwoCentre;
		pLineTwoCentre.pLineNumber = 15;
		pLineTwoCentre.pPointOne = pPointTwo;
		pLineTwoCentre.pPointTwo = pCentre;
		pLineTwoCentre.pLineWidth = pSectorLength2Centre;

		Line2D pLineThreeCentre;
		pLineThreeCentre.pLineNumber = 16;
		pLineThreeCentre.pPointOne = pPointThree;
		pLineThreeCentre.pPointTwo = pCentre;
		pLineThreeCentre.pLineWidth = pSectorLength3Centre;


		Line2D pLineFourCentre;
		pLineFourCentre.pLineNumber = 16;
		pLineFourCentre.pPointOne = pPointFour;
		pLineFourCentre.pPointTwo = pCentre;
		pLineFourCentre.pLineWidth = pSectorLength4Centre;


		Line2D pLineFiveCentre;
		pLineFiveCentre.pLineNumber = 17;
		pLineFiveCentre.pPointOne = pPointFive;
		pLineFiveCentre.pPointTwo = pCentre;
		pLineFiveCentre.pLineWidth = pSectorLength5Centre;


		Line2D pLineSixCentre;
		pLineSixCentre.pLineNumber = 18;
		pLineSixCentre.pPointOne = pPointSix;
		pLineSixCentre.pPointTwo = pCentre;
		pLineSixCentre.pLineWidth = pSectorLength6Centre;


		Line2D pLineSevenCentre;
		pLineSevenCentre.pLineNumber = 19;
		pLineSevenCentre.pPointOne = pPointSeven;
		pLineSevenCentre.pPointTwo = pCentre;
		pLineSevenCentre.pLineWidth = pSectorLength7Centre;


		Line2D pLineEightCentre;
		pLineEightCentre.pLineNumber = 20;
		pLineEightCentre.pPointOne = pPointEight;
		pLineEightCentre.pPointTwo = pCentre;
		pLineEightCentre.pLineWidth = pSectorLength8Centre;


		Line2D pLineNineCentre;
		pLineNineCentre.pLineNumber = 21;
		pLineNineCentre.pPointOne = pPointNine;
		pLineNineCentre.pPointTwo = pCentre;
		pLineNineCentre.pLineWidth = pSectorLength9Centre;


		Line2D pLineTenCentre;
		pLineTenCentre.pLineNumber = 22;
		pLineTenCentre.pPointOne = pPointTen;
		pLineTenCentre.pPointTwo = pCentre;
		pLineTenCentre.pLineWidth = pSectorLength10Centre;


		Line2D pLineElevenCentre;
		pLineElevenCentre.pLineNumber = 23;
		pLineElevenCentre.pPointOne = pPointEleven;
		pLineElevenCentre.pPointTwo = pCentre;
		pLineElevenCentre.pLineWidth = pSectorLength11Centre;


		Line2D pLineTwelveCentre;
		pLineTwelveCentre.pLineNumber = 24;
		pLineTwelveCentre.pPointOne = pPointTwelve;
		pLineTwelveCentre.pPointTwo = pCentre;
		pLineTwelveCentre.pLineWidth = pSectorLength12Centre;








		float pTriangleOneArea = 0.0f;
		float pTriangleTwoArea = 0.0f;
		float pTriangleThreeArea = 0.0f;
		float pTriangleFourArea = 0.0f;
		float pTriangleFiveArea = 0.0f;
		float pTriangleSixArea = 0.0f;
		float pTriangleSevenArea = 0.0f;
		float pTriangleEightArea = 0.0f;
		float pTriangleNineArea = 0.0f;
		float pTriangleTenArea = 0.0f;
		float pTriangleElevenArea = 0.0f;
		float pTriangleTwelveArea = 0.0f;





		float pTriangleAreaTotal = 0.0f;
		pTriangleOneArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineOneCentre, pLineTwoCentre, pLine12);
		pTriangleTwoArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwoCentre, pLineThreeCentre, pLine23);
		pTriangleThreeArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineThreeCentre, pLineFourCentre, pLine34);
		pTriangleFourArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFourCentre, pLineFiveCentre, pLine45);
		pTriangleFiveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineFiveCentre, pLineSixCentre, pLine56);
		pTriangleSixArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSixCentre, pLineSevenCentre, pLine67);
		pTriangleSevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineSevenCentre, pLineEightCentre, pLine78);
		pTriangleEightArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineEightCentre, pLineNineCentre, pLine89);
		pTriangleNineArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineNineCentre, pLineTenCentre, pLine910);
		pTriangleTenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTenCentre, pLineElevenCentre, pLine1011);
		pTriangleElevenArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineElevenCentre, pLineTwelveCentre, pLine1112);
		pTriangleTwelveArea = ComputeTriangleAreaUsingHeronsFormulaLines(pLineTwelveCentre, pLineOneCentre, pLine1201);
		pTotalArea = pTriangleOneArea + pTriangleTwoArea + pTriangleThreeArea + pTriangleFourArea + pTriangleFiveArea + pTriangleSixArea + pTriangleSevenArea + pTriangleEightArea + pTriangleNineArea + pTriangleTenArea + pTriangleElevenArea + pTriangleTwelveArea;

		cout << "Triangle One Area: " << pTriangleOneArea << endl;
		cout << "Triangle Two Area: " << pTriangleTwoArea << endl;
		cout << "Triangle Three Area: " << pTriangleThreeArea << endl;
		cout << "Triangle Four Area: " << pTriangleFourArea << endl;
		cout << "Triangle Five Area: " << pTriangleFiveArea << endl;
		cout << "Triangle Six Area: " << pTriangleSixArea << endl;
		cout << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		cout << "Triangle Eight Area: " << pTriangleEightArea << endl;
		cout << "Triangle Nine Area: " << pTriangleNineArea << endl;
		cout << "Triangle Ten Area: " << pTriangleTenArea << endl;
		cout << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		cout << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;

		imageSegmentationDataFile << "Triangle One Area: " << pTriangleOneArea << endl;
		imageSegmentationDataFile << "Triangle Two Area: " << pTriangleTwoArea << endl;
		imageSegmentationDataFile << "Triangle Three Area: " << pTriangleThreeArea << endl;
		imageSegmentationDataFile << "Triangle Four Area: " << pTriangleFourArea << endl;
		imageSegmentationDataFile << "Triangle Five Area: " << pTriangleFiveArea << endl;
		imageSegmentationDataFile << "Triangle Six Area: " << pTriangleSixArea << endl;
		imageSegmentationDataFile << "Triangle Seven Area: " << pTriangleSevenArea << endl;
		imageSegmentationDataFile << "Triangle Eight Area: " << pTriangleEightArea << endl;
		imageSegmentationDataFile << "Triangle Nine Area: " << pTriangleNineArea << endl;
		imageSegmentationDataFile << "Triangle Ten Area: " << pTriangleTenArea << endl;
		imageSegmentationDataFile << "Triangle Eleven Area: " << pTriangleElevenArea << endl;
		imageSegmentationDataFile << "Triangle Twelve Area: " << pTriangleTwelveArea << endl;


		cout << "Constructing Triangle Structures" << endl;
		TriangleObject pTriangleObjectOne = TriangleObject(1, pPointOne, pCentre, pPointTwo,
			pLineOneCentre, pLineTwoCentre, pLine12, pTriangleOneArea);
		TriangleObject pTriangleObjectTwo = TriangleObject(2, pPointTwo, pCentre, pPointThree,
			pLineTwoCentre, pLineThreeCentre, pLine23, pTriangleTwoArea);
		TriangleObject pTriangleObjectThree = TriangleObject(3, pPointThree, pCentre, pPointFour,
			pLineThreeCentre, pLineFourCentre, pLine34, pTriangleThreeArea);
		TriangleObject pTriangleObjectFour = TriangleObject(4, pPointFour, pCentre, pPointFive,
			pLineFourCentre, pLineFiveCentre, pLine45, pTriangleFourArea);
		TriangleObject pTriangleObjectFive = TriangleObject(5, pPointFive, pCentre, pPointSix,
			pLineFiveCentre, pLineSixCentre, pLine56, pTriangleFiveArea);
		TriangleObject pTriangleObjectSix = TriangleObject(6, pPointSix, pCentre, pPointSeven,
			pLineSixCentre, pLineSevenCentre, pLine67, pTriangleSixArea);
		TriangleObject pTriangleObjectSeven = TriangleObject(7, pPointSeven, pCentre, pPointEight,
			pLineSevenCentre, pLineEightCentre, pLine78, pTriangleSevenArea);
		TriangleObject pTriangleObjectEight = TriangleObject(8, pPointEight, pCentre, pPointNine,
			pLineEightCentre, pLineNineCentre, pLine89, pTriangleEightArea);
		TriangleObject pTriangleObjectNine = TriangleObject(9, pPointNine, pCentre, pPointTen,
			pLineNineCentre, pLineTenCentre, pLine910, pTriangleNineArea);
		TriangleObject pTriangleObjectTen = TriangleObject(10, pPointTen, pCentre, pPointEleven,
			pLineTenCentre, pLineElevenCentre, pLine1011, pTriangleTenArea);
		TriangleObject pTriangleObjectEleven = TriangleObject(11, pPointEleven, pCentre, pPointTwelve,
			pLineElevenCentre, pLineTwelveCentre, pLine1112, pTriangleElevenArea);
		TriangleObject pTriangleObjectTwelve = TriangleObject(12, pPointTwelve, pCentre, pPointOne,
			pLineTwelveCentre, pLineOneCentre, pLine1201, pTriangleTwelveArea);

		cout << "Storing Our Triangle Data into A Vector" << endl;
		imageSegmentationDataFile << "Storing Our Triangle Data into A Vector" << endl;

		vector<TriangleObject> pTriangleObjectVector = vector<TriangleObject>();
		pTriangleObjectVector.push_back(pTriangleObjectOne);
		pTriangleObjectVector.push_back(pTriangleObjectTwo);
		pTriangleObjectVector.push_back(pTriangleObjectThree);
		pTriangleObjectVector.push_back(pTriangleObjectFour);
		pTriangleObjectVector.push_back(pTriangleObjectFive);
		pTriangleObjectVector.push_back(pTriangleObjectSix);
		pTriangleObjectVector.push_back(pTriangleObjectSeven);
		pTriangleObjectVector.push_back(pTriangleObjectEight);
		pTriangleObjectVector.push_back(pTriangleObjectNine);
		pTriangleObjectVector.push_back(pTriangleObjectTen);
		pTriangleObjectVector.push_back(pTriangleObjectEleven);
		pTriangleObjectVector.push_back(pTriangleObjectTwelve);

		for (TriangleObject pTriangleObject : pTriangleObjectVector)
		{
			cout << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			cout << "Point A:" << endl;
			cout << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointA.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			cout << "Point B:" << endl;
			cout << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointB.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			cout << "Point C:" << endl;
			cout << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			cout << "X = " << pTriangleObject.pPointC.xPosition << endl;
			cout << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			cout << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			cout << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			cout << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			cout << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			cout << "Area = " << pTriangleObject.pTriangleArea << endl;

			imageSegmentationDataFile << "Triangle Number: " << pTriangleObject.pTriangleId << endl;
			imageSegmentationDataFile << "Point A:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointA.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointA.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointA.yPosition << endl;
			imageSegmentationDataFile << "Point B:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointB.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointB.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointB.yPosition << endl;
			imageSegmentationDataFile << "Point C:" << endl;
			imageSegmentationDataFile << "Point Id" << pTriangleObject.pPointC.pPointNumber << endl;
			imageSegmentationDataFile << "X = " << pTriangleObject.pPointC.xPosition << endl;
			imageSegmentationDataFile << "Y = " << pTriangleObject.pPointC.yPosition << endl;
			imageSegmentationDataFile << "Line AB Magnitude =  " << pTriangleObject.pABVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line BC Magnitude =  " << pTriangleObject.pBCVector.pLineWidth << endl;
			imageSegmentationDataFile << "Line AC Magnitude = " << pTriangleObject.pACVector.pLineWidth << endl;
			imageSegmentationDataFile << "Perimeter = " << pTriangleObject.pPerimeterValue << endl;
			imageSegmentationDataFile << "Area = " << pTriangleObject.pTriangleArea << endl;
		}




		cout << "Computing Perimeter for the Shape" << endl;
		float pShapePerimeter = 0.0f;
		pShapePerimeter = pLine12.pLineWidth + pLine23.pLineWidth + pLine34.pLineWidth + pLine45.pLineWidth + pLine56.pLineWidth + pLine67.pLineWidth + pLine78.pLineWidth + pLine89.pLineWidth + pLine910.pLineWidth + pLine1011.pLineWidth + pLine1112.pLineWidth + pLine1201.pLineWidth;


		cout << "Perimeter Value: " << pShapePerimeter << endl;
		imageSegmentationDataFile << "Perimeter Value: " << pShapePerimeter << endl;






		cout << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;
		imageSegmentationDataFile << "The Approximation Area of the Secluded Shape = " << pTotalArea << endl;






		LPWSTR pScreenImfloage = L"C:\\RobotData\\RestoredImageFromExperimentOfFilter.jpg";


		SYSTEMTIME endTimeSystem;
		SYSTEMTIME endTimeLocal;


		fstream pReportFileForSelectedExperiment;
		pReportFileForSelectedExperiment.open("C:\\pixels\\ReportFileOfTheExperiment.txt", fstream::in | fstream::out | fstream::trunc);
		pReportFileForSelectedExperiment.clear();

		pReportFileForSelectedExperiment << "Printing Container Sizes" << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For Y Axis:" << pixelObjectVectorOne.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Scan For X Axis:" << pixelObjectVectorTwo.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter:" << ppOutputPixelVectorOutput.size() << endl;
		pReportFileForSelectedExperiment << "Size of Container of Pixels After RGB Output Filter Restoration:" << pFilteredObjectArrayRGBOneRestored.size() << endl;
		pReportFileForSelectedExperiment.close();














		GetSystemTime(&endTimeSystem);
		GetLocalTime(&endTimeLocal);
		cout << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeSystem.wSecond << endl;
		cout << " Experiment End Time is: %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << "Experiment End Time is: %02d:%02d\n" << endTimeSystem.wHour << ":" <<
			endTimeSystem.wMinute << ":" << endTimeLocal.wSecond << endl;
		imageSegmentationDataFile << " Experiment End Time %02d:%02d\n" << endTimeLocal.wHour << ":" <<
			endTimeLocal.wMinute << ":" << endTimeLocal.wSecond << endl;

	}

	imageSegmentationDataFile.close();
	imageSectorsData.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SelectPixelsOfColorFromImage(HINSTANCE hInstance, HWND hWnd)
{


	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";


	Point2D pCentre;
	pCentre.pPointNumber = 55;
	pCentre.xPosition = 430;
	pCentre.yPosition = 410;



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilter.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();


	float pStepX = 0.0f;
	float pStepY = 0.0f;
	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();


	float pCentreX = 430.0;
	float pCentreY = 410.0f;

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;




	vector<PixelObject> pSectorOne = vector<PixelObject>();
	vector<PixelObject> pSectorTwo = vector<PixelObject>();
	vector<PixelObject> pSectorThree = vector<PixelObject>();
	vector<PixelObject> pSectorFour = vector<PixelObject>();
	vector<PixelObject> pSectorFive = vector<PixelObject>();
	vector<PixelObject> pSectorSix = vector<PixelObject>();
	vector<PixelObject> pSectorSeven = vector<PixelObject>();
	vector<PixelObject> pSectorEight = vector<PixelObject>();
	vector<PixelObject> pSectorNine = vector<PixelObject>();
	vector<PixelObject> pSectorTen = vector<PixelObject>();
	vector<PixelObject> pSectorEleven = vector<PixelObject>();
	vector<PixelObject> pSectorTwelve = vector<PixelObject>();




	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;




	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		pixelDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		pixelDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		auto stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << "seconds" << endl;
		cout << "Time taken by Clip Two: "
			<< duration.count() / 1000000 << " seconds" << endl;
		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
			clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
			clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
			filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
			filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());






		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();

		hr = ppStandardAlgorithmExecutor->SelectPixelsOfColorFromImage(hInstance, hWnd,
			pRedValueToSelect,
			pGreenValueToSelect,
			pBlueValueToSelect,
			pixelObjectVectorOne,
			&ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;


		int pPixelNumberOutput = 0.0f;
		float pXValueOutput = 0.0f;
		float pYValueOutput = 0.0f;
		float pRedComponentOutput = 0.0f;
		float pGreenComponentOutput = 0.0f;
		float pBlueComponentOutput = 0.0f;
		bool pUsedInComputations = false;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputPixelVector)
		{

			pPixelNumberOutput = pPixelObject.pixelNumber;
			pXValueOutput = pPixelObject.xPosition;
			pYValueOutput = pPixelObject.yPosition;
			pRedComponentOutput = pPixelObject.rValue;
			pGreenComponentOutput = pPixelObject.gValue;
			pBlueComponentOutput = pPixelObject.bValue;
			pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumberOutput << endl;
			cout << "X Value = " << pXValueOutput << endl;
			cout << "Y Value = " << pYValueOutput << endl;
			cout << "Red Component = " << pRedComponentOutput << endl;
			cout << "Green Component = " << pGreenComponentOutput << endl;
			cout << "Blue Component = " << pBlueComponentOutput << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumberOutput << endl;
			pixelDataFile << "X Value = " << pXValueOutput << endl;
			pixelDataFile << "Y Value = " << pYValueOutput << endl;
			pixelDataFile << "Red Component = " << pRedComponentOutput << endl;
			pixelDataFile << "Green Component = " << pGreenComponentOutput << endl;
			pixelDataFile << "Blue Component = " << pBlueComponentOutput << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			pIndexValue++;
		}

		vector<PixelObject> ppRecoveredPixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, ppOutputPixelVector, &ppRecoveredPixelArray);

		for (PixelObject pixelObject : ppRecoveredPixelArray)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		LPCWSTR pImageFIle = L"C:\\RobotData\\CompressedImageFromFilter.jpg";

		int pImageWidthVar = sqrt(ppRecoveredPixelArray.size());
		int pImageHeighthVar = sqrt(ppRecoveredPixelArray.size());




		cout << "Drawing Our Square on the screen" << endl;
		hr = md2dmanager->DrawPixelBuffer(hInstance, hWnd, ppRecoveredPixelArray, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);



	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ApplyKMeansToRGBImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\KMeansFilterRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFilteredRGBKMeans> ppOutputPixelVector = vector<OutputPixelObjectFilteredRGBKMeans>();
	vector<OutputPixelObjectFiltered> pFilterToRecover = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pRecoveredImage = vector<PixelObject>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pCentreClusterX = 0.0f;
	float pCentreClusterY = 0.0f;
	float pRadiusValueObject = 0.0f;



	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME grayscaleTimeStartSystem;
	SYSTEMTIME grayscaleTimeStartLocal;
	SYSTEMTIME grayscaleTimeEndSystem;
	SYSTEMTIME grayscaleTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;



	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the X Value for the Centre Cluster" << endl;
	cin >> pCentreClusterX;

	cout << "Enter the Y Value for the Centre Cluster" << endl;
	cin >> pCentreClusterY;

	cout << "Enter the Value for the Radius Object" << endl;
	cin >> pRadiusValueObject;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Centre X = " << pCentreClusterX << endl;
	cout << "Centre Y " << pCentreClusterY << endl;
	cout << "Radius Value = " << pRadiusValueObject << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Centre X = " << pCentreClusterX << endl;
	pixelDataFile << "Centre Y " << pCentreClusterY << endl;
	pixelDataFile << "Radius Value = " << pRadiusValueObject << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;

		GetSystemTime(&grayscaleTimeStartSystem);
		GetLocalTime(&grayscaleTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;



		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ApplyKMeansFilterToRGBImage(hInstance, hWnd,
			pixelObjectVector,
			pCentreClusterX,
			pCentreClusterY,
			pRadiusValueObject,
			&ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pixelDataFile << "Printing Output" << endl;

		int pAmountOfPixelsUses = 0;



		for (OutputPixelObjectFilteredRGBKMeans pPixelObject : ppOutputPixelVector)
		{


			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pIsPixelValid;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pRedComponent << endl;
			cout << "Blue Component = " << pRedComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pRedComponent << endl;
			pixelDataFile << "Blue Component = " << pRedComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

		}

		cout << "Amount of filtered pixels = " << pAmountOfPixelsUses;
		pixelDataFile << "Amount of filtered pixels = " << pAmountOfPixelsUses;

	}

	cout << "Now We Would Like to Recover the output Grayscale Values" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
		hWnd, pFilterToRecover, &pRecoveredImage);





	for (PixelObject pixelObject : pRecoveredImage)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;



	pixelDataFile.close();
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ApplyKMeansToGrayScaleImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\KMeansAlgorithmGrayScale.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelObjectFilteredGrayScaleKMeans> ppOutputPixelVector = vector<OutputPixelObjectFilteredGrayScaleKMeans>();
	vector<OutputPixelObjectFilteredGrayScale> pFilterToRecover = vector<OutputPixelObjectFilteredGrayScale>();
	vector<PixelObjectGrayScale> pRecoveredImage = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pCentreClusterX = 0.0f;
	float pCentreClusterY = 0.0f;
	float pRadiusValueObject = 0.0f;



	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME grayscaleTimeStartSystem;
	SYSTEMTIME grayscaleTimeStartLocal;
	SYSTEMTIME grayscaleTimeEndSystem;
	SYSTEMTIME grayscaleTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;



	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the X Value for the Centre Cluster" << endl;
	cin >> pCentreClusterX;

	cout << "Enter the Y Value for the Centre Cluster" << endl;
	cin >> pCentreClusterY;

	cout << "Enter the Value for the Radius Object" << endl;
	cin >> pRadiusValueObject;






	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;

		GetSystemTime(&grayscaleTimeStartSystem);
		GetLocalTime(&grayscaleTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
			pixelObjectVector, &pPixelObjectToGrayScale);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		float pIndexValue = 0;

		cout << "Grayscale Section Begin" << endl;
		pixelDataFile << "Grayscale Section Begin" << endl;



		for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
		{

			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


			pIndexValue++;
		}

		GetSystemTime(&grayscaleTimeEndSystem);
		GetLocalTime(&grayscaleTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;




		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;



		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ApplyKMeansFilterToGrayScaleImage(hInstance,
			hWnd,
			pPixelObjectToGrayScale,
			pCentreClusterX,
			pCentreClusterY,
			pRadiusValueObject,
			&ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

		int pAmountOfPixelsUses = 0;



		for (OutputPixelObjectFilteredGrayScaleKMeans pPixelObject : ppOutputPixelVector)
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale = pPixelObject.pGrayScaleValue;
			bool pIsPixelUsed = pPixelObject.pIsPixelValid;

			OutputPixelObjectFilteredGrayScale pOutputFilterVar;
			pOutputFilterVar.xPosition = pXValue;
			pOutputFilterVar.yPosition = pYValue;
			pOutputFilterVar.pGrayScaleValue = pPixeoObjectGrayScale;
			pOutputFilterVar.pIsPixelValid = pIsPixelUsed;


			pFilterToRecover.push_back(pOutputFilterVar);



			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
			cout << "Is Pixel Used = " << pIsPixelUsed << endl;



			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
			pixelDataFile << "Is Pixel Used = " << pIsPixelUsed << endl;





			pIndexValue++;
		}

		cout << "Amount of filtered pixels = " << pAmountOfPixelsUses;
		pixelDataFile << "Amount of filtered pixels = " << pAmountOfPixelsUses;

	}

	cout << "Now We Would Like to Recover the output Grayscale Values" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreGrayScalePixelFromFilter(hInstance,
		hWnd, pFilterToRecover, &pRecoveredImage);





	for (PixelObjectGrayScale pPixelObject : pRecoveredImage)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
	}


	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;



	pixelDataFile.close();
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::ExtractDataPacketFromWeb(HINSTANCE hInstance, HWND hWnd, LPCSTR dataAddress)
{
	HRESULT hr = S_OK;

	DirectXNetworkPacketManagementClass* ppNetworkModule = m_pGPUNetworkModule;
	ppNetworkModule = new DirectXNetworkPacketManagementClass(hInstance, hWnd);

	hr = ppNetworkModule->StartEmptyHttpGetRequest(hInstance, hWnd, (LPCSTR)dataAddress);

	return hr;
}






HRESULT WINAPI SimulateGasDynamicsModelsFunction(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	

	CLSID clsid;
	IClassFactory* pKernelObjectFactory = nullptr;
	IDirectXDigitalLabSoftwareKernelInterface *pMainKernelInterface = nullptr;

	hr = CoGetClassObject(CLSID_GPUDigitalLabCore, CLSCTX_LOCAL_SERVER,
		NULL, IID_IClassFactory, (void**)&pKernelObjectFactory);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObjectFactory->CreateInstance(NULL, CLSID_GPUDigitalLabCore, reinterpret_cast<void**>(&pMainKernelInterface));

		if (FAILED(hr))
		{
			DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
			hr = pExtraModule->ComputeGasSpeedData(hInstance, hWnd);
		}

		else
		{
			hr = pMainKernelInterface->ComputeGasSpeedData(hInstance, hWnd);
		}

	}
	if (FAILED(hr))
	{
		DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
		hr = pExtraModule->ComputeGasSpeedData(hInstance, hWnd);
	}

	return hr;
}


HRESULT WINAPI SimulateArrayAdditionAlgorithm()
{
	HRESULT hr = S_OK;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	CLSID clsid;
	IClassFactory* pKernelObjectFactory = nullptr;
	IDirectXDigitalLabSoftwareKernelInterface *pMainKernelInterface = nullptr;

	hr = CoGetClassObject(CLSID_GPUDigitalLabCore, CLSCTX_LOCAL_SERVER,
		NULL, IID_IClassFactory, (void**)&pKernelObjectFactory);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObjectFactory->CreateInstance(NULL, CLSID_GPUDigitalLabCore, reinterpret_cast<void**>(&pMainKernelInterface));

		if (FAILED(hr))
		{
			DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
			hr = pExtraModule->SimulateSortingAlgorithm(hInstance, hWnd);
		}

		else
		{
			hr = pMainKernelInterface->SimulateArrayAdditionAlgorithm(hInstance, hWnd);
		}

	}
	if (FAILED(hr))
	{
		DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
		hr = pExtraModule->SimulateSortingAlgorithm(hInstance, hWnd);
	}

	return hr;
}

HRESULT WINAPI InitializeInternalTCPServer()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc;
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	CLSID clsid;
	IClassFactory* pKernelObjectFactory = nullptr;
	IDirectXDigitalLabSoftwareKernelInterface *pMainKernelInterface = nullptr;

	hr = CoGetClassObject(CLSID_GPUDigitalLabCore, CLSCTX_LOCAL_SERVER,
		NULL, IID_IClassFactory, (void**)&pKernelObjectFactory);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObjectFactory->CreateInstance(NULL, clsid, reinterpret_cast<void**>(&pMainKernelInterface));
		if (FAILED(hr))
		{
			DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
			hr = pExtraModule->InitializeInternalTCPServer(hInstance, hWnd);
			return hr;
		}
		else
		{
			hr = pMainKernelInterface->InitializeInternalTCPServer(hInstance, hWnd);
		}

	}
	if (FAILED(hr))
	{
		DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
		hr = pExtraModule->InitializeInternalTCPServer(hInstance, hWnd);
	}
	return hr;
}



HRESULT WINAPI ComputeGasDynamicsFunction()
{
	HRESULT hr = S_OK;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	CLSID clsid;
	CLSIDFromString(L"{7066de6c-0ded-11e6-a148-3e1d05defe78}", &clsid);
	IClassFactory* pKernelObjectFactory = nullptr;
	IDirectXDigitalLabSoftwareKernelInterface *pMainKernelInterface = nullptr;

	hr = CoGetClassObject(CLSID_GPUDigitalLabCore, CLSCTX_LOCAL_SERVER,
		NULL, IID_IClassFactory, (void**)&pKernelObjectFactory);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObjectFactory->CreateInstance(NULL, CLSID_GPUDigitalLabCore, reinterpret_cast<void**>(&pMainKernelInterface));

		if (FAILED(hr))
		{
			DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
			hr = pExtraModule->SimulateGasDynamicsModelsFunction(hInstance, hWnd);
		}

		else
		{
			hr = pMainKernelInterface->SimulateGasDynamicsModelsFunction(hInstance, hWnd);
		}

	}
	if (FAILED(hr))
	{
		DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
		hr = pExtraModule->SimulateGasDynamicsModelsFunction(hInstance, hWnd);
	}

	return hr;
}



HRESULT WINAPI SimulateRobotCleanerObject()
{

	HRESULT hr = S_OK;


	HINSTANCE hInstance = GetModuleHandle(NULL);
	HWND hWnd = NULL;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	GetClientRect(hWnd, &rc);

	CLSID clsid;
	IClassFactory* pKernelObjectFactory = nullptr;
	IDirectXDigitalLabSoftwareKernelInterface *pMainKernelInterface = nullptr;

	hr = CoGetClassObject(CLSID_GPUDigitalLabCore, CLSCTX_LOCAL_SERVER,
		NULL, IID_IClassFactory, (void**)&pKernelObjectFactory);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObjectFactory->CreateInstance(NULL, CLSID_GPUDigitalLabCore, reinterpret_cast<void**>(&pMainKernelInterface));

		if (FAILED(hr))
		{
			DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
			pExtraModule->InitializeGPUDigitalLabCore(hInstance, hWnd);
//			hr = pExtraModule->SimulateRobotCleanerSystemObject(hInstance, hWnd);
		}

		else
		{
			hr = pMainKernelInterface->SimulateSortingAlgorithm(hInstance, hWnd);
		}

	}
	if (FAILED(hr))
	{
		DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
		pExtraModule->InitializeGPUDigitalLabCore(hInstance, hWnd);
//		hr = pExtraModule->SimulateRobotCleanerSystemObject(hInstance, hWnd);
	}

	return hr;
}


HRESULT WINAPI SimulateArraySortingAlgorirthm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };

	CLSID clsid;
	IClassFactory* pKernelObjectFactory = nullptr;
	IDirectXDigitalLabSoftwareKernelInterface *pMainKernelInterface = nullptr;

	hr = CoGetClassObject(CLSID_GPUDigitalLabCore, CLSCTX_LOCAL_SERVER,
		NULL, IID_IClassFactory, (void**)&pKernelObjectFactory);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObjectFactory->CreateInstance(NULL, CLSID_GPUDigitalLabCore, reinterpret_cast<void**>(&pMainKernelInterface));

		if (FAILED(hr))
		{
			DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
			hr = pExtraModule->SimulateSortingAlgorithm(hInstance, hWnd);
		}

		else
		{
			hr = pMainKernelInterface->SimulateSortingAlgorithm(hInstance, hWnd);
		}

	}
	if (FAILED(hr))
	{
		DirectXGPUDigitalLabCoreModule* pExtraModule = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
		hr = pExtraModule->SimulateSortingAlgorithm(hInstance, hWnd);
	}

	return hr;
	
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateScientificAlgortihm(HINSTANCE hInstance, HWND hWnd, LPCSTR webAddress)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DownloadDataPacketFromWeb(HINSTANCE hInstance, HWND hWnd, LPCSTR webAddress)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateDirect3D11TextureForFurtherProcessing(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11Texture2D** ppTexture2DObject,
	ID3D11ShaderResourceView** ppShaderResourceObject)
{
	HRESULT hr = S_OK;
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	ID3D11Texture2D* pTexture2DObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewObject = nullptr;
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelDataArray = vector<PixelObject>();



	D3D11_TEXTURE2D_DESC pTexureDesc;
	D3D11_SHADER_RESOURCE_VIEW_DESC  pShaderResourceViewDesc;

	cout << "Getting the Description of Texture2D" << endl;
	pTexture2DObject->GetDesc(&pTexureDesc);
	pShaderResourceViewObject->GetDesc(&pShaderResourceViewDesc);

	cout << "Texture Array Size:" << pTexureDesc.ArraySize << endl;
	cout << "Bind Flags:" << pTexureDesc.BindFlags << endl;
	cout << "CPU Access Flags:" << pTexureDesc.CPUAccessFlags << endl;
	cout << "DXGI Format:" << pTexureDesc.Format << endl;
	cout << "Texture Height: " << pTexureDesc.Height << endl;
	cout << "Mip Levels: " << pTexureDesc.MipLevels << endl;
	cout << "Misc Flags: " << pTexureDesc.MiscFlags << endl;
	cout << "Sample Count: " << pTexureDesc.SampleDesc.Count << endl;
	cout << "Quality: " << pTexureDesc.SampleDesc.Quality << endl;


	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::CreateDirect3D11TextureFromAnImageFileW(
	HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	ID3D11Texture2D* pTexture2DObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewObject = nullptr;
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelDataArray = vector<PixelObject>();

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable To Load Direct3D11 Texture From Selected File Error: " << pLastError << endl;
		return hr;
	}

	D3D11_TEXTURE2D_DESC pTexureDesc;
	D3D11_SHADER_RESOURCE_VIEW_DESC  pShaderResourceViewDesc;

	

	cout << "Getting the Description of Texture2D" << endl;
	pTexture2DObject->GetDesc(&pTexureDesc);
	pShaderResourceViewObject->GetDesc(&pShaderResourceViewDesc);

	cout << "Texture Array Size:" << pTexureDesc.ArraySize << endl;
	cout << "Bind Flags:" << pTexureDesc.BindFlags << endl;
	cout << "CPU Access Flags:" << pTexureDesc.CPUAccessFlags << endl;
	cout << "DXGI Format:" << pTexureDesc.Format << endl;
	cout << "Texture Height: " << pTexureDesc.Height << endl;
	cout << "Mip Levels: " << pTexureDesc.MipLevels << endl;
	cout << "Misc Flags: " << pTexureDesc.MiscFlags << endl;
	cout << "Sample Count: " << pTexureDesc.SampleDesc.Count << endl;
	cout << "Quality: " << pTexureDesc.SampleDesc.Quality << endl;


	return hr;

}




HRESULT DirectXGPUDigitalLabCoreModule::RegisterGPUDigitalLabServer(
	const CLSID& clsid,
	const WCHAR* szFriendlyName,
	const WCHAR* szSerIDProgID,
	const WCHAR* szProgramId)
{
	HRESULT hr = S_OK;
	WCHAR szModule[512];
	HMODULE hModule = GetModuleHandle(NULL);
	DWORD dwResult = GetModuleFileName(hModule, szModule, sizeof(szModule) / sizeof(WCHAR));
	assert(dwResult != 0);

	WCHAR szCLSID[CLSID_STRING_SIZE];
	CLSIDToChar(clsid, szCLSID, sizeof(szCLSID));

	WCHAR szKey[264];
	wcscpy(szKey, L"CLSID\\");
	wcscpy(szKey, szCLSID);
	return hr;
}



void CLSIDtochar(const CLSID& clsid,
	char* szCLSID,
	int length)
{
	assert(length >= CLSID_STRING_SIZE);
	// Get CLSID
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	assert(SUCCEEDED(hr));

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length);

	// Free memory.
	CoTaskMemFree(wszCLSID);
}




HRESULT DirectXGPUDigitalLabCoreModule::InitializeGPUDigitalLabKernel()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	DirectXGPUDigitalLabCoreModule* pNewKernelModule = new DirectXGPUDigitalLabCoreModule();
	HWND hWnd = NULL;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	GetClientRect(hWnd, &rc);
	hr = pNewKernelModule->InitializeGPUDigitalLabCore(hInstance, hWnd);
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::ControlAgentServer()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	ControlAgentServer(hInstance, hWnd);
	return hr;
}





void DirectXGPUDigitalLabCoreModule::RedirectIOToConsole()
{
	
		int hConHandle;
		long lStdHandle;

		CONSOLE_SCREEN_BUFFER_INFO coninfo;

		FILE *fp;

		// allocate a console for this app

		AllocConsole();

		// set the screen buffer to be big enough to let us scroll text

		GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),

			&coninfo);

		coninfo.dwSize.Y = MAX_CONSOLE_LINES;

		SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE),

			coninfo.dwSize);

		// redirect unbuffered STDOUT to the console

		lStdHandle = (long)GetStdHandle(STD_OUTPUT_HANDLE);

		hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);

		fp = _fdopen(hConHandle, "w");

		*stdout = *fp;

		setvbuf(stdout, NULL, _IONBF, 0);

		// redirect unbuffered STDIN to the console

		lStdHandle = (long)GetStdHandle(STD_INPUT_HANDLE);

		hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);

		fp = _fdopen(hConHandle, "r");

		*stdin = *fp;

		setvbuf(stdin, NULL, _IONBF, 0);

		// redirect unbuffered STDERR to the console

		lStdHandle = (long)GetStdHandle(STD_ERROR_HANDLE);

		hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);

		fp = _fdopen(hConHandle, "w");

		*stderr = *fp;

		setvbuf(stderr, NULL, _IONBF, 0);

		// make cout, wcout, cin, wcin, wcerr, cerr, wclog and clog

		// point to console as well

		ios::sync_with_stdio();
}
























BOOL DirectXGPUDigitalLabCoreModule::SetKeyAndValue(const WCHAR* szKey,
	const WCHAR* szSubKey,
	const WCHAR* szValue)
{
	HKEY hKey;
	WCHAR szKeyBuf[1024];
	wcscpy(szKeyBuf, szKey);

	if (szSubKey != NULL)
	{
		wcscat(szKeyBuf, L"\\");
		wcscat(szKeyBuf, szSubKey);
	}
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT,
		szKeyBuf,
		0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL,
		&hKey, NULL);
	
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE;
	}

	if (szValue != NULL)
	{
		RegSetValueEx(hKey, NULL, 0, REG_SZ,
			(BYTE*)szValue,
			2 * wcslen(szValue) + 1);
	}
	RegCloseKey(hKey);
	return TRUE;
}


LONG DirectXGPUDigitalLabCoreModule::RecursivelyDeleteKey(HKEY hKeyParent, const WCHAR* szKeyChild)
{
	DirectXGPUDigitalLabCoreModule* pClassInstance = (DirectXGPUDigitalLabCoreModule*)this;
	HKEY hkeyChild;
	LONG lRes = RegOpenKeyEx(hKeyParent, szKeyChild, 0,
		KEY_ALL_ACCESS, &hkeyChild);

	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	FILETIME time;
	WCHAR szBuffer[256];
	DWORD dwSize = 256;
	
	while (RegEnumKeyEx(hkeyChild, 0, szBuffer, &dwSize, NULL,
		NULL, NULL, &time) == S_OK)
	{
		lRes = pClassInstance->RecursivelyDeleteKey(hkeyChild, szBuffer);

		if (lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hkeyChild);
			return lRes;
		}
		dwSize = 256;
	}
	RegCloseKey(hkeyChild);
	BOOL pResult = RegDeleteKey(hKeyParent, szKeyChild);
	return pResult;

}


void DirectXGPUDigitalLabCoreModule::RunMessageLoop()
{

}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeDataProcessingStream(HINSTANCE hInstance, HWND hWnd, LPCSTR address, LPCSTR usernme, LPCSTR password)
{
	HRESULT hr = S_OK;


	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateRandomizingAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;




	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pOutputResultData = vector<UINT>();
	


	cout << "Generating Initial Data" << endl;

	float pStep = 0.01f;
	for (UINT pValue = (-1 * M_PI); pValue <= M_PI; ++pStep)
	{
		pArrayEightValues.push_back(pValue);
	}

	UINT pIndex = 0;
	cout << "Printing the Data For Array Eight" << endl;

	for (UINT pVariable : pArrayEightValues)
	{
		cout << "The Array Eight Element At Index: " << pIndex << " = " << pVariable << endl;
	}



	hr = ppStandardAlgorithmExecutor->SimulateRandomAlgorithm(hInstance, hWnd);

	cout << "Printing the Results Of The Computations" << endl;

	for (UINT pVariable : pOutputResultData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pVariable << endl;
	}


	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DrawRenctangleSet(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\RectangleQuizData.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	vector<D2D1_RECT_F> pRectangleArrayEight = vector<D2D1_RECT_F>();
	vector<D2D1_RECT_F> pRectangleArrayTwo = vector<D2D1_RECT_F>();


	hr = md2dmanager->DrawRenctangleSet(hInstance, hWnd, &pRectangleArrayEight,
		&pRectangleArrayTwo);

	cout << "Printing the Data About Rectangle Eight" << endl;

	pixelDataFile << "Printing the Data About Rectangle Eight" << endl;



	int pRectangleNumber = 0;
	int pRectangleWidth = 0;
	int pRectangleHeight = 0;
	for (D2D1_RECT_F pRectangleEight : pRectangleArrayEight)
	{
		cout << "Rectangle Number: " << pRectangleNumber << endl;
		cout << "X Position Rectangle: " << pRectangleEight.left << endl;
		cout << "Y Position Rectangle: " << pRectangleEight.top << endl;

		pixelDataFile << "Rectangle Number: " << pRectangleNumber << endl;
		pixelDataFile << "X Position Rectangle: " << pRectangleEight.left << endl;
		pixelDataFile << "Y Position Rectangle: " << pRectangleEight.top << endl;


		
		pRectangleWidth = pRectangleEight.right - pRectangleEight.left;
		pRectangleHeight = pRectangleEight.bottom - pRectangleEight.top;

		cout << "Rectangle Width: " << pRectangleWidth << endl;
		cout << "Rectangle Height: " << pRectangleHeight << endl;

		pixelDataFile << "Rectangle Width: " << pRectangleWidth << endl;
		pixelDataFile << "Rectangle Height: " << pRectangleHeight << endl;

		pRectangleNumber = pRectangleNumber + 1;
	}

	cout << "Printing the Data About Rectangle Set Two" << endl;

	pixelDataFile << "Printing the Data About Rectangle Set Eight" << endl;


	pRectangleNumber = 0;



	for (D2D1_RECT_F pRectangleEight : pRectangleArrayTwo)
	{
		cout << "Rectangle Number: " << pRectangleNumber << endl;
		cout << "X Position Rectangle: " << pRectangleEight.left << endl;
		cout << "Y Position Rectangle: " << pRectangleEight.top << endl;

		pixelDataFile << "Rectangle Number: " << pRectangleNumber << endl;
		pixelDataFile << "X Position Rectangle: " << pRectangleEight.left << endl;
		pixelDataFile << "Y Position Rectangle: " << pRectangleEight.top << endl;



		pRectangleWidth = pRectangleEight.right - pRectangleEight.left;
		pRectangleHeight = pRectangleEight.bottom - pRectangleEight.top;

		cout << "Rectangle Width: " << pRectangleWidth << endl;
		cout << "Rectangle Height: " << pRectangleHeight << endl;

		pixelDataFile << "Rectangle Width: " << pRectangleWidth << endl;
		pixelDataFile << "Rectangle Height: " << pRectangleHeight << endl;


		pRectangleNumber = pRectangleNumber + 1;

	}

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::DrawSampleTextOnTheScreen(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\RectangleQuizData.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	 char* pString = nullptr;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	vector<D2D1_RECT_F> pRectangleArrayEight = vector<D2D1_RECT_F>();
	vector<D2D1_RECT_F> pRectangleArrayTwo = vector<D2D1_RECT_F>();



	cout << "Enter the Text That you Would Like to be PRINTED" << endl;

	string pStringToPrint;

	getline(cin, pStringToPrint);
	wstring pStringW(pStringToPrint.begin(), pStringToPrint.end());

	cout << "Your String: " << pStringToPrint << endl;
	LPCWSTR output = nullptr;
	output = pStringW.c_str();

	cout << "my_str is : " << pStringToPrint << endl;
	cout << "Long String is : " << output << endl;


	hr = md2dmanager->DrawSampleTextOnTheScreenGDI(hInstance, hWnd,
		output);


	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::DrawSampleTextOnTheScreenD2D(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\RectangleQuizData.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	char* pString = nullptr;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	vector<D2D1_RECT_F> pRectangleArrayEight = vector<D2D1_RECT_F>();
	vector<D2D1_RECT_F> pRectangleArrayTwo = vector<D2D1_RECT_F>();



	cout << "Enter the Text That you Would Like to be PRINTED" << endl;

	string pStringToPrint;

	getline(cin, pStringToPrint);
	wstring pStringW(pStringToPrint.begin(), pStringToPrint.end());

	cout << "Your String: " << pStringToPrint << endl;
	LPCWSTR output = nullptr;
	output = pStringW.c_str();


	UINT pFontSize = 0;
	cout << "Enter the Size of The Font to Draw your Text" << endl;
	cin >> pFontSize;


	const wchar_t* pMessage = pStringW.c_str();

	cout << "my_str is : " << pStringToPrint << endl;
	cout << "Long String is : " << output << endl;

	LPCWSTR pDataVar = pMessage;




	hr = md2dmanager->DrawSampleTextOnTheScreenDirect2D(hInstance, hWnd,
		(WCHAR*)pDataVar, pFontSize);

	return hr;

}



HRESULT DirectXGPUDigitalLabCoreModule::ClearRenctangleSet(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\RectangleQuizData.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	vector<D2D1_RECT_F> pRectangleArrayEight = vector<D2D1_RECT_F>();
	vector<D2D1_RECT_F> pRectangleArrayTwo = vector<D2D1_RECT_F>();


	hr = md2dmanager->ClearRenctangleSet(hInstance, hWnd, &pRectangleArrayEight,
		&pRectangleArrayTwo);

	cout << "Printing the Data About Rectangle Eight" << endl;

	pixelDataFile << "Printing the Data About Rectangle Eight" << endl;



	int pRectangleNumber = 0;
	int pRectangleWidth = 0;
	int pRectangleHeight = 0;
	for (D2D1_RECT_F pRectangleEight : pRectangleArrayEight)
	{
		cout << "Rectangle Number: " << pRectangleNumber << endl;
		cout << "X Position Rectangle: " << pRectangleEight.left << endl;
		cout << "Y Position Rectangle: " << pRectangleEight.top << endl;

		pixelDataFile << "Rectangle Number: " << pRectangleNumber << endl;
		pixelDataFile << "X Position Rectangle: " << pRectangleEight.left << endl;
		pixelDataFile << "Y Position Rectangle: " << pRectangleEight.top << endl;



		pRectangleWidth = pRectangleEight.right - pRectangleEight.left;
		pRectangleHeight = pRectangleEight.bottom - pRectangleEight.top;

		cout << "Rectangle Width: " << pRectangleWidth << endl;
		cout << "Rectangle Height: " << pRectangleHeight << endl;

		pixelDataFile << "Rectangle Width: " << pRectangleWidth << endl;
		pixelDataFile << "Rectangle Height: " << pRectangleHeight << endl;

		pRectangleNumber = pRectangleNumber + 1;
	}

	cout << "Printing the Data About Rectangle Set Two" << endl;

	pixelDataFile << "Printing the Data About Rectangle Set Eight" << endl;


	pRectangleNumber = 0;



	for (D2D1_RECT_F pRectangleEight : pRectangleArrayTwo)
	{
		cout << "Rectangle Number: " << pRectangleNumber << endl;
		cout << "X Position Rectangle: " << pRectangleEight.left << endl;
		cout << "Y Position Rectangle: " << pRectangleEight.top << endl;

		pixelDataFile << "Rectangle Number: " << pRectangleNumber << endl;
		pixelDataFile << "X Position Rectangle: " << pRectangleEight.left << endl;
		pixelDataFile << "Y Position Rectangle: " << pRectangleEight.top << endl;



		pRectangleWidth = pRectangleEight.right - pRectangleEight.left;
		pRectangleHeight = pRectangleEight.bottom - pRectangleEight.top;

		cout << "Rectangle Width: " << pRectangleWidth << endl;
		cout << "Rectangle Height: " << pRectangleHeight << endl;

		pixelDataFile << "Rectangle Width: " << pRectangleWidth << endl;
		pixelDataFile << "Rectangle Height: " << pRectangleHeight << endl;


		pRectangleNumber = pRectangleNumber + 1;

	}

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateQuadraticFunctionAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	std::cout << "Simulating the Quadratic Function Graph " << endl;
	
    vector<InputStructureForGraph> pInputStructureArray = vector<InputStructureForGraph>();
	vector<OutputStructureForGraph> pOutputResultData = vector<OutputStructureForGraph>();
	
    float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	float pCoefficientA = 0.0f;
	float pCoefficientB = 0.0f;
	float pCoefficientC = 0.0f;
	float pStepValue = 0.0f;
	std::cout << "Enter the Value For Coefficient A " << endl;
	cin >> pCoefficientA;
	std::cout << "Enter the Value For Coefficient B" << endl;
	cin >> pCoefficientB;
	std::cout << "Enter the Value For Coefficient C" << endl;
	cin >> pCoefficientC;
    
	std::cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;
	std::cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;


    std::cout << "Enter the Function Step Value" << endl;
	cin >> pStepValue;
	std::cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	std::cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;
	// Specify the engine and distribution.
	std::cout << "Generating Initial Data" << endl;
	int pIndexVar = 0;
	float pVal = pMinimumOfRange;
	
    for (pVal = pMinimumOfRange; pVal <= pMaximumOfRange; ++pVal)
	{
		std::cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
		InputStructureForGraph pInputStructureForGraph;
		pInputStructureForGraph.pItemIndex = pIndexVar;
		pInputStructureForGraph.pInputItemValue = pVal;
		pInputStructureArray.push_back(pInputStructureForGraph);
		pIndexVar++;
	}
	
    hr = ppStandardAlgorithmExecutor->SimulateQuadraticFunction(hInstance, hWnd, pCoefficientA,
		pCoefficientB, pCoefficientC,
		pInputStructureArray,
		&pOutputResultData);
	
    fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\QuadraticFunctionTxt.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pixelDataFile.clear();
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	
    std::cout << "We are Simulating the function y = a*x^2 + b*x + c" << endl;
	std::cout << "Coefficient A: " << pCoefficientA << endl;
	std::cout << "Coefficient B: " << pCoefficientB << endl;
	std::cout << "Coefficient C: " << pCoefficientC << endl;

	pixelDataFile << "We are Simulating the function y = a*x^2 + b*x + c" << endl;
	pixelDataFile << "Coefficient A: " << pCoefficientA << endl;
	pixelDataFile << "Coefficient B: " << pCoefficientB << endl;
	pixelDataFile << "Coefficient C: " << pCoefficientC << endl;
	std::cout << "Printing X Values" << endl;
	pixelDataFile << "Printing X Values" << endl;
	
	vector<OutputStructureForGraph2D> ppOutputGraphFor2DArray = vector<OutputStructureForGraph2D>();

	



    for (OutputStructureForGraph pOutputStructure : pOutputResultData)
	{
		cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
		cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		pixelDataFile << "Item Index = " << pOutputStructure.pItemIndex << endl;
		pixelDataFile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		pixelDataFile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;

		OutputStructureForGraph2D pOutputStructure2D;
		pOutputStructure2D.pItemIndex = pOutputStructure.pItemIndex;
		pOutputStructure2D.pInputStructureForGraph = pOutputStructure.pInputStructureForGraph;
		pOutputStructure2D.pOutputStructureForGraph = pOutputStructure.pOutputStructureForGraph;
        ppOutputGraphFor2DArray.push_back(pOutputStructure2D);

		// Add a list of animals

		// Create a node
		


	}

	cout << "Plotting Quadratic Function Graph Object" << endl;

	hr = md2dmanager->PlotAGraphGeometryForGivenQuadraticData(hInstance, hWnd,
		ppOutputGraphFor2DArray);





	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();

	std::cout << "Simulation Has Been Completed" << endl;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SimulateExponentialFunctionAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;

	cout << "Simulating the fact Fourier Transform " << endl;
	vector<double> pArrayEightValues = vector<double>();
	vector<BufType> pInputArrayData = vector<BufType>();
	vector<BufType> pOutputResultData = vector<BufType>();

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ExponentialFunctionTxt.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	float pCoefficientParam = 0.0f;
	float pFreeCoefficient = 0.0f;


	cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;

	cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;

	cout << "Enter the Function Coefficient Param" << endl;
	cin >> pCoefficientParam;

	cout << "Enter Free Coefficient" << endl;
	cin >> pFreeCoefficient;

	cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;


	// Specify the engine and distribution.


	cout << "Generating Initial Data" << endl;
	float pStep = 1.0f;
	for (float pVal = pMinimumOfRange; pVal < pMaximumOfRange; pVal++)
	{
		cout << "Initial Input Data Array Element = " << pVal << endl;
		pixelDataFile << "Initial Input Data Array Element = " << pVal << endl;
		BufType pInputData;
		pInputData.f = pVal;
		pInputData.i = (int)pVal;
		pInputData.d = (double)pVal;
		pInputArrayData.push_back(pInputData);
	}

	hr = ppStandardAlgorithmExecutor->PerformExponentialFunctionSimulation(hInstance, hWnd,
		pCoefficientParam, pFreeCoefficient,
		pInputArrayData, &pOutputResultData);

	
	pixelDataFile.clear();
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;


	cout << "Printing X Values" << endl;
	pixelDataFile << "Printing X Values" << endl;

    cout << "Printing Y Values" << endl;
	pixelDataFile << "Printing Y Values" << endl;

	UINT iIndex = 0;
	for (BufType pNumberData : pOutputResultData)
	{

		cout << "Output Function Value At Index: " << iIndex << " = " << pNumberData.d << endl;
		pixelDataFile << "Output Function Value At Index: " << iIndex << " = " << pNumberData.d << endl;
		iIndex++;
	}

	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();




	cout << "Simulation Has Been Completed" << endl;


	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateSineFunctionCS(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	std::cout << "Simulating the Quadratic Function Graph " << endl;

	vector<InputStructureForGraph> pInputStructureArray = vector<InputStructureForGraph>();
	vector<OutputStructureForGraph> pOutputResultData = vector<OutputStructureForGraph>();

	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;

	float pCosineFunctionCoefficient = 0.0f;
	float pCoefficientB = 0.0f;

	float pStepValue = 0.0f;
	std::cout << "Enter the Value For Sine Coefficient" << endl;
	cin >> pCosineFunctionCoefficient;
	std::cout << "Enter the Value For Empty Coefficient" << endl;
	cin >> pCoefficientB;


	std::cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;
	std::cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;


	std::cout << "Enter the Function Step Value" << endl;
	cin >> pStepValue;
	std::cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	std::cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;
	// Specify the engine and distribution.
	std::cout << "Generating Initial Data" << endl;
	int pIndexVar = 0;
	float pVal = pMinimumOfRange;

	for (pVal = pMinimumOfRange; pVal <= pMaximumOfRange; ++pVal)
	{
		std::cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
		InputStructureForGraph pInputStructureForGraph;
		pInputStructureForGraph.pItemIndex = pIndexVar;
		pInputStructureForGraph.pInputItemValue = pVal;
		pInputStructureArray.push_back(pInputStructureForGraph);
		pIndexVar++;
	}

	hr = ppStandardAlgorithmExecutor->SimulateSineFunctionBehaviour(hInstance, hWnd,
		pCosineFunctionCoefficient,
		pCoefficientB,
		pInputStructureArray,
		&pOutputResultData);

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\SineFunctionTxt.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pixelDataFile.clear();
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;

	std::cout << "We are Simulating the function y = a*sin(x) + b" << endl;
	std::cout << "Sine Coefficient: " << pCosineFunctionCoefficient << endl;
	std::cout << "Empty Coefficient: " << pCoefficientB << endl;


	pixelDataFile << "We are Simulating the function y = a*SIN(x) + b" << endl;
	pixelDataFile << "Sine Coefficient: " << pCosineFunctionCoefficient << endl;
	pixelDataFile << "Empty Coefficient: " << pCoefficientB << endl;

	std::cout << "Printing X Values" << endl;
	pixelDataFile << "Printing X Values" << endl;

	for (OutputStructureForGraph pOutputStructure : pOutputResultData)
	{
		cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
		cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		pixelDataFile << "Item Index = " << pOutputStructure.pItemIndex << endl;
		pixelDataFile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		pixelDataFile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
	}

	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();

	std::cout << "Simulation Has Been Completed" << endl;
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::SimulateCosineFunctionCS(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	std::cout << "Simulating the Quadratic Function Graph " << endl;

	vector<InputStructureForGraph> pInputStructureArray = vector<InputStructureForGraph>();
	vector<OutputStructureForGraph> pOutputResultData = vector<OutputStructureForGraph>();

	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	
    float pCosineFunctionCoefficient = 0.0f;
	float pCoefficientB = 0.0f;

	float pStepValue = 0.0f;
	std::cout << "Enter the Value For Cosine Coefficient" << endl;
	cin >> pCosineFunctionCoefficient;
	std::cout << "Enter the Value For Empty Coefficient" << endl;
	cin >> pCoefficientB;


	std::cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;
	std::cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;


	std::cout << "Enter the Function Step Value" << endl;
	cin >> pStepValue;
	std::cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	std::cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;
	// Specify the engine and distribution.
	std::cout << "Generating Initial Data" << endl;
	int pIndexVar = 0;
	float pVal = pMinimumOfRange;

	for (pVal = pMinimumOfRange; pVal <= pMaximumOfRange; ++pVal)
	{
		std::cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
		InputStructureForGraph pInputStructureForGraph;
		pInputStructureForGraph.pItemIndex = pIndexVar;
		pInputStructureForGraph.pInputItemValue = pVal;
		pInputStructureArray.push_back(pInputStructureForGraph);
		pIndexVar++;
	}

	hr = ppStandardAlgorithmExecutor->SimulateCosineFunctionBehaviour(hInstance, hWnd,
        pCosineFunctionCoefficient,
        pCoefficientB,
		pInputStructureArray,
		&pOutputResultData);

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CosineFunctionTxt.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pixelDataFile.clear();
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;

	std::cout << "We are Simulating the function y = a*cos(x) + b" << endl;
	std::cout << "Cosine Coefficient: " << pCosineFunctionCoefficient << endl;
	std::cout << "Empty Coefficient: " << pCoefficientB << endl;


	pixelDataFile << "We are Simulating the function y = a*cos(x) + b" << endl;
	pixelDataFile << "Cosine Coefficient: " << pCosineFunctionCoefficient << endl;
	pixelDataFile << "Empty Coefficient: " << pCoefficientB << endl;
	
    std::cout << "Printing X Values" << endl;
	pixelDataFile << "Printing X Values" << endl;

	for (OutputStructureForGraph pOutputStructure : pOutputResultData)
	{
		cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
		cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		pixelDataFile << "Item Index = " << pOutputStructure.pItemIndex << endl;
		pixelDataFile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		pixelDataFile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
	}

	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();

	std::cout << "Simulation Has Been Completed" << endl;
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateFFTAlgorithmObject(HINSTANCE hInstance, HWND hWnd)
{
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;


	vector<_complex> vBuf1 = vector<_complex>();
	vector<_complex> vBufOutput = vector<_complex>();
	vector<float> pComplexNumbers = vector<float>();
	vector<float> pOutputArray = vector<float>();

	float pMinimumVal = 0;
	float pMaximumVal = 0;
	float pStepValue = 0;

	cout << "Input the Minimum Value for the Input Range" << endl;
	cin >> pMinimumVal;

	cout << "Input the Maximum Value For the Input Range" << endl;
	cin >> pMaximumVal;

	cout << "Enter the function Step" << endl;
	cin >> pStepValue;

	int pIndex = 0;
	for (float pValue = pMinimumVal; pValue < pMaximumVal; pValue += pStepValue)
	{
		cout << "Input Value At Index" << pIndex << "Value = " << pValue << " = " << endl;
		pComplexNumbers.push_back(pValue);
	}


	hr = ppStandardAlgorithmExecutor->PerformFFTSimulationData(hInstance, hWnd, pComplexNumbers, &pOutputArray);

	cout << "Printing Output Data Values" << endl;
    pIndex = 0;
	for (float pComplexValue : pOutputArray)
	{
		cout << "Item At Index: " << pIndex << "pValue = " << pComplexValue << endl;
	}

	return hr;
}

BOOL DirectXGPUDigitalLabCoreModule::LocateCSVFile(HWND hWnd, LPWSTR pszFileName, DWORD cbFileName)
{
	pszFileName[0] = L'\0';
	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(ofn));

	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"All Image Files\0"              L"*.bmp;*.dib;*.wdp;*.mdp;*.hdp;*.gif;*.png;*.jpg;*.jpeg;*.tif;*.ico\0"
		L"Windows Bitmap\0"               L"*.bmp;*.dib\0"
		L"High Definition Photo\0"        L"*.wdp;*.mdp;*.hdp\0"
		L"Graphics Interchange Format\0"  L"*.gif\0"
		L"Portable Network Graphics\0"    L"*.png\0"
		L"JPEG File Interchange Format\0" L"*.jpg;*.jpeg\0"
		L"Tiff File\0"                    L"*.tif\0"
		L"Icon\0"                         L"*.ico\0"
		L"All Files\0"                    L"*.*\0"
		L"\0";
	ofn.lpstrFile = pszFileName;
	ofn.nMaxFile = cbFileName;
	ofn.lpstrTitle = L"Open Image";
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

	return GetOpenFileName(&ofn);

}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageClippingExperimentWithCoordinates(HINSTANCE hInstance,
	HWND hWnd,
	UINT pXPosition,
	UINT pYPosition,
	UINT pClipWidth,
	UINT pClipHeight,
	vector<PixelObject> *ppPixelObjectArray)
{
	HRESULT hr = S_OK;


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	
	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pXPosition, pYPosition, pClipWidth, pClipHeight, &pixelObjectVector);


	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageClippers.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Image Clip" << endl;
	imageSegmentationDataFile.clear();
	for (PixelObject pixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}
	imageSegmentationDataFile.close();
	*ppPixelObjectArray = pixelObjectVector;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageClippingExperimentUsingClipper(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pXPosition1 = 0.0f;
	float pYPosition1 = 0.0f;
	LPWSTR path = nullptr;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageClippingExperimentsFile.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	cout << "Enter The X Position For Top Left Point of Rectangle" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Value for Top Left Point of Rectangle" << endl;
	cin >> pYPosition;

	cout << "Enter the X Position for Bottom Right Point of Rectangle" <<  endl;
	cin >> pXPosition1;
	cout << "Enter the Y Position for Bottom Right Point of Rectangle" << endl;
	cin >> pYPosition1;
	
	float pImageWidth = sqrt(pow((pXPosition1 - pXPosition), 2));
	float pImageHeight = sqrt(pow((pYPosition1 - pYPosition), 2));
	if (pXPosition == 0 && pYPosition == 0)
	{
		pImageWidth = pImageWidth + 1;
		pImageHeight = pImageHeight + 1;
	}
	

	cout << "Your Image Width = " << pImageWidth << endl;
	cout << "Your Image Height = " << pImageHeight << endl;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectVector);





		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();
		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Index: " << pIndex << endl;
			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
		imageSegmentationDataFile.close();

	}
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageClippingExperimentWithoutDirect2D(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pImageWidth = 0.0f;
	float pImageHeight = 0.0f;
	LPWSTR path = nullptr;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageClippingExperimentsFile.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	cout << "Enter The X Position For Top Left Point of Rectangle" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Value for Top Left Point of Rectangle" << endl;
	cin >> pYPosition;

	cout << "Enter the Width of the Image" << endl;
	cin >> pImageWidth;

	cout << "Enter the Y Position for Bottom Right Point of Rectangle" << endl;
	cin >> pImageHeight;

	


	cout << "Your Image Width = " << pImageWidth << endl;
	cout << "Your Image Height = " << pImageHeight << endl;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
			hWnd, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectVector);





		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();
		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Index: " << pIndex << endl;
			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
		imageSegmentationDataFile.close();

	}
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SaveScreenDataToImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPWSTR path = nullptr;

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	return hr;

}


















HRESULT DirectXGPUDigitalLabCoreModule::RecoverRGBImageFromTextFile(HINSTANCE hInstance, HWND hWnd)
{
	std::ifstream in("C:\\pixels\\ImageClippingExperimentsFileInts.txt");

	// Check if object is valid
	if (!in)
	{
		std::cerr << "Cannot open the File : " << std::endl;
		return false;
	}

	std::string strPixelNumber;
	std::string strPixelXPosition;
	std::string strPixelYPosition;
	std::string strPixelRedComponent;
	std::string strPixelGreenComponent;
	std::string strPixelBlueComponent;


	int pPixelNumber = 0;
	float pXPosition0 = 0.0f;
	float pYPosition0 = 0.0f;
	float pRedComponent = 0.0f;
	float pGreenComponent = 0.0f;
	float pBlueComponent = 0.0f;
	vector<PixelObject> pPixelObjetArray = vector<PixelObject>();

	int pIndex = 0;
	// Read the next line from File untill it reaches the end.
	do
	{
		cout << "Amount of Processes Pixels = " << pIndex;
		std::getline(in, strPixelNumber);
		std::getline(in, strPixelXPosition);
		std::getline(in, strPixelYPosition);
		std::getline(in, strPixelRedComponent);
		std::getline(in, strPixelGreenComponent);
		std::getline(in, strPixelBlueComponent);
		
		stringstream pPixelNumberStream(strPixelNumber);
		stringstream pPixelXPositionStream(strPixelXPosition);
		stringstream pPixelYPositionStream(strPixelYPosition);
		stringstream pPixelRedComponentStream(strPixelRedComponent);
		stringstream pPixelGreenComponentStream(strPixelGreenComponent);
		stringstream pPixelBlueComponentStream(strPixelBlueComponent);

		pPixelNumberStream >> pPixelNumber;
		pPixelXPositionStream >> pXPosition0;
		pPixelYPositionStream >> pYPosition0;
		pPixelRedComponentStream >> pRedComponent;
		pPixelGreenComponentStream >> pGreenComponent;
		pPixelBlueComponentStream >> pBlueComponent;

		PixelObject pPixelObject = PixelObject(pPixelNumber,
			pXPosition0,
			pYPosition0,
			pRedComponent,
			pGreenComponent,
			pBlueComponent);

			// Line contains string of length > 0 then save it in vector
		pPixelObjetArray.push_back(pPixelObject);

	} while (in.eof() == false);
	cout << "Printing Output of RGB Pixel Array" << endl;
	for (PixelObject pixelObject : pPixelObjetArray)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;
	}

}


PixelObject DirectXGPUDigitalLabCoreModule::GetPixelObjectByXAndYPositiion(vector<PixelObject> pPixelObjectVector, float pXPosition, float pYPosition)
{
	PixelObject pPixelObjectVar = PixelObject(0, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);

	for (auto pPixelObject = std::begin(pPixelObjectVector); pPixelObject < std::end(pPixelObjectVector); ++pPixelObject)
	{
		PixelObject pPixelClass = *pPixelObject;
		
		if (pPixelClass.xPosition == pXPosition && pPixelClass.yPosition == pYPosition)
		{
			pPixelObjectVar = pPixelClass;
			break;
		}
	}

	return pPixelObjectVar;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageClippingExperimentBinaryTree(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pWidth = 0.0f;
	float pHeight = 0.0f;
	LPWSTR path = nullptr;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageClippingExperimentsFileBinaryTree.txt", fstream::in | fstream::out | fstream::app);
	imageSegmentationDataFile.clear();

	fstream imageSegmentationDataFileSerialized;
	imageSegmentationDataFileSerialized.open("C:\\pixels\\ImageClippingExperimentsFileSerialized.txt", fstream::in | fstream::out | fstream::app);
	imageSegmentationDataFileSerialized.clear();







	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	cout << "Enter The X Position For Top Left Point of Rectangle" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Value for Top Left Point of Rectangle" << endl;
	cin >> pYPosition;

	cout << "Enter the width for the rectangular area" << endl;
	cin >> pWidth;

	cout << "Enter the height for the rectangular area" << endl;
	cin >> pHeight;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorRestored = vector<PixelObject>();

	BinaryTreeNode pRootNode = BinaryTreeNode(0, nullptr);



	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	
	if (GetOpenFileNameW(&ofn))
	{


		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pXPosition, pYPosition, pWidth, pHeight, &pixelObjectVector);





		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		imageSegmentationDataFile.clear();

		imageSegmentationDataFile << "New Image Clip" << endl;

		cout << "We Will Also try to save image in binary format" << endl;
		cout << "For This We Will Try To Create a File with a ROS extention" << endl;

		vector<PixelObjectClass*> ppPixelClassObjectsArray = vector<PixelObjectClass*>();

		float pCurrentXPosition = 0.0f;
		float pCurrentYPosition = 0.0f;

		for (PixelObject pixelObject : pixelObjectVector)
		{
		
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



			BinaryTreeNode pBinaryTreeNode = BinaryTreeNode(0, nullptr);
			pBinaryTreeNode.pBinaryTreeNodeId = pixelObject.pixelNumber;
			pBinaryTreeNode.pPixelObject = &pixelObject;
		


		



			if (pBinaryTreeNode.pPixelObject->xPosition > pCurrentXPosition && pBinaryTreeNode.pPixelObject->yPosition == pCurrentYPosition)
			{
				pRootNode.SetRight(&pBinaryTreeNode);
			}
		
			
			if (pixelObject.xPosition < pCurrentXPosition && pBinaryTreeNode.pPixelObject->yPosition == pCurrentYPosition)
			{
				pRootNode.SetLeft(&pBinaryTreeNode);

			}

			pRootNode = pBinaryTreeNode;
		}

		cout << "Saving the Clip To DAT file" << endl;

		LPCWSTR pFIleName = L"C:\\RobotData\\StorageImage.jpg";


		UINT pImageSize = 0;
		cout << "Let Us Determine the size of Our Vector we Have Recorded" << endl;
		pImageSize = pixelObjectVector.size();
		cout << "The Array Object Size: " << pImageSize << endl;
		cout << "Now We will To Restore the Saved Pixel Array" << endl;
		cout << "We Will Store the Contents in a new Vector" << endl;

		cout << "Let Us Determine the size of Our Vector we Have Recorded" << endl;
		pImageSize = pixelObjectVector.size();
		cout << "The Array Object Size: " << pImageSize << endl;
		cout << "Now We will To Restore the Saved Pixel Array" << endl;
		cout << "We Will Store the Contents in a new Vector" << endl;




	}

	

	cout << "Saving clipper Image file" << endl;

	cout << "Print Binary Tree" << endl;
	
	do 
	{
		BinaryTreeNode pCurrentNode = pRootNode;
		cout << "Node Id: " << pCurrentNode.pBinaryTreeNodeId << endl;
		cout << "Current Node Pixel Number: " << pCurrentNode.pPixelObject->pixelNumber << endl;
		cout << "Current Node X Position: " << pCurrentNode.pPixelObject->xPosition << endl;
		cout << "Current Node Y Position: " << pCurrentNode.pPixelObject->yPosition << endl;
		cout << "R Mask: " << pCurrentNode.pPixelObject->RMask << endl;
		cout << "G Mask: " << pCurrentNode.pPixelObject->GMask << endl;
		cout << "B Mask: " << pCurrentNode.pPixelObject->BMask << endl;

		cout << "Priniting Left Child" << endl;
		BinaryTreeNode* pLeftChild = pCurrentNode.GetLeft();

		if ((unsigned int)pLeftChild == 0xCCCCCCCC)
		{
			break;
		}

		


		if (pLeftChild != nullptr && pXPosition > 0 && (unsigned int)pLeftChild != 0xCCCCCCCC)
		{
			cout << "Node Id: " << pLeftChild->pBinaryTreeNodeId << endl;
			cout << "Current Node Pixel Number: " << pLeftChild->pPixelObject->pixelNumber << endl;
			cout << "Current Node X Position: " << pLeftChild->pPixelObject->xPosition << endl;
			cout << "Current Node Y Position: " << pLeftChild->pPixelObject->yPosition << endl;
			cout << "R Mask: " << pLeftChild->pPixelObject->RMask << endl;
			cout << "G Mask: " << pLeftChild->pPixelObject->GMask << endl;
			cout << "B Mask: " << pLeftChild->pPixelObject->BMask << endl;

		}
	
		BinaryTreeNode* pRightChild = pCurrentNode.GetRight();
		if ((unsigned int)pRightChild == 0xCCCCCCCC)
		{
			break;
		}

		if (pRightChild != nullptr && pYPosition < pHeight && (unsigned int)pRightChild != 0xCCCCCCCC)
		{
			cout << "Node Id: " << pRightChild->pBinaryTreeNodeId << endl;
			cout << "Current Node Pixel Number: " << pRightChild->pPixelObject->pixelNumber << endl;
			cout << "Current Node X Position: " << pRightChild->pPixelObject->xPosition << endl;
			cout << "Current Node Y Position: " << pRightChild->pPixelObject->yPosition << endl;
			cout << "R Mask: " << pRightChild->pPixelObject->RMask << endl;
			cout << "G Mask: " << pRightChild->pPixelObject->GMask << endl;
			cout << "B Mask: " << pRightChild->pPixelObject->BMask << endl;

		}

		pRootNode = pCurrentNode;
		
 
	} while (false);





	imageSegmentationDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageClippingExperiment(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pWidth = 0.0f;
	float pHeight = 0.0f;
	LPWSTR path = nullptr;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageClippingExperimentsFile.txt", fstream::in | fstream::out | fstream::app);
	imageSegmentationDataFile.clear();

	fstream imageSegmentationDataFileSerialized;
	imageSegmentationDataFileSerialized.open("C:\\pixels\\ImageClippingExperimentsFileSerialized.txt", fstream::in | fstream::out | fstream::app);
	imageSegmentationDataFileSerialized.clear();







	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	cout << "Enter The X Position For Top Left Point of Rectangle" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Value for Top Left Point of Rectangle" << endl;
	cin >> pYPosition;

	cout << "Enter the width for the rectangular area" << endl;
	cin >> pWidth;

	cout << "Enter the height for the rectangular area" << endl;
	cin >> pHeight;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorRestored = vector<PixelObject>();


	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


				imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, 
			hWnd, pXPosition, pYPosition, pWidth, pHeight, &pixelObjectVector);





		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		imageSegmentationDataFile.clear();

		imageSegmentationDataFile << "New Image Clip" << endl;

		cout << "We Will Also try to save image in binary format" << endl;
		cout << "For This We Will Try To Create a File with a ROS extention" << endl;

		
		vector<PixelObjectClass*> ppPixelClassObjectsArray = vector<PixelObjectClass*>();
		for (PixelObject pixelObject : pixelObjectVector)
		{
			

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;
		
			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


			
			

	

			
			
		}

		cout << "Computing Average X FOR Pixel Array" << endl;
		float pAverageX = 0.0f;
		float pAverageY = 0.0f;

		pAverageX = ComputeAverageXForPixelArray(pixelObjectVector);
		pAverageY = ComputeAverageYForPixelArray(pixelObjectVector);

		cout << "Overall Average X: " << pAverageX << endl;
		cout << "Overall Average Y: " << pAverageY << endl;
		
		imageSegmentationDataFile << "Overall Average X: " << pAverageX << endl;
		imageSegmentationDataFile << "Overall Average Y: " << pAverageY << endl;


		float pYConstant = 0.0f;
		cout << "Enter The y Constant for X Averaging" << endl;
		cin >> pYConstant;


		float pXConstant = 0.0f;
		cout << "Enter The X Constant for Y Averaging" << endl;
		cin >> pXConstant;

		cout << "Computing X Average for Y = " << pYConstant << endl;
		imageSegmentationDataFile << "Computing X Average for Y = " << pYConstant << endl;

		float pAverageXForYConstant = 0.0f;
		pAverageXForYConstant = ComputeAverageXForPixelArrayWithYConstantAndXRange(pixelObjectVector,
			0,
			pWidth,
			pYConstant);

		cout << "Average X for Y = " << pYConstant << " = " << pAverageXForYConstant << endl;
		imageSegmentationDataFile << "Average X for Y = " << pYConstant << " = " << pAverageXForYConstant << endl;

		cout << "Computing Y Average for X = " << pXConstant << endl;
		imageSegmentationDataFile << "Computing Y Average for X = " << pXConstant << endl;

		float pAverageYForXConstant = 0.0f;
		pAverageYForXConstant = ComputeAverageXForPixelArrayWithYConstantAndXRange(pixelObjectVector,
			0,
			pHeight,
			pXConstant);

		cout << "Average Y for X = " << pXConstant << " = " << pAverageYForXConstant << endl;
		imageSegmentationDataFile << "Average Y for X = " << pXConstant << " = " << pAverageYForXConstant << endl;

		

		cout << "Simulate Path Geometry" << endl;
		cout << "Saving the Clip To DAT file" << endl;
	
		LPCWSTR pFIleName =  L"C:\\RobotData\\StorageImage.jpg";


		UINT pImageSize = 0;
		cout << "Let Us Determine the size of Our Vector we Have Recorded" << endl;
		pImageSize = pixelObjectVector.size();
		cout << "The Array Object Size: " << pImageSize << endl;
		cout << "Now We will To Restore the Saved Pixel Array" << endl;
		cout << "We Will Store the Contents in a new Vector" << endl;

		cout << "Let Us Determine the size of Our Vector we Have Recorded" << endl;
		pImageSize = pixelObjectVector.size();
		cout << "The Array Object Size: " << pImageSize << endl;
		cout << "Now We will To Restore the Saved Pixel Array" << endl;
		cout << "We Will Store the Contents in a new Vector" << endl;


			
		
	}


	

	cout << "Saving clipper Image file" << endl;


	imageSegmentationDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageClippingExperimentWithSegmentation(HINSTANCE hInstance, HWND hWnd, int xPosition, int yPosition, int pImageWidth, int pImageHeight,
	vector<PixelObject> *ppPixelObjectArray)
{
	HRESULT hr = S_OK;

	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pWidth = 0.0f;
	float pHeight = 0.0f;
	LPWSTR path = nullptr;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageClippingExperimentsFile.txt", fstream::in | fstream::out | fstream::app);
	imageSegmentationDataFile.clear();

	fstream imageSegmentationDataFileSerialized;
	imageSegmentationDataFileSerialized.open("C:\\pixels\\ImageClippingExperimentsFileSerialized.txt", fstream::in | fstream::out | fstream::app);
	imageSegmentationDataFileSerialized.clear();








	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorRestored = vector<PixelObject>();


	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	if (GetOpenFileNameW(&ofn))
	{


		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectVector);





		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		imageSegmentationDataFile.clear();

		imageSegmentationDataFile << "New Image Clip" << endl;

		cout << "We Will Also try to save image in binary format" << endl;
		cout << "For This We Will Try To Create a File with a ROS extention" << endl;


		vector<PixelObjectClass> ppPixelClassObjectsArray = vector<PixelObjectClass>();
		for (PixelObject pixelObject : pixelObjectVector)
		{


			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



		





		}
		cout << "Saving the Clip To DAT file" << endl;



		UINT pImageSize = 0;
		cout << "Let Us Determine the size of Our Vector we Have Recorded" << endl;
		pImageSize = pixelObjectVector.size();
		cout << "The Array Object Size: " << pImageSize << endl;
		cout << "Now We will To Restore the Saved Pixel Array" << endl;
		cout << "We Will Store the Contents in a new Vector" << endl;

		cout << "Let Us Determine the size of Our Vector we Have Recorded" << endl;
		pImageSize = pixelObjectVector.size();
		cout << "The Array Object Size: " << pImageSize << endl;
		cout << "Now We will To Restore the Saved Pixel Array" << endl;
		cout << "We Will Store the Contents in a new Vector" << endl;




	}

	

	cout << "Saving clipper Image file" << endl;


	imageSegmentationDataFile.close();

	*ppPixelObjectArray = pixelObjectVector;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::OpenTheContentOfTheRosFileImageRGB(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	cout << "We Will Recover the Structure Of the Stored Image File" << endl;
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	UINT pImageSize = 0;
	vector<PixelObject> ppPixelObjectRestoredArray = vector<PixelObject>();
	UINT pIndex = 0;
	fstream imageRecoveryDataFile;
	imageRecoveryDataFile.open("C:\\pixels\\RosImageFileRestoration.txt", fstream::in | fstream::out | fstream::trunc);
	imageRecoveryDataFile.clear();

	cout << "Enter the Width of the Image To Restore" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of the Image To Restore" << endl;
	cin >> pImageHeight;

	pImageSize = pImageHeight * pImageWidth;


	cout << "The Size of the Image Buffer = " << pImageSize << endl;


	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		ifstream pPixelObjectReader(ofn.lpstrFile, ios::binary);
		for (int pIndex = 0; pIndex < pImageSize; ++pIndex)
		{
			cout << "Reading Pixel Object With Index: " << pIndex << endl;
			PixelObject pixelObjectReadback = PixelObject(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
			pPixelObjectReader.read((char *)&pixelObjectReadback, sizeof(pixelObjectReadback));
			ppPixelObjectRestoredArray.push_back(pixelObjectReadback);
		}

		cout << "Now We Will Print the Restored Pixels" << endl;
		pIndex = 0;
		for (PixelObject pixelObject : ppPixelObjectRestoredArray)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageRecoveryDataFile << "Index: " << pIndex << endl;
			imageRecoveryDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageRecoveryDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageRecoveryDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageRecoveryDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageRecoveryDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageRecoveryDataFile << "Blue Value: " << pixelObject.BMask << endl;
			pIndex++;
		}


	}

	return hr;
}




	HRESULT DirectXGPUDigitalLabCoreModule::SimulateStandardDeviationExperimentFromTextFile(HINSTANCE hInstance, HWND hWnd)
	{
		HRESULT hr = S_OK;

		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		ofstream pStream("C:\\pixels\\StandardDeviation.txt");
		pStream.clear();

		int pXPosition = 0;
		int pYPosition = 0;
		int pClipWidth = 0;
		int pClipHeight = 0;

		vector<float> pInputDataBuffer = vector<float>();
		vector<BufType> pOutputDataBuffer = vector<BufType>();


		LPWSTR pFileName = nullptr;
		LPWSTR pFileObject = nullptr;


		string pStr = ".";
		float pValue = 0.0f;
		ifstream inFile;
		inFile.open("C:\\pixels\\Dollar - Values.txt");

		while (inFile.good())
		{
			std::getline(inFile, pStr);
			cout << "New Item Read ValueL" << pStr << endl;
			pValue = atof(pStr.c_str());
			pInputDataBuffer.push_back(pValue);
		}
		inFile.close();


		cout << "Printing the Contents of Initial Array" << endl;
		int pItemIndex = 0;
		for (float pValue : pInputDataBuffer)
		{
			cout << "Initial Array Item At Index: " << pItemIndex << " = " << pValue << endl;
			pStream << "Initial Array Item At Index: " << pItemIndex << " = " << pValue << endl;

			pItemIndex = pItemIndex + 1;
		}



		//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));

		vector<InputItemType> pInputBufferObjectEight = vector<InputItemType>();
		vector<CStandardDeviationOutputType> pOutputDataBufferP = vector<CStandardDeviationOutputType>();
		UINT pIndex = 0;

		for (float pArrayValue : pInputDataBuffer)
		{
			InputItemType pInputItemObject;
			pInputItemObject.pItemId = pIndex;
			pInputItemObject.pItemValue = pArrayValue;

			cout << "Item Id " << pIndex << " = " << pInputItemObject.pItemId << endl;
			cout << "Value : " << pIndex << " = " << pInputItemObject.pItemValue << endl;

			pInputBufferObjectEight.push_back(pInputItemObject);
			pIndex = pIndex + 1;
		}

		int pOutputValue = 0;
		hr = ppStandardAlgorithmExecutor->SimulateStandardDeviationComputationP(hInstance, hWnd,
			pInputBufferObjectEight, &pOutputDataBufferP,
			&pOutputValue);

		pIndex = 0;
		float pSumValueFinal = 0;
		float pAverageValue = 0;

		UINT iIndex = 0;
		for (CStandardDeviationOutputType pNumberData : pOutputDataBufferP)
		{
			cout << "Item Index: " << pNumberData.pItemIndex << endl;
			cout << "input Value: " << pNumberData.pInputValue << endl;
			cout << "Output Value: " << pNumberData.pOutputValue << endl;

			pStream << "Item Index: " << pNumberData.pItemIndex << endl;
			pStream << "input Value: " << pNumberData.pInputValue << endl;
			pStream << "Output Value: " << pNumberData.pOutputValue << endl;

			pSumValueFinal = pSumValueFinal + pNumberData.pOutputValue;

		}


		cout << "Computing the Mean Standard Deviation Output" << endl;
		cout << "Standard Deviation Sum: " << pSumValueFinal << endl;
		pAverageValue = sqrt(pSumValueFinal / pOutputDataBufferP.size());
		cout << "Standard Deviation Value: " << pAverageValue << endl;
		pStream << "Standard Deviation Value: " << pAverageValue << endl;

		pStream.close();
		return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ComputeImageGradientFunctionForGrayscaleImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ComputeImageInstensityFunctionLog.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		fstream imageSegmentationDataFile("C:\\pixels\ImageClips.txt");
		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = pVideoAnalyticsManagementClass->ClipSelectedImageToRect(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppPixelObjectInput);
	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : ppPixelObjectInput)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	cout << "Converting Clipped Area To GrayScale Image" << endl;
	pixelDataFile << "Converting Clipped Area To GrayScale Image" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		ppPixelObjectInput, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;
	cout << "Sorting Initial Grayscale Pixel Vector According to X Values" << endl;
//	std::sort(begin(pPixelObjectToGrayScale), end(pPixelObjectToGrayScale), pSortGrayscalePixelsByXAscending);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Pixel Number: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Computing Image Intensity Function Gradient For X Parameter " << endl;
	pixelDataFile << "Computing Image Intensity Function Gradient For X Parameter " << endl;


	vector<CImageDerivativeClass> pCImageDerivativeClassForXValues = vector<CImageDerivativeClass>();
	vector<CImageDerivativeClass> pCImageDerivativeClassForYValues = vector<CImageDerivativeClass>();



	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;






	hr = ppStandardAlgorithmExecutor->ComputePixelImageDerivativeFunctionForXValues(hInstance, hWnd,
		pPixelObjectToGrayScale, pImageWidth, pImageHeight, &pCImageDerivativeClassForXValues);

	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Sorting The Initial Pixel Object Grayscale Vector For Y Parameter" << endl;
	//std::sort(begin(pPixelObjectToGrayScale), end(pPixelObjectToGrayScale), pSortGrayscalePixelsByCbAscending);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Pixel Number: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	cout << "Computing Image Intensity Function Gradient For Y Parameter " << endl;
	pixelDataFile << "Computing Image Intensity Function Gradient For Y Parameter " << endl;



	hr = ppStandardAlgorithmExecutor->ComputePixelImageDerivativeFunctionForYValues(hInstance, hWnd,
		pPixelObjectToGrayScale, pImageWidth, pImageHeight, &pCImageDerivativeClassForYValues);

	cout << "Printing the Derivative Function Output For Y Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForYValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value Y = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Computing Common Image Gradient Component" << endl;
	pixelDataFile << "Computing Common Image Gradient Component" << endl;


	cout << "Sorting the X Position Derivative Vector" << endl;
//	std::sort(begin(pCImageDerivativeClassForXValues), end(pCImageDerivativeClassForXValues), pSortImageDerivativeByXAscending);
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Sorting The Y Position Derivative Vector" << endl;
//	std::sort(begin(pCImageDerivativeClassForYValues), end(pCImageDerivativeClassForYValues), pSortImageDerivativeByCbAscending);
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForYValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}





	vector<CImageFullDerivativesClass> ppFullDerivativesClassObjectCollection = vector<CImageFullDerivativesClass>();
	hr = ppStandardAlgorithmExecutor->ComputeImageFunctionDerivativesFinal(hInstance, hWnd,
		pCImageDerivativeClassForXValues, pCImageDerivativeClassForYValues, &ppFullDerivativesClassObjectCollection);

	cout << "Printing the Final Image Gradients" << endl;
	for (CImageFullDerivativesClass pImageFullDerivativeObject : ppFullDerivativesClassObjectCollection)
	{
		cout << "Pixel Number = " << pImageFullDerivativeObject.pDerivativeIndex << endl;
		cout << "X Position = " << pImageFullDerivativeObject.pXPosition << endl;
		cout << "Y Position = " << pImageFullDerivativeObject.pYPosition << endl;
		cout << "Gradient Value Magnitude = " << pImageFullDerivativeObject.pMagnitudeValue << endl;
		cout << "Gradient Value Direction = " << pImageFullDerivativeObject.pDirectionValue << endl;

		pixelDataFile << "Pixel Number = " << pImageFullDerivativeObject.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageFullDerivativeObject.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageFullDerivativeObject.pYPosition << endl;
		pixelDataFile << "Gradient Value Magnitude = " << pImageFullDerivativeObject.pMagnitudeValue << endl;
		pixelDataFile << "Gradient Value Direction = " << pImageFullDerivativeObject.pDirectionValue << endl;

	}


	pixelDataFile.close();

	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ComputeImageGradientFunctionForGrayscaleImageOnGPU(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ComputeImageInstensityFunctionOnGPU.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		fstream imageSegmentationDataFile("C:\\pixels\ImageClips.txt");
		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppPixelObjectInput);
	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : ppPixelObjectInput)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	cout << "Converting Clipped Area To GrayScale Image" << endl;
	pixelDataFile << "Converting Clipped Area To GrayScale Image" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		ppPixelObjectInput, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;
	cout << "Sorting Initial Grayscale Pixel Vector According to X Values" << endl;
	//	std::sort(begin(pPixelObjectToGrayScale), end(pPixelObjectToGrayScale), pSortGrayscalePixelsByXAscending);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Pixel Number: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Computing Image Intensity Function Gradient For X Parameter " << endl;
	pixelDataFile << "Computing Image Intensity Function Gradient For X Parameter " << endl;


	vector<CImageDerivativeClass> pCImageDerivativeClassForXValues = vector<CImageDerivativeClass>();
	vector<CImageDerivativeClass> pCImageDerivativeClassForYValues = vector<CImageDerivativeClass>();



	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;






	hr = ppStandardAlgorithmExecutor->ComputePixelImageDerivativeFunctionForXValues(hInstance, hWnd,
		pPixelObjectToGrayScale, pImageWidth, pImageHeight, &pCImageDerivativeClassForXValues);

	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Sorting The Initial Pixel Object Grayscale Vector For Y Parameter" << endl;
	//std::sort(begin(pPixelObjectToGrayScale), end(pPixelObjectToGrayScale), pSortGrayscalePixelsByCbAscending);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Pixel Number: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	cout << "Computing Image Intensity Function Gradient For Y Parameter " << endl;
	pixelDataFile << "Computing Image Intensity Function Gradient For Y Parameter " << endl;



	hr = ppStandardAlgorithmExecutor->ComputePixelImageDerivativeFunctionForYValues(hInstance, hWnd,





		pPixelObjectToGrayScale, pImageWidth, pImageHeight, &pCImageDerivativeClassForYValues);

	cout << "Printing the Derivative Function Output For Y Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForYValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value Y = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Computing Common Image Gradient Component" << endl;
	pixelDataFile << "Computing Common Image Gradient Component" << endl;


	cout << "Sorting the X Position Derivative Vector" << endl;
	//	std::sort(begin(pCImageDerivativeClassForXValues), end(pCImageDerivativeClassForXValues), pSortImageDerivativeByXAscending);
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Sorting The Y Position Derivative Vector" << endl;
	//	std::sort(begin(pCImageDerivativeClassForYValues), end(pCImageDerivativeClassForYValues), pSortImageDerivativeByCbAscending);
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForYValues)
	{
		cout << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Pixel Number = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}





	vector<CImageFullDerivativeClassStruct> ppFullDerivativesClassObjectCollection = vector<CImageFullDerivativeClassStruct>();
	hr = ppStandardAlgorithmExecutor->ComputeImageFunctionDerivativesFinalGPU(hInstance, hWnd,
		pCImageDerivativeClassForXValues, pCImageDerivativeClassForYValues, &ppFullDerivativesClassObjectCollection);

	cout << "Printing the Final Image Gradients" << endl;
	for (CImageFullDerivativeClassStruct pImageFullDerivativeObject : ppFullDerivativesClassObjectCollection)
	{
		cout << "Pixel Number = " << pImageFullDerivativeObject.pDerivativeIndex << endl;
		cout << "X Position = " << pImageFullDerivativeObject.pXPosition << endl;
		cout << "Y Position = " << pImageFullDerivativeObject.pYPosition << endl;
		cout << "Gradient Value Magnitude = " << pImageFullDerivativeObject.pMagnitude << endl;
		cout << "Gradient Value Direction = " << pImageFullDerivativeObject.pDirection << endl;

		pixelDataFile << "Pixel Number = " << pImageFullDerivativeObject.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageFullDerivativeObject.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageFullDerivativeObject.pYPosition << endl;
		pixelDataFile << "Gradient Value Magnitude = " << pImageFullDerivativeObject.pMagnitude<< endl;

		pixelDataFile << "Gradient Value Direction = " << pImageFullDerivativeObject.pDirection << endl;

	}


	pixelDataFile.close();

	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::ComputeImageGradientFunctionForGrayscaleImageWithGaussianSmoothing(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ComputeImageInstensityFunctionLogGaussian.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		fstream imageSegmentationDataFile("C:\\pixels\ImageClips.txt");
		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = pVideoAnalyticsManagementClass->ClipSelectedImageToRect(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppPixelObjectInput);
	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : ppPixelObjectInput)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	cout << "Converting Clipped Area To GrayScale Image" << endl;
	pixelDataFile << "Converting Clipped Area To GrayScale Image" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		ppPixelObjectInput, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;
	cout << "Sorting Initial Grayscale Pixel Vector According to X Values" << endl;
	std::sort(std::begin(pPixelObjectToGrayScale), std::end(pPixelObjectToGrayScale), pSortGrayscalePixelsByXAscending);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Computing Image Intensity Function Gradient For X Parameter " << endl;
	pixelDataFile << "Computing Image Intensity Function Gradient For X Parameter " << endl;


	vector<CImageDerivativeClass> pCImageDerivativeClassForXValues = vector<CImageDerivativeClass>();
	vector<CImageDerivativeClass> pCImageDerivativeClassForYValues = vector<CImageDerivativeClass>();



	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;



	hr = ppStandardAlgorithmExecutor->SimulateStandardOnSelectedImage(hInstance, hWnd, pPixelObjectToGrayScale,
		&pOutputDataBufferP);

	pIndex = 0;
	float pSumValueFinal = 0;
	float pStandardDeviationValue = 0;
	float pi_var = DirectX::XM_PI;






	for (CStandardDeviationImageOutputType pImageStandardDeviaionVar : pOutputDataBufferP)
	{
		cout << "Pixel Number: " << pImageStandardDeviaionVar.pixelNumber << endl;
		cout << "X Position: " << pImageStandardDeviaionVar.xPosition << endl;
		cout << "Y Position: " << pImageStandardDeviaionVar.yPosition << endl;
		cout << "Standard Deviation: " << pImageStandardDeviaionVar.pStandardDeviationVar << endl;

		pixelDataFile << "Pixel Number: " << pImageStandardDeviaionVar.pixelNumber << endl;
		pixelDataFile << "X Position: " << pImageStandardDeviaionVar.xPosition << endl;
		pixelDataFile << "Y Position: " << pImageStandardDeviaionVar.yPosition << endl;
		pixelDataFile << "Standard Deviation: " << pImageStandardDeviaionVar.pStandardDeviationVar << endl;
		pSumValueFinal = pSumValueFinal + pImageStandardDeviaionVar.pStandardDeviationVar;

	}




	cout << "Computing the Mean Standard Deviation Output" << endl;
	cout << "Standard Deviation Sum: " << pSumValueFinal << endl;
	pStandardDeviationValue = pSumValueFinal / pOutputDataBufferP.size();
	cout << "Standard Deviation Value: " << pStandardDeviationValue << endl;
	pixelDataFile << "Standard Deviation Value: " << pStandardDeviationValue << endl;


	cout << "Now We will Simulate the Gaussian Blur on Selected Grayscale Image" << endl;
	float pSigmaValue = 0;
	cout << "Enter the Value that You Would like to Use for Gaussian Smoothing" << endl;
	cin >> pSigmaValue;

	float pDifferentialIndex = 0.0f;
	cout << "Enter the Differentiation Index" << endl;
	cin >> pDifferentialIndex;


	vector<GaussianOutputVar> ppGaussianBlurOutputArray = vector<GaussianOutputVar>();
	hr = ppStandardAlgorithmExecutor->SimulateGaussianFilteringOnSelectedImage2D(
		hInstance, hWnd, pPixelObjectToGrayScale,
		pi_var, pStandardDeviationValue,
		&ppGaussianBlurOutputArray);

	cout << "Printing The Output Results of the Simulation File" << endl;
	pixelDataFile << "Printing The Output Results of the Simulation File" << endl;

	pIndex = 0;
	for (GaussianOutputVar pGaussianBlurOutputValue : ppGaussianBlurOutputArray)
	{

		cout << "Item Index: " << pIndex << endl;
		cout << "Pixel Id: " << " = " << pGaussianBlurOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pGaussianBlurOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pGaussianBlurOutputValue.yPosition << endl;
		cout << "Gaussian Blur Value: " << " = " <<  pGaussianBlurOutputValue.pGaussianValueF << endl;


		pixelDataFile << "Item Index: " << pIndex << endl;
		pixelDataFile << "Pixel Id: " << " = " << pGaussianBlurOutputValue.pixelNumber << endl;
		pixelDataFile << "X Position: " << " = " << pGaussianBlurOutputValue.xPosition << endl;
		pixelDataFile << "Y Position: " << " = " << pGaussianBlurOutputValue.yPosition << endl;
		pixelDataFile << "Gaussian Blur Value: " << " = " << pGaussianBlurOutputValue.pGaussianValueF << endl;

	}

	hr = ppStandardAlgorithmExecutor->ComputeImageDerivativeFunctionForwardForXValuesGaussian(hInstance, hWnd,
		ppGaussianBlurOutputArray, pImageWidth, pImageHeight, pDifferentialIndex, &pCImageDerivativeClassForXValues);
	
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Sorting The Initial Pixel Object Grayscale Vector For Y Parameter" << endl;
	std::sort(std::begin(pPixelObjectToGrayScale), std::end(pPixelObjectToGrayScale), pSortGrayscalePixelsByCbAscending);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	
	cout << "Computing Image Intensity Function Gradient For Y Parameter " << endl;
	pixelDataFile << "Computing Image Intensity Function Gradient For Y Parameter " << endl;



	hr = ppStandardAlgorithmExecutor->ComputeImageDerivativeFunctionForwardForYValuesGaussian(hInstance, hWnd,
		ppGaussianBlurOutputArray, pImageWidth, pImageHeight, pDifferentialIndex,  &pCImageDerivativeClassForYValues);

	cout << "Printing the Derivative Function Output For Y Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForYValues)
	{
		cout << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value Y = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Computing Common Image Gradient Component" << endl;
	pixelDataFile << "Computing Common Image Gradient Component" << endl;


	cout << "Sorting the X Position Derivative Vector" << endl;
	std::sort(std::begin(pCImageDerivativeClassForXValues), std::end(pCImageDerivativeClassForXValues), pSortImageDerivativeByXAscending);
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}

	cout << "Sorting The Y Position Derivative Vector" << endl;
	std::sort(std::begin(pCImageDerivativeClassForYValues), std::end(pCImageDerivativeClassForYValues), pSortImageDerivativeByCbAscending);
	cout << "Printing the Derivative Function Output For X Parameter" << endl;
	for (CImageDerivativeClass pImageDerivativeClass : pCImageDerivativeClassForXValues)
	{
		cout << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		cout << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		cout << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;

		pixelDataFile << "Index Value = " << pImageDerivativeClass.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageDerivativeClass.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageDerivativeClass.pYPosition << endl;
		pixelDataFile << "Gradient Value X = " << pImageDerivativeClass.pDerivativeValue << endl;
	}





	vector<CImageFullDerivativesClass> ppFullDerivativesClassObjectCollection = vector<CImageFullDerivativesClass>();
	hr = ppStandardAlgorithmExecutor->ComputeImageFunctionDerivativesFinal(hInstance, hWnd,
		pCImageDerivativeClassForXValues, pCImageDerivativeClassForYValues, &ppFullDerivativesClassObjectCollection);

	cout << "Printing the Final Image Gradients" << endl;
	for (CImageFullDerivativesClass pImageFullDerivativeObject : ppFullDerivativesClassObjectCollection)
	{
		cout << "Index Value = " << pImageFullDerivativeObject.pDerivativeIndex << endl;
		cout << "X Position = " << pImageFullDerivativeObject.pXPosition << endl;
		cout << "Y Position = " << pImageFullDerivativeObject.pYPosition << endl;
		cout << "Gradient Value Magnitude = " << pImageFullDerivativeObject.pMagnitudeValue << endl;
		cout << "Gradient Value Direction = " << pImageFullDerivativeObject.pDirectionValue << endl;

		pixelDataFile << "Index Value = " << pImageFullDerivativeObject.pDerivativeIndex << endl;
		pixelDataFile << "X Position = " << pImageFullDerivativeObject.pXPosition << endl;
		pixelDataFile << "Y Position = " << pImageFullDerivativeObject.pYPosition << endl;
		pixelDataFile << "Gradient Value Magnitude = " << pImageFullDerivativeObject.pMagnitudeValue << endl;
		pixelDataFile << "Gradient Value Direction = " << pImageFullDerivativeObject.pDirectionValue << endl;

	}


	pixelDataFile.close();

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToHSI(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	vector<PixelObjectHSI> pPixelObjectToHSI = vector<PixelObjectHSI>();

	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToHSIFinalOutput.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	if (pImageProcessingManager == nullptr)
	{
		pImageProcessingManager = new Direct2DImageProcessingManager(hInstance, hWnd);
		hr = pImageProcessingManager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = pImageProcessingManager->CreateDeviceResources(hInstance, hWnd);
	}
	float pXPosition = 0.0f;
	float pYPosition = 0.0f;
	float pWidth = 0.0f;
	float pHeight = 0.0f;

	cout << "Enter The X Position For Top Left Point of Rectangle" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Value for Top Left Point of Rectangle" << endl;
	cin >> pYPosition;

	cout << "Enter the width for the rectangular area" << endl;
	cin >> pWidth;

	cout << "Enter the height for the rectangular area" << endl;
	cin >> pHeight;

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	hr = pVideoAnalyticsManagementClass->ClipSelectedImageToRect(hInstance, hWnd, pXPosition, pYPosition, pWidth, pHeight,
		&pixelObjectVector);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	fstream imageSegmentationDataFile("C:\\pixels\ImageClips.txt");
	imageSegmentationDataFile << "New Image Clip" << endl;
	imageSegmentationDataFile.clear();
	for (PixelObject pixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}
	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToHSI(hInstance, hWnd,





		pixelObjectVector, &pPixelObjectToHSI);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectHSI pPixelObject : pPixelObjectToHSI)
	{

		float pXValue = pPixelObject.pXValue;
		float pYValue =pPixelObject.pYValue;
		float pHueValue =pPixelObject.pHueValue;
		float pSaturationValue =pPixelObject.pSaturationValue;
		float pIntensityValue =pPixelObject.pIntensityValue;
		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Hue Value = " << pHueValue << endl;
		cout << "Saturation Value = " << pSaturationValue << endl;
		cout << "Intensity Value = " << pIntensityValue << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "Hue Value = " << pHueValue << endl;
		pixelDataFile << "Saturation Value = " << pSaturationValue << endl;
		pixelDataFile << "Intensity Value = " << pIntensityValue << endl;
		pIndexValue++;
	} 

	cout << "Plotting the Graph Data Object" << endl;

	pixelDataFile.close();

	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::ClipSelectedImageWithAStep(HINSTANCE hInstance, HWND hWnd)
{	


	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	float pStepX = 0.0f;
	float pStepY = 0.0f;


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ClipperFile.txt", fstream::in | fstream::out | fstream::trunc);
	imageSegmentationDataFile.clear();

	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();



	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::
		Instance(hInstance, hWnd);



	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;






	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;


	float pYSortingConstant0 = pStepY;
	float pYSortingConstant1 = pStepY * 2;
	float pYSortingConstant2 = pStepY * 3;

	float pXSortingConstant0 = pStepX;
	float pXSortingConstant1 = pStepX * 2;
	float pXSortingConstant2 = pStepX * 3;





	LPWSTR path = nullptr;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);
		cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{


			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}

		cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
			clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
			clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		cout << "Verifying Container for Identical Elements" << endl;





		for (PixelObject pixelObject : pixelObjectVectorOne)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		}
		imageSegmentationDataFile.close();
	}

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::OpenImageFileForProcessing(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImagePropertyScannerTxt.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile << "New Record" << endl;
	pixelDataFile << "Loading A New Image File For Analysis" << endl;

	vector<PixelObject> pPixelObjectArray = vector<PixelObject>();
	float pImageWidth = 0.0f;
	float pImageHeight = 0.0f;

	cout << "Enter the Value for the Width of the Image" << endl;
	cin >> pImageWidth;

	cout << "Enter the Value for the Height of the Image " << endl;
	cin >> pImageHeight;

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	hr = md2dmanager->CreateD2DBitmapFromFile(hInstance, hWnd, 
		pImageWidth, pImageHeight,
	&pPixelObjectArray);

	cout << "Printing Final Output" << endl;

	int pIndex = 0;	for (PixelObject pixelObject : pPixelObjectArray)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;




	}


	pixelDataFile.close();


	return hr;
	

}

HRESULT DirectXGPUDigitalLabCoreModule::ApplyGaussianFilterToSelectedImageFile(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\GaussianBlurImageFileRecordEightDimensionCS.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		fstream imageSegmentationDataFile("C:\\pixels\ImageClips.txt");
		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppPixelObjectInput);
	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : ppPixelObjectInput)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		ppPixelObjectInput, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
	cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;
	vector<UINT> pPixelObjectToGrayScaleValues = vector<UINT>();

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pPixelObjectToGrayScaleValues.push_back(pPixeoObjectGrayScale);

		pIndexValue++;
	}




	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;



	hr = ppStandardAlgorithmExecutor->SimulateStandardOnSelectedImage(hInstance, hWnd, pPixelObjectToGrayScale,
		&pOutputDataBufferP);

	pIndex = 0;
	float pSumValueFinal = 0;
	float pStandardDeviationValue = 0;
	float pi_var = DirectX::XM_PI;






	for (CStandardDeviationImageOutputType pImageStandardDeviaionVar : pOutputDataBufferP)
	{
		cout << "Pixel Number: " << pImageStandardDeviaionVar.pixelNumber << endl;
		cout << "X Position: " << pImageStandardDeviaionVar.xPosition << endl;
		cout << "Y Position: " << pImageStandardDeviaionVar.yPosition << endl;
		cout << "Standard Deviation: " << pImageStandardDeviaionVar.pStandardDeviationVar << endl;

		pixelDataFile << "Pixel Number: " << pImageStandardDeviaionVar.pixelNumber << endl;
		pixelDataFile << "X Position: " << pImageStandardDeviaionVar.xPosition << endl;
		pixelDataFile << "Y Position: " << pImageStandardDeviaionVar.yPosition << endl;
		pixelDataFile << "Standard Deviation: " << pImageStandardDeviaionVar.pStandardDeviationVar << endl;
		pSumValueFinal = pSumValueFinal + pImageStandardDeviaionVar.pStandardDeviationVar;

	}




	cout << "Computing the Mean Standard Deviation Output" << endl;
	cout << "Standard Deviation Sum: " << pSumValueFinal << endl;
	pStandardDeviationValue = pSumValueFinal / pOutputDataBufferP.size();
	cout << "Standard Deviation Value: " << pStandardDeviationValue << endl;
	pixelDataFile << "Standard Deviation Value: " << pStandardDeviationValue << endl;

	float pStandardDeviationVal = 0.0f;
	cout << "Please Enter the Value for Standard Deviation for Image Smoothing" << endl;
	cin >> pStandardDeviationVal;
	cout << "Now We will Simulate the Gaussian Blur on Selected Grayscale Image" << endl;

	vector<GaussianOutputVar> ppGaussianBlurOutputArrayX	 = vector<GaussianOutputVar>();
	vector<GaussianOutputVar> ppGaussianBlurOutputArrayFinal = vector<GaussianOutputVar>();
	hr = ppStandardAlgorithmExecutor->SimulateGaussianFilteringOnSelectedImage2D(
		hInstance, hWnd, pPixelObjectToGrayScale,
		pi_var, pStandardDeviationVal,
		&ppGaussianBlurOutputArrayFinal);

	cout << "Printing The Output Results of the Simulation File" << endl;
	pIndex = 0;


	auto ItA = ppGaussianBlurOutputArrayX.begin();
	auto ItB = ppGaussianBlurOutputArrayFinal.begin();

	cout << "Fixing the Coordinates for the Output Vector" << endl;


	while (ItA < std::end(ppGaussianBlurOutputArrayX) && ItB < std::end(ppGaussianBlurOutputArrayFinal))
	{
		cout << "Processing Item At Index: " << pIndex << endl;
		GaussianOutputVar pGaussianBlurOutputValueX = *ItA;
		GaussianOutputVar pGaussianBlurOutputValueY = *ItB;

		cout << "Item Index: " << pIndex << endl;
		cout << "Pixel Id: " << " = " << pGaussianBlurOutputValueX.pixelNumber << endl;
		cout << "X Position: " << " = " << pGaussianBlurOutputValueX.xPosition << endl;
		cout << "Y Position: " << " = " << pGaussianBlurOutputValueX.yPosition << endl;
		cout << "Gradient Value X" << " = " << pGaussianBlurOutputValueX.pGradientValue << endl;
		cout << "Gaussian Blur Value X: " << " = " << pGaussianBlurOutputValueX.pGaussianValueF << endl;
		cout << "Gradient Value Y: " << " = " << pGaussianBlurOutputValueY.pGradientValue << endl;
		cout << "Gaussian Blur Value Final: " << " = " << pGaussianBlurOutputValueY.pGaussianValueF << endl;

		pixelDataFile << "Item Index: " << pIndex << endl;
		pixelDataFile << "Pixel Id: " << " = " << pGaussianBlurOutputValueX.pixelNumber << endl;
		pixelDataFile << "X Position: " << " = " << pGaussianBlurOutputValueX.xPosition << endl;
		pixelDataFile << "Y Position: " << " = " << pGaussianBlurOutputValueX.yPosition << endl;
		pixelDataFile << "Gradient Value X" << " = " << pGaussianBlurOutputValueX.pGradientValue << endl;
		pixelDataFile << "Gaussian Blur Value X: " << " = " << pGaussianBlurOutputValueX.pGaussianValueF << endl;
		pixelDataFile << "Gradient Value Y: " << " = " << pGaussianBlurOutputValueY.pGradientValue << endl;
		pixelDataFile << "Gaussian Blur Value Final: " << " = " << pGaussianBlurOutputValueY.pGaussianValueF << endl;




		++ItA;
		++ItB;
		pIndex = pIndex + 1;
	}





	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ApplyCannyEdgeDetectionFilterToSelectedImageFile(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CannyEdgeDetectorFilterCS.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
	pixelDataFile << "New Image Clip" << endl;
	pixelDataFile.clear();

	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;



	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pPixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd, pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
	cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;
	vector<UINT> pPixelObjectToGrayScaleValues = vector<UINT>();

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pPixelObjectToGrayScaleValues.push_back(pPixeoObjectGrayScale);

		pIndexValue++;
	}




	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;



	float pStandardDeviationValue = 0.0f;
	hr = ppStandardAlgorithmExecutor->SimulateStandardDeviationOnSelectedImageOnCPU(hInstance, hWnd, pPixelObjectToGrayScale,
		&pStandardDeviationValue);


	cout << "The Standard Deviation for Selected Image On Cpu = " << pStandardDeviationValue << endl;
	pixelDataFile << "The Standard Deviation for Selected Image On Cpu = " << pStandardDeviationValue << endl;


	
	pIndex = 0;
	float pSumValueFinal = 0;
	 pStandardDeviationValue = 0;
	float pi_var = DirectX::XM_PI;









	cout << "Standard Deviation Value: " << pStandardDeviationValue << endl;
	pixelDataFile << "Standard Deviation Value: " << pStandardDeviationValue << endl;

	float pStandardDeviationVal = 0.0f;
	cout << "Please Enter the Value for Standard Deviation for Image Smoothing" << endl;
	cin >> pStandardDeviationVal;
	cout << "Now We will Simulate the Gaussian Blur on Selected Grayscale Image" << endl;


	
    pStandardDeviationVal = 0.0f;
	cout << "Please Enter the Value for Standard Deviation for Image Smoothing" << endl;
	cin >> pStandardDeviationVal;
	cout << "Now We will Simulate the Gaussian Blur on Selected Grayscale Image" << endl;


	vector<CannyOutputVar> ppCannyEdgeOutputArray = vector<CannyOutputVar>();
	hr = ppStandardAlgorithmExecutor->SimulateCannyEdgeDetectionFilteringOnSelectedImage2D(
		hInstance, hWnd, pPixelObjectToGrayScale,
		pi_var, pStandardDeviationVal,
		&ppCannyEdgeOutputArray);

	cout << "Printing The Output Results of Computing the filter values" << endl;
	pIndex = 0;
	

	cout << "Printing The Output Results of Computing the filter values" << endl;
	pIndex = 0;
	for (CannyOutputVar pBufItem : ppCannyEdgeOutputArray)
	{

		cout << "Pixel Number = " << pBufItem.pixelNumber << endl;
		cout << "X Position  =  " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position = " << " = " << pBufItem.yPosition << endl;
		cout << "Gaussian Function Value =  " << pIndex << " = " << pBufItem.pGaussianValueF << endl;
		cout << "Canny X Direction Value =  " << pBufItem.pCannyEdgeDetectorX << endl;
		cout << "Canny Y Direction Value =  " << pBufItem.pCannyEdgeDetectorY << endl;
		cout << "Canny Filter Magnitude =  " << pBufItem.pCannyMagnitude << endl;
		cout << "Canny Filter Direction = " << pBufItem.pCannyDirection << endl;

		pixelDataFile << "Pixel Number = " << pBufItem.pixelNumber << endl;
		pixelDataFile << "X Position =  " << " = " << pBufItem.xPosition << endl;
		pixelDataFile << "Y Position =  " << " = " << pBufItem.yPosition << endl;
		pixelDataFile << "Gaussian Function Value =  " << pIndex << " = " << pBufItem.pGaussianValueF << endl;
		pixelDataFile << "Canny X Direction Value =  " << pBufItem.pCannyEdgeDetectorX << endl;
		pixelDataFile << "Canny Y Direction Value =  " << pBufItem.pCannyEdgeDetectorY << endl;
		pixelDataFile << "Canny Filter Magnitude =  " << pBufItem.pCannyMagnitude << endl;
		pixelDataFile << "Canny Filter Direction = " << pBufItem.pCannyDirection << endl;



	}











	pixelDataFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ApplyGaussianFilterToSelectedImageFileOneDimension(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\GaussianFilterLogFileCS.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;



	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	 pIndex = 0;

	 for (PixelObject pPixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd, pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
	cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;
	vector<UINT> pPixelObjectToGrayScaleValues = vector<UINT>();

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pPixelObjectToGrayScaleValues.push_back(pPixeoObjectGrayScale);

		pIndexValue++;
	}




	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;


	float pStandardDeviationValue = 0.0f;
	hr = ppStandardAlgorithmExecutor->SimulateStandardDeviationOnSelectedImageOnCPU(hInstance, hWnd, pPixelObjectToGrayScale,
		&pStandardDeviationValue);

	float pNewStandardDeviationVal = 0.0f;
	cout << "Standard Deviation: " << pStandardDeviationValue << endl;
	pixelDataFile << "Standard Deviation: " << pStandardDeviationValue << endl;

	cout << "Enter new Value for standard Deviation" << endl;
	cin >> pNewStandardDeviationVal;

	

	vector<GaussianOutputVar> ppGaussianBlurOutputArray = vector<GaussianOutputVar>();
	hr = ppStandardAlgorithmExecutor->SimulateGaussianFilteringOnSelectedImage2D(
		hInstance, hWnd, pPixelObjectToGrayScale,
		3.14f, pNewStandardDeviationVal,
		&ppGaussianBlurOutputArray);

	cout << "Printing The Output Results of Computing the filter values" << endl;
	pIndex = 0;
	for (GaussianOutputVar pGaussianBlurOutputValue : ppGaussianBlurOutputArray)
	{

		cout << "Item Index: " << pIndex << endl;
		cout << "Pixel Id: " << " = " << pGaussianBlurOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pGaussianBlurOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pGaussianBlurOutputValue.yPosition << endl;
		cout << "Intensity Value: " << pGaussianBlurOutputValue.pIntensityValue << endl;
		cout << "Gradient Value " << " = " << pGaussianBlurOutputValue.pGradientValue << endl;
		cout << "Output Value" << " = " << pGaussianBlurOutputValue.pGaussianValueF << endl;
		



		pixelDataFile << "Item Index: " << pIndex << endl;
		pixelDataFile << "Pixel Id: " << " = " << pGaussianBlurOutputValue.pixelNumber << endl;
		pixelDataFile << "X Position: " << " = " << pGaussianBlurOutputValue.xPosition << endl;
		pixelDataFile << "Y Position: " << " = " << pGaussianBlurOutputValue.yPosition << endl;
		pixelDataFile << "Intensity Value: " << pGaussianBlurOutputValue.pIntensityValue << endl;
		pixelDataFile << "Gradient Value " << " = " << pGaussianBlurOutputValue.pGradientValue << endl;
		pixelDataFile << "Output Value" << " = " << pGaussianBlurOutputValue.pGaussianValueF << endl;
		pIndex++;
	}







	pixelDataFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ComputeStandardDeviationForSelectedImageOnCPU(HINSTANCE hInstance, HWND hWnd) 
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\StandardDeviationComputationForImageFile.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	UINT pIndex = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);



	for (PixelObject pPixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;


	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
	cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;


	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pIndexValue++;
	}

	cout << "Now we Will Compute the Value for the standard Deviation" << endl;
	float pStandardDeviationValue = 0.0f;
	
	hr = ppStandardAlgorithmExecutor->SimulateStandardDeviationOnSelectedImageOnCPU(hInstance, hWnd,
		pPixelObjectToGrayScale, &pStandardDeviationValue);

	cout << "The Standard Deviation Value for An Image File = " << pStandardDeviationValue << endl;
	pixelDataFile << "The Standard Deviation Value for An Image File = " << pStandardDeviationValue << endl;

	pixelDataFile.close();

	return hr;

}

HRESULT DirectXGPUDigitalLabCoreModule::ApplyLaplacianOfGaussianFilterToSelectedImageFile(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\LaplactianGaussianFilterImageFileRecordCS.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	UINT pIndex = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);



	for (PixelObject pPixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Value: " << pPixelObject.RMask << endl;
			cout << "Green Value: " << pPixelObject.GMask << endl;
			cout << "Blue Value: " << pPixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
		}
		pixelDataFile << "End of Clipping" << endl;


		pixelDataFile << "Converting Clipped Area To HSI" << endl;

		hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
			pixelObjectVector, &pPixelObjectToGrayScale);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		float pIndexValue = 0;

		cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
		cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;
		vector<UINT> pPixelObjectToGrayScaleValues = vector<UINT>();


		for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
		{

			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

			pPixelObjectToGrayScaleValues.push_back(pPixeoObjectGrayScale);

			pIndexValue++;
		}




		//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));





		vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
		pIndex = 0;


		float pStandardDeviationValue = 0.0f;
		hr = ppStandardAlgorithmExecutor->SimulateStandardDeviationOnSelectedImageOnCPU(hInstance, hWnd, pPixelObjectToGrayScale,
			&pStandardDeviationValue);


		cout << "The Standard Deviation for Selected Image On Cpu = " << pStandardDeviationValue << endl;
		pixelDataFile << "The Standard Deviation for Selected Image On Cpu = " << pStandardDeviationValue << endl;

	

		cout << "Now We will Simulate the Gaussian Blur on Selected Grayscale Image" << endl;
		float pStandardDeviationVal = 0.0f;
		cout << "Enter the Value for the Standard Deviation for Image Kernel" << endl;
		cin >> pStandardDeviationVal;
		cout << "Your Selected Value for Sigma that Would be used for Laplacian of Gaussian Edge Detection = " << pStandardDeviationVal << endl;
		pixelDataFile << "Your Selected Value for Sigma that Would be used for Laplacian of Gaussian Edge Detection = " << pStandardDeviationVal << endl;
		float pi_var = 3.14f;

		vector<GaussianOutputVar> ppGaussianBlurOutputArray = vector<GaussianOutputVar>();
		hr = ppStandardAlgorithmExecutor->SimulateLaplacianOfGaussianFilteringOnSelectedImage(
			hInstance, hWnd, pPixelObjectToGrayScale,
			pi_var, pStandardDeviationVal,
			&ppGaussianBlurOutputArray);

		cout << "Printing The Output Results of the Simulation File" << endl;
		pIndex = 0;
		cout << "Values using defaultfloat are : " << std::defaultfloat << endl;

		for (GaussianOutputVar pGaussianBlurOutputValue : ppGaussianBlurOutputArray)
		{
			cout << "Item Index: " << pIndex << endl;
			cout << "Pixel Id: " << " = " << pGaussianBlurOutputValue.pixelNumber << endl;

			cout << "X Position: " << " = " << pGaussianBlurOutputValue.xPosition << endl;
			cout << "Y Position: " << " = " << pGaussianBlurOutputValue.yPosition << endl;
			cout << "Intensity Value: " << pGaussianBlurOutputValue.pIntensityValue << endl;
			cout << "Laplacian of Gaussian Blur Value: " << " = " << pGaussianBlurOutputValue.pGaussianValueF << endl;


			pixelDataFile << "Item Index: " << pIndex << endl;
			pixelDataFile << "Pixel Id: " << " = " << pGaussianBlurOutputValue.pixelNumber << endl;
			pixelDataFile << "X Position: " << " = " << pGaussianBlurOutputValue.xPosition << endl;
			pixelDataFile << "Y Position: " << " = " << pGaussianBlurOutputValue.yPosition << endl;
			pixelDataFile << "Intensity Value: " << pGaussianBlurOutputValue.pIntensityValue << endl;
			pixelDataFile << "Laplacian of Gaussian Blur Value: " << " = " << pGaussianBlurOutputValue.pGaussianValueF << endl;
			pIndex++;


		}
		pixelDataFile.close();
		return hr;
	}
	



HRESULT DirectXGPUDigitalLabCoreModule::ApplyMeanFilterForSelectedImageFile(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageMeanFilterOperationTextFile.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();
	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	vector<ImageKernelItem> pImageKernelArray = vector<ImageKernelItem>();
	vector<PixelObjectGrayScale> ppOutputPixelObjectFilteringResultX = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppFinalOutputPixelResultX = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelObjectFilteringResultY = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppFinalOutputPixelResultY = vector<PixelObjectGrayScale>();
	vector<CImageFullDerivativesClass> ppFullDerivativeClassCollection = vector<CImageFullDerivativesClass>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	CbKernelConvolution pConvolutionKernelX;
	CbKernelConvolution pConvolutionKernelY;




	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);




	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
	cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;
	vector<UINT> pPixelObjectToGrayScaleValues = vector<UINT>();
	std::sort(std::begin(pPixelObjectToGrayScale), std::end(pPixelObjectToGrayScale), SortByXPosition);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

	

		pIndexValue++;
	}

	cout << "We will Use the filtering operation of a mean Filter" << endl;
	pixelDataFile << "We will Use the filtering operation of a mean Filter" << endl;

	int pPixelNumber = 0;
	vector<float> pCurrentValFilter = vector<float>();
	float pFilterValue = 0.0f;
	float pXValuesArray[6];
	float pYValuesArray[6];

	cout << "First We have to Fill the X kernel for X Values" << endl;


	for (int pIndex = 0; pIndex < 3; ++pIndex)
	{
		cout << "Enter Filter Item Element At Index: " << pIndex << endl;
		cin >> pFilterValue;
		pConvolutionKernelX.pKernelGate[pIndex] = pFilterValue;
	}

	cout << "First We have to Fill the Y kernel for X Values" << endl;


	for (int pIndex = 3; pIndex < 6; ++pIndex)
	{
		cout << "Enter Filter Item Element At Index: " << pIndex << endl;
		cin >> pFilterValue;
		pConvolutionKernelX.pKernelGate[pIndex] = pFilterValue;
	}


	
	


	pConvolutionKernelY.pImageWidth = pImageWidth;
	pConvolutionKernelY.pImageHeight = pImageHeight;
	cout << "Filling the y Kernel" << endl;
	for (int pIndex = 0; pIndex < 3; ++pIndex)
	{
		cout << "Enter Filter Item Element At Index: " << pIndex << endl;
		cin >> pFilterValue;
		pConvolutionKernelY.pKernelGate[pIndex] = pFilterValue;
	}
	;
	for (int pIndex = 3; pIndex < 6; ++pIndex)
	{
		float pFilterVal0 = 0.0f;
		cout << "Enter Filter Item Element At Index: " << pIndex << endl;
		cin >> pFilterVal0;
		pConvolutionKernelY.pKernelGate[pIndex] = pFilterVal0;
	}



	cout << "Printing the Content of Our Kernel Element" << endl;
	pixelDataFile << "Printing the Content of Our Kernel Element" << endl;

	vector<ImageKernelItem> pImageKernelItemCollection = vector<ImageKernelItem>();


	for (int pKernelIndex = 0; pKernelIndex < 6; ++pKernelIndex)
	{

		cout << "Index: " << pKernelIndex << endl;
		cout << "X Kernel Value: " << pConvolutionKernelX.pKernelGate[pKernelIndex] << endl;
		cout << "Y Kernel Value: " << pConvolutionKernelY.pKernelGate[pKernelIndex] << endl;



		pixelDataFile << "Index: " << pKernelIndex << endl;
		pixelDataFile << "Kernel Value: " << pConvolutionKernelX.pKernelGate[pKernelIndex] << endl;
		pixelDataFile << "Kernel Value: " << pConvolutionKernelY.pKernelGate[pKernelIndex] << endl;



	}
		
	


	
	
	
	cout << "Sorting Pixel for Convolution" << endl;

	std::sort(std::begin(pPixelObjectToGrayScale), std::end(pPixelObjectToGrayScale), SortByXPosition);
	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



		pIndexValue++;
	}




	float pKernelFilterValues[3];

	
	float xValuesKernelX[3] = { pConvolutionKernelX.pKernelGate[0], pConvolutionKernelX.pKernelGate[1], pConvolutionKernelX.pKernelGate[2] };
	float yValuesKernelX[3] = { pConvolutionKernelX.pKernelGate[3], pConvolutionKernelX.pKernelGate[4], pConvolutionKernelX.pKernelGate[5] };
	float xValuesKernelY[3] = { pConvolutionKernelY.pKernelGate[0], pConvolutionKernelY.pKernelGate[1], pConvolutionKernelY.pKernelGate[2] };
	float yValuesKernelY[3] = { pConvolutionKernelY.pKernelGate[3], pConvolutionKernelY.pKernelGate[4], pConvolutionKernelY.pKernelGate[5] };


	cout << "First We Convolve Image with the Horizontal Kernel" << endl;
	
  pIndexValue = 0;
  hr = ppStandardAlgorithmExecutor->SimulateImageConvolutionOperationStructuredX(hInstance,
	  hWnd, pImageWidth, pImageHeight, 3, 3, pImageWidth, pImageHeight,  pPixelObjectToGrayScale, xValuesKernelX, &ppOutputPixelObjectFilteringResultX);
  
  std::sort(std::begin(ppOutputPixelObjectFilteringResultY), std::end(ppOutputPixelObjectFilteringResultY), SortByXPosition);

  for (PixelObjectGrayScale pPixelObject : ppOutputPixelObjectFilteringResultX)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "Filtered Image X Kernel X Value  =  " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}
	cout << "Next We Convolve Image with the Verical Kernel" << endl;

	
	hr = ppStandardAlgorithmExecutor->SimulateImageConvolutionOperationStructuredY(hInstance,
		hWnd, pImageWidth, pImageHeight, 3, 3, pImageWidth, pImageHeight, ppOutputPixelObjectFilteringResultX, yValuesKernelX, &ppFinalOutputPixelResultX);

	pIndexValue = 0;
	std::sort(std::begin(ppFinalOutputPixelResultY), std::end(ppFinalOutputPixelResultY), SortByXPosition);

	for (PixelObjectGrayScale pPixelObject : ppFinalOutputPixelResultX)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Filtered Image X Kernel Y Value  = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "Filtered Image X Kernel Y Value  = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "First We Convolve Image with the Horizontal Kernel" << endl;
	hr = ppStandardAlgorithmExecutor->SimulateImageConvolutionOperationStructuredX(hInstance,
		hWnd, pImageWidth, pImageHeight, 3, 3, pImageWidth, pImageHeight, ppFinalOutputPixelResultX, xValuesKernelY, &ppOutputPixelObjectFilteringResultY);

	pIndexValue = 0;
	std::sort(std::begin(ppOutputPixelObjectFilteringResultY), std::end(ppOutputPixelObjectFilteringResultY), SortByXPosition);

	for (PixelObjectGrayScale pPixelObject : ppOutputPixelObjectFilteringResultY)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Filtered Image Y Kernel X Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "Filtered Image Y Kernel X Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}
	cout << "First We Convolve Image with the Verical Kernel" << endl;
	hr = ppStandardAlgorithmExecutor->SimulateImageConvolutionOperationStructuredY(hInstance,
		hWnd, pImageWidth, pImageHeight, 3, 3, pImageWidth, pImageHeight, ppOutputPixelObjectFilteringResultY, yValuesKernelY, &ppFinalOutputPixelResultY);

	pIndexValue = 0;
	std::sort(std::begin(ppFinalOutputPixelResultX), std::end(ppFinalOutputPixelResultX), &SortByXPosition);

	for (PixelObjectGrayScale pPixelObject : ppFinalOutputPixelResultY)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Filtered Image Y Kernel Y Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "Filtered Image Y Kernel Y Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}




	pixelDataFile.close();






	return hr;

}


PixelObjectGrayScale DirectXGPUDigitalLabCoreModule::GetImagePixelObjectByXAndYPosition(vector
	<PixelObjectGrayScale> ppImageDerivativeList, float pXPosition, float pYPosition)
{
	PixelObjectGrayScale pImageDerivativeObject = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);
	pImageDerivativeObject.pixelNumber = 0;
	pImageDerivativeObject.xPosition = 0.0f;
	pImageDerivativeObject.yPosition = 0.0f;
	for (PixelObjectGrayScale pSelectedObject : ppImageDerivativeList)
	{
		if ((pSelectedObject.xPosition == pXPosition) && (pSelectedObject.yPosition == pYPosition))
		{
			pImageDerivativeObject.pixelNumber = pSelectedObject.pixelNumber;
			pImageDerivativeObject.xPosition = pSelectedObject.xPosition;
			pImageDerivativeObject.yPosition = pSelectedObject.yPosition;
			pImageDerivativeObject.pGreyLevel = pSelectedObject.pGreyLevel;
		}
	}
	return pImageDerivativeObject;
}


HRESULT DirectXGPUDigitalLabCoreModule::ApplyStandardDeviationFunctionToGrayscaleImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\StandardDeviationForAnImageFileOutput.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> ppPixelObjectInput = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		fstream imageSegmentationDataFile("C:\\pixels\ImageClips.txt");
		imageSegmentationDataFile << "New Image Clip" << endl;
		imageSegmentationDataFile.clear();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppPixelObjectInput);
	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pixelDataFile << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : ppPixelObjectInput)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Value: " << pPixelObject.RMask << endl;
		cout << "Green Value: " << pPixelObject.GMask << endl;
		cout << "Blue Value: " << pPixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pPixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pPixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.BMask << endl;
	}
	pixelDataFile << "End of Clipping" << endl;

	pixelDataFile << "Converting Clipped Area To HSI" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		ppPixelObjectInput, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	cout << "Now We will Output The Pixels of the Grayscale Image" << endl;
	cout << "We will save numerical values of Intensities  For Standard Deviation Operation" << endl;
	vector<UINT> pPixelObjectToGrayScaleValues = vector<UINT>();

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pPixelObjectToGrayScaleValues.push_back(pPixeoObjectGrayScale);

		pIndexValue++;
	}

	cout << "Printing the Contents of Initial Array" << endl;
	int pItemIndex = 0;
	


	//	std::reverse(begin(pArrayEightValues), end(pArrayEightValues));
	
	vector<CStandardDeviationImageOutputType> pOutputDataBufferP = vector<CStandardDeviationImageOutputType>();
	pIndex = 0;



	hr = ppStandardAlgorithmExecutor->SimulateStandardOnSelectedImage(
		hInstance, hWnd, pPixelObjectToGrayScale, &pOutputDataBufferP);

	pIndex = 0;
	float pSumValueFinal = 0;
	float pStandardDeviationValue = 0;

	auto ItA = pPixelObjectToGrayScale.begin();
	auto ItB = pOutputDataBufferP.begin();
	cout << "Fixing Output Indexes" << endl;
	int pItemCounter = 0;
	while (ItA != pPixelObjectToGrayScale.end() || ItB != pOutputDataBufferP.end())
	{
		cout << "Amount of Output Items Processed = " << pItemCounter << endl;
		ItB->pixelNumber = ItA->pixelNumber;
		ItB->xPosition = ItA->xPosition;
		ItB->yPosition = ItA->yPosition;

		if (ItA != pPixelObjectToGrayScale.end())
		{
			++ItA;
		}
		if (ItB != pOutputDataBufferP.end())
		{
			++ItB;
		}
		pItemCounter++;
	}


	for (CStandardDeviationImageOutputType pOutputItem : pOutputDataBufferP)
	{
		cout.precision(4);
		cout << "Pixel Number: " << pOutputItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputItem.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputItem.yPosition << endl;
		cout << "Standard Deviation Val : " << " = " << pOutputItem.pStandardDeviationVar << endl;
		pixelDataFile << "Pixel Number: " << pOutputItem.pixelNumber << endl;
		pixelDataFile << "X Position: " << " = " << pOutputItem.xPosition << endl;
		pixelDataFile << "Y Position: " << " = " << pOutputItem.yPosition << endl;
		pixelDataFile << "Standard Deviation Val: " << " = " << pOutputItem.pStandardDeviationVar << endl;

	}
	




	pixelDataFile.close();

	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldImagePixelByCoordinatesCriteriaRGB(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationCoordinatesRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;

	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;





	
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCoordinatesCriteriaRGB(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pixelObjectVector, &ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;


		int pPixelNumberOutput = 0.0f;
		float pXValueOutput = 0.0f;
		float pYValueOutput = 0.0f;
		float pRedComponentOutput = 0.0f;
		float pGreenComponentOutput = 0.0f;
		float pBlueComponentOutput = 0.0f;
		bool pUsedInComputations = false;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputPixelVector)
		{

			pPixelNumberOutput = pPixelObject.pixelNumber;
			pXValueOutput = pPixelObject.xPosition;
			pYValueOutput = pPixelObject.yPosition;
			pRedComponentOutput = pPixelObject.rValue;
			pGreenComponentOutput = pPixelObject.gValue;
			pBlueComponentOutput = pPixelObject.bValue;
			pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumberOutput << endl;
			cout << "X Value = " << pXValueOutput << endl;
			cout << "Y Value = " << pYValueOutput << endl;
			cout << "Red Component = " << pRedComponentOutput << endl;
			cout << "Green Component = " << pGreenComponentOutput << endl;
			cout << "Blue Component = " << pBlueComponentOutput << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumberOutput << endl;
			pixelDataFile << "X Value = " << pXValueOutput << endl;
			pixelDataFile << "Y Value = " << pYValueOutput << endl;
			pixelDataFile << "Red Component = " << pRedComponentOutput << endl;
			pixelDataFile << "Green Component = " << pGreenComponentOutput << endl;
			pixelDataFile << "Blue Component = " << pBlueComponentOutput << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			pIndexValue++;
		}

		vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			ppOutputPixelVector, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;
		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		pixelDataFile.close();


	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::DetectPixelsOnAVerticalLine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectPixelOnAVerticalLine.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pColumnStart = 0.0f;
	float pColumEnd = 0.0f;
	float pRowValue = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pColumnStart;

	cout << "Enter the Maximum Value for Y Position" << endl;
	cin >> pColumEnd;

	cout << "Enter the Value for X Position" << endl;
	cin >> pRowValue;

	float pRedComponentVal = 0.0f;
	float pGreenComponentVal = 0.0f;
	float pBlueComponentVal = 0.0f;


	cout << "Enter the Red Component" << endl;
	cin >> pRedComponentVal;

	cout << "Enter the Green Component" << endl;
	cin >> pGreenComponentVal;

	cout << "Enter the Blue Component" << endl;
	cin >> pBlueComponentVal;



	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pRowValue << endl;
	cout << "Cropped Image Top Left Y Position = " << pColumnStart << endl;
	cout << "Cropped Image Bottom Right X Position = " << pRowValue << endl;
	cout << "Cropped Image Top Left Y Position = " << pColumEnd << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pRowValue << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pColumnStart << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pRowValue << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pColumEnd << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;






		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAVerticalLine(hInstance, hWnd,
			pColumnStart,
			pColumEnd,
			pRowValue,
			pRedComponentVal,
			pGreenComponentVal, 
			pBlueComponentVal,
			pixelObjectVector, &ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;


		int pPixelNumberOutput = 0.0f;
		float pXValueOutput = 0.0f;
		float pYValueOutput = 0.0f;
		float pRedComponentOutput = 0.0f;
		float pGreenComponentOutput = 0.0f;
		float pBlueComponentOutput = 0.0f;
		bool pUsedInComputations = false;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputPixelVector)
		{

			pPixelNumberOutput = pPixelObject.pixelNumber;
			pXValueOutput = pPixelObject.xPosition;
			pYValueOutput = pPixelObject.yPosition;
			pRedComponentOutput = pPixelObject.rValue;
			pGreenComponentOutput = pPixelObject.gValue;
			pBlueComponentOutput = pPixelObject.bValue;
			pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumberOutput << endl;
			cout << "X Value = " << pXValueOutput << endl;
			cout << "Y Value = " << pYValueOutput << endl;
			cout << "Red Component = " << pRedComponentOutput << endl;
			cout << "Green Component = " << pGreenComponentOutput << endl;
			cout << "Blue Component = " << pBlueComponentOutput << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumberOutput << endl;
			pixelDataFile << "X Value = " << pXValueOutput << endl;
			pixelDataFile << "Y Value = " << pYValueOutput << endl;
			pixelDataFile << "Red Component = " << pRedComponentOutput << endl;
			pixelDataFile << "Green Component = " << pGreenComponentOutput << endl;
			pixelDataFile << "Blue Component = " << pBlueComponentOutput << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			pIndexValue++;
		}

		vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			ppOutputPixelVector, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;
		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		pixelDataFile.close();


	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}














HRESULT DirectXGPUDigitalLabCoreModule::DetectPixelSOnAHorizontalLine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectPixelsOnAHorizontalLine.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	float pRedComponentVal = 0.0f;
	float pGreenComponentVal = 0.0f;
	float pBlueComponentVal = 0.0f;


	cout << "Enter the Red Component" << endl;
	cin >> pRedComponentVal;

	cout << "Enter the Green Component" << endl;
	cin >> pGreenComponentVal;

	cout << "Enter the Blue Component" << endl;
	cin >> pBlueComponentVal;


	
	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;






		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		hr = ppStandardAlgorithmExecutor->DetectPixelsOnAHorizontalLine(hInstance, hWnd,
			pMinimumX,
			pMaximumX,
			pMinimumY,
			pRedComponentVal,
			pGreenComponentVal,
			pBlueComponentVal,
			pixelObjectVector, &ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;


		int pPixelNumberOutput = 0.0f;
		float pXValueOutput = 0.0f;
		float pYValueOutput = 0.0f;
		float pRedComponentOutput = 0.0f;
		float pGreenComponentOutput = 0.0f;
		float pBlueComponentOutput = 0.0f;
		bool pUsedInComputations = false;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputPixelVector)
		{

			pPixelNumberOutput = pPixelObject.pixelNumber;
			pXValueOutput = pPixelObject.xPosition;
			pYValueOutput = pPixelObject.yPosition;
			pRedComponentOutput = pPixelObject.rValue;
			pGreenComponentOutput = pPixelObject.gValue;
			pBlueComponentOutput = pPixelObject.bValue;
			pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumberOutput << endl;
			cout << "X Value = " << pXValueOutput << endl;
			cout << "Y Value = " << pYValueOutput << endl;
			cout << "Red Component = " << pRedComponentOutput << endl;
			cout << "Green Component = " << pGreenComponentOutput << endl;
			cout << "Blue Component = " << pBlueComponentOutput << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumberOutput << endl;
			pixelDataFile << "X Value = " << pXValueOutput << endl;
			pixelDataFile << "Y Value = " << pYValueOutput << endl;
			pixelDataFile << "Red Component = " << pRedComponentOutput << endl;
			pixelDataFile << "Green Component = " << pGreenComponentOutput << endl;
			pixelDataFile << "Blue Component = " << pBlueComponentOutput << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			pIndexValue++;
		}

		vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			ppOutputPixelVector, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;
		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		pixelDataFile.close();


	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldRGBImagePixelByCriteriaWithRecovery(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationWthRGBRecovery.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilterToReverse = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorCommon);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorY)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;


			}
	

		}

	
	

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVectorCommon, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}

	




		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pFinalOutputSquare, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;
		
		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}


		pixelDataFile.close();

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);





	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SubtractValuesFromColorsOfRGBImageWithResultsRestorationForNonIdenticalPixels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ExtractObjectFromDigitalImagesUsingPixelDataSubtraction.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelBufferRGB> pOutputFilterResult = vector<OutputPixelBufferRGB>();
	vector <OutputPixelBufferRGB> pFilterToReverse = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;
	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;
	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;
	cout << "Selected Red: " << pRedValueBottom << endl;
	cout << "Selected Green: " << pGreenValueBottom << endl;
	cout << "Selected Blue: " << pBlueValueBottom << endl;


	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;
	pixelDataFile << "Selected Red: " << pRedValueBottom << endl;
	pixelDataFile << "Selected Green: " << pGreenValueBottom << endl;
	pixelDataFile << "Selected Blue: " << pBlueValueBottom << endl;

	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	vector<PixelObject> pCommonPixelArray = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	if (GetOpenFileNameW(&ofn))
	{



		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 
			auto start = high_resolution_clock::now();

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;

			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;


			for (PixelObject pixelObject : pixelObjectVectorY)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}


			}

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());





			}
		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pCommonPixelArray);
		}


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Filter Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "Filtering Started " << endl;
		pixelDataFile << "Filtering Started " << endl;
	
		vector<OutputPixelObjectFiltered> pFilteredArray = vector<OutputPixelObjectFiltered>();
		pFilteredArray.clear();



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;

		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImage(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVectorX,
			pRedValueBottom,
			pGreenValueBottom,
			pBlueValueBottom,
			&pAmountOfIdenticalPixels,
			&pAmountOfDifferentPixels,
			&ppVerificationOutputArray,
			&ppIdenticalPixelOutputArray,
			&ppDifferentPixelOutputArray,
			&pImageOneIntensitySumRedVar,
			&pImageOneIntensitySumGreenVar,
			&pImageOneIntensitySumBlueVar,
			&pOutputArrayIntensitySumRedVar,
			&pOutputArrayIntensitySumGreenVar,
			&pOutputArrayIntensitySumBlueVar,
			&pIdenticalArrayIntensitySumRedVar,
			&pIdenticalArrayIntensitySumGreenVar,
			&pIdenticalArrayIntensitySumBlueVar,
			&pDifferentArrayIntensitySumRedVar,
			&pDifferentArrayIntensitySumGreenVar,
			&pDifferentArrayIntensitySumBlueVar,
			&pImageOneIntensityAverageRedVar,
			&pImageOneIntensityAverageGreenVar,
			&pImageOneIntensityAverageBlueVar,
			&pOutputArrayIntensityAverageRedVar,
			&pOutputArrayIntensityAverageGreenVar,
			&pOutputArrayIntensityAverageBlueVar,
			&pIdenticalArrayIntensityAverageRedVar,
			&pIdenticalArrayIntensityAverageGreenVar,
			&pIdenticalArrayIntensityAverageBlueVar,
			&pDifferentArrayIntensityAverageRedVar,
			&pDifferentArrayIntensityAverageGreenVar,
			&pDifferentArrayIntensityAverageBlueVar,
			&pAreImagesIdentical);



		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		pixelDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();


		for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
		{

			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pixelDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pixelDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pixelDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pixelDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pixelDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pixelDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pixelDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pixelDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pixelDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pixelDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pixelDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


			}


		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		




		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompation(hInstance, hWnd,
			ppVerificationOutputArray, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}


		pixelDataFile.close();

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);





	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SubtractValuesFromColorsOfRGBImageWithResultsRestorationForIdenticalPixels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ExtractObjectFromDigitalImagesUsingPixelDataSubtractionIdenticalParts.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelBufferRGB> pOutputFilterResult = vector<OutputPixelBufferRGB>();
	vector <OutputPixelBufferRGB> pFilterToReverse = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;
	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;
	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;
	cout << "Selected Red: " << pRedValueBottom << endl;
	cout << "Selected Green: " << pGreenValueBottom << endl;
	cout << "Selected Blue: " << pBlueValueBottom << endl;


	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;
	pixelDataFile << "Selected Red: " << pRedValueBottom << endl;
	pixelDataFile << "Selected Green: " << pGreenValueBottom << endl;
	pixelDataFile << "Selected Blue: " << pBlueValueBottom << endl;

	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	vector<PixelObject> pCommonPixelArray = vector<PixelObject>();
	pCommonPixelArray.clear();

	if (GetOpenFileNameW(&ofn))
	{

	

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 
			auto start = high_resolution_clock::now();

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;

			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;


			for (PixelObject pixelObject : pixelObjectVectorY)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}


			}

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}	
		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX);
		}



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Filter Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "Filtering Started " << endl;
		pixelDataFile << "Filtering Started " << endl;

		vector<OutputPixelObjectFiltered> pFilteredArray = vector<OutputPixelObjectFiltered>();
		pFilteredArray.clear();



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;

		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImage(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVectorX,
			pRedValueBottom,
			pGreenValueBottom,
			pBlueValueBottom,
			&pAmountOfIdenticalPixels,
			&pAmountOfDifferentPixels,
			&ppVerificationOutputArray,
			&ppIdenticalPixelOutputArray,
			&ppDifferentPixelOutputArray,
			&pImageOneIntensitySumRedVar,
			&pImageOneIntensitySumGreenVar,
			&pImageOneIntensitySumBlueVar,
			&pOutputArrayIntensitySumRedVar,
			&pOutputArrayIntensitySumGreenVar,
			&pOutputArrayIntensitySumBlueVar,
			&pIdenticalArrayIntensitySumRedVar,
			&pIdenticalArrayIntensitySumGreenVar,
			&pIdenticalArrayIntensitySumBlueVar,
			&pDifferentArrayIntensitySumRedVar,
			&pDifferentArrayIntensitySumGreenVar,
			&pDifferentArrayIntensitySumBlueVar,
			&pImageOneIntensityAverageRedVar,
			&pImageOneIntensityAverageGreenVar,
			&pImageOneIntensityAverageBlueVar,
			&pOutputArrayIntensityAverageRedVar,
			&pOutputArrayIntensityAverageGreenVar,
			&pOutputArrayIntensityAverageBlueVar,
			&pIdenticalArrayIntensityAverageRedVar,
			&pIdenticalArrayIntensityAverageGreenVar,
			&pIdenticalArrayIntensityAverageBlueVar,
			&pDifferentArrayIntensityAverageRedVar,
			&pDifferentArrayIntensityAverageGreenVar,
			&pDifferentArrayIntensityAverageBlueVar,
			&pAreImagesIdentical);



		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		pixelDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();


		for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
		{

			if ((pOutputPixelValue.pOutputComparisonValueRed == 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen == 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue == 0.0f))
			{
				cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




				pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				pixelDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				pixelDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				pixelDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				pixelDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				pixelDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				pixelDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				pixelDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				pixelDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				pixelDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				pixelDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				pixelDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
			}
		}


		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreZeroRGBPixelsFromImageCompation(hInstance, hWnd,
			ppVerificationOutputArray, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}


		pixelDataFile.close();

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);





	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldRGBImagePixelByCriteriaWithRecoveryWithStepsDefined(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationWthRGBRecoveryWithStepsDefined.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilterToReverse = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;

		// Get starting timepoint 
		auto start = high_resolution_clock::now();

		// Call the function, here sort() 

		// Get ending timepoint 

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		
		pixelDataFile << "New Image Clip" << endl;

		cout << "Performing Image Scan Eight Cliing X" << endl;
		pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorX);

		cout << "Clip for Image X Position" << endl;
		pixelDataFile << "Clip for Image X Position" << endl;

		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorX)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		


		}

		cout << "Clip for Image X Position End" << endl;
		pixelDataFile << "Clip for Image X Position End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		auto stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For X End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;

		pixelDataFile << "Clipping Session For X End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


		cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For Y End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << "Clipping Session For Y End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Filter Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "Filtering Started " << endl;
		pixelDataFile << "Filtering Started " << endl;
		start = high_resolution_clock::now();

		vector<OutputPixelObjectFiltered> pFilteredArray = vector<OutputPixelObjectFiltered>();
		pFilteredArray.clear();



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;

		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVectorX, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


				if (pPixelObject.pUsedInComputations == 255 || pPixelObject.pUsedInComputations == true)
				{
					pFinalOutputSquare.push_back(pPixelObject);
					pAmountOfFilteredPixels++;
				}



				pIndexValue++;
			}
		}






		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pFinalOutputSquare, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				pXPositionValues.push_back(pixelObject.xPosition);
				pYPositionValues.push_back(pixelObject.yPosition);
			}
		}


		pixelDataFile.close();

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);





	

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldGrayScaleImagePixelByCriteriaWithRecoveryWithStepsDefined(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationWthGrayScaleRecoveryWithStepsDefined.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilterToReverse = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pGreydValueBottom = 0.0f;
	float pGreyValueTop = 0.0f;
	
	cout << "Enter the Lowest Value for Grey Component" << endl;
	cin >> pGreydValueBottom;
	cout << "Enter the Highest Value for Grey Component" << endl;
	cin >> pGreyValueTop;



	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;






	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;

	// Get starting timepoint 
	auto start = high_resolution_clock::now();

	// Call the function, here sort() 

	// Get ending timepoint 

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




	pixelDataFile << "New Image Clip" << endl;

	cout << "Performing Image Scan Eight Cliing X" << endl;
	pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorX);

	cout << "Clip for Image X Position" << endl;
	pixelDataFile << "Clip for Image X Position" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVectorX)
	{

		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}



	}

	cout << "Clip for Image X Position End" << endl;
	pixelDataFile << "Clip for Image X Position End" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




	auto stop = high_resolution_clock::now();

	// Get duration. Substart timepoints to  
	// get durarion. To cast it to proper unit 
	// use duration cast method 
	auto duration = duration_cast<microseconds>(stop - start);
	cout << "Clipping Session For X End" << endl;
	cout << "Time taken by function: "
		<< duration.count() / 1000000 << " seconds" << endl;

	pixelDataFile << "Clipping Session For X End" << endl;
	pixelDataFile << "Time taken by function: "
		<< duration.count() / 1000000 << " seconds" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	stop = high_resolution_clock::now();

	// Get duration. Substart timepoints to  
	// get durarion. To cast it to proper unit 
	// use duration cast method 
	duration = duration_cast<microseconds>(stop - start);
	cout << "Clipping Session For Y End" << endl;
	cout << "Time taken by function: "
		<< duration.count() / 1000000 << " seconds" << endl;
	pixelDataFile << "Clipping Session For Y End" << endl;
	pixelDataFile << "Time taken by function: "
		<< duration.count() / 1000000 << " seconds" << endl;



	cout << "RGB Section End" << endl;
	pixelDataFile << "RGB Section End" << endl;


	cout << "Grayscale Section End" << endl;
	pixelDataFile << "Grayscale Section End" << endl;


	vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
	cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
	pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "Filter Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " Filter Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

	cout << "Filtering Started " << endl;
	pixelDataFile << "Filtering Started " << endl;
	start = high_resolution_clock::now();

	vector<OutputPixelObjectFiltered> pFilteredArray = vector<OutputPixelObjectFiltered>();
	pFilteredArray.clear();



	cout << "RGB Section End" << endl;
	pixelDataFile << "RGB Section End" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	cout << "Grayscale Section End" << endl;
	pixelDataFile << "Grayscale Section End" << endl;

	cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
	pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



	vector<PixelObjectGrayScale> pGrayScaleVector = vector<PixelObjectGrayScale>();
	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance,
		hWnd, pixelObjectVectorX,
		&pGrayScaleVector);


	for (PixelObjectGrayScale pPixelObject : pGrayScaleVector)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		cout << "Pixel Number: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


	
	}



	cout << "Grayscale Section End" << endl;
	pixelDataFile << "Grayscale Section End" << endl;

	vector<OutputPixelObjectFilteredGrayScale> ppOutputPixelVectorGrayScale = vector<OutputPixelObjectFilteredGrayScale>();
	cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
	pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaGrayScale(hInstance, hWnd,
		pMinimumX,
		pMinimumY,
		pMaximumX,
		pMaximumY,
		pThresholdIntensityMinimum, pThresholdIntensityMaximum,
		pGrayScaleVector, &ppOutputPixelVectorGrayScale);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;


	int pAmountOfPixelsUses = 0;
	for (OutputPixelObjectFilteredGrayScale pPixelObject : ppOutputPixelVectorGrayScale)
	{
		
		
		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGrayScaleValue;
		bool pIsPixelUsed = pPixelObject.pIsPixelValid;

		if ((pIsPixelUsed == true) || (pIsPixelUsed == 255))
		{
			pAmountOfPixelsUses++;
		}

		cout << "Step: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
		cout << "Is Pixel Used = " << pIsPixelUsed << endl;



		pixelDataFile << "Step: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
		pixelDataFile << "Is Pixel Used = " << pIsPixelUsed << endl;

	}

	vector<PixelObjectGrayScale> pGrayScaleFilterOutput = vector<PixelObjectGrayScale>();

	hr = ppStandardAlgorithmExecutor->RestoreGrayScalePixelFromFilter(hInstance,
		hWnd,
		ppOutputPixelVectorGrayScale,
		&pGrayScaleFilterOutput);

	for (PixelObjectGrayScale pPixelObject : pGrayScaleFilterOutput)
	{

	
		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Pixel Number: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



	}









	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DetectSquareOnWhiteFont(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	std::remove("C:\\pixels\\DetectionOfSquareOnWhiteFontExperiment.txt");
	DestroyFilePermanently(hInstance, hWnd, L"C:\\pixels\\DetectionOfSquareOnWhiteFontExperiment.txt");

	
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\DetectionOfSquareOnWhiteFontExperiment.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	fstream correctFilterData;
	correctFilterData.open("C:\\pixels\\CorrectFilterOutputRGB.txt", fstream::in | fstream::out | fstream::trunc);
	correctFilterData.clear();

	LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds;
	LARGE_INTEGER Frequency;

	QueryPerformanceFrequency(&Frequency);
	QueryPerformanceCounter(&StartingTime);

	// Activity to be timed

	

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVectorCommon = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilterToReverse = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();

	pixelObjectVectorCommon.clear();
	pixelObjectVectorX.clear();
	pixelObjectVectorY.clear();
	pOutputFilterResult.clear();
	pFilterToReverse.clear();
	pFilterToReverseOutput.clear();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;

	float pStepX = 0.0f;
	float pStepY = 0.0F;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step for X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the step for Y Coordinate" << endl;
	cin >> pStepY;




	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




	if (GetOpenFileNameW(&ofn))
	{


		// Get starting timepoint 
		auto start = high_resolution_clock::now();

		// Call the function, here sort() 
	
		// Get ending timepoint 
		
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;

		cout << "Performing Image Scan Eight Cliing X" << endl;
		pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorX);

		cout << "Clip for Image X Position" << endl;
		pixelDataFile << "Clip for Image X Position" << endl;

		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorX)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Clip for Image X Position End" << endl;
		pixelDataFile << "Clip for Image X Position End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		auto stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For X End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;

		pixelDataFile << "Clipping Session For X End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Performing Image Scan Two" << endl;
		start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorY);

		cout << "Printing the Contents of Clipped Area" << endl;
		 pIndex = 0;

		 cout << "Clip for Image Y Position" << endl;
		 pixelDataFile << "Clip for Image Y Position" << endl;


		for (PixelObject pixelObject : pixelObjectVectorY)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		 stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		 duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For Y End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << "Clipping Session For Y End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		vector<PixelObject> pCommonPixelArray = vector<PixelObject>();
		pCommonPixelArray.clear();
		pCommonPixelArray.insert(pCommonPixelArray.end(), pixelObjectVectorX.begin(), pixelObjectVectorX.end());
		pCommonPixelArray.insert(pCommonPixelArray.end(), pixelObjectVectorY.begin(), pixelObjectVectorY.end());

			

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Filter Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Filter Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "Filtering Started " << endl;
		pixelDataFile << "Filtering Started " << endl;
		start = high_resolution_clock::now();

		vector<OutputPixelObjectFiltered> pFilteredArray = vector<OutputPixelObjectFiltered>();
		pFilteredArray.clear();

		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pCommonPixelArray, &pOutputFilterResult);


		stop = high_resolution_clock::now();

	
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{


			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile <<  "Pixel Number: "  << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;


			

			pIndexValue++;
		}

		
		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		duration = duration_cast<microseconds>(stop - start);
		cout << "Filtering end" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << "Filtering end" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;




		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "Filtering End System: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " Filtering End Local: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "Filtering End Local: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " Filtering End Local: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Restoring Image Pixel Data for Filter Output" << endl;
		cout << "Restoration Started " << endl;
		pixelDataFile << "Restoration Started " << endl;
		start = high_resolution_clock::now();

		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Restoration Time Start is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Restoration Time Start is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "Restoration Time Start: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " Restoration Time Start: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
			pOutputFilterResult, &pFilterToReverseOutput);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pFilterToReverseOutput)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);

		}

			


		vector<Point2D> pPointToDraw = vector <Point2D>();

		for (PixelObject pVectorItem : pFilterToReverseOutput)
		{
			Point2D pPointObject;
			pPointObject.pPointNumber = pVectorItem.pixelNumber;
			pPointObject.xPosition = pVectorItem.xPosition;
			pPointObject.yPosition = pVectorItem.yPosition;
			pPointToDraw.push_back(pPointObject);

		}


		cout << "Computing The Line Equations for an array of twelve pixels" << endl;
		pixelDataFile << "Computing The Line Equations for an array of twelve pixels" << endl;



		PixelObject pSamplePixel = pFilterToReverseOutput[0];
		float pRedComponent = pSamplePixel.RMask;
		float pGreenComponent = pSamplePixel.GMask;
		float pBlueComponent = pSamplePixel.RMask;

		PixelObject pPixelObjectOne = PixelObject(1, 151.0f, 200.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectTwo = PixelObject(2, 151.0f, 400.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectThree = PixelObject(3, 151.0f, 600.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectFour = PixelObject(4, 648.0f, 200.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectFive = PixelObject(5, 648.0f, 400.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectSix = PixelObject(6, 648.0f, 600.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectSeven = PixelObject(7,200.0f, 121.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectEight = PixelObject(8, 200.0f, 618.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectNine = PixelObject(9, 400.0f, 121.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectTen = PixelObject(10, 400.0f, 618.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectEleven = PixelObject(11, 600.0f, 121.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectTwelve = PixelObject(12, 600.0f, 618.0f, pRedComponent, pGreenComponent, pBlueComponent);
		PixelObject pPixelObjectCentre = PixelObject(0, 470.0f, 200.0f, pRedComponent, pGreenComponent, pBlueComponent);

		
	
		vector<PixelObject> pPixelsToAnalyze = vector<PixelObject>();
		pPixelsToAnalyze.clear();
		vector<LinearFunctionStruct> pLineSemgments = vector<LinearFunctionStruct>();
		pLineSemgments.clear();
		pPixelsToAnalyze.push_back(pPixelObjectEight);
		pPixelsToAnalyze.push_back(pPixelObjectTwo);
		pPixelsToAnalyze.push_back(pPixelObjectThree);
		pPixelsToAnalyze.push_back(pPixelObjectFive);
		pPixelsToAnalyze.push_back(pPixelObjectSix);
		pPixelsToAnalyze.push_back(pPixelObjectSeven);
		pPixelsToAnalyze.push_back(pPixelObjectEight);
		pPixelsToAnalyze.push_back(pPixelObjectNine);
		pPixelsToAnalyze.push_back(pPixelObjectTen);
		pPixelsToAnalyze.push_back(pPixelObjectEleven);
		pPixelsToAnalyze.push_back(pPixelObjectTwelve);



		vector<PixelObject> pCommonPixelObjectArrayEightRGB = vector<PixelObject>();
		PixelObject pPixelObjectCentreEight = PixelObject(1, 151.0f, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwo = PixelObject(2, 151.0f, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreThree = PixelObject(3, 151.0f, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFour = PixelObject(4, 648.0f, 200.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreFive = PixelObject(5, 648.0f, 400.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSix = PixelObject(6, 648.0f, 600.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreSeven = PixelObject(7, 200.0f, 121.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCenteEight = PixelObject(8, 200.0f, 618.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreNine = PixelObject(9, 400.0f, 121.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTen = PixelObject(10, 400.0f, 618.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreEleven = PixelObject(11, 600.0f, 121.0f, 0.0f, 0.0f, 0.0f);
		PixelObject pPixelObjectCentreTwelve = PixelObject(12, 600.0f, 618.0f, 0.0f, 0.0f, 0.0f);


		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreEight);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTwo);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreThree);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreFour);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreFive);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreSix);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreSeven);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCenteEight);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreNine);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTen);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreEleven);
		pCommonPixelObjectArrayEightRGB.push_back(pPixelObjectCentreTwelve);








		cout << "Computing Cluster Centrers" << endl;

		Point2D pCentre;
		pCentre.pPointNumber = 1.0f;
		pCentre.xPosition = 430.0f;
		pCentre.yPosition = 370.0f;

		cout << "Your Pixel Centre X Position: " << pCentre.xPosition << endl;
		cout << "Your Pixel Centre Y Position: " << pCentre.yPosition << endl;
		pixelDataFile << "Your Pixel Centre X Position: " << pCentre.xPosition << endl;
		pixelDataFile << "Your Pixel Centre Y Position: " << pCentre.yPosition << endl;




		cout << "Computing Pixel Object Centres Tangients" << endl;
		pixelDataFile << "Computing Pixel Object Centres Tangents" << endl;


		vector<OutputPixelObjectWithAngleValues> pCommonOutputVector = vector<OutputPixelObjectWithAngleValues>();
		hr = ppStandardAlgorithmExecutor->ComputePixelDeltaFunctionFromCentre(hInstance,
			hWnd, pCentre.xPosition, pCentre.yPosition,
			pCommonPixelObjectArrayEightRGB, &pCommonOutputVector);

		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorEight = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorTwo = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorThree = vector<OutputPixelObjectWithAngleValues>();
		vector<OutputPixelObjectWithAngleValues> pVectorPointsSectorFour = vector<OutputPixelObjectWithAngleValues>();



		for (OutputPixelObjectWithAngleValues pPixelObject : pCommonOutputVector)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pixelDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pixelDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
			pixelDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pixelDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pixelDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
			pixelDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;









		}





		cout << "Computing Pixel Line Segments" << endl;

		int pId = 0;
		for (PixelObject pPixelToCompute : pPixelsToAnalyze)
		{
			LinearFunctionStruct pNewSegment = ComputeLineEquationBetweenPixels(pId, pPixelToCompute, pPixelObjectCentre);
			cout << "Segment Id: " << pNewSegment.pSegmentNumber << endl;
			cout << "Pixel Number: " << pNewSegment.pPixelNumberEight << endl;
			cout << "X Position 0: " << pNewSegment.xPosition0 << endl;
			cout << "y Position 0: " << pNewSegment.yPosition0 << endl;
			cout << "X Position 1: " << pNewSegment.xPosition1 << endl;
			cout << "y Position 1: " << pNewSegment.yPosition1 << endl;
			cout << "Distance From Centre: " << pNewSegment.pDistanceValue << endl;
			cout << "A Coefficient for y = a*x + b equation" << pNewSegment.pKCoefficient <<  endl;
			cout << "B Coefficent for = y = a*x + b equation" << pNewSegment.pBCoefficient <<  endl;

			pixelDataFile << "Segment Id: " << pNewSegment.pSegmentNumber << endl;
			pixelDataFile << "Pixel Number: " << pNewSegment.pPixelNumberEight << endl;
			pixelDataFile << "X Position 0: " << pNewSegment.xPosition0 << endl;
			pixelDataFile << "y Position 0: " << pNewSegment.yPosition0 << endl;
			pixelDataFile << "X Position 1: " << pNewSegment.xPosition1 << endl;
			pixelDataFile << "y Position 1: " << pNewSegment.yPosition1 << endl;
			pixelDataFile << "Distance From Centre: " << pNewSegment.pDistanceValue << endl;
			pixelDataFile << "A Coefficient for y = a*x + b equation" << pNewSegment.pKCoefficient << endl;
			pixelDataFile << "B Coefficent for = y = a*x + b equation" << pNewSegment.pBCoefficient << endl;


			pLineSemgments.push_back(pNewSegment);
			pId++;
		}


	

		float pEightSevenLength = 0.0f;
		pEightSevenLength = sqrtf((abs(pow(pLineSemgments[0].pDistanceValue, 2) - pow(pLineSemgments[6].pDistanceValue, 2))));

		float pSevenNineLength = 0.0f;
		pSevenNineLength = sqrtf((abs(pow(pLineSemgments[6].pDistanceValue, 2) - pow(pLineSemgments[8].pDistanceValue, 2))));


		float pNineElevenLength = 0.0f;
		pNineElevenLength = sqrtf((abs(pow(pLineSemgments[8].pDistanceValue, 2) - pow(pLineSemgments[10].pDistanceValue, 2))));

		float pElevenFourLength= 0.0f;
		pElevenFourLength = sqrtf((abs(pow(pLineSemgments[10].pDistanceValue, 2) - pow(pLineSemgments[3].pDistanceValue, 2))));

		float pFourFiveLength = 0.0f;
		pFourFiveLength = sqrtf((abs(pow(pLineSemgments[3].pDistanceValue, 2) - pow(pLineSemgments[4].pDistanceValue, 2))));

		float pFiveSixLength = 0.0f;
		pFiveSixLength = sqrtf((abs(pow(pLineSemgments[4].pDistanceValue, 2) - pow(pLineSemgments[5].pDistanceValue, 2))));

		float pSixTwelveLength = 0.0f;
		pSixTwelveLength = sqrtf((abs(pow(pLineSemgments[10].pDistanceValue, 2) - pow(pLineSemgments[5].pDistanceValue, 2))));

		float pTwelveTenLength = 0.0f;
		pTwelveTenLength = sqrtf((abs(pow(pLineSemgments[9].pDistanceValue, 2) - pow(pLineSemgments[10].pDistanceValue, 2))));

		float pTenEightLength = 0.0f;
		pTenEightLength = sqrtf((abs(pow(pLineSemgments[9].pDistanceValue, 2) - pow(pLineSemgments[7].pDistanceValue, 2))));

		float pEightThreeLength = 0.0f;
		pEightThreeLength = sqrtf((abs(pow(pLineSemgments[7].pDistanceValue, 2) - pow(pLineSemgments[2].pDistanceValue, 2))));

		float pThreeTwoLength = 0.0f;
		pThreeTwoLength = sqrtf((abs(pow(pLineSemgments[2].pDistanceValue, 2) - pow(pLineSemgments[1].pDistanceValue, 2))));

		float pTwoEightLength = 0.0f;
		pTwoEightLength = sqrtf((abs(pow(pLineSemgments[1].pDistanceValue, 2) - pow(pLineSemgments[0].pDistanceValue, 2))));


		cout << "Printing Lengths of Segments: " << endl;
		cout << "1-7: " << pEightSevenLength << endl;
		cout << "7-9: " << pSevenNineLength << endl;
		cout << "9-11: " << pNineElevenLength << endl;
		cout << "11-4: " << pElevenFourLength << endl;
		cout << "4-5: " << pFourFiveLength << endl;
		cout << "5-6: " << pFiveSixLength << endl;
		cout << "6-12: " << pSixTwelveLength << endl;
		cout << "12-10: " << pTwelveTenLength << endl;
		cout << "10-8: " << pTenEightLength << endl;
		cout << "8-3: " << pEightThreeLength << endl;
		cout << "3-2: " << pThreeTwoLength << endl;
		cout << "2-1: " << pTwoEightLength << endl;


		pixelDataFile << "Printing Lengths of Segments: " << endl;
		pixelDataFile << "1-7: " << pEightSevenLength << endl;
		pixelDataFile << "7-9: " << pSevenNineLength << endl;
		pixelDataFile << "9-11: " << pNineElevenLength << endl;
		pixelDataFile << "11-4: " << pElevenFourLength << endl;
		pixelDataFile << "4-5: " << pFourFiveLength << endl;
		pixelDataFile << "5-6: " << pFiveSixLength << endl;
		pixelDataFile << "6-12: " << pSixTwelveLength << endl;
		pixelDataFile << "12-10: " << pTwelveTenLength << endl;
		pixelDataFile << "10-8: " << pTenEightLength << endl;
		pixelDataFile << "8-3: " << pEightThreeLength << endl;
		pixelDataFile << "3-2: " << pThreeTwoLength << endl;
		pixelDataFile << "2-1: " << pTwoEightLength << endl;







		vector<PixelObject> pPixelObjectForEquations = vector<PixelObject>();

		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "Restoration Time End is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " Restoration Time End is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "Restoration End Start: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " Restoration End Start: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		duration = duration_cast<microseconds>(stop - start);
		cout << "Filtering end" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << "Filtering end" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		vector<Point2D> pPointsDataToConnect = vector<Point2D>();

		for (PixelObject pPixelToCompute : pCommonPixelObjectArrayEightRGB)
		{
			Point2D pNewPoint;
			pNewPoint.pPointNumber = pPixelToCompute.pixelNumber;
			pNewPoint.xPosition = pPixelToCompute.xPosition;
			pNewPoint.yPosition = pPixelToCompute.yPosition;
			pPointsDataToConnect.push_back(pNewPoint);
		}


		pixelDataFile.close();

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->ConnectPointsUsingLinesDirectForSquare(hInstance, hWnd, pPointsDataToConnect);



		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;

	
		QueryPerformanceCounter(&EndingTime);
		ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;
		float pAmountInSeconds = ElapsedMicroseconds.QuadPart / 1000000;

		cout << "COde Execution Time in Seconds = " << pAmountInSeconds << endl;
		pixelDataFile << "Time taken by whole function: "
			<< pAmountInSeconds << " seconds" << endl;


	}
	pixelDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldImagePixelByCriteriaWithRecovery(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationWithGrayScaleRecovery.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelObjectFilteredGrayScale> ppOutputPixelVector = vector<OutputPixelObjectFilteredGrayScale>();
	vector<OutputPixelObjectFilteredGrayScale> pFilterToRecover = vector<OutputPixelObjectFilteredGrayScale>();
	vector<PixelObjectGrayScale> pRecoveredImage = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME grayscaleTimeStartSystem;
	SYSTEMTIME grayscaleTimeStartLocal;
	SYSTEMTIME grayscaleTimeEndSystem;
	SYSTEMTIME grayscaleTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;



	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the Step For X Coordinate" << endl;
	cin >> pStepX;

	cout << "Enter the Step for Y Coordinate" << endl;
	cin >> pStepY;

	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;


	cout << "Enter the Value For The Minimum Intensity Threshold" << endl;
	cin >> pThresholdIntensityMinimum;


	cout << "Enter the Value For The Maximum Intensity Threshold" << endl;
	cin >> pThresholdIntensityMaximum;

	cout << "Your Selected Minimum Value Of the Threshold = " << pThresholdIntensityMinimum << endl;
	pixelDataFile << "Your Selected Minimum Value Of the Threshold = " << pThresholdIntensityMinimum << endl;

	cout << "Your Selected Maximum Value Of the Threshold = " << pThresholdIntensityMaximum << endl;
	pixelDataFile << "Your Selected Maximum Value Of the Threshold = " << pThresholdIntensityMaximum << endl;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
	


		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;

		GetSystemTime(&grayscaleTimeStartSystem);
		GetLocalTime(&grayscaleTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
			pixelObjectVector, &pPixelObjectToGrayScale);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		float pIndexValue = 0;

		cout << "Grayscale Section Begin" << endl;
		pixelDataFile << "Grayscale Section Begin" << endl;



		for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
		{

			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


			pIndexValue++;
		}

		GetSystemTime(&grayscaleTimeEndSystem);
		GetLocalTime(&grayscaleTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;




		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;

		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaGrayScale(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pThresholdIntensityMinimum, pThresholdIntensityMaximum,
			pPixelObjectToGrayScale, &ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

		int pAmountOfPixelsUses = 0;



		for (OutputPixelObjectFilteredGrayScale pPixelObject : ppOutputPixelVector)
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale = pPixelObject.pGrayScaleValue;
			bool pIsPixelUsed = pPixelObject.pIsPixelValid;

			if ((pIsPixelUsed == true) || (pIsPixelUsed == 255))
			{
				pAmountOfPixelsUses++;
				pFilterToRecover.push_back(pPixelObject);
				
			}

			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
			cout << "Is Pixel Used = " << pIsPixelUsed << endl;



			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
			pixelDataFile << "Is Pixel Used = " << pIsPixelUsed << endl;

		
		
			

			pIndexValue++;
		}

		cout << "Amount of filtered pixels = " << pAmountOfPixelsUses;
		pixelDataFile << "Amount of filtered pixels = " << pAmountOfPixelsUses;

	}

	cout << "Now We Would Like to Recover the output Grayscale Values" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreGrayScalePixelFromFilter(hInstance,
		hWnd, pFilterToRecover, &pRecoveredImage);





	for (PixelObjectGrayScale pPixelObject : pRecoveredImage)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pPixelNumber << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
	}


	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;



	pixelDataFile.close();
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::FilterOutRGBImageByCriteria(HINSTANCE hInstance,
	HWND hWnd, vector<PixelObject> pInputPixelObjectArray,
	float pMinimumX, float pMinimumY, float pMaximumX, float pMaximumY, float pMinimumRed, float pMaximumRed, float pMinimumGreen, float pMaximumGreen, float pMinimumBlue, float pMaximumBlue, vector<OutputPixelObjectFiltered> *pFilterResults)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationRGBApiFunction.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	cout << "RGB Section End" << endl;
	pixelDataFile << "RGB Section End" << endl;




	cout << "Grayscale Section End" << endl;
	pixelDataFile << "Grayscale Section End" << endl;

	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();


	hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
		pMinimumX,
		pMinimumY,
		pMaximumX,
		pMaximumY,
		pMinimumRed,
		pMaximumRed,
		pMinimumGreen,
		pMaximumGreen,
		pMinimumBlue,
		pMaximumBlue,
		pInputPixelObjectArray, &pOutputFilterResult);


	*pFilterResults = pOutputFilterResult;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldImagePixelByCriteriaRGB(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVector, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{

            
			if ((pPixelObject.rValue != 255) && (pPixelObject.gValue != 255) && (pPixelObject.bValue != 255.0f))
			{
				float pPixelNumber = pIndexValue;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				bool pUsedInComputations = pPixelObject.pUsedInComputations;

				if ((pUsedInComputations == true) || (pUsedInComputations == 255))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Used In Computations = " << pUsedInComputations << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;

			}
	


			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}

	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateCarNumberDetectionOperationFromImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CarNumberDetectionImageSubtraction", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	vector<OutputPixelBufferRGB> pOutputDataBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalDataBuffer = vector<PixelObject>();
	vector<PixelObject> pDifferentDataBuffer = vector<PixelObject>();


	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;


	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{


		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;






		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 
			auto start = high_resolution_clock::now();

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		
			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;


			for (PixelObject pixelObject : pixelObjectVectorY)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}


			}

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


	

		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;
		BOOL pAreImagesIdentical = FALSE;


		hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImage(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVectorX,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			&pAmountOfIdenticalPixels,
			&pAmountOfDifferentPixels,
			&pOutputDataBuffer,
			&pIdenticalDataBuffer,
			&pDifferentDataBuffer,
			&pImageOneIntensitySumRedVar,
			&pImageOneIntensitySumGreenVar,
			&pImageOneIntensitySumBlueVar,
			&pOutputArrayIntensitySumRedVar,
			&pOutputArrayIntensitySumGreenVar,
			&pOutputArrayIntensitySumBlueVar,
			&pIdenticalArrayIntensitySumRedVar,
			&pIdenticalArrayIntensitySumGreenVar,
			&pIdenticalArrayIntensitySumBlueVar,
			&pDifferentArrayIntensitySumRedVar,
			&pDifferentArrayIntensitySumGreenVar,
			&pDifferentArrayIntensitySumBlueVar,
			&pImageOneIntensityAverageRedVar,
			&pImageOneIntensityAverageGreenVar,
			&pImageOneIntensityAverageBlueVar,
			&pOutputArrayIntensityAverageRedVar,
			&pOutputArrayIntensityAverageGreenVar,
			&pOutputArrayIntensityAverageBlueVar,
			&pIdenticalArrayIntensityAverageRedVar,
			&pIdenticalArrayIntensityAverageGreenVar,
			&pIdenticalArrayIntensityAverageBlueVar,
			&pDifferentArrayIntensityAverageRedVar,
			&pDifferentArrayIntensityAverageGreenVar,
			&pDifferentArrayIntensityAverageBlueVar,
			&pAreImagesIdentical);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		pixelDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		cout << "Printing out the Output the Experiment" << endl;

		vector<PixelObject> pOutputImage = vector<PixelObject>();

		float pColorSum = 0.0f;
		for (OutputPixelBufferRGB pOutputPixelValue : pOutputDataBuffer)
		{


			if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
			{

				cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




				pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
				pixelDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
				pixelDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
				pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
				pixelDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
				pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
				pixelDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
				pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
				pixelDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
				pixelDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
				pixelDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
				pixelDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
				pixelDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
				pixelDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
				pixelDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
			}




		}



		vector<PixelObject> pIdenticalPixelBuffer = vector<PixelObject>();


		cout << "Restoring Image Pixel Data for Filter Output for Identical Pixels" << endl;
		pixelDataFile << "Restoring Image Pixel Data for Filter Output for Identical Pixels" << endl;

		hr = ppStandardAlgorithmExecutor->RestoreZeroRGBPixelsFromImageCompationInitialPixels(hInstance, hWnd,
			pOutputDataBuffer, &pIdenticalPixelBuffer);

		cout << "Printing the Results of the Output" << endl;

		vector<float> pXPositionValues = vector<float>();
		vector<float> pYPositionValues = vector<float>();

		for (PixelObject pixelObject : pIdenticalPixelBuffer)
		{


			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}

	vector<PixelObject> pDifferentPixelBuffer = vector<PixelObject>();

	cout << "Restoring Image Pixel Data for Filter Output for Different Pixels" << endl;
	pixelDataFile << "Restoring Image Pixel Data for Filter Output for Different Pixels" << endl;


	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompationInitialPixels(hInstance, hWnd,
		pOutputDataBuffer, &pDifferentPixelBuffer);

	cout << "Printing the Results of the Output" << endl;

	for (PixelObject pixelObject : pDifferentPixelBuffer)
	{


		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}

	cout << "Printing Array Sizes" << endl;
	pixelDataFile << "Printing Array Sizes" << endl;

	cout << "Identical Pixel Array Size = " << pIdenticalDataBuffer.size() << endl;
	cout << "Different Pixel Array Size = " << pDifferentPixelBuffer.size() << endl;


	pixelDataFile << "Identical Pixel Array Size = " << pIdenticalDataBuffer.size() << endl;
	pixelDataFile << "Different Pixel Array Size = " << pDifferentPixelBuffer.size() << endl;




	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pDifferentDataBuffer, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);
	pixelDataFile.close();
	return hr;

}

		
		
	






	HRESULT DirectXGPUDigitalLabCoreModule::SimulateCarNumberDetectionOperationFromImageUsingBoundaryDescriptor(HINSTANCE hInstance, HWND hWnd)
	{
		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\СarNumberDetectionBoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME classOneRestorationSystem;
		SYSTEMTIME classOneRestorationLocal;
		SYSTEMTIME classTwoRestorationSystem;
		SYSTEMTIME classTwoRestorationLocal;
		SYSTEMTIME experimentEndTimeSystem;
		SYSTEMTIME experimentEndTimeLocal;

		int pAmountOfFilteredPixels = 0;


		vector<OutputPixelObjectDescriptor> pDescriptorArray = vector<OutputPixelObjectDescriptor>();
		vector<PixelObject> pDifferentPixelObject = vector<PixelObject>();

		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;
		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;


		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;

		cout << "Enter the step to scan X Axis" << endl;
		cin >> pStepX;

		cout << "Enter the step to scan Y Axis" << endl;
		cin >> pStepY;


		float pMinimumX = 0.0f;
		float pMinimumY = 0.0f;
		float pMaximumX = 0.0f;
		float pMaximumY = 0.0f;
		float pThresholdIntensityMinimum = 0;
		float pThresholdIntensityMaximum = 0;


		cout << "Enter the Minimum Value for X Position" << endl;
		cin >> pMinimumX;

		cout << "Enter the Minimum Value for Y Position" << endl;
		cin >> pMinimumY;
		cout << "Enter the Minimum Value for X Position" << endl;
		cin >> pMaximumX;

		cout << "Enter the Minimum Value for Y Position" << endl;
		cin >> pMaximumY;


		float pRedValueOne = 0.0f;
		float pGreenValueOne = 0.0f;
		float pBlueValueOne = 0.0f;


		cout << "Enter Red 1" << endl;
		cin >> pRedValueOne;

		cout << "Enter Green 1" << endl;
		cin >> pGreenValueOne;

		cout << "Enter Blue 1" << endl;
		cin >> pBlueValueOne;


		float pRedValueTwo = 0.0f;
		float pGreenValueTwo = 0.0f;
		float pBlueValueTwo = 0.0f;

		cout << "Enter Red 2" << endl;
		cin >> pRedValueTwo;

		cout << "Enter Green 2" << endl;
		cin >> pGreenValueTwo;

		cout << "Enter Blue 2" << endl;
		cin >> pBlueValueTwo;




		cout << "Top Left X Position = " << pTopLeftX << endl;
		cout << "Top Left Y Position = " << pTopLeftY << endl;
		cout << "Image Width = " << pImageWidth << endl;
		cout << "Image Height = " << pImageWidth << endl;
		cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
		cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
		cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
		cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

		pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
		pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
pixelDataFile << "Image Width = " << pImageWidth << endl;
pixelDataFile << "Image Height = " << pImageWidth << endl;
pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




cout << "Printing RGB Clip Object" << endl;
pixelDataFile << "Printing RGB Clip Object" << endl;





LPWSTR path = nullptr;

OPENFILENAMEW ofn;
ZeroMemory(&ofn, sizeof(ofn));
ofn.lStructSize = sizeof(ofn);
ofn.hwndOwner = hWnd;
ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
ofn.lpstrFile = path;
ofn.nMaxFile = MAX_PATH;
ofn.Flags = OFN_FILEMUSTEXIST;
ofn.hInstance = hInstance;

GetSystemTime(&clippingTimeStartSystem);
GetLocalTime(&clippingTimeStartLocal);

cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



GetSystemTime(&clippingTimeStartSystem);
GetLocalTime(&clippingTimeStartLocal);

cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



if (GetOpenFileNameW(&ofn))
{


	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;






	if ((pStepX > 1) && (pStepY > 1))
	{

		pixelDataFile << "New Image Clip" << endl;

		// Get starting timepoint 
		auto start = high_resolution_clock::now();

		// Call the function, here sort() 

		// Get ending timepoint 

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		pixelDataFile << "New Image Clip" << endl;

	
		cout << "Performing Image Scan Eight Cliing X" << endl;
		pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;

		if ((pStepX > 1) || (pStepY > 1))
				{
					hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
						hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorX);

					cout << "Clip for Image X Position" << endl;
					pixelDataFile << "Clip for Image X Position" << endl;

					int pIndex = 0;

					for (PixelObject pixelObject : pixelObjectVectorX)
					{

						if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
						{
							cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
							cout << "X Position: " << pixelObject.xPosition << endl;
							cout << "Y Position: " << pixelObject.yPosition << endl;
							cout << "Red Value: " << pixelObject.RMask << endl;
							cout << "Green Value: " << pixelObject.GMask << endl;
							cout << "Blue Value: " << pixelObject.BMask << endl;

							pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
							pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
							pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
							pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
							pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
							pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

						}



					}

					cout << "Clip for Image X Position End" << endl;
					pixelDataFile << "Clip for Image X Position End" << endl;


					GetSystemTime(&clippingTimeStartSystem);
					GetLocalTime(&clippingTimeStartLocal);

					cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
					cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
					pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
					pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




					auto stop = high_resolution_clock::now();

					// Get duration. Substart timepoints to  
					// get durarion. To cast it to proper unit 
					// use duration cast method 
					auto duration = duration_cast<microseconds>(stop - start);
					cout << "Clipping Session For X End" << endl;
					cout << "Time taken by function: "
						<< duration.count() / 1000000 << " seconds" << endl;

					pixelDataFile << "Clipping Session For X End" << endl;
					pixelDataFile << "Time taken by function: "
						<< duration.count() / 1000000 << " seconds" << endl;


					GetSystemTime(&clippingTimeStartSystem);
					GetLocalTime(&clippingTimeStartLocal);

					cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
					cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
					pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
					pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

					pStepX = 50.0f;
					pStepY = 500.0f;


					cout << "Performing Image Scan Two" << endl;
					start = high_resolution_clock::now();
					hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
						hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorY);

					cout << "Printing the Contents of Clipped Area" << endl;
					pIndex = 0;

					cout << "Clip for Image Y Position" << endl;
					pixelDataFile << "Clip for Image Y Position" << endl;


					for (PixelObject pixelObject : pixelObjectVectorY)
					{
						if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
						{
							cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
							cout << "X Position: " << pixelObject.xPosition << endl;
							cout << "Y Position: " << pixelObject.yPosition << endl;
							cout << "Red Value: " << pixelObject.RMask << endl;
							cout << "Green Value: " << pixelObject.GMask << endl;
							cout << "Blue Value: " << pixelObject.BMask << endl;

							pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
							pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
							pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
							pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
							pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
							pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
						}


					}
				}
				else if ((pStepX == 1) && (pStepY == 1))
				{
					hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
						hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight,
						&pixelObjectVectorX);
				}
				

				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);

				cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		

				vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
				pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

			}


			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
			cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
			pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		

			cout << "Applying a Descriptor to A Pixel Vector" << endl;
			pixelDataFile << "Applying a Descriptor to A Pixel Vector" << endl;

		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptor(hInstance,
				hWnd,
				pRedValueOne,
				pGreenValueOne,
				pBlueValueOne,
				pRedValueTwo,
				pGreenValueTwo,
				pBlueValueTwo,
				pClassOneLabel,
				pClassTwoLabel,
				pClassThreeLabel,
				pixelObjectVectorX,
				&pDescriptorArray);
		
			}

			cout << "Applying a Descriptor to A Pixel Vector" << endl;
			pixelDataFile << "Applying a Descriptor to A Pixel Vector" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
				hWnd, pClassOneLabel, pDescriptorArray,
				&pDifferentPixelObject);


				for (PixelObject pixelObject : pDifferentPixelObject)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}


			md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			md2dmanager->CreateDeviceResources(hInstance, hWnd);
			md2dmanager->DrawPixelBuffer(hInstance, hWnd, pDifferentPixelObject, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

			pixelDataFile.close();
			return hr;

	}
	
	


	HRESULT DirectXGPUDigitalLabCoreModule::SimulateCarNumberDetectionOperationFromImageUsingBoundaryDescriptorWithDefinedDelta(HINSTANCE hInstance, HWND hWnd)
	{
		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\СarNumberDetectionBoundaryDescriptorWithDefinedDelta.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME classOneRestorationSystem;
		SYSTEMTIME classOneRestorationLocal;
		SYSTEMTIME classTwoRestorationSystem;
		SYSTEMTIME classTwoRestorationLocal;
		SYSTEMTIME experimentEndTimeSystem;
		SYSTEMTIME experimentEndTimeLocal;

		int pAmountOfFilteredPixels = 0;


		vector<OutputPixelObjectDescriptor> pDescriptorArray = vector<OutputPixelObjectDescriptor>();
		vector<PixelObject> pDifferentPixelObject = vector<PixelObject>();

		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;
		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;


		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;

		cout << "Enter the step to scan X Axis" << endl;
		cin >> pStepX;

		cout << "Enter the step to scan Y Axis" << endl;
		cin >> pStepY;


		float pMinimumX = 0.0f;
		float pMinimumY = 0.0f;
		float pMaximumX = 0.0f;
		float pMaximumY = 0.0f;
		float pThresholdIntensityMinimum = 0;
		float pThresholdIntensityMaximum = 0;


		cout << "Enter the Minimum Value for X Position" << endl;
		cin >> pMinimumX;

		cout << "Enter the Minimum Value for Y Position" << endl;
		cin >> pMinimumY;
		cout << "Enter the Minimum Value for X Position" << endl;
		cin >> pMaximumX;

		cout << "Enter the Minimum Value for Y Position" << endl;
		cin >> pMaximumY;


		float pRedValueOne = 0.0f;
		float pGreenValueOne = 0.0f;
		float pBlueValueOne = 0.0f;


		cout << "Enter Red 1" << endl;
		cin >> pRedValueOne;

		cout << "Enter Green 1" << endl;
		cin >> pGreenValueOne;

		cout << "Enter Blue 1" << endl;
		cin >> pBlueValueOne;


		float pRedValueTwo = 0.0f;
		float pGreenValueTwo = 0.0f;
		float pBlueValueTwo = 0.0f;

		cout << "Enter Red 2" << endl;
		cin >> pRedValueTwo;

		cout << "Enter Green 2" << endl;
		cin >> pGreenValueTwo;

		cout << "Enter Blue 2" << endl;
		cin >> pBlueValueTwo;

		float pColorDeltaValue = 0.0f;
		cout << "Enter the Value for Color Delta Constant" << endl;
		cin >> pColorDeltaValue;



		cout << "Top Left X Position = " << pTopLeftX << endl;
		cout << "Top Left Y Position = " << pTopLeftY << endl;
		cout << "Image Width = " << pImageWidth << endl;
		cout << "Image Height = " << pImageWidth << endl;
		cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
		cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
		cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
		cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

		pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
		pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
		pixelDataFile << "Image Width = " << pImageWidth << endl;
		pixelDataFile << "Image Height = " << pImageWidth << endl;
		pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
		pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
		pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
		pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{


			vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
			vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;






			if ((pStepX > 1) && (pStepY > 1))
			{

				pixelDataFile << "New Image Clip" << endl;

				// Get starting timepoint 
				auto start = high_resolution_clock::now();

				// Call the function, here sort() 

				// Get ending timepoint 

				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);

				cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




				pixelDataFile << "New Image Clip" << endl;

	
				cout << "Performing Image Scan Eight Cliing X" << endl;
				pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
				hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
					hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorX);

				cout << "Clip for Image X Position" << endl;
				pixelDataFile << "Clip for Image X Position" << endl;

				int pIndex = 0;

				for (PixelObject pixelObject : pixelObjectVectorX)
				{

					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}



				}

				cout << "Clip for Image X Position End" << endl;
				pixelDataFile << "Clip for Image X Position End" << endl;


				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);

				cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




				auto stop = high_resolution_clock::now();

				// Get duration. Substart timepoints to  
				// get durarion. To cast it to proper unit 
				// use duration cast method 
				auto duration = duration_cast<microseconds>(stop - start);
				cout << "Clipping Session For X End" << endl;
				cout << "Time taken by function: "
					<< duration.count() / 1000000 << " seconds" << endl;

				pixelDataFile << "Clipping Session For X End" << endl;
				pixelDataFile << "Time taken by function: "
					<< duration.count() / 1000000 << " seconds" << endl;


				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);

				cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			

				cout << "Performing Image Scan Two" << endl;
				start = high_resolution_clock::now();
				hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
					hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVectorY);

				cout << "Printing the Contents of Clipped Area" << endl;
				pIndex = 0;

				cout << "Clip for Image Y Position" << endl;
				pixelDataFile << "Clip for Image Y Position" << endl;


				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}

				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);

				cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

				stop = high_resolution_clock::now();

				// Get duration. Substart timepoints to  
				// get durarion. To cast it to proper unit 
				// use duration cast method 
				duration = duration_cast<microseconds>(stop - start);
				cout << "Clipping Session For Y End" << endl;
				cout << "Time taken by function: "
					<< duration.count() / 1000000 << " seconds" << endl;
				pixelDataFile << "Clipping Session For Y End" << endl;
				pixelDataFile << "Time taken by function: "
					<< duration.count() / 1000000 << " seconds" << endl;



				vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
				pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

			}


			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
			cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
			pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



			cout << "Applying a Descriptor to A Pixel Vector" << endl;
			pixelDataFile << "Applying a Descriptor to A Pixel Vector" << endl;

			hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithThresoldConstant(hInstance,
				hWnd,
				pRedValueOne,
				pGreenValueOne,
				pBlueValueOne,
				pRedValueTwo,
				pGreenValueTwo,
				pBlueValueTwo,
				pColorDeltaValue,
				pClassOneLabel,
				pClassTwoLabel,
				pClassThreeLabel,
				pixelObjectVectorX,
				&pDescriptorArray);



			cout << "Applying a Descriptor to A Pixel Vector" << endl;
			pixelDataFile << "Applying a Descriptor to A Pixel Vector" << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
				hWnd, pClassOneLabel, pDescriptorArray,
				&pDifferentPixelObject);


			for (PixelObject pixelObject : pDifferentPixelObject)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}


			}

		}
		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pDifferentPixelObject, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

		pixelDataFile.close();
		return hr;

	}







	HRESULT DirectXGPUDigitalLabCoreModule::DetectCircularClipWithinImages(HINSTANCE hInstance, HWND hWnd)
	{
		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectCirclesInRGBImages.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;
		vector<float> pXValuesArray = vector<float>();
		vector<float> pYValuesArray = vector<float>();


		vector<PixelObject> pixelObjectVector = vector<PixelObject>();
		vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;


		float pMinimumX = 0.0f;
		float pMinimumY = 0.0f;
		float pMaximumX = 0.0f;
		float pMaximumY = 0.0f;
		float pRedValueToSelect = 0.0f;
		float pGreenValueToSelect = 0.0f;
		float pBlueValueToSelect = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;
		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;
		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;
		cout << "Enter the Red Component To Select" << endl;
		cin >> pRedValueToSelect;
		cout << "Enter the Green Component to Select" << endl;
		cin >> pGreenValueToSelect;
		cout << "Enter the BLue Component to Select" << endl;
		cin >> pBlueValueToSelect;
		cout << "Enter the step for the X Clip " << endl;
		cin >> pStepX;
		cout << "Enter the step for the Y Clip " << endl;
		cin >> pStepY;




		float pThresholdIntensityMinimum = 0;
		float pThresholdIntensityMaximum = 0;




		float pCentreX = 0.0f;
		float pCentreY = 0.0f;
		float pRadiusValue = 0.0f;

		cout << "Enter The X Position for Circle Centre" << endl;
		cin >> pCentreX;

		cout << "Enter the Y Position for Circle Centre" << endl;
		cin >> pCentreY;

		cout << "Enter the Length of the Radius" << endl;
		cin >> pRadiusValue;



		fstream imageSegmentationDataFile;
		imageSegmentationDataFile.open("C:\\pixels\\DetectSpatialObjectFourthExperimentRGBFilterFullScaleGPUDynamic.txt", fstream::in | fstream::out | fstream::trunc);
		imageSegmentationDataFile.clear();

		fstream imageSectorsData;
		imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
		imageSectorsData.clear();



		int pValidClassifierToken = 1;
		int pInvalidClassifierToken = 0;

		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
		vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

		float pSectionOneXMin = 180.0f;
		float pSectionOneXMax = 680.0f;
		float pSectionOneY = 200.0f;






		vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
		vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();


		float pYSortingConstant0 = pStepY;
		float pYSortingConstant1 = pStepY * 2;
		float pYSortingConstant2 = pStepY * 3;

		float pXSortingConstant0 = pStepX;
		float pXSortingConstant1 = pStepX * 2;
		float pXSortingConstant2 = pStepX * 3;







		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;








			LPWSTR path = nullptr;
			OPENFILENAMEW ofn;
			ZeroMemory(&ofn, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = hWnd;
			ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
			ofn.lpstrFile = path;
			ofn.nMaxFile = MAX_PATH;
			ofn.Flags = OFN_FILEMUSTEXIST;
			ofn.hInstance = hInstance;
			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);
			cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
				clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
				clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
				clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
				clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			std::chrono::system_clock::time_point start;
			std::chrono::system_clock::time_point stop;
			std::chrono::system_clock::duration duration;

			if (GetOpenFileNameW(&ofn))
			{
				Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
				hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
				hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
				cout << "New Image Clip" << endl;
				// Get starting timepoint
				start = high_resolution_clock::now();
				// Call the function, here sort()
				vector<float> pXValuesArray = vector<float>();
				vector<float> pYValuesArray = vector<float>();

				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);
				cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
					clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
					clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
					clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
					clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


				// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
				hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
					hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
				cout << "Printing the Contents of Clipped Area" << endl;
				imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
				int pIndex = 0;
				for (PixelObject pixelObject : pixelObjectVectorOne)
				{

					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{

						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}
				}

				cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
					clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
					clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
					clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
					clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

				cout << "Verifying Container for Identical Elements" << endl;



				stop = high_resolution_clock::now();
				// Get duration. Substart timepoints to
				// get durarion. To cast it to proper unit
				// use duration cast method
				duration = duration_cast<microseconds>(stop - start);
				cout << "Time taken by Clip One: "
					<< duration.count() << " microseconds" << endl;
				cout << "Time taken by Clip One: "
					<< duration.count() / 10000000 << " seconds" << endl;
				cout << "Performing the Second scan of the image" << endl;
				auto start = high_resolution_clock::now();
				GetSystemTime(&clippingTimeStartSystem);
				GetLocalTime(&clippingTimeStartLocal);
				cout << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
					clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
				cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
					clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << "Clipping Started System Time\n" << clippingTimeStartSystem.wHour << ":" <<
					clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
					clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

				hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
					hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
				cout << "Printing the Contents of Clipped Area" << endl;
				imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

				pIndex = 0;
				for (PixelObject pixelObject : pixelObjectVectorTwo)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{

						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}

				}
				float pCentreX = 0.0f;
				float pCentreY = 0.0f;
				float pYDelta = 0.0f;

				vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();


				imageSegmentationDataFile << "Your Centre Point Is: " << endl;
				imageSegmentationDataFile << "X Position: " << pCentreX << endl;
				imageSegmentationDataFile << "Y Position: " << pCentreY << endl;





				auto stop = high_resolution_clock::now();
				// Get duration. Substart timepoints to
				// get durarion. To cast it to proper unit
				// use duration cast method
				auto duration = duration_cast<microseconds>(stop - start);
				cout << "Time taken by Clip Two: "
					<< duration.count() / 1000000 << "seconds" << endl;
				cout << "Time taken by Clip Two: "
					<< duration.count() / 1000000 << " seconds" << endl;
				cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
					clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
					clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
					clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
					clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				cout << "RGB Section End" << endl;
				imageSegmentationDataFile << "RGB Section End" << endl;
				GetSystemTime(&filterTimeStartSystem);
				GetLocalTime(&filterTimeStartLocal);
				cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

				vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
				pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());
			}



			cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
				clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
				clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
				clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
				clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			cout << "RGB Section End" << endl;
			cout << "RGB Section End" << endl;
			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);
			cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			start = high_resolution_clock::now();

			hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
				hWnd,
				pTopLeftX,
				pTopLeftY,
				pImageWidth,
				pImageHeight,
				pRedValueToSelect,
				pRedValueToSelect,
				pGreenValueToSelect,
				pGreenValueToSelect,
				pBlueValueToSelect,
				pBlueValueToSelect,
				pixelObjectVectorOne,
				&pFilteredObjectArrayRGBOne);

			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);
			cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
					endl;
				imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
					pLastError << endl;
				imageSegmentationDataFile.close();
				return hr;
			}
			stop = high_resolution_clock::now();
			// Get duration. Substart timepoints to
			// get durarion. To cast it to proper unit
			// use duration cast method
			duration = duration_cast<microseconds>(stop - start);
			cout << "Time taken by RGB Filter: "
				<< duration.count() / 1000000 << "seconds" << endl;
			cout << "Time taken by RGB Filter: "
				<< duration.count() / 1000000 << " seconds" << endl;
			cout << " " << endl;
			cout << " " << endl;
			cout << "New Operation Begin" << endl;
			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			cout << "Printing Output" << endl;
			UINT pIndexValue = 0;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			start = high_resolution_clock::now();

			SYSTEMTIME restorationStartSystem;
			SYSTEMTIME restorationStartLocal;

			GetSystemTime(&restorationStartSystem);
			GetLocalTime(&restorationStartLocal);
			cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
				restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
			cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
				restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
			imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
				restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
			imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
				restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pFilteredObjectArrayRGBOne,
				&pFilteredObjectArrayRGBOneRestored);
			cout << "Printing the Results of the Valid Pixels" << endl;


			SYSTEMTIME restorationEndSystem;
			SYSTEMTIME restorationEndLocal;

			GetSystemTime(&restorationEndSystem);
			GetLocalTime(&restorationEndLocal);
			cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
				restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
			cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
				restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
			imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
				restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
			imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
				restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



			for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
					imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
					imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
					imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
					imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}
				pXValuesArray.push_back(pixelObject.xPosition);
				pYValuesArray.push_back(pixelObject.yPosition);
			}



			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
			cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
			pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			int pPointLiesInsideTheCircle = 1;
			int pPointLiesOnTheCircle = 2;
			int pPointLiesOutsideOfTheCircle = 3;
			float pi_var = 0.0f;
			pi_var = DirectX::XM_PI;
			vector<OutputPixelObjectCircularData> pCircularDataArray = vector<OutputPixelObjectCircularData>();

			hr = ppStandardAlgorithmExecutor->LocalizePixelsUsingCircleEquatuion(hInstance, hWnd,
				pCentreX,
				pCentreY,
				pi_var,
				pRadiusValue,
				pPointLiesOnTheCircle,
				pPointLiesInsideTheCircle,
				pPointLiesOutsideOfTheCircle,
				pixelObjectVector, &pCircularDataArray);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			pIndexValue = 0;

			vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();





			cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
			pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output" << endl;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd,
				pOutputFilterResult, &pFilterToReverseOutput);

			cout << "Printing the Results of the Output" << endl;
			for (PixelObject pixelObject : pFilterToReverseOutput)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;







				GetSystemTime(&filterTimeEndSystem);
				GetLocalTime(&filterTimeEndLocal);

				md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
				md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
				md2dmanager->CreateDeviceResources(hInstance, hWnd);
				md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

				float pCircleDiameter = 0.0f;
				float pCircleLength = 0.0f;
				float pCircleArea = 0.0f;
				float pi_var = DirectX::XM_PI;

				pCircleDiameter = 2 * pRadiusValue;
				pCircleLength = 2 * pi_var * pRadiusValue;
				pCircleArea = pi_var * pow(pRadiusValue, 2.0f);

				cout << "Circle Diameter = " << pCircleDiameter << endl;
				cout << "Circle Length =  " << pCircleLength << endl;
				cout << "Circle Area = " << pCircleArea << endl;

				pixelDataFile << "Circle Diameter = " << pCircleDiameter << endl;
				pixelDataFile << "Circle Length =  " << pCircleLength << endl;
				pixelDataFile << "Circle Area = " << pCircleArea << endl;



				cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
				pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
				pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;

			}
		}
		pixelDataFile.close();
		return hr;
	}


	




HRESULT DirectXGPUDigitalLabCoreModule::DetectStraightLineWithinImagesForYPosition(HINSTANCE hInstance, HWND hWnd)
{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseYPosition.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorForY = vector<PixelObject>();
		vector<PixelObject> pPixelArrayForAnalysis = vector<PixelObject>();

		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResult = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultBelowTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultOnTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultAboveTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();

		vector<PixelObject> pPixelsLyingBelowTheLine = vector<PixelObject>();
		vector<PixelObject> pPixelsLyingOnTheLine = vector<PixelObject>();
		vector<PixelObject> pPixelsLyingAboveTheLine = vector<PixelObject>();


		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;

		float pYCoefficient = 0.0f;
		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;

		int pAboveTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pBelowTheLineLabel = -1;
	
		cout << "Enter The Y Value Of Straight LINE" << endl;
		cin >> pYCoefficient;

		cout << "Enter the Red Value to Select" << endl;
		cin >> pRedValueParam;

		cout << "Enter the Green Value to Select" << endl;
		cin >> pGreenValueParam;

		cout << "Enter the Blue Value to Select" << endl;
		cin >> pBlueValueParam;


		

		cout << "X Position: " << pTopLeftX << endl;
		cout << "Y Position: " << pTopLeftY << endl;
		cout << "Image Width: " << pImageWidth << endl;
		cout << "Image Height: " << pImageHeight << endl;



		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorForX);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorForX)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}



		

			pPixelArrayForAnalysis.insert(pPixelArrayForAnalysis.end(), pixelObjectVectorForX.begin(), pixelObjectVectorForX.end());
	

			
			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		

			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			int pOnTheLineLabel = 1;
			int pAboveTheLineLabel = 0;
			int pBelowTheLineLabel = -1;

			
			hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstYPosition(hInstance,
				hWnd,
				pYCoefficient,
				pOnTheLineLabel,
				pAboveTheLineLabel,
				pBelowTheLineLabel,
				pRedValueParam,
				pGreenValueParam,
				pBlueValueParam,
				pixelObjectVectorForX, &pOutputFilterResult);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;

			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pOutputFilterResult)
			{



				int pPixelNumber = pPixelObject.pixelNumber;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				float pLinearFunctionValue = pPixelObject.pLinearFunctionValue;
				float pClassOfPixelValue = pPixelObject.pClassOfPixelValue;
				bool pIsValidMarker = pPixelObject.pIsPixelObjectValid;

				if ((pClassOfPixelValue == pOnTheLineLabel) || (pClassOfPixelValue == pBelowTheLineLabel))
				{
					pAmountOfFilteredPixels++;
				}


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Linear Function Value = " << pLinearFunctionValue << endl;
				cout << "Class of Pixel Value = " << pClassOfPixelValue << endl;
				cout << "Is Point Valid = " << pIsValidMarker << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Linear Function Value = " << pLinearFunctionValue << endl;
				pixelDataFile << "Class of Pixel Value = " << pClassOfPixelValue << endl;
				pixelDataFile << "Is Point Valid = " << pIsValidMarker << endl;



				pIndexValue++;
			}



		}
		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineYPosition(hInstance, hWnd,
			pYCoefficient,
			pRedValueParam,
			pGreenValueParam,
			pBlueValueParam,
			pOnTheLineLabel,
			pBelowTheLineLabel,
			pAboveTheLineLabel,
			pOutputFilterResult,
			&pPixelsLyingOnTheLine);

		UINT pIndex = 0;
		for (PixelObject pixelObject : pPixelsLyingOnTheLine)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pPixelsLyingOnTheLine, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		pixelDataFile.close();
		return hr;
	}



	HRESULT DirectXGPUDigitalLabCoreModule::DetectStraightLineWithinImagesForXPosition(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseXPosition.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorForY = vector<PixelObject>();
		vector<PixelObject> pPixelArrayForAnalysis = vector<PixelObject>();
		vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();

		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResult = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultLeftOfTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultOnTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultRightOfTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();

		vector<PixelObject> pPixelsLyingBelowTheLine = vector<PixelObject>();
		vector<PixelObject> pPixelsLyingOnTheLine = vector<PixelObject>();
		vector<PixelObject> pPixelsLyingAboveTheLine = vector<PixelObject>();


		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;

		cout << "Enter the Value for step for X" << endl;
		cin >> pStepX;

		cout << "Enter the Value for step for Y" << endl;
		cin >> pStepY;


		float pXCoefficient = 0.0f;
		int pLeftOfTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pRightOfTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;

		cout << "Enter The X Value for the Vertical Straight LINE" << endl;
		cin >> pXCoefficient;

		cout << "Enter the Red Value to Select" << endl;
		cin >> pRedValueParam;

		cout << "Enter the Green Value to Select" << endl;
		cin >> pGreenValueParam;

		cout << "Enter the Blue Value to Select" << endl;
		cin >> pBlueValueParam;


	

		cout << "X Position: " << pTopLeftX << endl;
		cout << "Y Position: " << pTopLeftY << endl;
		cout << "Image Width: " << pImageWidth << endl;
		cout << "Image Height: " << pImageHeight << endl;

		cout << "Linear Function Takes a form of x = xCoefficient" << endl;
		cout << "X Coefficient = " << pXCoefficient << endl;
		

		pixelDataFile << "X Position: " << pTopLeftX << endl;
		pixelDataFile << "Y Position: " << pTopLeftY << endl;
		pixelDataFile << "Image Width: " << pImageWidth << endl;
		pixelDataFile << "Image Height: " << pImageHeight << endl;

		pixelDataFile << "Linear Function Takes a form of x = xCoefficient" << endl;
		pixelDataFile << "X Coefficient = " << pXCoefficient << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;

			// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorOne);
			cout << "Printing the Contents of Clipped Area" << endl;
			pixelDataFile << "Clipping Image for X Axis" << endl;
			int pIndex = 0;
			for (PixelObject pixelObject : pixelObjectVectorOne)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{

					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}
			}

			cout << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
				clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
				clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "Clipping END System Time\n" << clippingTimeStartSystem.wHour << ":" <<
				clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " Clipping END System Local\n" << clippingTimeStartLocal.wHour << ":" <<
				clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			cout << "Verifying Container for Identical Elements" << endl;



			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
			cout << "Printing the Contents of Clipped Area" << endl;
			pixelDataFile << "Clipping Image for Y Axis" << endl;

			pIndex = 0;
			for (PixelObject pixelObject : pixelObjectVectorTwo)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{

					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}

			}
			float pCentreX = 0.0f;
			float pCentreY = 0.0f;
			float pYDelta = 0.0f;

			vector<PixelObject> pCommonPixelObjectArrayOneRGB = vector<PixelObject>();


			pixelDataFile << "Your Centre Point Is: " << endl;
			pixelDataFile << "X Position: " << pCentreX << endl;
			pixelDataFile << "Y Position: " << pCentreY << endl;





		
			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;
			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);
			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
			pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());








			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();


			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



			vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
			vector<PixelObject> pFilteredObjectArrayRGBRestored = vector<PixelObject>();

			hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
				hWnd,
				pTopLeftX,
				pTopLeftY,
				pImageWidth,
				pImageHeight,
				pRedValueParam,
				pRedValueParam,
				pGreenValueParam,
				pGreenValueParam,
				pBlueValueParam,
				pBlueValueParam,
				pixelObjectVectorOne,
				&pFilteredObjectArrayRGBOne);

			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);
			cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
				filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
				filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			pixelDataFile << "Filtering Images Against Color Thresold" << endl;

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
					endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
					pLastError << endl;
				pixelDataFile.close();
				return hr;
			}
			
			cout << " " << endl;
			cout << " " << endl;
			cout << "New Operation Begin" << endl;
			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			cout << "Printing Output" << endl;
			UINT pIndexValue = 0;


			vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
			pixelDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
		
			SYSTEMTIME restorationStartSystem;
			SYSTEMTIME restorationStartLocal;

			GetSystemTime(&restorationStartSystem);
			GetLocalTime(&restorationStartLocal);
			cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
				restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
			cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
				restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
			pixelDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
				restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
			pixelDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
				restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
				hWnd,
				pFilteredObjectArrayRGBOne,
				&pFilteredObjectArrayRGBOneRestored);
			cout << "Printing the Results of the Valid Pixels" << endl;


			SYSTEMTIME restorationEndSystem;
			SYSTEMTIME restorationEndLocal;

			GetSystemTime(&restorationEndSystem);
			GetLocalTime(&restorationEndLocal);
			cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
				restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
			cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
				restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
			pixelDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
				restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
			pixelDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
				restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



			for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}
				
			}




			hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstXPosition(hInstance,
				hWnd, pXCoefficient,
				pRedValueParam,
				pGreenValueParam, 
				pBlueValueParam,
				pOnTheLineLabel,
				pLeftOfTheLineLabel, pRightOfTheLineLabel,
				pFilteredObjectArrayRGBOneRestored,
				&pOutputFilterResult);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			pIndexValue = 0;

			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pOutputFilterResult)
			{



				int pPixelNumber = pPixelObject.pixelNumber;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				float pLinearFunctionValue = pPixelObject.pLinearFunctionValue;
				float pClassOfPixelValue = pPixelObject.pClassOfPixelValue;
				bool pIsPixelValid = pPixelObject.pIsPixelObjectValid;

			


				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Linear Function Value = " << pLinearFunctionValue << endl;
				cout << "Class of Pixel Value = " << pClassOfPixelValue << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Linear Function Value = " << pLinearFunctionValue << endl;
				pixelDataFile << "Class of Pixel Value = " << pClassOfPixelValue << endl;

				if (pLinearFunctionValue == pXCoefficient)
				{
					cout << "Point Lies On The Defined Line" << endl;
					pixelDataFile << "Point Lies On The Defined Line" << endl;

					pOutputFilterResultOnTheLine.push_back(pPixelObject);

				}

				else if (pLinearFunctionValue < pXCoefficient)
				{
					cout << "Point Lies to the Left of the Line" << endl;
					pixelDataFile << "Point Lies to the Left of the Line" << endl;
					pOutputFilterResultLeftOfTheLine.push_back(pPixelObject);
				}
				else if (pLinearFunctionValue > pXCoefficient)
				{
					cout << "Point Lies to htr Right The Defined Line" << endl;
					pixelDataFile << "Point Lies to the Right defines Line" << endl;
					pOutputFilterResultRightOfTheLine.push_back(pPixelObject);

				}

				pIndexValue++;
			}



		}
		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance, hWnd,
			pXCoefficient,
			pRedValueParam,
			pGreenValueParam,
			pBlueValueParam,
			pOnTheLineLabel,
			pLeftOfTheLineLabel,
			pRightOfTheLineLabel,
			pOutputFilterResult,
			&pPixelsLyingOnTheLine);

		UINT pIndex = 0;
		for (PixelObject pixelObject : pPixelsLyingOnTheLine)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pPixelsLyingOnTheLine, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		pixelDataFile.close();
		return hr;
	}



	HRESULT DirectXGPUDigitalLabCoreModule::DetectStraightLineWithinImagesForXPositionConstant(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseXPosition.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorForY = vector<PixelObject>();
		vector<PixelObject> pPixelArrayForAnalysis = vector<PixelObject>();

		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResult = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultLeftOfTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultOnTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pOutputFilterResultRightOfTheLine = vector<OutputPixelObjectCorrespondenceLinearFunction>();

		vector<PixelObject> pPixelsLyingBelowTheLine = vector<PixelObject>();
		vector<PixelObject> pPixelsLyingOnTheLine = vector<PixelObject>();
		vector<PixelObject> pPixelsLyingAboveTheLine = vector<PixelObject>();


		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;



		float pXCoefficient = 0.0f;
		float pYCoefficient0 = 0.0f;
		float pYCoefficient1 = 0.0f;
		int pLeftOfTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pRightOfTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;

		cout << "Enter The X Value for the Vertical Straight LINE" << endl;
		cin >> pXCoefficient;

		cout << "Enter the Value for Y0" << endl;
		cin >> pYCoefficient0;

		cout << "Enter the Value for Y0" << endl;
		cin >> pYCoefficient1;

		float pMiddleY = 0.0f;



		cout << "Enter the Red Value to Select" << endl;
		cin >> pRedValueParam;

		cout << "Enter the Green Value to Select" << endl;
		cin >> pGreenValueParam;

		cout << "Enter the Blue Value to Select" << endl;
		cin >> pBlueValueParam;




		cout << "X Position: " << pTopLeftX << endl;
		cout << "Y Position: " << pTopLeftY << endl;
		cout << "Image Width: " << pImageWidth << endl;
		cout << "Image Height: " << pImageHeight << endl;

		cout << "Linear Function Takes a form of x = xCoefficient" << endl;
		cout << "X Coefficient = " << pXCoefficient << endl;


		pixelDataFile << "X Position: " << pTopLeftX << endl;
		pixelDataFile << "Y Position: " << pTopLeftY << endl;
		pixelDataFile << "Image Width: " << pImageWidth << endl;
		pixelDataFile << "Image Height: " << pImageHeight << endl;

		pixelDataFile << "Linear Function Takes a form of x = xCoefficient" << endl;
		pixelDataFile << "X Coefficient = " << pXCoefficient << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorForX);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorForX)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}





			pPixelArrayForAnalysis.insert(pPixelArrayForAnalysis.end(), pixelObjectVectorForX.begin(), pixelObjectVectorForX.end());



			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();


			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




			hr = ppStandardAlgorithmExecutor->DetectAStraigntLineAgainstXPosition(hInstance,
				hWnd, pXCoefficient,
				pRedValueParam,
				pGreenValueParam,
				pBlueValueParam,
				pOnTheLineLabel,
				pLeftOfTheLineLabel, pRightOfTheLineLabel,
				pixelObjectVectorForX,
				&pOutputFilterResult);

			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;

			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pOutputFilterResult)
			{



				int pPixelNumber = pPixelObject.pixelNumber;
				float pXValue = pPixelObject.xPosition;
				float pYValue = pPixelObject.yPosition;
				float pRedComponent = pPixelObject.rValue;
				float pGreenComponent = pPixelObject.gValue;
				float pBlueComponent = pPixelObject.bValue;
				float pLinearFunctionValue = pPixelObject.pLinearFunctionValue;
				float pClassOfPixelValue = pPixelObject.pClassOfPixelValue;
				bool pIsPixelValid = pPixelObject.pIsPixelObjectValid;




				cout << "Pixel Number: " << pPixelNumber << endl;
				cout << "X Value = " << pXValue << endl;
				cout << "Y Value = " << pYValue << endl;
				cout << "Red Component = " << pRedComponent << endl;
				cout << "Green Component = " << pGreenComponent << endl;
				cout << "Blue Component = " << pBlueComponent << endl;
				cout << "Linear Function Value = " << pLinearFunctionValue << endl;
				cout << "Class of Pixel Value = " << pClassOfPixelValue << endl;

				pixelDataFile << "Step: " << pPixelNumber << endl;
				pixelDataFile << "X Value = " << pXValue << endl;
				pixelDataFile << "Y Value = " << pYValue << endl;
				pixelDataFile << "Red Component = " << pRedComponent << endl;
				pixelDataFile << "Green Component = " << pGreenComponent << endl;
				pixelDataFile << "Blue Component = " << pBlueComponent << endl;
				pixelDataFile << "Linear Function Value = " << pLinearFunctionValue << endl;
				pixelDataFile << "Class of Pixel Value = " << pClassOfPixelValue << endl;

				if (pLinearFunctionValue == pXCoefficient)
				{
					cout << "Point Lies On The Defined Line" << endl;
					pixelDataFile << "Point Lies On The Defined Line" << endl;

					pOutputFilterResultOnTheLine.push_back(pPixelObject);

				}

				else if (pLinearFunctionValue < pXCoefficient)
				{
					cout << "Point Lies to the Left of the Line" << endl;
					pixelDataFile << "Point Lies to the Left of the Line" << endl;
					pOutputFilterResultLeftOfTheLine.push_back(pPixelObject);
				}
				else if (pLinearFunctionValue > pXCoefficient)
				{
					cout << "Point Lies to htr Right The Defined Line" << endl;
					pixelDataFile << "Point Lies to the Right defines Line" << endl;
					pOutputFilterResultRightOfTheLine.push_back(pPixelObject);

				}

				pIndexValue++;
			}



		}
		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLineXPosition(hInstance, hWnd,
			pXCoefficient,
			pRedValueParam,
			pGreenValueParam,
			pBlueValueParam,
			pOnTheLineLabel,
			pLeftOfTheLineLabel,
			pRightOfTheLineLabel,
			pOutputFilterResult,
			&pPixelsLyingOnTheLine);

		UINT pIndex = 0;
		for (PixelObject pixelObject : pPixelsLyingOnTheLine)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pPixelsLyingOnTheLine, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		pixelDataFile.close();
		return hr;
	}






	HRESULT DirectXGPUDigitalLabCoreModule::DetectPixelOrientationAgainstAPoint(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream imageSegmentationDataFile;
		imageSegmentationDataFile.open("C:\\pixels\\ComputePixelOrientationAgainstAPoint.txt", fstream::in | fstream::out | fstream::trunc);
		imageSegmentationDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
		vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
		vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
		vector<OutputPixelObjectCorrespondenceLinearCluster> pOutputFilterResult = vector<OutputPixelObjectCorrespondenceLinearCluster>();

		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;



		float pXCoefficient = 0.0f;
		float pYCoefficient = 0.0f;
		int pLeftOfTheLineLabel = -1;
		int pOnTheLineLabelX = 1;
		int pRightOfTheLineLabel = 0;
		int pAboveTheLineLabel = 0;
		int pOnTheLineLabelY = 1;
		int pBelowTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;
		float pDistanceThresold = 0.0f;
		float pAngleThresold = 0.0f;



		float pMinimumX = 0.0f;
		float pMinimumY = 0.0f;
		float pMaximumX = 0.0f;
		float pMaximumY = 0.0f;
		float pRedValueToSelect = 0.0f;
		float pGreenValueToSelect = 0.0f;
		float pBlueValueToSelect = 0.0f;
		
		cout << "Enter the Red Component To Select" << endl;
		cin >> pRedValueToSelect;
		cout << "Enter the Green Component to Select" << endl;
		cin >> pGreenValueToSelect;
		cout << "Enter the BLue Component to Select" << endl;
		cin >> pBlueValueToSelect;
		cout << "Enter the step for the X Clip " << endl;
		cin >> pStepX;
		cout << "Enter the step for the Y Clip " << endl;
		cin >> pStepY;



		cout << "Enter The X Value for the Centre" << endl;
		cin >> pXCoefficient;


		cout << "Enter The Y Value for the Centre" << endl;
		cin >> pYCoefficient;



		int pOnTheLineXParam = 0.0f;
		int pOnTheLineYParam = 0.0f;
		int pBelowTheLineXParam = 0.0f;
		int pBelowTheLineYParam = 0.0f;
		int pAboveTheTheLineXParam = 0.0f;
		int pAboveTheTheLineYParam = 0.0f;
		int pSectorOneLabel = 0.0f;
		int pSectorTwoLabel = 0.0f;
		int pSectorThreeLabel = 0.0f;
		int pSectorFourLabvel = 0.0f;
		int pAxisLabel = 0.0f;

		cout << "Enter the Value for the Label for On The Line X Param" << endl;
		cin >> pOnTheLineXParam;


		cout << "Enter the Value for the Label for On The Line Y Param" << endl;
		cin >> pOnTheLineYParam;

		cout << "Enter the Value for the Label for Below The Line X Param" << endl;
		cin >> pBelowTheLineXParam;


		cout << "Enter the Value for the Label for Below The Line Y Param" << endl;
		cin >> pBelowTheLineYParam;


		cout << "Enter the Value for the Label for Above The Line X Param" << endl;
		cin >> pAboveTheTheLineXParam;


		cout << "Enter the Value for the Label for Below The Line Y Param" << endl;
		cin >> pAboveTheTheLineYParam;


		int pQuarterOneValue = 1;
		int pQuarterTwoValue = 2;
		int pQuarterThreeValue = 3;
		int pQuarterFourValue = 4;


		cout << "Your Selected Point has the following Coordinates: " << endl;
		cout << "X = " << pXCoefficient << endl;
		cout << "Y = " << pYCoefficient << endl;


		imageSegmentationDataFile <<  "Your Selected Point has the following Coordinates: " << endl;
		imageSegmentationDataFile << "X = " << pXCoefficient << endl;
		imageSegmentationDataFile << "Y = " << pYCoefficient << endl;



		cout << "Printing RGB Clip Object" << endl;
		imageSegmentationDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{





			float pYSortingConstant0 = pStepY;
			float pYSortingConstant1 = pStepY * 2;
			float pYSortingConstant2 = pStepY * 3;

			float pXSortingConstant0 = pStepX;
			float pXSortingConstant1 = pStepX * 2;
			float pXSortingConstant2 = pStepX * 3;





			LPWSTR path = nullptr;
			OPENFILENAMEW ofn;
			ZeroMemory(&ofn, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = hWnd;
			ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
			ofn.lpstrFile = path;
			ofn.nMaxFile = MAX_PATH;
			ofn.Flags = OFN_FILEMUSTEXIST;
			ofn.hInstance = hInstance;
			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);
			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
				clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
				clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
				clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
				clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			std::chrono::system_clock::time_point start;
			std::chrono::system_clock::time_point stop;
			std::chrono::system_clock::duration duration;
			if (GetOpenFileNameW(&ofn))
			{
				Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
				hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
				hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
				cout << "New Image Clip" << endl;
				// Get starting timepoint
				start = high_resolution_clock::now();
				// Call the function, here sort()
				// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
				hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
					hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
				cout << "Printing the Contents of Clipped Area" << endl;
				imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
				int pIndex = 0;
				for (PixelObject pixelObject : pixelObjectVectorOne)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{

						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}
				}

				cout << "Verifying Container for Identical Elements" << endl;



				stop = high_resolution_clock::now();
				// Get duration. Substart timepoints to
				// get durarion. To cast it to proper unit
				// use duration cast method
				duration = duration_cast<microseconds>(stop - start);
				cout << "Time taken by Clip One: "
					<< duration.count() << " microseconds" << endl;
				cout << "Time taken by Clip One: "
					<< duration.count() / 10000000 << " seconds" << endl;
				cout << "Performing the Second scan of the image" << endl;
				auto start = high_resolution_clock::now();
				hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
					hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
				cout << "Printing the Contents of Clipped Area" << endl;
				imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

				pIndex = 0;
				for (PixelObject pixelObject : pixelObjectVectorTwo)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Index: " << pIndex << endl;
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Index: " << pIndex << endl;
						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}
				}

				auto stop = high_resolution_clock::now();
				// Get duration. Substart timepoints to
				// get durarion. To cast it to proper unit
				// use duration cast method
				auto duration = duration_cast<microseconds>(stop - start);
				cout << "Time taken by Clip Two: "
					<< duration.count() / 1000000 << "seconds" << endl;
				cout << "Time taken by Clip Two: "
					<< duration.count() / 1000000 << " seconds" << endl;
				cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
					clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
					clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
					clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
					clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				cout << "RGB Section End" << endl;
				imageSegmentationDataFile << "RGB Section End" << endl;
				GetSystemTime(&filterTimeStartSystem);
				GetLocalTime(&filterTimeStartLocal);
				cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

				vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
				pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());




				cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
					clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
					clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" <<
					clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" <<
					clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
				cout << "RGB Section End" << endl;
				cout << "RGB Section End" << endl;
				GetSystemTime(&filterTimeStartSystem);
				GetLocalTime(&filterTimeStartLocal);
				cout << "Filter Stared: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
				cout << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << "Filter Started: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << " Filter Started: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				start = high_resolution_clock::now();

				hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance,
					hWnd,
					pTopLeftX,
					pTopLeftY,
					pImageWidth,
					pImageHeight,
					pRedValueToSelect,
					pRedValueToSelect,
					pGreenValueToSelect,
					pGreenValueToSelect,
					pBlueValueToSelect,
					pBlueValueToSelect,
					pixelObjectVectorOne,
					&pFilteredObjectArrayRGBOne);

				GetSystemTime(&filterTimeEndSystem);
				GetLocalTime(&filterTimeEndLocal);
				cout << "Filter Ended: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
				cout << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << "Filter Ended: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" <<
					filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
				imageSegmentationDataFile << " Filter Ended: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" <<
					filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

				imageSegmentationDataFile << "Filtering Images Against Color Thresold" << endl;

				if (FAILED(hr))
				{
					int pLastError = GetLastError();
					cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError <<
						endl;
					imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " <<
						pLastError << endl;
					imageSegmentationDataFile.close();
					return hr;
				}
				stop = high_resolution_clock::now();
				// Get duration. Substart timepoints to
				// get durarion. To cast it to proper unit
				// use duration cast method
				duration = duration_cast<microseconds>(stop - start);
				cout << "Time taken by RGB Filter: "
					<< duration.count() / 1000000 << "seconds" << endl;
				cout << "Time taken by RGB Filter: "
					<< duration.count() / 1000000 << " seconds" << endl;
				cout << " " << endl;
				cout << " " << endl;
				cout << "New Operation Begin" << endl;
				UINT pOperationNumber = 0;
				cout << "Printing Output" << endl;
				cout << "Printing Output" << endl;
				UINT pIndexValue = 0;


				vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
				cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
				imageSegmentationDataFile << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
				start = high_resolution_clock::now();

				SYSTEMTIME restorationStartSystem;
				SYSTEMTIME restorationStartLocal;

				GetSystemTime(&restorationStartSystem);
				GetLocalTime(&restorationStartLocal);
				cout << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
					restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
				cout << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
					restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;
				imageSegmentationDataFile << "Restoration STARTED: %02d:%02d\n" << restorationStartSystem.wHour << ":" <<
					restorationStartSystem.wMinute << ":" << restorationStartSystem.wSecond << endl;
				imageSegmentationDataFile << "Restoration Stated: %02d:%02d\n" << restorationStartLocal.wHour << ":" <<
					restorationStartLocal.wMinute << ":" << restorationStartLocal.wSecond << endl;


				hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance,
					hWnd,
					pFilteredObjectArrayRGBOne,
					&pFilteredObjectArrayRGBOneRestored);
				cout << "Printing the Results of the Valid Pixels" << endl;


				SYSTEMTIME restorationEndSystem;
				SYSTEMTIME restorationEndLocal;

				GetSystemTime(&restorationEndSystem);
				GetLocalTime(&restorationEndLocal);
				cout << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
					restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
				cout << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
					restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;
				imageSegmentationDataFile << "Restoration EndED: %02d:%02d\n" << restorationEndSystem.wHour << ":" <<
					restorationEndSystem.wMinute << ":" << restorationEndSystem.wSecond << endl;
				imageSegmentationDataFile << "Restoration Ended: %02d:%02d\n" << restorationEndLocal.wHour << ":" <<
					restorationEndLocal.wMinute << ":" << restorationEndLocal.wSecond << endl;



				for (PixelObject pixelObject : pFilteredObjectArrayRGBOneRestored)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}
				}





				int pAxisLabel = 55;





				hr = ppStandardAlgorithmExecutor->DetectPixelOrientationAgainstAPoint(hInstance,
					hWnd, pXCoefficient,
					pYCoefficient,
					pOnTheLineXParam,
					pBelowTheLineXParam,
					pAboveTheTheLineXParam,
					pOnTheLineYParam,
					pBelowTheLineYParam,
					pAboveTheTheLineYParam,
					pQuarterOneValue, pQuarterTwoValue,
					pQuarterThreeValue, pQuarterFourValue,
					pAxisLabel,
					pFilteredObjectArrayRGBOneRestored,
					&pOutputFilterResult);

				if (FAILED(hr))
				{
					int pLastError = GetLastError();
					cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
					imageSegmentationDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
					imageSegmentationDataFile.close();
					return hr;

				}

				imageSegmentationDataFile << " " << endl;
				imageSegmentationDataFile << " " << endl;
				imageSegmentationDataFile << "New Operation Begin" << endl;

				 pOperationNumber = 0;
				cout << "Printing Output" << endl;
				imageSegmentationDataFile << "Printing Output" << endl;
				pIndexValue = 0;




				for (OutputPixelObjectCorrespondenceLinearCluster pPixelObject : pOutputFilterResult)
				{
					cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
					cout << "X Position: " << pPixelObject.xPosition << endl;
					cout << "Y Position: " << pPixelObject.yPosition << endl;
					cout << "Red Component " << pPixelObject.rValue << endl;
					cout << "Green Component: " << pPixelObject.gValue << endl;
					cout << "Blue Component: " << pPixelObject.bValue << endl;
					cout << "Polar X Value: " << pPixelObject.xCentrePosition  << endl;
					cout << "Polar Y Value: " << pPixelObject.yCentrePosition << endl;
					cout << "Distance to Point: " << pPixelObject.pDistanceToPoint << endl;
					cout << "Angle Tangent: " << pPixelObject.pAngleTangent << endl;
					cout << "Angle Cosine: " << pPixelObject.pAngleCosine << endl;
					cout << "Angle Sine: " << pPixelObject.pAngleSine << endl;
					cout << "Orientation Angle: " << pPixelObject.pAngleToPixelData << endl;
					cout << "Class Of Pixel X :" << pPixelObject.pClassOfPixelValueX << endl;
					cout << "Class Of Pixel Y : " << pPixelObject.pClassOfPixelValueY << endl;
					cout << "Quarter Value = " << pPixelObject.pQuarterValue << endl;

					imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
					imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
					imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
					imageSegmentationDataFile << "Red Component Difference: " << pPixelObject.rValue << endl;
					imageSegmentationDataFile << "Red Component Difference: " << pPixelObject.gValue << endl;
					imageSegmentationDataFile << "Red Component Difference: " << pPixelObject.bValue << endl;
					imageSegmentationDataFile << "Polar X Value: " << pPixelObject.xCentrePosition << endl;
					imageSegmentationDataFile << "Polar Y Value: " << pPixelObject.yCentrePosition << endl;
					imageSegmentationDataFile << "Distance to Point: " << pPixelObject.pDistanceToPoint << endl;
					imageSegmentationDataFile << "Angle Tangent: " << pPixelObject.pAngleTangent << endl;
					imageSegmentationDataFile << "Angle Cosine: " << pPixelObject.pAngleCosine << endl;
					imageSegmentationDataFile << "Angle Sine: " << pPixelObject.pAngleSine << endl;
					imageSegmentationDataFile << "Orientation Angle: " << pPixelObject.pAngleToPixelData << endl;
					imageSegmentationDataFile << "Class Of Pixel X :" << pPixelObject.pClassOfPixelValueX << endl;
					imageSegmentationDataFile << "Class Of Pixel Y : " << pPixelObject.pClassOfPixelValueY << endl;
					imageSegmentationDataFile << "Quarter Value = " << pPixelObject.pQuarterValue << endl;



				}





			}


			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);

			md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			md2dmanager->CreateDeviceResources(hInstance, hWnd);

			cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


			imageSegmentationDataFile.close();
		}
		return hr;
	}




	HRESULT DirectXGPUDigitalLabCoreModule::DetectStraightLineWithinImagesUsingPoints(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseAgainstALinearFunction.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pFilteredOutputArray = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<PixelObject> pRecoveredPixelArray = vector<PixelObject>();



		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;



		float pXPosition0 = 0.0f;
		float pYPosition0 = 0.0f;
		float pXPosition1 = 0.0f;
		float pYPosition1 = 0.0f;
		int pLeftOfTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pRightOfTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;


		cout << "Enter the Value of X for Point A of Line AB" << endl;
		cin >> pXPosition0;

		cout << "Enter the Value of Y for Point A of Line AB" << endl;
		cin >> pYPosition0;

		cout << "Enter the Value of X for Point B of Line AB" << endl;
		cin >> pXPosition1;

		cout << "Enter the Value of Y for Point B of Line AB" << endl;
		cin >> pYPosition1;


	


		cout << "X Position: " << pTopLeftX << endl;
		cout << "Y Position: " << pTopLeftY << endl;
		cout << "Image Width: " << pImageWidth << endl;
		cout << "Image Height: " << pImageHeight << endl;


		pixelDataFile << "X Position: " << pTopLeftX << endl;
		pixelDataFile << "Y Position: " << pTopLeftY << endl;
		pixelDataFile << "Image Width: " << pImageWidth << endl;
		pixelDataFile << "Image Height: " << pImageHeight << endl;


		pixelDataFile << "Linear Function Takes a form of Y = A*x + b Where: " << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorForX);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorForX)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}







			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();



			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			float pKCoefficient = 0.0f;
			float pUCoefficient = 0.0;;

			pKCoefficient = (pYPosition1 - pYPosition0) / (pXPosition1 - pXPosition0);
			pUCoefficient = pYPosition0 - (pKCoefficient * pXPosition0);




			hr = ppStandardAlgorithmExecutor->DetectLineBetweenPoints(hInstance,
				hWnd, pXPosition0, pYPosition0, pXPosition1, pYPosition1,
				pixelObjectVectorForX,
				&pFilteredOutputArray);


			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pFilteredOutputArray)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
				cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
				cout << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;
				
				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
				pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
				pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
				pixelDataFile << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
				pixelDataFile << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
				pixelDataFile << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;



			}





			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;

			cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
			pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output" << endl;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLine(hInstance, hWnd,
				pKCoefficient, pUCoefficient,
				1, 0, -1,
				pFilteredOutputArray, &pFilterToReverseOutput);

			cout << "Printing the Results of the Output" << endl;
			for (PixelObject pixelObject : pFilterToReverseOutput)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);

			md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			md2dmanager->CreateDeviceResources(hInstance, hWnd);
			md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

			cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


			pixelDataFile.close();








			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);

			md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			md2dmanager->CreateDeviceResources(hInstance, hWnd);

			cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;

		}
		pixelDataFile.close();
		return hr;
	}


	HRESULT DirectXGPUDigitalLabCoreModule::ConnectPointsUsingLines(HINSTANCE hInstance, HWND hWnd)
	{
		HRESULT hr = S_OK;


		float pXPosition0 = 0.0f;
		float pYPosition0 = 0.0f;

		float pXPosition1 = 0.0f;
		float pYPosition1 = 0.0f;

		float pXPosition2 = 0.0f;
		float pYPosition2 = 0.0f;




		cout << "Enter the Value of X for Point A of Line AB" << endl;
		cin >> pXPosition0;

		cout << "Enter the Value of Y for Point A of Line AB" << endl;
		cin >> pYPosition0;

		cout << "Enter the Value of X for Point B of Line AB" << endl;
		cin >> pXPosition1;

		cout << "Enter the Value of Y for Point B of Line AB" << endl;
		cin >> pYPosition1;



		cout << "Enter the Value of X for Point C of Line BC" << endl;
		cin >> pXPosition2;

		cout << "Enter the Value of Y for Point C of Line BC" << endl;
		cin >> pYPosition2;


		Point2D pPoint[3];
		pPoint[0].pPointNumber = 0;
		pPoint[0].xPosition = pXPosition0;
		pPoint[0].yPosition = pYPosition0;


		pPoint[1].pPointNumber = 0;
		pPoint[1].xPosition = pXPosition2;
		pPoint[1].yPosition = pYPosition2;


		pPoint[2].pPointNumber = 0;
		pPoint[2].xPosition = pXPosition2;
		pPoint[2].yPosition = pYPosition2;


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		hr = md2dmanager->DrawLinesBetweenPoints(hInstance, hWnd, pPoint);

		return hr;
	}


	HRESULT DirectXGPUDigitalLabCoreModule::DectectLinesOnWhiteFontExperimentViaThreePoints(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseAgainstALinearFunctiEightxperiments.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
	

		vector<OutputPixelObjectCorrespondenceLinearFunction> pFilteredOutputArrayEight = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<PixelObject> pRecoveredPixelArrayEight = vector<PixelObject>();


		vector<OutputPixelObjectCorrespondenceLinearFunction> pFilteredOutputArrayTwo = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<PixelObject> pRecoveredPixelArrayTwo = vector<PixelObject>();




		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;


		cout << "Enter the value for the step for X Axis" << endl;
		cin >> pStepX;

		cout << "Enter the valuE for the step for Y Axis" << endl;
		cin >> pStepY;


		float pXPosition0 = 0.0f;
		float pYPosition0 = 0.0f;
		float pXPosition1 = 0.0f;
		float pYPosition1 = 0.0f;
		float pXPosition2 = 0.0f;
		float pYPosition2 = 0.0f;

		int pLeftOfTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pRightOfTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;


		cout << "Enter the Value of X for Point A of Line AB" << endl;
		cin >> pXPosition0;

		cout << "Enter the Value of Y for Point A of Line AB" << endl;
		cin >> pYPosition0;

		cout << "Enter the Value of X for Point B of Line AB" << endl;
		cin >> pXPosition1;

		cout << "Enter the Value of Y for Point B of Line AB" << endl;
		cin >> pYPosition1;



		cout << "Enter the Value of X for Point C of Line BC" << endl;
		cin >> pXPosition2;

		cout << "Enter the Value of Y for Point C of Line BC" << endl;
		cin >> pYPosition2;




		cout << "X Position: " << pTopLeftX << endl;
		cout << "Y Position: " << pTopLeftY << endl;
		cout << "Image Width: " << pImageWidth << endl;
		cout << "Image Height: " << pImageHeight << endl;


		pixelDataFile << "X Position: " << pTopLeftX << endl;
		pixelDataFile << "Y Position: " << pTopLeftY << endl;
		pixelDataFile << "Image Width: " << pImageWidth << endl;
		pixelDataFile << "Image Height: " << pImageHeight << endl;


		pixelDataFile << "Linear Function Takes a form of Y = A*x + b Where: " << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;

		int pPixelNumber = 0;

		cout << "Geneating a Data Set" << endl;

		for (float pXPosition = pTopLeftX; pXPosition < pImageWidth; pXPosition++)
		{
			for (float pYPosition = pTopLeftY; pYPosition < pImageHeight; pYPosition++)
			{
				PixelObject pBlackPixel = PixelObject(pPixelNumber,
					pXPosition, pYPosition, 0.0f, 0.0f, 0.0f);
				pixelObjectVectorForX.push_back(pBlackPixel);
			}

		}
	

			cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;




			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;








			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();



			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

			float pKCoefficient0 = 0.0f;
			float pUCoefficient0 = 0.0;;


			float pKCoefficient1 = 0.0f;
			float pUCoefficient1 = 0.0;;



			pKCoefficient0 = (pYPosition1 - pYPosition0) / (pXPosition1 - pXPosition0);
			pUCoefficient0 = pYPosition0 - (pKCoefficient0 * pXPosition0);


			pKCoefficient1 = (pYPosition2 - pYPosition1) / (pXPosition2 - pXPosition1);
			pUCoefficient1 = pYPosition1 - (pKCoefficient1 * pXPosition1);




			hr = ppStandardAlgorithmExecutor->DetectLineBetweenPoints(hInstance,
				hWnd, pXPosition0, pYPosition0, pXPosition1, pYPosition1,
				pixelObjectVectorForX,
				&pFilteredOutputArrayEight);


			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pFilteredOutputArrayEight)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
				cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
				cout << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;

				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
				pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
				pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
				pixelDataFile << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
				pixelDataFile << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
				pixelDataFile << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;



			}





			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;

			cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
			pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


			cout << "Restoring filter Results into RGB" << endl;


			vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
			cout << "Restoring Image Pixel Data for Filter Output" << endl;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLine(hInstance, hWnd,
				pKCoefficient0, pUCoefficient0,
				1, 0, -1,
				pFilteredOutputArrayEight, &pRecoveredPixelArrayEight);

			cout << "Printing the Results of the Output" << endl;
			for (PixelObject pixelObject : pRecoveredPixelArrayEight)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}



			hr = ppStandardAlgorithmExecutor->DetectLineBetweenPoints(hInstance,
				hWnd, pXPosition1, pYPosition1, pXPosition2, pYPosition2,
				pixelObjectVectorForX,
				&pFilteredOutputArrayTwo);


			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pFilteredOutputArrayTwo)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
				cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
				cout << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;

				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
				pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
				pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
				pixelDataFile << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
				pixelDataFile << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
				pixelDataFile << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;



			}





			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			pIndexValue = 0;

			cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
			pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;


			cout << "Restoring filter Results into RGB" << endl;

			cout << "Restoring Image Pixel Data for Filter Output" << endl;
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLine(hInstance, hWnd,
				pKCoefficient1, pUCoefficient1,
				1, 0, -1,
				pFilteredOutputArrayTwo, &pRecoveredPixelArrayTwo);

			cout << "Printing the Results of the Output" << endl;
			for (PixelObject pixelObject : pRecoveredPixelArrayTwo)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;


				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}
			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);

		
			vector<PixelObject> pRecoveredPixels = vector<PixelObject>();
			pRecoveredPixels.insert(pRecoveredPixels.end(), pRecoveredPixelArrayEight.begin(), pRecoveredPixelArrayEight.end());
			pRecoveredPixels.insert(pRecoveredPixels.end(), pRecoveredPixelArrayTwo.begin(), pRecoveredPixelArrayTwo.end());


			md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			md2dmanager->CreateDeviceResources(hInstance, hWnd);
			md2dmanager->DrawPixelBuffer(hInstance, hWnd, pRecoveredPixels, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

			cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


			pixelDataFile.close();








			GetSystemTime(&filterTimeEndSystem);
			GetLocalTime(&filterTimeEndLocal);

			md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			md2dmanager->CreateDeviceResources(hInstance, hWnd);

			cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;

			return hr;

}
		









	HRESULT DirectXGPUDigitalLabCoreModule::DetectStraightLineUsingHoughTransform(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseAgainstALinearFunction.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
		vector<OutputPixelObjectFiltered> pFilteredOutputArray = vector<OutputPixelObjectFiltered>();
		vector<PixelObject> pRecoveredPixelArray = vector<PixelObject>();



		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;



		float pXPosition0 = 0.0f;
		float pYPosition0 = 0.0f;
		float pXPosition1 = 0.0f;
		float pYPosition1 = 0.0f;
		float pLineMagnitude = 0.0f;
		float pAngleValue = 0.0f;
		int pLeftOfTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pRightOfTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;
		

		cout << "Enter the Value For Line magnitude" << endl;
		cin >> pLineMagnitude;

		cout << "Enter the Value For Line magnitude" << endl;
		cin >> pAngleValue;




		cout << "Enter the Value for Red Component" << endl;
		cin >> pRedValueParam;

		cout << "Enter the Value for Green Component" << endl;
		cin >> pGreenValueParam;

		cout << "Enter the Value for Blue Component" << endl;
		cin >> pBlueValueParam;




		cout << "X Position: " << pTopLeftX << endl;
		cout << "Y Position: " << pTopLeftY << endl;
		cout << "Image Width: " << pImageWidth << endl;
		cout << "Image Height: " << pImageHeight << endl;


		pixelDataFile << "X Position: " << pTopLeftX << endl;
		pixelDataFile << "Y Position: " << pTopLeftY << endl;
		pixelDataFile << "Image Width: " << pImageWidth << endl;
		pixelDataFile << "Image Height: " << pImageHeight << endl;


		pixelDataFile << "Linear Function Takes a form of Y = A*x + b Where: " << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorForX);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorForX)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}







			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();



			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




			hr = ppStandardAlgorithmExecutor->DetectAHoughTransformAgainstADefinedLine(hInstance,
				hWnd, pLineMagnitude,
				pAngleValue,
				1, 0, -1,
				pRedValueParam,
				pGreenValueParam,
				pBlueValueParam,
				pixelObjectVectorForX,
				&pFilteredOutputArray);


			for (OutputPixelObjectFiltered pPixelObject : pFilteredOutputArray)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
				pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
				pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
				pixelDataFile << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;




			}


			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;



		}
		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;





		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pRecoveredPixelArray, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		pixelDataFile.close();
		return hr;
	}







	HRESULT DirectXGPUDigitalLabCoreModule::DetectStraightLineWithinImagesUsingALinearFunction(HINSTANCE hInstance, HWND hWnd)
	{


		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\DetectStraightLineCorrespondenseAgainstALinearFunction.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		SYSTEMTIME clippingTimeStartSystem;
		SYSTEMTIME clippingTimeStartLocal;
		SYSTEMTIME clippingTimeEndSystem;
		SYSTEMTIME clippingTimeEndLocal;
		SYSTEMTIME filterTimeStartSystem;
		SYSTEMTIME filterTimeStartLocal;
		SYSTEMTIME filterTimeEndSystem;
		SYSTEMTIME filterTimeEndLocal;
		int pAmountOfFilteredPixels = 0;


		vector<PixelObject> pixelObjectVectorForX = vector<PixelObject>();
		vector<OutputPixelObjectCorrespondenceLinearFunction> pPointOutputArray = vector<OutputPixelObjectCorrespondenceLinearFunction>();
		vector<PixelObject> pRecoveredPixelArray = vector<PixelObject>();



		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		float pStepX = 0.0f;
		float pStepY = 0.0f;

		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Height of Image Sector" << endl;
		cin >> pImageHeight;



		float pACoefficient = 0.0f;
		float pBCoefficient = 0.0f;

		int pLeftOfTheLineLabel = 0;
		int pOnTheLineLabel = 1;
		int pRightOfTheLineLabel = -1;

		float pRedValueParam = 0.0f;
		float pGreenValueParam = 0.0f;
		float pBlueValueParam = 0.0f;

		cout << "Enter the value of the A component for the equation y = a*x + b" << endl;
		cin >> pACoefficient;


		cout << "Enter the value of the B component for the equation y = a*x + b" << endl;
		cin >> pBCoefficient;

		cout << "Enter the value for the RED Component" << endl;
		cin >> pRedValueParam;

		cout << "Enter the value for the Green Component" << endl;
		cin >> pRedValueParam;

		cout << "Enter the value for the RED Component" << endl;
		cin >> pRedValueParam;




		pixelDataFile << "Linear Function Takes a form of Y = A*x + b Where: " << endl;




		cout << "Printing RGB Clip Object" << endl;
		pixelDataFile << "Printing RGB Clip Object" << endl;





		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		if (GetOpenFileNameW(&ofn))
		{



			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorForX);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorForX)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}







			cout << "RGB Section End" << endl;
			pixelDataFile << "RGB Section End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Grayscale Section End" << endl;
			pixelDataFile << "Grayscale Section End" << endl;


			vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();



			GetSystemTime(&filterTimeStartSystem);
			GetLocalTime(&filterTimeStartLocal);

			cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
			cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
			pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



			hr = ppStandardAlgorithmExecutor->DetectAStraigntWithinAnImage(hInstance, hWnd,
				pACoefficient, pBCoefficient, 1, 0, -1, pRedValueParam,
				pGreenValueParam,
				pBlueValueParam,
				pixelObjectVectorForX,
				&pPointOutputArray);


			for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pPointOutputArray)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
				cout << "Is Pixel Valid: " << pPixelObject.pIsPixelObjectValid << endl;

				pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
				cout << "Is Pixel Valid: " << pPixelObject.pIsPixelObjectValid << endl;




			}


			if (FAILED(hr))
			{
				int pLastError = GetLastError();
				cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
				pixelDataFile.close();
				return hr;

			}

			pixelDataFile << " " << endl;
			pixelDataFile << " " << endl;
			pixelDataFile << "New Operation Begin" << endl;

			UINT pOperationNumber = 0;
			cout << "Printing Output" << endl;
			pixelDataFile << "Printing Output" << endl;

			UINT pIndexValue = 0;



		}
		cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromLineDetectorOnTheLine(hInstance,
			hWnd,
			pACoefficient,
			pBCoefficient,
			1, 0, -1,
			pPointOutputArray,
			&pRecoveredPixelArray);

		UINT pIndex = 0;

		for (PixelObject pixelObject : pRecoveredPixelArray)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}




		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		md2dmanager->DrawPixelBuffer(hInstance, hWnd, pRecoveredPixelArray, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		pixelDataFile.close();
		return hr;
	}







HRESULT DirectXGPUDigitalLabCoreModule::SimulateInterestingPointDetector(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageInterestPointDetectorRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectInterestPoint> pOutputFilterResult = vector<OutputPixelObjectInterestPoint>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the Step for X  of Image Sector" << endl;
	cin >> pStepX;

	cout << "Enter the Step for Y  of Image Sector" << endl;
	cin >> pStepY;


	float pCommonFactorValue = 0.0f;
	

	cout << "Enter Pixel Number Common Factor Value" << endl;
	cin >> pCommonFactorValue;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
	

		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->SimulateInterestPointDetector(hInstance, hWnd,
			pCommonFactorValue,
			pixelObjectVector, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectInterestPoint pPixelObject : pOutputFilterResult)
		{



			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			float pPixelNumberRemainder = pPixelObject.pRemainderVar;
			bool pUsedInComputations = pPixelObject.pIsPixelValid;

			if ((pUsedInComputations == true) || (pUsedInComputations == 255))
			{
				pAmountOfFilteredPixels++;
			}


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Remainder Var: " << pPixelNumberRemainder << endl;
			cout << "Is Interest Point = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Remainder Var: " << pPixelNumberRemainder << endl;
			pixelDataFile << "Is Interest Point = " << pUsedInComputations << endl;


			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreInterestPointsFromFilter(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateInterestingPointCoordinatesDetector(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageInterestPointDetectorRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectInterestPoint> pOutputFilterResult = vector<OutputPixelObjectInterestPoint>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the Step for X  of Image Sector" << endl;
	cin >> pStepX;

	cout << "Enter the Step for Y  of Image Sector" << endl;
	cin >> pStepY;


	float pCommonFactorValueX = 0.0f;


	cout << "Enter Pixel Number Common Factor Value " << endl;
	cin >> pCommonFactorValueX;





	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, pStepY, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->SimulateInterestPointDetector(hInstance, hWnd,
			pCommonFactorValueX,
			pixelObjectVector, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectInterestPoint pPixelObject : pOutputFilterResult)
		{



			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			float pPixelNumberRemainder = pPixelObject.pRemainderVar;
			bool pUsedInComputations = pPixelObject.pIsPixelValid;

			if ((pUsedInComputations == true) || (pUsedInComputations == 255))
			{
				pAmountOfFilteredPixels++;
			}


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Remainder Var: " << pPixelNumberRemainder << endl;
			cout << "Is Interest Point = " << pUsedInComputations << endl;

			pixelDataFile << "Pixel Number: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Remainder Var: " << pPixelNumberRemainder << endl;
			pixelDataFile << "Is Interest Point = " << pUsedInComputations << endl;


			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreInterestPointsFromFilter(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::ApplyBinaryFilterForSelectedImageFile(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\BinaryFilterWithPixelReconstruction.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectClassified> pOutputFilterResult = vector<OutputPixelObjectClassified>();
	vector<PixelObject> pValidPixels = vector<PixelObject>();
	vector<PixelObject> pInvalidPixels = vector<PixelObject>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;





	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	int pValidClassifierToken = 0;
	int pInvalidClassifierToken = 1;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	
	cout << "Enter the Highest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Highest Value for Blue Component" << endl;
	cin >> pBlueValueTop;

	cout << "Enter the Value for valid classifier" << endl;
	cin >> pValidClassifierToken;

	cout << "Enter the Value for invalid classifier" << endl;
	cin >> pInvalidClassifierToken;

	CBBinaryClassifierConstantBuffer  pConstantBufferStruct;
	pConstantBufferStruct.pThresholdIntensityValueR = pRedValueTop;
	pConstantBufferStruct.pThresholdIntensityValueG = pGreenValueTop;
	pConstantBufferStruct.pThresholdIntensityValueB = pBlueValueTop;
	pConstantBufferStruct.pValidPixelConstant = pValidClassifierToken;
	pConstantBufferStruct.pInvalidPixelConstant = pInvalidClassifierToken;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		
		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

	
		hr = ppStandardAlgorithmExecutor->ApplyBinaryClassifierForImagePixels(hInstance,
			hWnd,
			pRedValueTop,
			pGreenValueTop,
			pBlueValueTop,
			pValidClassifierToken,
			pInvalidClassifierToken,
			pixelObjectVector,
			&pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();
	
		for (OutputPixelObjectClassified pPixelObject : pOutputFilterResult)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			cout << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			cout << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			cout << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;

			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component: " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			pixelDataFile << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			pixelDataFile << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			pixelDataFile << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;



		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutputValidPixels = vector<PixelObject>();
	vector<PixelObject> pFilterToReverseOutputInvalidPixels = vector<PixelObject>();

	cout << "Restoring Image Pixel Data for Filter Output Valid Pixels" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreValidRGBPixelFromClassifier(hInstance, hWnd,
		pConstantBufferStruct,
		pOutputFilterResult, &pFilterToReverseOutputValidPixels);

	cout << "Printing the Results of the Valid Pixels" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutputValidPixels)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Restoring Image Pixel Data for Filter Output Invalid Pixels" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreInvalidRGBPixelFromClassifier(hInstance, hWnd,
		pConstantBufferStruct,
		pOutputFilterResult, &pFilterToReverseOutputInvalidPixels);

	cout << "Printing the Results of the Valid Pixels" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutputInvalidPixels)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutputValidPixels, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldImagePixelByCriteriaRGBWithoutExclusion(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationRGBWithoutExclusion.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterResult = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;



	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the Lowest Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the Highest Value for Red Component" << endl;
	cin >> pRedValueTop;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Green Component" << endl;
	cin >> pGreenValueTop;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueTop;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaRGB(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pRedValueBottom,
			pRedValueTop,
			pGreenValueBottom,
			pGreenValueTop,
			pBlueValueBottom,
			pBlueValueTop,
			pixelObjectVector, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		vector<OutputPixelObjectFiltered> pFinalOutputSquare = vector<OutputPixelObjectFiltered>();


		for (OutputPixelObjectFiltered pPixelObject : pOutputFilterResult)
		{



			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.bValue;
			bool pUsedInComputations = pPixelObject.pUsedInComputations;

			if ((pUsedInComputations == true) || (pUsedInComputations == 255))
			{
				pAmountOfFilteredPixels++;
			}


			cout << "Pixel Number: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Component = " << pRedComponent << endl;
			cout << "Green Component = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Used In Computations = " << pUsedInComputations << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "Red Component = " << pRedComponent << endl;
			pixelDataFile << "Green Component = " << pGreenComponent << endl;
			pixelDataFile << "Blue Component = " << pBlueComponent << endl;
			pixelDataFile << "Used In Computations = " << pUsedInComputations << endl;



			pIndexValue++;
		}



	}
	cout << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;
	pixelDataFile << "Amount of Filtered Pixels: " << pAmountOfFilteredPixels << endl;



	cout << "Restoring filter Results into RGB" << endl;


	vector<PixelObject> pFilterToReverseOutput = vector<PixelObject>();
	cout << "Restoring Image Pixel Data for Filter Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilterWithoutExclusion(hInstance, hWnd,
		pOutputFilterResult, &pFilterToReverseOutput);

	cout << "Printing the Results of the Output" << endl;
	for (PixelObject pixelObject : pFilterToReverseOutput)
	{

		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;


		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pFilterToReverseOutput, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);


	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	pixelDataFile.close();
	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldImagePixelByCriteria(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperation.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME grayscaleTimeStartSystem;
	SYSTEMTIME grayscaleTimeStartLocal;
	SYSTEMTIME grayscaleTimeEndSystem;
	SYSTEMTIME grayscaleTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;



	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
    	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;


	cout << "Enter the Value For The Minimum Intensity Threshold" << endl;
	cin >> pThresholdIntensityMinimum;


	cout << "Enter the Value For The Maximum Intensity Threshold" << endl;
	cin >> pThresholdIntensityMaximum;

	cout << "Your Selected Minimum Value Of the Threshold = " << pThresholdIntensityMinimum << endl;
	pixelDataFile << "Your Selected Minimum Value Of the Threshold = " << pThresholdIntensityMinimum << endl;

	cout << "Your Selected Maximum Value Of the Threshold = " << pThresholdIntensityMaximum << endl;
	pixelDataFile << "Your Selected Maximum Value Of the Threshold = " << pThresholdIntensityMaximum << endl;




	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;

		GetSystemTime(&grayscaleTimeStartSystem);
		GetLocalTime(&grayscaleTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;


		hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
			pixelObjectVector, &pPixelObjectToGrayScale);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		float pIndexValue = 0;

		cout << "Grayscale Section Begin" << endl;
		pixelDataFile << "Grayscale Section Begin" << endl;



		for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
		{

			float pPixelNumber = pIndexValue;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


			pIndexValue++;
		}

		GetSystemTime(&grayscaleTimeEndSystem);
		GetLocalTime(&grayscaleTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;




		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;

	    vector<OutputPixelObjectFilteredGrayScale> ppOutputPixelVector = vector<OutputPixelObjectFilteredGrayScale>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCriteriaGrayScale(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pThresholdIntensityMinimum, pThresholdIntensityMaximum,
			pPixelObjectToGrayScale, &ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
	
	     pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

	   pIndexValue = 0;

	  int pAmountOfPixelsUses = 0;
	   for (OutputPixelObjectFilteredGrayScale pPixelObject : ppOutputPixelVector)
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale = pPixelObject.pGrayScaleValue;
			bool pIsPixelUsed = pPixelObject.pIsPixelValid;

			if ((pIsPixelUsed == true) || (pIsPixelUsed == 255))
			{
				pAmountOfPixelsUses++;
			}

			cout << "Step: " << pIndexValue << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
			cout << "Is Pixel Used = " << pIsPixelUsed << endl;



			pixelDataFile << "Step: " << pIndexValue << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
			pixelDataFile << "Is Pixel Used = " << pIsPixelUsed << endl;


			pIndexValue++;
		}

	   cout << "Amount of filtered pixels = " << pAmountOfPixelsUses;
	   pixelDataFile << "Amount of filtered pixels = " << pAmountOfPixelsUses;

	}
	
	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;



	pixelDataFile.close();
	return hr;
}








HRESULT DirectXGPUDigitalLabCoreModule::CreateAndRednerHistogramForAnImage(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	cout << "Loading an image Histogram" << endl;
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageHistogramData.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	vector<float> pHistogramData = vector<float>();
	hr = md2dmanager->ApplyHistogramEffect(hInstance, hWnd, &pHistogramData);

	int pIndex = 0;


	for (float pValue : pHistogramData)
	{
		cout << "Index: " << pIndex << endl;
		pixelDataFile << "Index: " << pIndex << endl;
		cout << "Histogram Value =  " << pValue << endl;
		pixelDataFile << "Histogram Value =  " << pValue << endl;
	}
	pixelDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToGrayScale(HINSTANCE hInstance, HWND hWnd, vector<PixelObjectGrayScale> *ppGrayScale)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToGrayScaleFinalOutput.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	pixelDataFile.close();
	*ppGrayScale = pPixelObjectToGrayScale;
	return hr;
}











HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPIMotionDetected(HINSTANCE hInstance, HWND hWnd,
	LPWSTR pFileNameVideoEight, LPWSTR pFileNameVideoTwo, int pXPosition, int pYPosition, int pImageWidth, int pImageHeight, int pWaitingInterval,
	vector<PixelObject> *pImageOneRGBPixels, vector<PixelObject> *pImageTwoRGBPixels, vector<MotionPixelObjectRGB> *ppOutputPixelBufferArray)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerMotionDetectionRGB.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();






	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	vector<MotionPixelObjectRGB> ppVerificationOutputArray = vector<MotionPixelObjectRGB>();



	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}

	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEightNameLocal, pVideoFileTwoNameLocal, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingInterval);




	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageFourForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;





	hr = ppStandardAlgorithmExecutor->DetectMotionInRGBImage(hInstance, hWnd, pixelObjectImageEight,
		pixelObjectImageTwo, &ppVerificationOutputArray,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	float pPercentageValue = 0.0f;
	float pCheckSum = 0.0f;
	float pCurrentArraySize = 0.0f;
	double pRatioValue = 0.0f;
	for (MotionPixelObjectRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
		cout << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
		imageSegmentationDataFile << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

		pCheckSum = pOutputPixelValue.pRedComponentDifference + pOutputPixelValue.pGreenComponentDifference + pOutputPixelValue.pBlueComponentDifference;
		if (pCheckSum > 0.0f)
		{
			pAmountOfDifferentPixels = pAmountOfDifferentPixels + 1;
	

		}
		pCurrentArraySize = ppVerificationOutputArray.size();

		pRatioValue = pAmountOfDifferentPixels / pCurrentArraySize;
		pPercentageValue = pRatioValue * 100;
		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pPercentageValue,
			33.0f, 66.0f, 100.0f);

	}












	*pImageOneRGBPixels = pixelObjectImageEight;
	*pImageTwoRGBPixels = pixelObjectImageTwo;
	*ppOutputPixelBufferArray = ppVerificationOutputArray;

	imageSegmentationDataFile.close();

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonForRGBImagesSelectedFiles(HINSTANCE hInstance, HWND hWnd)
{
	
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerRGBSelectedFiles.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();


	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;




	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;




	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	pTotalImageIntensitySum = 0;

	 pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	cout << "Selecting Video File № 1" << endl;
	LPWSTR pVideoFileEight = nullptr;
	// Show the File Open dialog.
	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		// Open the file with the playback object.
		pVideoFileEight = ofn.lpstrFile;
	}

	cout << "Selecting Video File № 2" << endl;
	LPWSTR pVideoFileTwo = nullptr;
	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';
	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path1;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;

	if (GetOpenFileNameW(&ofn1))
	{
		// Open the file with the playback object.
		pVideoFileTwo = ofn1.lpstrFile;
	}


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEight, pVideoFileTwo, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingIntervalInSeconds);





	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;


	cout << "Launching Image Comparison OperationRGN" << endl;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;
	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject>  ppDifferentPixelOutputArray = vector<PixelObject>();


	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGB(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		hr = md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pOutputPixelValue.pAmountOfDifferentPixels,
			33, 66, 100);

		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}








	imageSegmentationDataFile.close();

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonForRGBImagesSelectedFilesThreaded(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerRGBSelectedFilesThreaded.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();


	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;




	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "Selecting Video File № 1" << endl;
	LPWSTR pVideoFileEight = nullptr;
	// Show the File Open dialog.
	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		// Open the file with the playback object.
		pVideoFileEight = ofn.lpstrFile;
	}

	cout << "Selecting Video File № 2" << endl;
	LPWSTR pVideoFileTwo = nullptr;
	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';
	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path1;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;

	if (GetOpenFileNameW(&ofn1))
	{
		// Open the file with the playback object.
		pVideoFileTwo = ofn1.lpstrFile;
	}


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEight, pVideoFileTwo, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingIntervalInSeconds);





	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;


	cout << "Launching Image Comparison OperationRGN" << endl;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;
	BOOL pAreImagesIdentical = FALSE;

	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject>  ppDifferentPixelOutputArray = vector<PixelObject>();



	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		hr = md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pOutputPixelValue.pAmountOfDifferentPixels, 33, 66, 100);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}








	imageSegmentationDataFile.close();

	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonForRGBImagesAutomatic(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerSelectedFilesRGBAutomatic.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();


	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;




	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	pXPosition = monitorWidth / 2;
	pYPosition = monitorHeight / 2;
	pImageWidth = 10;
	pImageHeight = 10;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingIntervalInSeconds);




	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();

	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();



	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}

	


	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;


	cout << "Launching Image Comparison OperationRGN" << endl;


	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGB(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pOutputPixelValue.pAmountOfDifferentPixels, 33, 66, 100);

		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}







	imageSegmentationDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonForRGBImagesAutomaticThreaded(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerRGBAutomaticThreaded.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();


	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);



	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;



	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	pXPosition = monitorWidth / 2;
	pYPosition = monitorHeight / 2;
	pImageWidth = 10;
	pImageHeight = 10;


	
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingIntervalInSeconds);




	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();

	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();



	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}




	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;


	cout << "Launching Image Comparison OperationRGN" << endl;


	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pOutputPixelValue.pAmountOfDifferentPixels,
			33, 66, 100);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}






	imageSegmentationDataFile.close();

	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPISptialShapeAnalysisDemo(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerRGBAutomaticThreaded.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();


	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);



	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;



	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";

	float pStepX = 0.0f;
	float pStepY = 0.0f;



	fstream imageSectorsData;
	imageSectorsData.open("C:\\pixels\\ImageSectorsData.txt", fstream::in | fstream::out | fstream::trunc);
	imageSectorsData.clear();






	int pValidClassifierToken = 1;
	int pInvalidClassifierToken = 0;
	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBOne = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBTwo = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBThree = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFour = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBFive = vector<OutputPixelObjectFiltered>();
	vector<OutputPixelObjectFiltered> pFilteredObjectArrayRGBSix = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pFilteredObjectArrayRGBOneRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBTwoRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBThreeRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFourRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBFiveRestored = vector<PixelObject>();
	vector<PixelObject> pFilteredObjectArrayRGBSixRestored = vector<PixelObject>();

	float pSectionOneXMin = 180.0f;
	float pSectionOneXMax = 680.0f;
	float pSectionOneY = 200.0f;




	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue1;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue1;

	UINT pRecordingTimeInSeconds = 0;
	UINT pWaitingIntervalInSeconds = 0;

	cout << "Enter the Lengh Of The Recoring In Seconds" << endl;
	cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;




	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();
	vector<OutputPixelObjectClassified> ppOutputPixelVectorOutput = vector<OutputPixelObjectClassified>();
	ID2D1Bitmap* pBitmapData = nullptr;

	float pTotalX1 = 0.0F;
	float pTotalX2 = 0.0F;
	float pTotalX3 = 0.0F;
	float pTotalX4 = 0.0F;
	float pTotalX5 = 0.0F;
	float pTotalX6 = 0.0F;

	float pAverageX1 = 0.0f;
	float pAverageX2 = 0.0f;
	float pAverageX3 = 0.0F;
	float pAverageX4 = 0.0f;
	float pAverageX5 = 0.0f;
	float pAverageX6 = 0.0F;


	float pTotalY1 = 0.0f;
	float pTotalY2 = 0.0F;
	float pTotalY3 = 0.0F;
	float pTotalY4 = 0.0F;
	float pTotalY5 = 0.0F;
	float pTotalY6 = 0.0F;



	float pAverageY1 = 0.0f;
	float pAverageY2 = 0.0f;
	float pAverageY3 = 0.0F;

	float pAverageY4 = 0.0f;
	float pAverageY5 = 0.0f;
	float pAverageY6 = 0.0F;


	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pRedValueToSelect = 0.0f;
	float pGreenValueToSelect = 0.0f;
	float pBlueValueToSelect = 0.0f;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;
	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;
	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	cout << "Enter the Red Component To Select" << endl;
	cin >> pRedValueToSelect;
	cout << "Enter the Green Component to Select" << endl;
	cin >> pGreenValueToSelect;
	cout << "Enter the BLue Component to Select" << endl;
	cin >> pBlueValueToSelect;
	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;




	float pTotalImageIntensitySum = 0;
    pWaitingIntervalInSeconds = 0;



	 cout << "Enter the Length of Recordings In Seconds" << endl;
	 cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulateRobotCleaner(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo,
		pHourValue0, pMinuteValue0, pHourValue1, pMinuteValue1,	
		constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pRecordingTimeInSeconds, pWaitingIntervalInSeconds);

	vector<PixelObject> pPixelArrayToProcessOneYAxis = vector<PixelObject>();
	vector<PixelObject> pPixelArrayToProcessOneXAxis = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> pOutputFilterOperationDataOne = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> pOutputFilterOperationDataRestoredOne = vector<PixelObject>();
	vector<PixelObject> pOutputPixelArraySectoredOne = vector<PixelObject>();

	vector<OutputPixelObjectWithAngleValues> pCommonPixelArrayObjectOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFourVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPoinstArrayOne = vector<Point2D>();
	vector<Line2D> pLineArrayOne = vector<Line2D>();

	vector<PixelObject> pPixelArrayToProcessTwoYAxis = vector<PixelObject>();
	vector<PixelObject> pPixelArrayToProcessTwoXAxis = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputFilterOperationDataTwo = vector<OutputPixelObjectFiltered>();
	vector<PixelObject> ppOutputFilterOperationDataRestoredTwo = vector<PixelObject>();
	vector<PixelObject> ppOutputPixelArraySectoredTwo = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pCommonPixelArrayObjecTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> ppSectorFourVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPoinstArrayTwo = vector<Point2D>();
	vector<Line2D> pLineArrayTwo = vector<Line2D>();
	float pPerimeterValueOne = 0.0f;
	float pAreaValueOne = 0.0f; 
	float pPerimeterValueTwo = 0.0f;
	float pAreaValueTwo = 0.0f;
	float pPerimeterDifference = 0.0f;
	float pAreaDifference = 0.0f;












	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPISptialShapeAnalysis(HINSTANCE hInstance, HWND hWnd,
	LPWSTR pFileNameVideoOne,
	LPWSTR pFileNameVideoTwo,
	int pXPosition, int pYPosition, int pImageWidth, int pImageHeight,
	float pRedValueToSelect,
	float pGreenValueToSelect,
	float pBlueValueToSelect,
	UINT pStepY,
	UINT pStepX,
	int pWaitingInterval,
	vector<PixelObject> pPixelArrayToProcessOneYAxis,
	vector<PixelObject> pPixelArrayToProcessOneXAxis,
	vector<OutputPixelObjectFiltered> *ppOutputFilterOperationDataOne,
	vector<PixelObject> *ppOutputFilterOperationDataRestoredOne,
	vector<PixelObject> *ppOutputPixelArraySectoredOne,
	vector<OutputPixelObjectWithAngleValues> *ppCommonPixelArrayObjecOne,
	vector<OutputPixelObjectWithAngleValues> *ppSectorOneExperimentOne,
	vector<OutputPixelObjectWithAngleValues> *ppSectorTwoExperimentOne,
	vector<OutputPixelObjectWithAngleValues> *ppSectorThreeExperimentOne,
	vector<OutputPixelObjectWithAngleValues> *ppSectorFourExperimentOne,
	vector<Point2D> *ppPoinstArrayOne,
	vector<Line2D> *ppLineArrayOne,
	vector<PixelObject> pPixelArrayToProcessTwoYAxis,
	vector<PixelObject> pPixelArrayToProcessTwoXAxis,
	vector<OutputPixelObjectFiltered> *ppOutputFilterOperationDataTwo,
	vector<PixelObject> *ppOutputFilterOperationDataRestoredTwo,
	vector<PixelObject> *ppOutputPixelArraySectoredTwo,
	vector<OutputPixelObjectWithAngleValues> *ppCommonPixelArrayObjecTwo,
	vector<OutputPixelObjectWithAngleValues> *ppSectorOneExperimentTwo,
	vector<OutputPixelObjectWithAngleValues> *ppSectorTwoExperimentTwo,
	vector<OutputPixelObjectWithAngleValues> *ppSectorThreeExperimentTwo,
	vector<OutputPixelObjectWithAngleValues> *ppSectorFourExperimentTwo,
	vector<Point2D> *ppPoinstArrayTwo,
	vector<Line2D> *ppLineArrayTwo,
	float* ppPeriemerValueOne, float* ppAreaValueOne,
	float* ppPeriemerValueTwo, float* ppAreaValueTwo,
	float* ppPerimeterDifference, float* ppAreaDifference)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerAsynchronousMode.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageOneXAxis = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageOneYAxis = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwoXAxis = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwoYAxis = vector<PixelObject>();




	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number One" << endl;
	BOOL pResult = FALSE;





	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSpatialShapeAnalysis(hInstance, hWnd,
		pFileNameVideoOne,
		constants::pSpatialShapeImageOne,
		constants::pSpatialShapeImageTwo,
		pWaitingInterval);





	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSpatialShapeAnalysis(hInstance, hWnd,
		pFileNameVideoTwo,
		constants::pSpatialShapeImageThree,
		constants::pSpatialShapeImageFour,
		pWaitingInterval);


	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
		hWnd, pXPosition, pYPosition, pImageWidth, pImageHeight,
		1, pStepY, constants::pSpatialShapeImageOne, &pixelObjectImageOneYAxis);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageOneYAxis)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
		hWnd,  pXPosition, pYPosition, pImageWidth, pImageHeight,
		pStepX, 1, constants::pSpatialShapeImageOne, &pixelObjectImageOneXAxis);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageOneXAxis)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}



	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
		hWnd, pXPosition, pYPosition, pImageWidth, pImageHeight,
		1, pStepY, constants::pSpatialShapeImageTwo, &pixelObjectImageTwoYAxis);

	cout << "Printing the Contents of Clipped Area" << endl;

	 pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageTwoYAxis)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
		hWnd,  pXPosition, pYPosition, pImageWidth, pImageHeight,
		pStepX, 1, constants::pSpatialShapeImageThree, &pixelObjectImageTwoXAxis);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwoXAxis)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}



	
	vector<PixelObject>::iterator pVectorOneIt = pixelObjectImageOneYAxis.end();
	pixelObjectImageOneYAxis.insert(pVectorOneIt, pixelObjectImageOneXAxis.begin(), pixelObjectImageOneXAxis.end());



	vector<PixelObject>::iterator pVectorTwoIt = pixelObjectImageTwoYAxis.end();
	pixelObjectImageTwoYAxis.insert(pVectorTwoIt, pixelObjectImageTwoXAxis.begin(), pixelObjectImageTwoXAxis.end());




	vector<OutputPixelObjectFiltered> pFilterContainerObjectOne = vector <OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterContainerObjectRestoredOne = vector <PixelObject>();
	vector<PixelObject> pPixelObjectSectoredOne = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pCommonArrayOutputOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFourVectorOne = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPointArrayVectorOne = vector<Point2D>();
	vector<Line2D> pLineArrayVectorOne = vector<Line2D>();
	float pPerimeterValueOne = 0.0f;
	float pAreaValueOne = 0.0f;



	vector<OutputPixelObjectFiltered> pFilterContainerObjectTwo = vector <OutputPixelObjectFiltered>();
	vector<PixelObject> pFilterContainerObjectRestoredTwo = vector <PixelObject>();
	vector<PixelObject> pPixelObjectSectoredTwo = vector<PixelObject>();
	vector<OutputPixelObjectWithAngleValues> pCommonArrayOutputTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorOneVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorTwoVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorThreeVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<OutputPixelObjectWithAngleValues> pSectorFourVectorTwo = vector<OutputPixelObjectWithAngleValues>();
	vector<Point2D> pPointArrayVectorTwo = vector<Point2D>();
	vector<Line2D> pLineArrayVectorTwo = vector<Line2D>();
	float pPerimeterValueTwo = 0.0f;	
	float pAreaValueTwo = 0.0f;

	cout << "Analysing Data From the First Image" << endl;
	imageSegmentationDataFile << "Analysing Data From the First Image" << endl;


	hr = DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicWithPreprocessedPixels(hInstance,
		hWnd,
		pXPosition, pYPosition, pImageWidth,
		pImageHeight, pStepX,
		pStepY, pRedValueToSelect, pGreenValueToSelect,
		pBlueValueToSelect, pixelObjectImageOneYAxis,
		&pFilterContainerObjectOne,
		&pFilterContainerObjectRestoredOne,
		&pPixelObjectSectoredOne,
		&pCommonArrayOutputOne,
		&pSectorOneVectorOne,
		&pSectorTwoVectorOne,
		&pSectorThreeVectorOne,
		&pSectorFourVectorOne,
		&pPointArrayVectorOne,
		&pLineArrayVectorOne,
		&pPerimeterValueOne,
		&pAreaValueOne);


	cout << "Analyzing Data From the Second Image" << endl;
	imageSegmentationDataFile << "Analyzing Data From the First Image" << endl;


	hr = DetectObjectOfSpatialShapeOnWhiteFontFourthExperimentRGBFilterWithSectorsAllocationOnGPUDynamicWithPreprocessedPixels(hInstance,
		hWnd,
		pXPosition, pYPosition,  pImageWidth,
		pImageHeight, pStepX,
		pStepY, pRedValueToSelect, pGreenValueToSelect,
		pBlueValueToSelect,
		pixelObjectImageTwoYAxis,
		&pFilterContainerObjectTwo,
		&pFilterContainerObjectRestoredTwo,
		&pPixelObjectSectoredTwo,
		&pCommonArrayOutputTwo,
		&pSectorTwoVectorTwo,
		&pSectorTwoVectorTwo,
		&pSectorThreeVectorTwo,
		&pSectorFourVectorTwo,
		&pPointArrayVectorTwo,
		&pLineArrayVectorTwo,
		&pPerimeterValueTwo,
		&pAreaValueTwo);
		


	cout << "Printing Image Parameters For Image One" << endl;
	imageSegmentationDataFile << "Prinitng Image Parameters" << endl;


	cout << "X0 = " << pXPosition << endl;
	cout << "Y0 = " << pYPosition << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Step for X Axis = " << pStepX << endl;
	cout << "Step for Y Axis = " << pStepY << endl;
	cout << "Red Color Value: " << pRedValueToSelect << endl;
	cout << "Green Color Value: " << pGreenValueToSelect << endl;
	cout << "Blue Color Value: " << pGreenValueToSelect << endl;


	imageSegmentationDataFile << "X0 = " << pXPosition << endl;
	imageSegmentationDataFile << "Y0 = " << pYPosition << endl;
	imageSegmentationDataFile << "Image Width = " << pImageWidth << endl;
	imageSegmentationDataFile << "Image Height = " << pImageWidth << endl;
	imageSegmentationDataFile << "Step for X Axis = " << pStepX << endl;
	imageSegmentationDataFile << "Step for Y Axis = " << pStepY << endl;
	imageSegmentationDataFile << "Red Color Value: " << pRedValueToSelect << endl;
	imageSegmentationDataFile << "Green Color Value: " << pGreenValueToSelect << endl;
	imageSegmentationDataFile << "Blue Color Value: " << pGreenValueToSelect << endl;


	cout << "RGB Filter Output Value Image One" << endl;
	imageSegmentationDataFile << "RGB Filter Output Value One" << endl;


	for (PixelObject pixelObject : pFilterContainerObjectRestoredOne)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}


	cout << "Result of Averaging" << endl;
	imageSegmentationDataFile << "Result of Averaging" << endl;


	for (PixelObject pixelObject : pPixelObjectSectoredOne)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}



	cout << "Printing Sector Clusters Data " << endl;
	imageSegmentationDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pCommonArrayOutputOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}

	cout << "Printing Sector One" << endl;
	imageSegmentationDataFile << "Printing Sector One" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorOneVectorOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





	}
	imageSegmentationDataFile << "Sector End" << endl;



	cout << "Printing Sector Two" << endl;
	imageSegmentationDataFile << "Printing Sector Two" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorTwoVectorOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






	}
	imageSegmentationDataFile << "Sector End" << endl;


	cout << "Printing Sector Three" << endl;
	imageSegmentationDataFile << "Printing Sector Three" << endl;


	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorThreeVectorOne)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




	}
	imageSegmentationDataFile << "Sector End" << endl;


	cout << "Printing Sector Four" << endl;
	imageSegmentationDataFile << "Printing Sector four" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorFourVectorOne)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




	}
	imageSegmentationDataFile << "Sector End" << endl;

	cout << "Printing Out Line Segments: " << endl;
	imageSegmentationDataFile << "Printing Out Line Segments: " << endl;

	for (Line2D pLineObject : pLineArrayVectorOne)
	{
		cout << "Line Number: " << pLineObject.pLineNumber << endl;
		cout << "Point One: " << endl;;
		cout << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
		cout << "X Position: " << pLineObject.pPointOne.xPosition << endl;
		cout << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
		cout << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
		cout << "Point Two: " << endl;;
		cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
		cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
		cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
		cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
		cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

		imageSegmentationDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
		imageSegmentationDataFile << "Point One: " << endl;;
		imageSegmentationDataFile << "Point Number: " << pLineObject.pPointOne.pPointNumber << endl;
		imageSegmentationDataFile << "X Position: " << pLineObject.pPointOne.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pLineObject.pPointOne.yPosition << endl;
		imageSegmentationDataFile << "Point Section: " << pLineObject.pPointOne.pSectorNumber << endl;
		imageSegmentationDataFile << "Point Two: " << endl;;
		imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
		imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
		imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
		imageSegmentationDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;


	}

	cout << "The Perimeter of the Shape One: " << pPerimeterValueOne << endl;
	imageSegmentationDataFile << "The Perimeter of the Shape One: " << pPerimeterValueOne << endl;

	cout << "The Area of the Shape One: " << pAreaValueOne << endl;
	imageSegmentationDataFile << "The Area of the Shape One: " << pAreaValueOne << endl;



	cout << "Printing Image Parameters For Image Two" << endl;
	imageSegmentationDataFile << "Prinitng Image Parameters" << endl;


	cout << "X0 = " << pXPosition << endl;
	cout << "Y0 = " << pYPosition << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Step for X Axis = " << pStepX << endl;
	cout << "Step for Y Axis = " << pStepY << endl;
	cout << "Red Color Value: " << pRedValueToSelect << endl;
	cout << "Green Color Value: " << pGreenValueToSelect << endl;
	cout << "Blue Color Value: " << pGreenValueToSelect << endl;


	imageSegmentationDataFile << "X0 = " << pXPosition << endl;
	imageSegmentationDataFile << "Y0 = " << pYPosition << endl;
	imageSegmentationDataFile << "Image Width = " << pImageWidth << endl;
	imageSegmentationDataFile << "Image Height = " << pImageWidth << endl;
	imageSegmentationDataFile << "Step for X Axis = " << pStepX << endl;
	imageSegmentationDataFile << "Step for Y Axis = " << pStepY << endl;
	imageSegmentationDataFile << "Red Color Value: " << pRedValueToSelect << endl;
	imageSegmentationDataFile << "Green Color Value: " << pGreenValueToSelect << endl;
	imageSegmentationDataFile << "Blue Color Value: " << pGreenValueToSelect << endl;


	cout << "RGB Filter Output Value Image Two" << endl;
	imageSegmentationDataFile << "RGB Filter Output Value Two" << endl;


	for (PixelObject pixelObject : pFilterContainerObjectRestoredOne)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}


	cout << "Result of Averaging" << endl;
	imageSegmentationDataFile << "Result of Averaging" << endl;


	for (PixelObject pixelObject : pPixelObjectSectoredTwo)
	{
		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

		}
	}



	cout << "Printing Sector Clusters Data " << endl;
	imageSegmentationDataFile << "Printing Sector Clusters Data " << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pCommonArrayOutputTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.rValue << endl;
		cout << "Green CompTwont: " << pPixelObject.gValue << endl;
		cout << "Blue CompTwont: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red CompTwont: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green CompTwont: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue CompTwont: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;



	}

	cout << "Printing Sector Two" << endl;
	imageSegmentationDataFile << "Printing Sector Two" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorTwoVectorTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.rValue << endl;
		cout << "Green CompTwont: " << pPixelObject.gValue << endl;
		cout << "Blue CompTwont: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red CompTwont: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green CompTwont: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue CompTwont: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;





	}
	imageSegmentationDataFile << "Sector End" << endl;



	cout << "Printing Sector Two" << endl;
	imageSegmentationDataFile << "Printing Sector Two" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorTwoVectorTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.rValue << endl;
		cout << "Green CompTwont: " << pPixelObject.gValue << endl;
		cout << "Blue CompTwont: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red CompTwont: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green CompTwont: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue CompTwont: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;






	}
	imageSegmentationDataFile << "Sector End" << endl;


	cout << "Printing Sector Three" << endl;
	imageSegmentationDataFile << "Printing Sector Three" << endl;


	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorThreeVectorTwo)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.rValue << endl;
		cout << "Green CompTwont: " << pPixelObject.gValue << endl;
		cout << "Blue CompTwont: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red CompTwont: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green CompTwont: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue CompTwont: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




	}
	imageSegmentationDataFile << "Sector End" << endl;


	cout << "Printing Sector Four" << endl;
	imageSegmentationDataFile << "Printing Sector four" << endl;

	for (OutputPixelObjectWithAngleValues pPixelObject : pSectorFourVectorTwo)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.rValue << endl;
		cout << "Green CompTwont: " << pPixelObject.gValue << endl;
		cout << "Blue CompTwont: " << pPixelObject.bValue << endl;
		cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		cout << "Radius: " << pPixelObject.pRadiusValue << endl;
		cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		cout << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red CompTwont: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green CompTwont: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue CompTwont: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
		imageSegmentationDataFile << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
		imageSegmentationDataFile << "Radius: " << pPixelObject.pRadiusValue << endl;
		imageSegmentationDataFile << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
		imageSegmentationDataFile << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
		imageSegmentationDataFile << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;
		imageSegmentationDataFile << "Pixel Quarter:" << pPixelObject.pQuarterNumberVar << endl;




	}
	imageSegmentationDataFile << "Sector End" << endl;

	cout << "Printing Out Line Segments: " << endl;
	imageSegmentationDataFile << "Printing Out Line Segments: " << endl;

	for (Line2D pLineObject : pLineArrayVectorTwo)
	{
		cout << "Line Number: " << pLineObject.pLineNumber << endl;
		cout << "Point Two: " << endl;;
		cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
		cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
		cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
		cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
		cout << "Point Two: " << endl;;
		cout << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
		cout << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
		cout << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
		cout << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
		cout << "Line Magnitude: " << pLineObject.pLineWidth << endl;

		imageSegmentationDataFile << "Line Number: " << pLineObject.pLineNumber << endl;
		imageSegmentationDataFile << "Point Two: " << endl;;
		imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
		imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
		imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
		imageSegmentationDataFile << "Point Two: " << endl;;
		imageSegmentationDataFile << "Point Number: " << pLineObject.pPointTwo.pPointNumber << endl;
		imageSegmentationDataFile << "X Position: " << pLineObject.pPointTwo.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pLineObject.pPointTwo.yPosition << endl;
		imageSegmentationDataFile << "Point Section: " << pLineObject.pPointTwo.pSectorNumber << endl;
		imageSegmentationDataFile << "Line Magnitude: " << pLineObject.pLineWidth << endl;


	}

	cout << "The Perimeter of the Shape Two: " << pPerimeterValueTwo << endl;
	imageSegmentationDataFile << "The Perimeter of the Shape Two: " << pPerimeterValueTwo << endl;

	cout << "The Area of the Shape Two: " << pAreaValueTwo << endl;
	imageSegmentationDataFile << "The Area of the Shape Two: " << pAreaValueTwo << endl;

	
	return hr;

}











HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPI(HINSTANCE hInstance, HWND hWnd,
	LPWSTR pFileNameVideoEight, LPWSTR pFileNameVideoTwo,
	int pXPosition, int pYPosition, int pImageWidth, int pImageHeight, int pWaitingInterval,
	vector<PixelObject> *pImageOneRGBPixels,
	vector<PixelObject> *pImageTwoRGBPixels,
	vector<PixelObjectGrayScale> *pImageOneGrayScale,
	vector<PixelObjectGrayScale> *pImageTwoGrayScale,
	vector<OutputPixelBuffer> *ppOutputPixelBufferArray,
	vector<PixelObjectGrayScale> *pppIdenticalPixelOutputArray,
	vector<PixelObjectGrayScale> *pppDifferentPixelOutputArray)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerAsynchronousMode.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();





	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}

	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEightNameLocal, pVideoFileTwoNameLocal, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingInterval);




	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}


	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;

	float pIntensitySum0 = 0.0f;
	float pIntensityAverage0 = 0.0f;


	float pIntensitySum1 = 0.0f;
	float pIntensityAverage1 = 0.0f;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
		pIntensitySum0 = pIntensitySum0 + pPixelObject.pGreyLevel;


		pIndexValue++;
	}
	pIntensityAverage0 = pIntensitySum0 / ppImageOneGrayScale.size();

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;


	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pIntensitySum1 = pIntensitySum1 + pPixelObject.pGreyLevel;
		pIndexValue++;
	}

	pIntensityAverage1 = pIntensitySum1 / ppImageTwoGrayScale.size();


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThreadWithRestoration(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, ppOutputPixelValue.pAmountOfDifferentPixels, 33, 66, 100);

		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;

		pIndex++;
	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();


	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}

	pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();

	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();




	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}



	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);


	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();

	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum << ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Creating Visualization Diagram" << endl;



	cout << "Simulation Using Web Has Been Completed" << endl;


	*pImageOneRGBPixels = pixelObjectImageEight;
	*pImageTwoRGBPixels = pixelObjectImageTwo;
	*pImageOneGrayScale = ppImageOneGrayScale;
	*pImageTwoGrayScale = ppImageTwoGrayScale;
	*ppOutputPixelBufferArray = ppVerificationOutputArray;
	*pppIdenticalPixelOutputArray = ppIdenticalPixelOutputArray;
	*pppDifferentPixelOutputArray = ppDifferentPixelOutputArray;

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPIUsingSemaphores(HINSTANCE hInstance, HWND hWnd,
	LPWSTR pFileNameVideoEight, LPWSTR pFileNameVideoTwo,
	int pXPosition, int pYPosition, int pImageWidth, int pImageHeight, int pWaitingInterval,
	vector<PixelObject> *pImageOneRGBPixels,
	vector<PixelObject> *pImageTwoRGBPixels,
	vector<PixelObjectGrayScale> *pImageOneGrayScale,
	vector<PixelObjectGrayScale> *pImageTwoGrayScale,
	vector<OutputPixelBuffer> *ppOutputPixelBufferArray,
	vector<PixelObjectGrayScale> *pppIdenticalPixelOutputArray,
	vector<PixelObjectGrayScale> *pppDifferentPixelOutputArray)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerAsynchronousMode.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();





	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}

	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEightNameLocal, pVideoFileTwoNameLocal, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingInterval);




	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThread(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

	
		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, ppOutputPixelValue.pAmountOfDifferentPixels, 33, 66, 100);




		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();




	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}



	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);


	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();

	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum << ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Creating Visualization Diagram" << endl;



	cout << "Simulation Using Web Has Been Completed" << endl;


	*pImageOneRGBPixels = pixelObjectImageEight;
	*pImageTwoRGBPixels = pixelObjectImageTwo;
	*pImageOneGrayScale = ppImageOneGrayScale;
	*pImageTwoGrayScale = ppImageTwoGrayScale;
	*ppOutputPixelBufferArray = ppVerificationOutputArray;
	*pppIdenticalPixelOutputArray = ppIdenticalPixelOutputArray;
	*pppDifferentPixelOutputArray = ppDifferentPixelOutputArray;

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPICriticalSections(HINSTANCE hInstance, HWND hWnd,
	LPWSTR pFileNameVideoEight, LPWSTR pFileNameVideoTwo,
	int pXPosition, int pYPosition, int pImageWidth, int pImageHeight, int pWaitingInterval,
	vector<PixelObject> *pImageOneRGBPixels,
	vector<PixelObject> *pImageTwoRGBPixels,
	vector<PixelObjectGrayScale> *pImageOneGrayScale,
	vector<PixelObjectGrayScale> *pImageTwoGrayScale,
	vector<OutputPixelBuffer> *ppOutputPixelBufferArray,
	vector<PixelObjectGrayScale> *pppIdenticalPixelOutputArray,
	vector<PixelObjectGrayScale> *pppDifferentPixelOutputArray)
{
	HRESULT hr = S_OK;

	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerAsynchronousMode.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();





	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}


	HANDLE pVideoPreparationState = CreateEventA(NULL, TRUE, FALSE, (LPCSTR)L"VideoPreparation");
	SetEvent(pVideoPreparationState);



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pFileNameVideoEight, pFileNameVideoTwo, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingInterval);

	CloseHandle(pVideoPreparationState);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);



	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;


	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThread(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);




	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();



	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}



	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);


	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();

	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum << ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Creating Visualization Diagram" << endl;

	if (pDifferentPixelArrayAverage >= 66)
	{
		md2dmanager->DrawRoadSignVertical(hInstance, hWnd, 0, 100);
	}
	else if (pDifferentPixelArrayAverage >= 33 && pDifferentPixelArrayAverage < 66)
	{
		md2dmanager->DrawRoadSignVertical(hInstance, hWnd, 0, 50);
	}
	else if (pDifferentPixelArrayAverage >= 0 && pDifferentPixelArrayAverage < 33)
	{
		md2dmanager->DrawRoadSignVertical(hInstance, hWnd, 0, 0);
	}


	cout << "Simulation Using Web Has Been Completed" << endl;


	*pImageOneRGBPixels = pixelObjectImageEight;
	*pImageTwoRGBPixels = pixelObjectImageTwo;
	*pImageOneGrayScale = ppImageOneGrayScale;
	*pImageTwoGrayScale = ppImageTwoGrayScale;
	*ppOutputPixelBufferArray = ppVerificationOutputArray;
	*pppIdenticalPixelOutputArray = ppIdenticalPixelOutputArray;
	*pppDifferentPixelOutputArray = ppDifferentPixelOutputArray;
	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToYCBCRColorSpace(HINSTANCE hInstance, HWND hWnd)
{
	
		HRESULT hr = S_OK;
		LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
		DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		fstream pixelDataFile;
		pixelDataFile.open("C:\\pixels\\ConvertImageToYCBCRColorSpace.txt", fstream::in | fstream::out | fstream::trunc);
		pixelDataFile.clear();

		vector<PixelObject> pixelObjectVector = vector<PixelObject>();
		vector<YCBRPixelDataBuffer> pPixelObjectYCBCRBuffer = vector<YCBRPixelDataBuffer>();


		UINT pImageWidth = 0;
		UINT pImageHeight = 0;
		ID2D1Bitmap* pBitmapData = nullptr;
		UINT pTopLeftX = 0;
		UINT pTopLeftY = 0;
		cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftX;
		cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
		cin >> pTopLeftY;


		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageWidth;

		cout << "Enter the Width of Image Sector" << endl;
		cin >> pImageHeight;

		LPWSTR path = nullptr;

		OPENFILENAMEW ofn;
		ZeroMemory(&ofn, sizeof(ofn));
		ofn.lStructSize = sizeof(ofn);
		ofn.hwndOwner = hWnd;
		ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
		ofn.lpstrFile = path;
		ofn.nMaxFile = MAX_PATH;
		ofn.Flags = OFN_FILEMUSTEXIST;
		ofn.hInstance = hInstance;


		SYSTEMTIME st, lt, st1, lt1;
		GetSystemTime(&st);
		GetLocalTime(&lt);

		cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


		if (GetOpenFileNameW(&ofn))
		{



			HRESULT hr = S_OK;

			Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

			pixelDataFile << "New Image Clip" << endl;


			hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

			cout << "Printing the Contents of Clipped Area" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVector)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Index: " << pIndex << endl;
				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}
		}

		fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
		UINT pIndexValue = 0;
		cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

		hr = ppStandardAlgorithmExecutor->ConvertRGBImageToYCbCrColorSpace(hInstance, hWnd,
			pixelObjectVector, &pPixelObjectYCBCRBuffer);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

		for (YCBRPixelDataBuffer pPixelObject : pPixelObjectYCBCRBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Component: " << pPixelObject.pYValue << endl;
			cout << "Cb Component: " << pPixelObject.pCbValue << endl;
			cout << "Cr Component: " << pPixelObject.pCrValue << endl;

			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
			pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
			pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

		}


	
		return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateWaitableTimerOperationForRobotCleanerSkype(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pTimerDurationInSeconds = 0;
	int pAmountInNanoseconds = 0;
	int pAmountInMiliseconds = 0;
	int pTimerDurationInMilliseconds = 0;

	SYSTEMTIME st;
	SYSTEMTIME lt;
	HANDLE pVideoEightEvent = INVALID_HANDLE_VALUE;
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerWaitableTimerControl.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	LPWSTR pDirectory = L"C:\\RobotData\\Skype\\Videos";
	LPWSTR pFileNameEight = L"C:\\RobotData\\Skype\\Videos\\VideoFTP1.mp4";
	LPWSTR pFileNameTwo = L"C:\\RobotData\\Skype\\Videos\\VideoFTP2.mp4";
	LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
	LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";


	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue0;
	cout << "Enter the timer interval in seconds" << endl;
	cin >> pTimerDurationInSeconds;


	cout << "Hour to Execute Timer: " << pHourValue0 << endl;
	cout << "Minute to Execute Timer: " << pMinuteValue0 << endl;
	cout << "Timer Interval: " << pTimerDurationInSeconds << endl;



	const int unitsPerSecond = pTimerDurationInSeconds * 1000 * 1000 * -1; // 100 nano seconds
	cout << "Interval In Milliseconds: " << pTimerDurationInMilliseconds << endl;
	imageSegmentationDataFile << "Interval In Milliseconds: " << pTimerDurationInMilliseconds << endl;




	cout << "Amount of Time In Nano Seconds = " << pAmountInNanoseconds << endl;
	imageSegmentationDataFile << "Amount of Time In Nano Seconds = " << pAmountInNanoseconds << endl;

	LARGE_INTEGER pTimerDurationVal;
	pTimerDurationVal.QuadPart = unitsPerSecond;

	BOOL pResult = TRUE;

	HANDLE pMutexEvent = INVALID_HANDLE_VALUE;
	HANDLE pTimerEvent = INVALID_HANDLE_VALUE;
	HANDLE pTimerQueue = INVALID_HANDLE_VALUE;
	SYSTEMTIME pLocalTime;
	SYSTEMTIME pSystemTime;



	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pCentreX = monitorWidth / 2;
	int pCentreY = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;

	cout << "Your Monitor Width = " << monitorWidth << endl;
	cout << "Your Monitor Heigh = " << monitorHeight << endl;
	cout << "Centre Of The Monitor X = " << pCentreX << endl;
	cout << "Centre of the Monitor Y" << pCentreY << endl;



	imageSegmentationDataFile << "Your Monitor Width = " << monitorWidth << endl;
	imageSegmentationDataFile << "Your Monitor Heigh = " << monitorHeight << endl;
	imageSegmentationDataFile << "Centre Of The Monitor X = " << pCentreX << endl;
	imageSegmentationDataFile << "Centre of the Monitor Y" << pCentreY << endl;

	vector<OutputPixelBuffer> pOutputImageVector = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pIdenticalImageVector = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentImageVector = vector<PixelObjectGrayScale>();


	try
	{





		MYDATAVAR pMyDataVar;


		cout << "Recoring Video Eight " << endl;
		BOOL pTimerResult = FALSE;



		// declaring argument of time() 


		pTimerEvent = CreateWaitableTimer(NULL, TRUE, NULL);
		LARGE_INTEGER   liDueTime;

		liDueTime.QuadPart = -1 * pTimerDurationInSeconds * 100000000LL;

		BOOL pSetWaitableTimer = FALSE;




		try
		{







			cout << "Recoring Video Eight " << endl;

			for (;;)
			{
				GetSystemTime(&st);
				GetLocalTime(&lt);

				printf("The system time is: %02d:%02d:%02d\n", st.wHour, st.wMinute, st.wSecond);
				printf(" The local time is: %02d:%02d:%02d\n", lt.wHour, lt.wMinute, lt.wSecond);




				if (lt.wHour >= pHourValue0 && lt.wMinute >= pMinuteValue0)
				{
					
					if (pTimerEvent != NULL)
					{
						pSetWaitableTimer = SetWaitableTimer(pTimerEvent,
							&liDueTime,
							0,
							NULL,
							NULL,
							false);
					}

					break;

				}
				else
				{
					cout << "Waiting for recording session 1" << endl;
					WaitForSingleObject(pVideoEightEvent, 0);
				}

			}

			// declaring argument of time() 

			CloseHandle(pVideoEightEvent);
		}
		catch (std::exception ex)
		{
			throw ex;
		}


	

		}

	catch (std::exception ex)
	{
		throw ex;
	}
	return hr;



	}
	



























HRESULT DirectXGPUDigitalLabCoreModule::SimulateBehaviourOfRobotCleanerUsingSemaphores(HINSTANCE hInstance,
	HWND hWnd)
{

	HRESULT hr = S_OK;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerSemaphoresObject.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();




	SYSTEMTIME st;
	SYSTEMTIME lt;
	GetSystemTime(&st);
	GetLocalTime(&lt);
	printf("The system time is: %02d:%02d:%02d\n", st.wHour, st.wMinute, st.wSecond);
	printf(" The local time is: %02d:%02d:%02d\n", lt.wHour, lt.wMinute, lt.wSecond);


	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pCentreX = monitorWidth / 2;
	int pCentreY = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;
	int pWaitingIntervalInSeconds = 0;

	HANDLE pSemaphoreObject = INVALID_HANDLE_VALUE;
	HANDLE pMutexObject = INVALID_HANDLE_VALUE;
	HANDLE pThreadObject = INVALID_HANDLE_VALUE;
	DWORD dwThreadId = 0;

	cout << "Your Monitor Width = " << monitorWidth << endl;
	cout << "Your Monitor Heigh = " << monitorHeight << endl;
	cout << "Centre Of The Monitor X = " << pCentreX << endl;
	cout << "Centre of the Monitor Y" << pCentreY << endl;

	cout << "Load Images from Preloaded Video Files" << endl;

	cout << "Input the Waiting Interval Value In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";



	vector<PixelObject> pRGBImageEight = vector<PixelObject>();
	vector<PixelObject> pRGBImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> pGrayScaleImageEight = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pGrayScaleImageTwo = vector<PixelObjectGrayScale>();


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}




	cout << "Download Video Number Eight" << endl;


	pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}


	HANDLE pVideoPreparationState = CreateEventA(NULL, TRUE, FALSE, (LPCSTR)L"VideoPreparation");
	SetEvent(pVideoPreparationState);



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEightNameLocal, pVideoFileTwoNameLocal, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingIntervalInSeconds);

	CloseHandle(pVideoPreparationState);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;

	HANDLE pDirect2DDeviceCheck = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"Direct2DDeviceCheck");
	SetEvent(pDirect2DDeviceCheck);



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	CloseHandle(pDirect2DDeviceCheck);

	HANDLE pImageOneClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageEightClippingEvent");
	SetEvent(pImageOneClippingEvent);


	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;






	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pCentreX, pCentreY, pImageWidth, pImageHeight, &pRGBImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pRGBImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	CloseHandle(pImageOneClippingEvent);

	HANDLE pImageTwoClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageTwoClippingEvent");
	SetEvent(pImageTwoClippingEvent);

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pCentreX, pCentreY, pImageWidth, pImageHeight, &pRGBImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pRGBImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	CloseHandle(pImageTwoClippingEvent);

	cout << "First We Will Create A Semaphore Object" << endl;

	pCommonPixelObjectArrayEight = pRGBImageEight;
	pCommonPixelObjectArrayTwo = pRGBImageTwo;



	pSemaphoreObjectGlobal = CreateSemaphore(NULL, 1, 1,
		L"RobotCleanerSemaphor");

	if (pSemaphoreObjectGlobal == NULL)
	{
		int pLastErrorValue = GetLastError();
		cout << "Unable to Create Semaphore Object Error: " << pLastErrorValue << endl;
		imageSegmentationDataFile << "Unable to Create Semaphore Object Error: " << pLastErrorValue << endl;

	}


	cout << "Our Next Step is to create A mutex Object FOR" << endl;
	cout << "Creating Mutex Object" << endl;

	pMutexObjectGlobal = CreateMutex(NULL, FALSE, L"MutexObject");

	cout << "Creating Thread Object for Image Comparison" << endl;
	pThreadObject = CreateThread(
		NULL, // атрибуты безопасности по умолчанию 
		0, // использовать размер стека по умолчанию   
		CompareImagesThreadFunctionSemaphores,
		hWnd,
		0,
		&dwThreadId); // возвращает идентификатор потока  // функция потока 
	WaitForSingleObject(pThreadObject, INFINITE);

	CloseHandle(pThreadObject);
	CloseHandle(pMutexObjectGlobal);
	CloseHandle(pSemaphoreObjectGlobal);
	pIndex = 0;
	cout << "Grayscale Array Eight Image Data" << endl;
	imageSegmentationDataFile << "Grayscale Array Eight Image Data" << endl;

	for (PixelObjectGrayScale pPixelObject : pCommonPixelObjectArrayEightGrayScale)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;


		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndex << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



	}

	cout << "Grayscale Array two Image Data" << endl;
	imageSegmentationDataFile << "Grayscale Array two Image Data" << endl;

	for (PixelObjectGrayScale pPixelObject : pCommonPixelObjectArrayTwoGrayScale)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelNumber << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



	}

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : pOutputImageComparisonArrayGlobal)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		if (ppOutputPixelValue.outputComparisonValue == 0)
		{
			hr = md2dmanager->DrawRoadSign(hInstance, hWnd, 0);

			HWND hListBox = NULL;
			hListBox = CreateWindow(L"listbox", NULL,
				WS_CHILD | WS_VISIBLE | LBS_STANDARD |
				LBS_WANTKEYBOARDINPUT,
				30, 30, 200, 100,
				hWnd, (HMENU)ID_LIST, hInstance, NULL);

			// Отменяем режим перерисовки списка
			SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
			// Добавляем в список несколько строк

			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Green - Intensity <= 33");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Red - Intensity <= 100");
		}

		if (ppOutputPixelValue.outputComparisonValue > 0)
		{
			hr = md2dmanager->DrawRoadSign(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);

			HWND hListBox = NULL;
			hListBox = CreateWindow(L"listbox", NULL,
				WS_CHILD | WS_VISIBLE | LBS_STANDARD |
				LBS_WANTKEYBOARDINPUT,
				30, 30, 200, 100,
				hWnd, (HMENU)ID_LIST, hInstance, NULL);

			// Отменяем режим перерисовки списка
			SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
			// Добавляем в список несколько строк

			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Green - Intensity <= 33");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Red - Intensity <= 100");
		}


		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : pIdenticalPixelObjectArrayGlobal)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : pDifferentPixelObjectArrayGlobal)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}

	imageSegmentationDataFile.close();
	return hr;

}




DWORD WINAPI CompareImagesThreadFunctionSemaphores(LPVOID lParam)
{
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	pCommonPixelObjectArrayEightGrayScale = vector<PixelObjectGrayScale>();
	pCommonPixelObjectArrayTwoGrayScale = vector<PixelObjectGrayScale>();
	pOutputImageComparisonArrayGlobal = vector<OutputPixelBuffer>();
	pIdenticalPixelObjectArrayGlobal = vector<PixelObjectGrayScale>();
	pDifferentPixelObjectArrayGlobal = vector<PixelObjectGrayScale>();


	WaitForSingleObject(pSemaphoreObjectGlobal, INFINITE);
	WaitForSingleObject(pMutexObjectGlobal, INFINITE);


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOperationThreadedInternal.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;


	if (pCommonPixelObjectArrayEight.size() == 0 || pCommonPixelObjectArrayTwo.size() == 0)
	{
		cout << "Data Processing Containers are empty" << endl;
		pResult = -1;
		return pResult;
	}


	cout << "Simulating the Image Subtraction Operation" << endl;

	cout << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (PixelObject pixelObject : pCommonPixelObjectArrayEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Printing Array Eight" << endl;

	pIndex = 0;
	for (PixelObject pixelObject : pCommonPixelObjectArrayTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	vector<PixelObject> ppImageTwoRGB = vector<PixelObject>();

	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();





	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = pAlgorithmManagerInternal->ConvertImageDataToGrayScale(hInstance, hWnd,
		pCommonPixelObjectArrayEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pCommonPixelObjectArrayEightGrayScale.push_back(pPixelObject);
		pIndexValue++;
	}







	hr = pAlgorithmManagerInternal->ConvertImageDataToGrayScale(hInstance, pGlobalWindow,
		pCommonPixelObjectArrayTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pCommonPixelObjectArrayTwoGrayScale.push_back(pPixelObject);
		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = pAlgorithmManagerInternal->CheckIfImagesAreIdentical(hInstance, pGlobalWindow, 10, 10, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pOutputImageComparisonArrayGlobal.push_back(ppOutputPixelValue);
		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelObjectArrayGlobal.push_back(pIdenticalPixelObject);
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelObjectArrayGlobal.push_back(pDifferentPixelObject);
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();

	ReleaseMutex(pMutexObjectGlobal);
	ReleaseSemaphore(pSemaphoreObjectGlobal, 1, 0);


	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToGrayScaleInAMutex(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToGrayScaleInAMutex.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScaleRestored = vector<PixelObjectGrayScale>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	SYSTEMTIME st1;
	SYSTEMTIME lt1;

	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	printf("The system time is: %02d:%02d:%02d\n", st1.wHour, st1.wMinute, st1.wSecond);
	printf(" The local time is: %02d:%02d:%02d\n", lt1.wHour, lt1.wMinute, lt1.wSecond);

	pixelDataFile << "The system time is: %02d:%02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << "The Local time is: %02d:%02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleInAMutex(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		int pixelNumberValue = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "Pixel Number = " << pixelNumberValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



		pIndexValue++;
	}


	SYSTEMTIME st2;
	SYSTEMTIME lt2;

	GetSystemTime(&st2);
	GetLocalTime(&lt2);

	printf("Operation Started: %02d:%02d:%02d\n", st1.wHour, st1.wMinute, st1.wSecond);
	printf(" Operation Started: %02d:%02d:%02d\n", lt1.wHour, lt1.wMinute, lt1.wSecond);

	pixelDataFile << "Operation Started: %02d:%02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << "Operation Started: %02d:%02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;


	printf("Operation Terminated: %02d:%02d:%02d\n", st2.wHour, st2.wMinute, st2.wSecond);
	printf(" Operation Terminated: %02d:%02d:%02d\n", lt2.wHour, lt2.wMinute, lt2.wSecond);

	pixelDataFile << "Operation Terminated: %02d:%02d:%02d\n" << st2.wHour << ":" << st2.wMinute << ":" << st2.wSecond << endl;
	pixelDataFile << "Operation Terminated: %02d:%02d:%02d\n" << lt2.wHour << ":" << lt2.wMinute << ":" << lt2.wSecond << endl;

	int pSeconds = lt2.wSecond - lt1.wSecond;
	cout << "Duration of GrayScale Operation in Seconds = " << pSeconds << endl;
	pixelDataFile << "Duration of GrayScale Operation in Seconds = " << pSeconds << endl;



	pixelDataFile.close();


	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerAsyncronousModeSkypeDemoWithCriticalSections(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	WIN32_FIND_DATA ffd;
	WIN32_FIND_DATA ffdFiles;

	LARGE_INTEGER filesize;
	TCHAR szDir[MAX_PATH];
	size_t  length_of_arg;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError = 0;

	LPWSTR pDirectory = L"C:\\RobotData\\Skype\\Videos";
	LPWSTR pFileNameEight = L"C:\\RobotData\\Skype\\Videos\\VideoFTP1.mp4";
	LPWSTR pFileNameTwo = L"C:\\RobotData\\Skype\\Videos\\VideoFTP2.mp4";
	LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
	LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";
	int pXPosition = 601;
	int pYPosition = 657;

	vector<WCHAR*> pFileNames = vector<WCHAR*>();

	vector<PixelObject> pRGBImageEight = vector<PixelObject>();
	vector<PixelObject> pRGBImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> pGrayScaleImageEight = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pGrayScaleImageTwo = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> pOutputPixelDataBuffer = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pIdenticalPixelDataBuffer = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentPixelDataBuffer = vector<PixelObjectGrayScale>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerSkypeFolderWithCrtiticalSections.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();



	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pCentreX = monitorWidth / 2;
	int pCentreY = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;

	cout << "Your Monitor Width = " << monitorWidth << endl;
	cout << "Your Monitor Heigh = " << monitorHeight << endl;
	cout << "Centre Of The Monitor X = " << pCentreX << endl;
	cout << "Centre of the Monitor Y" << pCentreY << endl;



	int pWaitingIntervalInSeconds = 0;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	cout << "X Position for Image Clip = " << pXPosition << endl;
	cout << "Y Position for Image Clip = " << pYPosition << endl;
	cout << "Image Width For the Clip Used = " << pImageWidth << endl;
	cout << "Image Height For the Clip Used = " << pImageHeight << endl;
	cout << "Waiting Interval = " << pWaitingIntervalInSeconds << endl;


	// If the directory is not specified as a command-line argument,
	// print usage.


	// Check that the input path plus 3 is not longer than MAX_PATH.
	// Three characters are for the "\*" plus NULL appended below.

	StringCchLength(pFileNameEight, MAX_PATH, &length_of_arg);

	if (length_of_arg > (MAX_PATH - 3))
	{
		_tprintf(TEXT("\nDirectory path is too long.\n"));
		hr = E_INVALIDARG;
		return hr;
	}

	_tprintf(TEXT("\nTarget directory is %s\n\n"), pDirectory);

	// Prepare string for use with FindFile functions.  First, copy the
	// string to a buffer, then append '\*' to the directory name.


	// Find the first file in the directory.

	hFind = FindFirstFile(pDirectory, &ffd);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
		return dwError;
	}

	// List all the files in the directory with some info about them.

	do
	{
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);
			hFind = FindFirstFile(pDirectory, &ffdFiles);
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);

		}
		else
		{
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);
		}

		BOOL pResult = PathFileExists(pFileNameEight);

		if (pResult == TRUE)
		{


			hr = SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPICriticalSections(hInstance,
				hWnd,
				pFileNameEight,
				pFileNameTwo,
				pCentreX,
				pCentreY,
				pImageWidth,
				pImageHeight,
				pWaitingIntervalInSeconds,
				&pRGBImageEight,
				&pRGBImageTwo,
				&pGrayScaleImageEight,
				&pGrayScaleImageTwo,
				&pOutputPixelDataBuffer,
				&pIdenticalPixelDataBuffer,
				&pDifferentPixelDataBuffer);



			cout << "RGB Array Eight" << endl;
			int pIndex = 0;

			for (PixelObject pixelObject : pRGBImageEight)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
				pIndex++;


			}

			cout << "RGB Array Two" << endl;
			pIndex = 0;

			for (PixelObject pixelObject : pRGBImageTwo)
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
				pIndex++;



			}


			cout << "Printing the Output of Grayscale Array Eight" << endl;
			imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
			for (PixelObjectGrayScale pIdenticalPixelObject : pGrayScaleImageEight)
			{
				cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
				cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
				cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
				cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


				imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
				imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
			}

			cout << "Printing the Output of Grayscale Array Two" << endl;
			imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
			for (PixelObjectGrayScale pIdenticalPixelObject : pGrayScaleImageTwo)
			{
				cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
				cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
				cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
				cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


				imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
				imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
			}



			int pIntensitySummation = 0;
			pIndex = 0;
			cout << "Printing out the Output the Experiment" << endl;
			for (OutputPixelBuffer ppOutputPixelValue : pOutputPixelDataBuffer)
			{
				cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
				cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
				cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
				cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
				cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
				cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
				cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
				cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
				cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

				imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
				imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
				imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
				imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
				imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
				imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
				imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

				pIndex++;
			}

			cout << "Printing the Output of Identical Pixels Array" << endl;
			imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
			for (PixelObjectGrayScale pIdenticalPixelObject : pIdenticalPixelDataBuffer)
			{
				cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
				cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
				cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
				cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


				imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
				imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
			}

			cout << "Printing the Output of Different Pixels Array" << endl;
			imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
			for (PixelObjectGrayScale pDifferentPixelObject : pDifferentPixelDataBuffer)
			{


				cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
				cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
				cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
				cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

				imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
				imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
			}



			imageSegmentationDataFile.close();



			break;
		}


	} while (FindNextFile(hFind, &ffd) != 0);

	dwError = GetLastError();
	if (dwError != ERROR_NO_MORE_FILES)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
	}

	FindClose(hFind);
	return dwError;
}


HRESULT DirectXGPUDigitalLabCoreModule::SegmentImageIntoRectangularSectors(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalThreaded(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

		auto start = high_resolution_clock::now();


	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThread(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	pIdenticalPixelOutputArraySum = 0.0f;
	pIdenticalPixelArrayAverage = 0.0f;
	pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSign(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);


	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}



	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}






HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalThreadedOnGPU(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFileWithRestorationOnGPUThreadedVersion.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	auto start = high_resolution_clock::now();


	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThreadWithRestoration(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	pIdenticalPixelOutputArraySum = 0.0f;
	pIdenticalPixelArrayAverage = 0.0f;
	pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSign(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);


	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}



	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}


HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalInAThreadPool(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFileUsingThreadPoolTech.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThreadPool(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	pIdenticalPixelOutputArraySum = 0.0f;
	pIdenticalPixelArrayAverage = 0.0f;
	pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSign(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);


	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}



	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}






HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalInAThreadPoolViaClassOfMathtmaticalModels(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXMathematicalModelsManagementClass* ppStandardAlgorithmExecutor = new DirectXMathematicalModelsManagementClass(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFileUsingThreadPoolTech.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalInAThreadPool(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	pIdenticalPixelOutputArraySum = 0.0f;
	pIdenticalPixelArrayAverage = 0.0f;
	pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSign(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);


	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}



	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}

HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalRGBThreadedWithPixelMarking(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFileWithPixelMarkings.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}









	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();




	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;




	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance,
		hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\PixelMarkings.jpg");



	imageSegmentationDataFile.close();

	return hr;



}


HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalApi(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> ppArrayEight,
	vector<PixelObjectGrayScale> ppArrayTwo,
	vector<OutputPixelBuffer> *ppOutputPixelGrayScale,
	vector<PixelObjectGrayScale> *ppIdenticalPixelVarables,
	vector<PixelObjectGrayScale> *ppDifferentPixelVariables)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	if (pAlgorithmManagerInternal != nullptr)
	{
		SafeDelete(pAlgorithmManagerInternal);

	}
	pAlgorithmManagerInternal = new DirectXStandardAlgorithmExecutor(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;








	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> pVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;
	int pImageWidth = 10;
	int pImageHeight = 10;

	hr = pAlgorithmManagerInternal->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppArrayEight,
		ppArrayTwo, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &pVerificationOutputArray,
		&pIdenticalPixelOutputArray, &pDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	pIdenticalPixelOutputArraySum = 0.0f;
	pIdenticalPixelArrayAverage = 0.0f;
	pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;

	cout << "Printing out the Output the Experiment" << endl;
	int pIndex = 0;

	for (OutputPixelBuffer ppOutputPixelValue : pVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		if (ppOutputPixelValue.outputComparisonValue == 0)
		{
			hr = md2dmanager->DrawRoadSign(hInstance, hWnd, 0);

			HWND hListBox = NULL;
			hListBox = CreateWindow(L"listbox", NULL,
				WS_CHILD | WS_VISIBLE | LBS_STANDARD |
				LBS_WANTKEYBOARDINPUT,
				30, 30, 200, 100,
				hWnd, (HMENU)ID_LIST, hInstance, NULL);

			// Отменяем режим перерисовки списка
			SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
			// Добавляем в список несколько строк

			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Green - Intensity <= 33");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Red - Intensity <= 100");
		}

		if (ppOutputPixelValue.outputComparisonValue > 0)
		{
			hr = md2dmanager->DrawRoadSign(hInstance, hWnd, 100);

			HWND hListBox = NULL;
			hListBox = CreateWindow(L"listbox", NULL,
				WS_CHILD | WS_VISIBLE | LBS_STANDARD |
				LBS_WANTKEYBOARDINPUT,
				30, 30, 200, 100,
				hWnd, (HMENU)ID_LIST, hInstance, NULL);

			// Отменяем режим перерисовки списка
			SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
			// Добавляем в список несколько строк

			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Green - Intensity <= 33");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
			SendMessage(hListBox, LB_ADDSTRING, 0,
				(LPARAM)(LPSTR)L"Red - Intensity <= 100");
		}

		UpdateWindow(hWnd);
	}

	pOutputArrayAverage = pOutputArrayIntensitySum / pVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : pIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (pIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / pIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : pDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (pDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / pDifferentPixelOutputArray.size();
	}



	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << pVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << pVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << pIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << pIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << pDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << pDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();
	*ppOutputPixelGrayScale = pVerificationOutputArray;
	*ppIdenticalPixelVarables = pIdenticalPixelOutputArray;
	*ppDifferentPixelVariables = pDifferentPixelOutputArray;
	SafeDelete(pAlgorithmManagerInternal);

	return hr;
}


stack<int> DirectXGPUDigitalLabCoreModule::ConvertIntToStack(int pNumber)
{
	stack<int> pDigits;
	std::stack<int> sd;

	while (pNumber > 0)
	{
		int digit = pNumber % 10;
		pNumber /= 10;
		pDigits.push(digit);
	}

	return sd;

}




HRESULT DirectXGPUDigitalLabCoreModule::ExperimentWithComplexNumbers(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	float pBase0 = 0.0f;
	float pMantissa0 = 0.0f;
	float pBase1 = 0.0f;
	float pMantissa1 = 0.0f;

	cout << "Enter the Value for Base Eight: " << endl;
	cin >> pBase0;
	cout << "Enter the Value for Mantissa Eight: " << endl;
	cin >> pMantissa0;


	cout << "Enter the Value for Base Eight: " << endl;
	cin >> pBase1;
	cout << "Enter the Value for Mantissa Eight: " << endl;
	cin >> pMantissa1;

	std::complex<float> pNumberEight(pBase0, pMantissa0);
	std::complex<float> pNumberTwo(pBase1, pMantissa1);
	std::complex<float> pNumberSum;
	std::complex<float> pNumberSubtraction;
	std::complex<float> pNumberMultiplication;
	std::complex<float> pNumberDivision;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	ppStandardAlgorithmExecutor->ExperimentWithComplexNumbers(hInstance, hWnd,
		pNumberEight,
		pNumberTwo,
		&pNumberSum,
		&pNumberSubtraction,
		&pNumberMultiplication,
		&pNumberDivision);
	
	cout << "Sum Value: " << pNumberSum << endl;
	cout << "Subtraction Value: " << pNumberSubtraction << endl;
	cout << "Multiplication Value: " << pNumberMultiplication << endl;
	cout << "Division Value: " << pNumberDivision << endl;

	return hr;
}













HRESULT DirectXGPUDigitalLabCoreModule::CompressRGBPixelVectorToImageFile(HINSTANCE hInstance, HWND hWnd, UINT pImageWidth, UINT pImageHeight, vector<PixelObject> pPixelObjectArray, LPCWSTR pImageFile)
{
	
	HRESULT hr = S_OK;

	vector<float> pYCompEighttArray = vector<float>();
	vector<float> pCBComponentArray = vector<float>();
	vector<float> pCRCompEighttArray = vector<float>();

	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\CompressionOfPixelArrayToImageFile.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCRBuffer = vector<YCBRPixelDataBuffer>();


	for (PixelObject pixelObject : pPixelObjectArray)
		{
			
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	


	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertRGBImageToYCbCrColorSpace(hInstance, hWnd,
		pPixelObjectArray, &pPixelObjectYCBCRBuffer);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (YCBRPixelDataBuffer pPixelObject : pPixelObjectYCBCRBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}




	cout << "Subtracting 128 from every Value" << endl;
	cbSubtractionBuffer pSubtractionBuffer;
	pSubtractionBuffer.pItemToSubtract = 128;;

	vector<YCBRPixelDataBuffer> pOutputDataArraySubtraction = vector<YCBRPixelDataBuffer>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageSubtraction(hInstance, hWnd,
		pPixelObjectYCBCRBuffer, pSubtractionBuffer,
		&pOutputDataArraySubtraction);

	for (YCBRPixelDataBuffer pPixelObject : pOutputDataArraySubtraction)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	vector<YCBRPixelDataBufferOutputCosine> pCosineTransformArray = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;
	pixelDataFile << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;


	cbCostantBufferCosine pConstantBufferCosine;
	pConstantBufferCosine.pi_var = DirectX::XM_PI;
	pConstantBufferCosine.pImageHeightVar = pImageHeight;
	pConstantBufferCosine.pImageWidthVar = pImageWidth;

	hr = ppStandardAlgorithmExecutor->ApplyDiscreteCosineTransformAlgorithm(hInstance,
		hWnd, pConstantBufferCosine, pOutputDataArraySubtraction, &pCosineTransformArray);

	cout << "Printing Output of the Cosine function:" << endl;
	pixelDataFile << "Printing Output of the Cosine function:" << endl;


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pCosineTransformArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



	}
	//Применяем Косинусное Преобразование



	//Заполняем решетку квантования
	cout << "Multiplying the YCBCR Image By A Kernel" << endl;
	pixelDataFile << "Multiplying the YCBCR Image By A Kernel" << endl;
	vector<QuantizationItem> ppQuantizationKernelArray = vector<QuantizationItem>();
	cout << "Computing the Quantization Matrix VariablE array" << endl;
	int pAmountOfItemToCompute = 8 * 8;
	int pIndex = 0;
	float pMatrixVar = 0.0f;
	float pXPositionVar = pXPositionVar;
	float pYPositionVar = pYPositionVar;

	float pQuontizationTable[64] = {
		16, 11, 10, 16, 24, 40, 51, 61,

		12, 12, 14, 19, 26, 58, 60, 55,

		14, 13, 16, 24, 40, 57, 69, 56,

		14, 17, 22, 29, 51, 87, 80, 62,

		18, 22, 37, 56, 68, 109, 103, 77,

		24, 35, 55, 64, 81, 104, 113, 92,

		49, 64, 78, 87, 103, 121, 120, 101,

		72, 92, 95, 98, 112, 100, 103, 99 };


	float pArrayMat[8][8];


	for (int pXIndex = 0; pXIndex < 8; ++pXIndex)
	{
		for (int pYIndex = 0; pYIndex < 8; ++pYIndex)
		{
			pArrayMat[pXIndex][pYIndex] = pQuontizationTable[pYIndex * 8 + pXIndex];
		}
	}
	vector<float> pQuontizationVector = vector<float>();







	pIndex = 0;
	int pPixelIndex = 0;
	int pXPosition0 = 0;
	int pYPosition0 = 0;

	do
	{
		QuantizationItem pQuontizationItem;
		pQuontizationItem.pPixelNumber = pPixelIndex;
		pQuontizationItem.pXPosition = pXPosition0;
		pQuontizationItem.pYPosition = pYPosition0;
		pQuontizationItem.pQuontizationValue = pArrayMat[pXPosition0][pYPosition0];
		pPixelIndex++;
		pXPosition0 = pXPosition0 + 1;
		if (pXPosition0 == 8)
		{
			pYPosition0 = pYPosition0 + 1;
			pXPosition0 = 0;
		}

		ppQuantizationKernelArray.push_back(pQuontizationItem);

	} while (pXPosition0 < 8 && pYPosition0 < 8);




	cout << "Printing the Kernel Gate" << endl;
	pixelDataFile << "Printing the Kernel Gate" << endl;
	for (QuantizationItem pItemInCollection : ppQuantizationKernelArray)
	{
		cout << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		cout << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		cout << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		cout << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
		pixelDataFile << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		pixelDataFile << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		pixelDataFile << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		pixelDataFile << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
	}
	//Применяем дискретное косинусное Преобразование

	vector<YCBRPixelDataBufferOutputCosine> pOutputDataArrayMultiplication = vector<YCBRPixelDataBufferOutputCosine>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageDivisionCPU(hInstance,
		hWnd, pCosineTransformArray, ppQuantizationKernelArray,
		&pOutputDataArrayMultiplication);


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pOutputDataArrayMultiplication)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pYCompEighttArray.push_back(pPixelObject.pYCosineValue);
		pCBComponentArray.push_back(pPixelObject.pCBCosineValue);
		pCRCompEighttArray.push_back(pPixelObject.pCRCosineValue);
	}

	//Кодирование Хаффманв





	vector<float>  pImageDataVar = vector<float>();
	for (float pYvar : pYCompEighttArray)
	{
		pImageDataVar.push_back(pYvar);
	}


	for (float pCbVar : pCBComponentArray)
	{
		pImageDataVar.push_back(pCbVar);
	}


	for (float pCrVar : pCRCompEighttArray)
	{
		pImageDataVar.push_back(pCrVar);
	}

	const int pImageSize = pImageDataVar.size();


	float pImageData[192];



	pIndex = 0;
	for (float pItem : pImageDataVar)
	{
		pImageData[pIndex] = pItem;
		pIndex++;
	}



	const int pArraySize = pImageDataVar.size() * sizeof(float);

	int size = pImageDataVar.size();



	float pCodeVars[] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };

	HuffmanCodes(pImageData, pCodeVars, size);




	cout << "Performing the Zig-Zag Operation" << endl;
	pixelDataFile << "Performing the Zig-Zag Operation" << endl;


	int n = pImageDataVar.size();
	ZigZagEnconding(pImageData, n);

	vector<unsigned char> pZigZagVector = vector<unsigned char>();

	for (int pArrayIndex = 0; pArrayIndex < pImageDataVar.size(); ++pArrayIndex)
	{
		pZigZagVector.push_back(pImageData[pArrayIndex]);
	}



	int pElementIndex = 0;
	for (unsigned char pCharacter : pZigZagVector)
	{
		cout << "Index: " << pElementIndex << "Value : " << (float)pCharacter << endl;
		pixelDataFile << "Index: " << pElementIndex << "Value : " << (float)pCharacter << endl;
		pElementIndex++;
	}





	cout << "Printing the Jpeg Content" << endl;
	pixelDataFile << "Printing the Jpeg Content" << endl;
	for (int pIndex = 0; pIndex < n; ++pIndex)
	{
		cout << pZigZagVector[pIndex];
		pixelDataFile << pZigZagVector[pIndex];
	}


	vector<BYTE> pByteArray = vector<BYTE>();
	for (unsigned char pByteObj : pZigZagVector)
	{
		pByteArray.push_back(pByteObj);
	}

	BYTE* pImageArrayObject = &pByteArray[0];

	cout << "Jpeg Content End" << endl;
	pixelDataFile << "Jpeg Content End" << endl;


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelObjectFromMemory = vector<PixelObject>();
	cout << "Encoding Our Bitmap To FinelName" << endl;

	DestroyFilePermanently(hInstance, hWnd, L"C:\\RobotData\\OutputImage.jpg");

	hr = md2dmanager->CreateBitmapFromMemory(hInstance, hWnd, pImageWidth, pImageHeight, (BYTE*)pImageData,
		L"C:\\RobotData\\OutputImageFilter.jpg",
		&pPixelObjectFromMemory);

	cout << "Reading Our Bitmap Back " << endl;
	pixelDataFile << "Reading Our Bitmap Back " << endl;


	for (PixelObject pixelObject : pPixelObjectFromMemory)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}






	cout << "Printing The Output of the Simulation in RGB Pixels" << endl;
	pixelDataFile << "Printing Output" << endl;

	SYSTEMTIME lt1, st1;
	GetSystemTime(&st1);
	GetLocalTime(&lt1);
	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}









HRESULT DirectXGPUDigitalLabCoreModule::PerformTheComplexAnalysisOfImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ComplexImageAnalysisRGB.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;

	vector<vector<OutputPixelObjectFiltered>> ppOutputPixelVectormMainForY = vector<vector<OutputPixelObjectFiltered>>();
	vector<vector<OutputPixelObjectFiltered>> ppOutputPixelVectormMainForX = vector<vector<OutputPixelObjectFiltered>>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectFiltered> ppOutputPixelVector = vector<OutputPixelObjectFiltered>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	std::cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	std::cin >> pTopLeftX;
	std::cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	std::cin >> pTopLeftY;

	vector<vector<OutputPixelBufferRGB>> ppOutputImageArray = vector<vector<OutputPixelBufferRGB>>();
	vector<vector<PixelObject>> ppIdenticalImageArray = vector<vector<PixelObject>>();
	vector<vector<PixelObject>> ppDifferentImageArray = vector<vector<PixelObject>>();



	std::cout << "Enter the Width of Image Sector" << endl;
	std::cin >> pImageWidth;

	std::cout << "Enter the Height of Image Sector" << endl;
	std::cin >> pImageHeight;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	std::cout << "Enter the Minimum Value for X Position" << endl;
	std::cin >> pMinimumX;

	std::cout << "Enter the Minimum Value for Y Position" << endl;
	std::cin >> pMinimumY;
	std::cout << "Enter the Minimum Value for X Position" << endl;
	std::cin >> pMaximumX;

	std::cout << "Enter the Minimum Value for Y Position" << endl;
	std::cin >> pMaximumY;




	float pRedValueBottom = 0.0f;
	float pRedValueTop = 0.0f;
	float pGreenValueBottom = 0.0f;
	float pGreenValueTop = 0.0f;
	float pBlueValueBottom = 0.0f;
	float pBlueValueTop = 0.0f;

	cout << "Enter the  Value for Red Component" << endl;
	cin >> pRedValueBottom;

	cout << "Enter the  Value for Green Component" << endl;
	cin >> pGreenValueBottom;

	cout << "Enter the Lowest Value for Blue Component" << endl;
	cin >> pBlueValueBottom;





	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;


	std::cout << "Top Left X Position = " << pTopLeftX << endl;
	std::cout << "Top Left Y Position = " << pTopLeftY << endl;
	std::cout << "Image Width = " << pImageWidth << endl;
	std::cout << "Image Height = " << pImageWidth << endl;
	std::cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	std::cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	std::cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	std::cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;




	std::cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;

	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	std::cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	std::cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		std::cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			std::cout << "Index: " << pIndex << endl;
			std::cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			std::cout << "X Position: " << pixelObject.xPosition << endl;
			std::cout << "Y Position: " << pixelObject.yPosition << endl;
			std::cout << "Red Value: " << pixelObject.RMask << endl;
			std::cout << "Green Value: " << pixelObject.GMask << endl;
			std::cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		std::cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		std::cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;


		std::cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;








		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		std::cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		std::cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		std::cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;

		vector<PixelObject> pLocalPixelArray = vector<PixelObject>();
		vector<OutputPixelObjectFiltered> ppFilterArray = vector<OutputPixelObjectFiltered>();
		vector<OutputPixelObjectFiltered> pLocalArrayOfPixels = vector<OutputPixelObjectFiltered>();
		vector<PixelObject> pLastRestorationArray = vector<PixelObject>();

		vector<vector<PixelObject>> pOutputVectorObjectX = vector<vector<PixelObject>>();
		vector<vector<PixelObject>> pOutputVectorObjectY = vector<vector<PixelObject>>();


		cout << "Scan for Y Position Started" << endl;

		float pYPosition0 = 0.0f;
		do
		{

			for (float pXPosition = 0; pXPosition < pImageWidth; ++pXPosition)
			{


				pLocalPixelArray.clear();
				ppFilterArray.clear();
				pLastRestorationArray.clear();

				ppStandardAlgorithmExecutor->ThresoldPixelValuesByCoordinatesCriteriaRGB(hInstance, hWnd, pXPosition, pYPosition0, pXPosition + pImageWidth, pYPosition0,
					pixelObjectVector,
					&ppFilterArray);

				ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, ppFilterArray,
					&pLocalPixelArray);

				hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondence(hInstance, hWnd,
					pRedValueBottom,
					pGreenValueBottom,
					pBlueValueBottom,
					pLocalPixelArray, &pLocalArrayOfPixels);


				hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, pLocalArrayOfPixels, &pLastRestorationArray);
				pOutputVectorObjectX.push_back(pLastRestorationArray);

			}
			pYPosition0 = pYPosition0 + 1;
		} while (pYPosition0 < pImageHeight);



		float pXPosition0 = 0.0f;

		do
		{

			for (float pYPosition = 0; pYPosition < pImageWidth; ++pYPosition)
			{


				pLocalPixelArray.clear();
				ppFilterArray.clear();
				pLastRestorationArray.clear();

				float pXPosition1 = pXPosition0 + pImageWidth;
				ppStandardAlgorithmExecutor->ThresoldPixelValuesByCoordinatesCriteriaRGB(hInstance, hWnd, pXPosition0, pYPosition0, pXPosition1, pYPosition0,
					pixelObjectVector,
					&ppFilterArray);

				ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, ppFilterArray,
					&pLocalPixelArray);

				hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondence(hInstance, hWnd,
					pRedValueBottom,
					pGreenValueBottom,
					pBlueValueBottom,
					pLocalPixelArray, &pLocalArrayOfPixels);


				hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromFilter(hInstance, hWnd, pLocalArrayOfPixels, &pLastRestorationArray);
				pOutputVectorObjectY.push_back(pLastRestorationArray);

			}
			pXPosition0 = pXPosition0 + 1;
		} while (pXPosition0 < pImageWidth);


		cout << "We have managed to take two sets of pixel Vector for x and y Coordinates" << endl;
		cout << "Now we we will compare our scans for the final time" << endl;
		cout << "The identical Pixels Arrays would form the item you neeed" << endl;

		vector<PixelObject> pFinalArrayValue = vector<PixelObject>();
		vector<OutputPixelBufferRGB> pOutputArray = vector<OutputPixelBufferRGB>();
		vector<PixelObject> pIdenticalArray = vector<PixelObject>();
		vector<PixelObject> pDifferentArray = vector<PixelObject>();

		int pIdenticalPixelsAmount = 0;
		int pDifferentPixelsAmount = 0;
		float pImageOneIntensitySumRed = 0.0f;
		float pImageOneIntensitySumGreen = 0.0f;
		float pImageOneIntensitySumBlue = 0.0f;
		float pImageTwoIntensitySumRed = 0.0f;
		float pImageTwoIntensitySumGreen = 0.0f;
		float pImageTwoIntensitySumBlue = 0.0f;
		float pOutputArraySumRed = 0.0f;
		float pOutputArraySumGreen = 0.0f;
		float pOutputArraySumBlue = 0.0f;
		float pIdenticalArraySumRed = 0.0f;
		float pIdenticalArraySumGreen = 0.0f;
		float pIdenticalArraySumBlue = 0.0f;
		float pDifferentArraySumRed = 0.0f;
		float pDifferentArraySumGreen = 0.0f;
		float pDifferentArraySumBlue = 0.0f;
		float pImageOneIntensityAverageRed = 0.0f;
		float pImageOneIntensityAverageGreen = 0.0f;
		float pImageOneIntensityAverageBlue = 0.0f;
		float pImageTwoIntensityAverageRed = 0.0f;
		float pImageTwoIntensityAverageGreen = 0.0f;
		float pImageTwoIntensityAverageBlue = 0.0f;
		float pOutputArrayAverageRed = 0.0f;
		float pOutputArrayAverageGreen = 0.0f;
		float pOutputArrayAverageBlue = 0.0f;
		float pIdenticalArrayAverageRed = 0.0f;
		float pIdenticalArrayAverageGreen = 0.0f;
		float pIdenticalArrayAverageBlue = 0.0f;
		float pDifferentArrayAverageRed = 0.0f;
		float pDifferentArrayAverageGreen = 0.0f;
		float pDifferentArrayAverageBlue = 0.0f;
		BOOL pAreImagesIdentical = FALSE;

	
		vector<vector<PixelObject>>::iterator pImageOneIterator;
		vector<vector<PixelObject>>::iterator pImageTwoIterator;


		pImageOneIterator = std::begin(pOutputVectorObjectX);
		pImageTwoIterator = std::begin(pOutputVectorObjectX);

		do
		{
			vector<PixelObject> pPixelObjectArrayEight = *pImageOneIterator;
			vector<PixelObject> pPixelObjectArrayTwo = *pImageTwoIterator;
			ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGB(hInstance,
				hWnd, pImageWidth, pImageHeight,
				pPixelObjectArrayEight,
				pPixelObjectArrayTwo,
				&pIdenticalPixelsAmount,
				&pDifferentPixelsAmount,
				&pOutputArray,
				&pIdenticalArray,
				&pDifferentArray,
				&pImageOneIntensitySumRed,
				&pImageOneIntensitySumGreen,
				&pImageOneIntensitySumBlue,
				&pImageTwoIntensitySumRed,
				&pImageTwoIntensitySumGreen,
				&pImageTwoIntensitySumBlue,
				&pOutputArraySumRed,
				&pOutputArraySumGreen,
				&pOutputArraySumBlue,
				&pIdenticalArraySumRed,
				&pIdenticalArraySumGreen,
				&pIdenticalArraySumBlue,
				&pDifferentArraySumRed,
				&pDifferentArraySumGreen,
				&pDifferentArraySumBlue,
				&pImageOneIntensityAverageRed,
				&pImageOneIntensityAverageGreen,
				&pImageOneIntensityAverageBlue,
				&pImageTwoIntensityAverageRed,
				&pImageTwoIntensityAverageGreen,
				&pImageTwoIntensityAverageBlue,
				&pOutputArrayAverageRed,
				&pOutputArrayAverageGreen,
				&pOutputArrayAverageBlue,
				&pIdenticalArrayAverageRed,
				&pIdenticalArrayAverageGreen,
				&pIdenticalArrayAverageBlue,
				&pDifferentArrayAverageRed,
				&pDifferentArrayAverageGreen,
				&pDifferentArrayAverageBlue,
				&pAreImagesIdentical);


			ppOutputImageArray.push_back(pOutputArray);
			ppIdenticalImageArray.push_back(pIdenticalArray);
			ppDifferentImageArray.push_back(pDifferentArray);
			++pImageOneIterator;
			++pImageTwoIterator;

		} while (pImageOneIterator != std::end(pOutputVectorObjectX) && pImageTwoIterator != std::end(pOutputVectorObjectY));





	}

	cout << "Merging Out Identical Arrays from X And y Scans" << endl;

	vector<PixelObject> pCommonPixelObjectArray = vector<PixelObject>();

	vector<PixelObject>::iterator pPixelVar;

	for (vector<PixelObject> pIdenticalPixelVector : ppIdenticalImageArray)
	{
		for (pPixelVar = std::begin(pIdenticalPixelVector); pPixelVar < std::end(pIdenticalPixelVector); ++pPixelVar)
		{
			pCommonPixelObjectArray.push_back(*pPixelVar);
		}
	}

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateJPEGRestorationAlgorithmUsingCosineTransform(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	vector<float> pYCompEighttArray = vector<float>();
	vector<float> pCBComponentArray = vector<float>();
	vector<float> pCRCompEighttArray = vector<float>();

	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;        
	pixelDataFile.open("C:\\pixels\\ImageRestorationUsingCosineTransform.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCRBuffer = vector<YCBRPixelDataBuffer>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}


	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertRGBImageToYCbCrColorSpace(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectYCBCRBuffer);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (YCBRPixelDataBuffer pPixelObject : pPixelObjectYCBCRBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	


	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "Subtracting 128 from every Value" << endl;
	cbSubtractionBuffer pSubtractionBuffer;
	pSubtractionBuffer.pItemToSubtract = 128;;

	vector<YCBRPixelDataBuffer> pOutputDataArraySubtraction = vector<YCBRPixelDataBuffer>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageSubtraction(hInstance, hWnd,
		pPixelObjectYCBCRBuffer, pSubtractionBuffer,
		&pOutputDataArraySubtraction);

	for (YCBRPixelDataBuffer pPixelObject : pOutputDataArraySubtraction)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	vector<YCBRPixelDataBufferOutputCosine> pCosineTransformArray = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;
	pixelDataFile << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;


	cbCostantBufferCosine pConstantBufferCosine;
	pConstantBufferCosine.pi_var = DirectX::XM_PI;
	pConstantBufferCosine.pImageHeightVar = pImageHeight;
	pConstantBufferCosine.pImageWidthVar = pImageWidth;

	hr = ppStandardAlgorithmExecutor->ApplyDiscreteCosineTransformAlgorithm(hInstance,
		hWnd, pConstantBufferCosine, pOutputDataArraySubtraction, &pCosineTransformArray);

	cout << "Printing Output of the Cosine function:" << endl;
	pixelDataFile << "Printing Output of the Cosine function:" << endl;


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pCosineTransformArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



	}
	//Применяем Косинусное Преобразование



	//Заполняем решетку квантования
	cout << "Multiplying the YCBCR Image By A Kernel" << endl;
	pixelDataFile << "Multiplying the YCBCR Image By A Kernel" << endl;
	vector<QuantizationItem> ppQuantizationKernelArray = vector<QuantizationItem>();
	cout << "Computing the Quantization Matrix VariablE array" << endl;
	int pAmountOfItemToCompute = 8 * 8;
	int pIndex = 0;
	float pMatrixVar = 0.0f;
	float pXPositionVar = pTopLeftX;
	float pYPositionVar = pTopLeftY;

	float pQuontizationTable[64] = {
		16, 11, 10, 16, 24, 40, 51, 61,

		12, 12, 14, 19, 26, 58, 60, 55,

		14, 13, 16, 24, 40, 57, 69, 56,

		14, 17, 22, 29, 51, 87, 80, 62,

		18, 22, 37, 56, 68, 109, 103, 77,

		24, 35, 55, 64, 81, 104, 113, 92,

		49, 64, 78, 87, 103, 121, 120, 101,

		72, 92, 95, 98, 112, 100, 103, 99 };


	float pArrayMat[8][8];


	for (int pXIndex = 0; pXIndex < 8; ++pXIndex)
	{
		for (int pYIndex = 0; pYIndex < 8; ++pYIndex)
		{
			pArrayMat[pXIndex][pYIndex] = pQuontizationTable[pYIndex * 8 + pXIndex];
		}
	}
	vector<float> pQuontizationVector = vector<float>();
	

	




	pIndex = 0;
	int pPixelIndex = 0;
	int pXPosition0 = 0;
	int pYPosition0 = 0;
	
	do
	{
			QuantizationItem pQuontizationItem;
			pQuontizationItem.pPixelNumber = pPixelIndex;
			pQuontizationItem.pXPosition = pXPosition0;
			pQuontizationItem.pYPosition = pYPosition0;
			pQuontizationItem.pQuontizationValue = pArrayMat[pXPosition0][pYPosition0];
			pPixelIndex++;
			pXPosition0 = pXPosition0 + 1;
			if (pXPosition0 == 8)
			{
				pYPosition0 = pYPosition0 + 1;
				pXPosition0 = 0;
			}

			ppQuantizationKernelArray.push_back(pQuontizationItem);

	} while (pXPosition0 < 8 && pYPosition0 < 8);

	


	cout << "Printing the Kernel Gate" << endl;
	pixelDataFile << "Printing the Kernel Gate" << endl;
	for (QuantizationItem pItemInCollection : ppQuantizationKernelArray)
	{
		cout << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		cout << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		cout << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		cout << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
		pixelDataFile << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		pixelDataFile << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		pixelDataFile << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		pixelDataFile << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
	}
	//Применяем дискретное косинусное Преобразование

	vector<YCBRPixelDataBufferOutputCosine> pOutputDataArrayMultiplication = vector<YCBRPixelDataBufferOutputCosine>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageDivisionCPU(hInstance,
		hWnd, pCosineTransformArray, ppQuantizationKernelArray,
		&pOutputDataArrayMultiplication);


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pOutputDataArrayMultiplication)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pYCompEighttArray.push_back(pPixelObject.pYCosineValue);
		pCBComponentArray.push_back(pPixelObject.pCBCosineValue);
		pCRCompEighttArray.push_back(pPixelObject.pCRCosineValue);
	}

	//Кодирование Хаффманв





	vector<float>  pImageDataVar = vector<float>();
	for (float pYvar : pYCompEighttArray)
	{
		pImageDataVar.push_back(pYvar);
	}


	for (float pCbVar : pCBComponentArray)
	{
		pImageDataVar.push_back(pCbVar);
	}


	for (float pCrVar: pCRCompEighttArray)
	{
		pImageDataVar.push_back(pCrVar);
	}

	const int pImageSize = pImageDataVar.size();


	float pImageData[192];


	
	int pAmountOfZeros = 0;
	int pAmountOfOnes = 0;
	int pAmountOfTwos = 0;
	int pAmountOfThrees = 0;
	int pAmountOfFours = 0;
	int pAmountOfFives = 0;
	int pAmountOfSixes = 0;
	int pAmountOfSevens = 0;
	int pAmountOfEights = 0;
	int pAmountOfNines = 0;
	int pAmountOfMinusEights = 0;
	int pAmountOfMinusTwos = 0;
	int pAmountOfMinusThrees = 0;
	int pAmountOfMinusFours = 0;
	int pAmountOfMinusFives = 0;
	int pAmountOfMinusSixes = 0;
	int pAmountOfMinusSevens = 0;
	int pAmountOfMinusOnes = 0;
	int pAmountOfMinusNines = 0;





	 pIndex = 0;
	for (float pItem : pImageDataVar)
	{
		if (pItem == -9.0f)
		{
			pAmountOfMinusNines++;
		}
		else if (pItem == -8.0f)
		{
			pAmountOfMinusEights++;
		}
		else if (pItem == -7.0f)
		{
			pAmountOfMinusSevens++;
		}
		else if (pItem == -6.0f)
		{
			pAmountOfMinusSixes++;
		}
		else if (pItem == -5.0f)
		{
			pAmountOfMinusFives++;
		}

		else if (pItem == -4.0f)
		{
			pAmountOfMinusFours++;
		}
		else if (pItem == -3.0f)
		{
			pAmountOfMinusThrees;
		}

		else if (pItem == -2.0f)
		{
			pAmountOfMinusTwos++;
		}

		else if (pItem == -1.0f)
		{
			pAmountOfMinusEights++;
		}

		else  if (pItem == 0.0f)
		{
			pAmountOfZeros++;
		}

		else if (pItem == 1.0f)
		{
			pAmountOfEights++;
		}

		else if (pItem == 2.0f)
		{
			pAmountOfTwos++;
		}


		else if (pItem == 3)
		{
			pAmountOfThrees++;
		}

		else if (pItem == 4)
		{
			pAmountOfFours++;
		}

		else if (pItem == 5)
		{
			pAmountOfFives++;
		}

		else if (pItem == 6)
		{
			pAmountOfSixes++;
		}

		else if (pItem == 7)
		{
			pAmountOfSevens++;
		}


		else if (pItem == 8)
		{
			pAmountOfEights++;
		}


		else if (pItem == 9)
		{
			pAmountOfNines++;
		}



		pImageData[pIndex] = pItem;
		pIndex++;
	}



	const int pArraySize = pImageDataVar.size() * sizeof(float);

	int size = pImageDataVar.size();

	

	float pCodeVars[] = {pAmountOfMinusNines, pAmountOfMinusEights, pAmountOfMinusSevens, pAmountOfMinusSixes, pAmountOfMinusFives, pAmountOfMinusFours, pAmountOfMinusThrees, pAmountOfMinusTwos, pAmountOfMinusEights, pAmountOfZeros, pAmountOfEights, pAmountOfTwos, pAmountOfThrees, pAmountOfFours, pAmountOfFives, pAmountOfSixes, pAmountOfSevens, pAmountOfEights, pAmountOfNines };

	HuffmanCodes(pImageData, pCodeVars, size);



	
	cout << "Performing the Zig-Zag Operation" << endl;
	pixelDataFile << "Performing the Zig-Zag Operation" << endl;


	int n = pImageDataVar.size();
	ZigZagEnconding(pImageData, n);

	vector<unsigned char> pZigZagVector = vector<unsigned char>();

	for (int pArrayIndex = 0; pArrayIndex < pImageDataVar.size(); ++pArrayIndex)
	{
		pZigZagVector.push_back(pImageData[pArrayIndex]);
	}



	int pElementIndex = 0;
	for (unsigned char pCharacter : pZigZagVector)
	{
		cout << "Index: " << pElementIndex << "Value : " << (float)pCharacter << endl;
		pixelDataFile << "Index: " << pElementIndex << "Value : " << (float)pCharacter << endl;
		pElementIndex++;
	}



	
	
	cout << "Printing the Jpeg Content" << endl;
	pixelDataFile << "Printing the Jpeg Content" << endl;
	for (int pIndex = 0; pIndex < n; ++pIndex)
	{
		cout << pZigZagVector[pIndex];
		pixelDataFile << pZigZagVector[pIndex];
	}

	
	vector<BYTE> pByteArray = vector<BYTE>();
	for (unsigned char pByteObj : pZigZagVector)
	{
		pByteArray.push_back(pByteObj);
	}

	BYTE* pImageArrayObject = &pByteArray[0];

	cout << "Jpeg Content End" << endl;
	pixelDataFile << "Jpeg Content End" << endl;

	
	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelObjectFromMemory = vector<PixelObject>();
	cout << "Encoding Our Bitmap To FinelName" << endl;

	DestroyFilePermanently(hInstance, hWnd, L"C:\\RobotData\\OutputImage.jpg");

	hr = md2dmanager->CreateBitmapFromMemory(hInstance, hWnd, pImageWidth, pImageHeight, (BYTE*)pImageData,
		L"C:\\RobotData\\OutputImage.jpg",
		&pPixelObjectFromMemory);

	cout << "Reading Our Bitmap Back " << endl;
	pixelDataFile << "Reading Our Bitmap Back " << endl;


	for (PixelObject pixelObject : pPixelObjectFromMemory)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}
	



	

	cout << "Printing The Output of the Simulation in RGB Pixels" << endl;
	pixelDataFile << "Printing Output" << endl;


	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();
	
	return hr;
}




HRESULT  DirectXGPUDigitalLabCoreModule::SimulateJPEGDecompressionAlgorithmUsingCosineTransform(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageDecompressionUsingCosineTransformInverse.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCRBuffer = vector<YCBRPixelDataBuffer>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}


	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertRGBImageToYCbCrColorSpace(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectYCBCRBuffer);

	for (YCBRPixelDataBuffer pPixelObject : pPixelObjectYCBCRBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}




	//Заполняем решетку квантования
	cout << "Multiplying the YCBCR Image By A Kernel" << endl;
	pixelDataFile << "Multiplying the YCBCR Image By A Kernel" << endl;
	vector<QuantizationItem> ppQuantizationKernelArray = vector<QuantizationItem>();
	cout << "Computing the Quantization Matrix VariablE array" << endl;
	int pAmountOfItemToCompute = 8 * 8;
	int pIndex = 0;
	float pMatrixVar = 0.0f;
	float pXPositionVar = pTopLeftX;
	float pYPositionVar = pTopLeftY;

	float pQuontizationTable[64] = {
		16, 11, 10, 16, 24, 40, 51, 61,

		12, 12, 14, 19, 26, 58, 60, 55,

		14, 13, 16, 24, 40, 57, 69, 56,

		14, 17, 22, 29, 51, 87, 80, 62,

		18, 22, 37, 56, 68, 109, 103, 77,

		24, 35, 55, 64, 81, 104, 113, 92,

		49, 64, 78, 87, 103, 121, 120, 101,

		72, 92, 95, 98, 112, 100, 103, 99 };


	float pArrayMat[8][8];


	for (int pXIndex = 0; pXIndex < 8; ++pXIndex)
	{
		for (int pYIndex = 0; pYIndex < 8; ++pYIndex)
		{
			pArrayMat[pXIndex][pYIndex] = pQuontizationTable[pYIndex * 8 + pXIndex];
		}
	}
	vector<float> pQuontizationVector = vector<float>();







	pIndex = 0;
	int pPixelIndex = 0;
	int pXPosition0 = 0;
	int pYPosition0 = 0;

	do
	{
		QuantizationItem pQuontizationItem;
		pQuontizationItem.pPixelNumber = pPixelIndex;
		pQuontizationItem.pXPosition = pXPosition0;
		pQuontizationItem.pYPosition = pYPosition0;
		pQuontizationItem.pQuontizationValue = pArrayMat[pXPosition0][pYPosition0];
		pPixelIndex++;
		pXPosition0 = pXPosition0 + 1;
		if (pXPosition0 == 8)
		{
			pYPosition0 = pYPosition0 + 1;
			pXPosition0 = 0;
		}

		ppQuantizationKernelArray.push_back(pQuontizationItem);

	} while (pXPosition0 < 8 && pYPosition0 < 8);


	vector<YCBRPixelDataBuffer> pOutputDataArrayMultiplication = vector<YCBRPixelDataBuffer>();

	cout << "Printing the Kernel Gate" << endl;
	pixelDataFile << "Printing the Kernel Gate" << endl;
	for (QuantizationItem pItemInCollection : ppQuantizationKernelArray)
	{
		cout << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		cout << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		cout << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		cout << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
		pixelDataFile << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		pixelDataFile << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		pixelDataFile << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		pixelDataFile << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
	}
	//Применяем дискретное косинусное Преобразование

	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageMultiplicationCPU(hInstance,
		hWnd, pPixelObjectYCBCRBuffer, ppQuantizationKernelArray,
		&pOutputDataArrayMultiplication);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (YCBRPixelDataBuffer pPixelObject : pOutputDataArrayMultiplication)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	GetSystemTime(&st1);
	GetLocalTime(&lt1);



	vector<YCBRPixelDataBufferOutputCosine> pCosineTransformArray = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "Applying Dicrete Cosinte TRANSFORM ALGORITHM Inverse" << endl;
	pixelDataFile << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;


	cbCostantBufferCosine pConstantBufferCosine;
	pConstantBufferCosine.pi_var = DirectX::XM_PI;
	pConstantBufferCosine.pImageHeightVar = pImageHeight;
	pConstantBufferCosine.pImageWidthVar = pImageWidth;

	hr = ppStandardAlgorithmExecutor->ApplyDiscreteCosineTransformAlgorithmInverse(hInstance,
		hWnd, pConstantBufferCosine, pOutputDataArrayMultiplication, &pCosineTransformArray);

	cout << "Printing Output of the Cosine function:" << endl;
	pixelDataFile << "Printing Output of the Cosine function:" << endl;


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pCosineTransformArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



	}
	//Применяем Косинусное Преобразование


	vector<YCBRPixelDataBuffer> pBufferForAdditionVector = vector<YCBRPixelDataBuffer>();





	for (YCBRPixelDataBufferOutputCosine pPixelObject : pCosineTransformArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;


					
	
	}

	//Кодирование Хаффманв








	cout << "Adding 128 from every Value" << endl;
	cbSubtractionBuffer pSubtractionBuffer;
	pSubtractionBuffer.pItemToSubtract = 128;;


	vector<float> pYCompEighttArray = vector<float>();
	vector<float> pCBComponentArray = vector<float>();
	vector<float> pCRCompEighttArray = vector<float>();
	vector<float> pImageData = vector<float>();


	vector<YCBRPixelDataBufferOutputCosine> pOutputDataArraySubtraction = vector<YCBRPixelDataBufferOutputCosine>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageAdditionCPU(hInstance,
		hWnd, pCosineTransformArray,
		pSubtractionBuffer,
		&pOutputDataArraySubtraction);




	for (YCBRPixelDataBufferOutputCosine pPixelObject : pOutputDataArraySubtraction)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pYCompEighttArray.push_back(pPixelObject.pYCosineValue);
		pCBComponentArray.push_back(pPixelObject.pCBCosineValue);
		pCRCompEighttArray.push_back(pPixelObject.pCRCosineValue);
	}

	
	vector<float> pImageDataVector = vector<float>();
	pImageDataVector.insert(pImageDataVector.end(), pYCompEighttArray.begin(), pYCompEighttArray.end());
	pImageDataVector.insert(pImageDataVector.end(), pCBComponentArray.begin(), pCBComponentArray.end());
	pImageDataVector.insert(pImageDataVector.end(), pCRCompEighttArray.begin(), pCRCompEighttArray.end());



	int pImageSize = pImageDataVector.size();
	float* pImageDataVar = &pImageDataVector[0];
	float pCodeVars[] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };

	HuffmanCodes(pImageDataVar, pCodeVars, pImageSize);




	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelObjectFromMemory = vector<PixelObject>();
	cout << "Encoding Our Bitmap To FinelName" << endl;

	DestroyFilePermanently(hInstance, hWnd, L"C:\\RobotData\\OutputImage.jpg");

	hr = md2dmanager->CreateBitmapFromMemory(hInstance, hWnd, pImageWidth, pImageHeight, (BYTE*)pImageDataVar,
		L"C:\\RobotData\\OutputImageInverse.jpg",
		&pPixelObjectFromMemory);

	cout << "Reading Our Bitmap Back " << endl;
	pixelDataFile << "Reading Our Bitmap Back " << endl;


	for (PixelObject pixelObject : pPixelObjectFromMemory)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}






	cout << "Printing The Output of the Simulation in RGB Pixels" << endl;
	pixelDataFile << "Printing Output" << endl;


	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CompressComplexImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageCompressionLargeImage.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCRBuffer = vector<YCBRPixelDataBuffer>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}


	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertRGBImageToYCbCrColorSpace(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectYCBCRBuffer);

	for (YCBRPixelDataBuffer pPixelObject : pPixelObjectYCBCRBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	cout << "Now We Will Split Our Vector Into 8 x 8 Pixel Vectors" << endl; 
	vector<YCBRPixelDataBuffer> pArrayEight = vector<YCBRPixelDataBuffer>();
	vector<YCBRPixelDataBuffer> pArrayTwo = vector<YCBRPixelDataBuffer>();
	vector<YCBRPixelDataBuffer> pArrayThree = vector<YCBRPixelDataBuffer>();
	vector<YCBRPixelDataBuffer> pArrayFour = vector<YCBRPixelDataBuffer>();



	for (YCBRPixelDataBuffer pPixelObject : pPixelObjectYCBCRBuffer)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

		if (pPixelObject.xPosition >= 0 && pPixelObject.xPosition < 8 && pPixelObject.yPosition >= 0 && pPixelObject.yPosition < 8)
		{
			pArrayEight.push_back(pPixelObject);
		}
		else if (pPixelObject.xPosition >= 8 && pPixelObject.xPosition < 16 && pPixelObject.yPosition >= 8 && pPixelObject.yPosition < 16)
		{
			pArrayTwo.push_back(pPixelObject);
		}
		else if (pPixelObject.xPosition >= 16 && pPixelObject.xPosition < 24 && pPixelObject.yPosition >= 16 && pPixelObject.yPosition < 24)
		{
			pArrayThree.push_back(pPixelObject);
		}

		else if (pPixelObject.xPosition >= 24 && pPixelObject.xPosition < 32 && pPixelObject.yPosition >= 24 && pPixelObject.yPosition < 32)
		{
			pArrayThree.push_back(pPixelObject);
		}


	
	}

	cout << "Now We Wiil Compress Our Blocks Eight By Eight" << endl;
	vector<YCBRPixelDataBufferOutputCosine> pBlockEightData = vector<YCBRPixelDataBufferOutputCosine>();
	vector<float> pImageData = vector<float>();
	if (pArrayEight.size() > 0)
	{
		vector<float> pYComponentArray = vector<float>();
		vector<float> pCbComponentArray = vector<float>();
		vector<float> pCrComponentArray = vector<float>();

		hr = ApplyCosineTransformToBlock(hInstance, hWnd,
			pArrayEight,
			0, 0, 8, 8,
			&pBlockEightData,
			&pYComponentArray,
			&pCbComponentArray,
			&pCrComponentArray);
	
		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pCbComponentArray), std::end(pCbComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));


	}

	if (pArrayTwo.size() > 0)
	{
		vector<float> pYComponentArray = vector<float>();
		vector<float> pCbComponentArray = vector<float>();
		vector<float> pCrComponentArray = vector<float>();

		hr = ApplyCosineTransformToBlock(hInstance, hWnd,
			pArrayEight,
			7, 7, 8, 8,
			&pBlockEightData,
			&pYComponentArray,
			&pCbComponentArray,
			&pCrComponentArray);
	

		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pCbComponentArray), std::end(pCbComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));



	}
	
	if (pArrayThree.size() > 0)
	{
		vector<float> pYComponentArray = vector<float>();
		vector<float> pCbComponentArray = vector<float>();
		vector<float> pCrComponentArray = vector<float>();

		hr = ApplyCosineTransformToBlock(hInstance, hWnd,
			pArrayEight,
			15, 15, 8, 8,
			&pBlockEightData,
			&pYComponentArray,
			&pCbComponentArray,
			&pCrComponentArray);


		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pCbComponentArray), std::end(pCbComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));



	}

	if (pArrayFour.size() > 0)
	{
		vector<float> pYComponentArray = vector<float>();
		vector<float> pCbComponentArray = vector<float>();
		vector<float> pCrComponentArray = vector<float>();

		hr = ApplyCosineTransformToBlock(hInstance, hWnd,
			pArrayEight,
			23, 23, 8, 8,
			&pBlockEightData,
			&pYComponentArray,
			&pCbComponentArray,
			&pCrComponentArray);


		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pCbComponentArray), std::end(pCbComponentArray));
		pImageData.insert(pImageData.end(), std::begin(pYComponentArray), std::end(pYComponentArray));
	}

	float pImageDataArray[768];


	int pIndex = 0;

	for (float pItem : pImageData)
	{
		pImageDataArray[pIndex] = pItem;
		pIndex++;
	}



	const int pArraySize = pImageData.size() * sizeof(float);

	int size = pImageData.size();



	float pCodeVars[] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };

	HuffmanCodes(pImageDataArray, pCodeVars, size);




	cout << "Performing the Zig-Zag Operation" << endl;
	pixelDataFile << "Performing the Zig-Zag Operation" << endl;


	int n = pImageData.size();
	ZigZagEnconding(pImageDataArray, n);

	vector<unsigned char> pZigZagVector = vector<unsigned char>();

	for (int pArrayIndex = 0; pArrayIndex < pImageData.size(); ++pArrayIndex)
	{
		pZigZagVector.push_back(pImageDataArray[pArrayIndex]);
	}



	int pElementIndex = 0;
	for (unsigned char pCharacter : pZigZagVector)
	{
		cout << "Index: " << pElementIndex << "Value : " << (float)pCharacter << endl;
		pixelDataFile << "Index: " << pElementIndex << "Value : " << (float)pCharacter << endl;
		pElementIndex++;
	}


	BYTE* pImageDataArrayMemory = &pZigZagVector[0];



	cout << "Printing the Jpeg Content" << endl;
	pixelDataFile << "Printing the Jpeg Content" << endl;
	for (int pIndex = 0; pIndex < pZigZagVector.size(); ++pIndex)
	{
		cout << pImageDataArrayMemory[pIndex];
		pixelDataFile << pImageDataArrayMemory;
	}

	cout << "Jpeg Content End" << endl;
	pixelDataFile << "Jpeg Content End" << endl;


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	vector<PixelObject> pPixelObjectFromMemory = vector<PixelObject>();
	cout << "Encoding Our Bitmap To FinelName" << endl;

	DestroyFilePermanently(hInstance, hWnd, L"C:\\RobotData\\OutputImage.jpg");

	hr = md2dmanager->CreateBitmapFromMemory(hInstance, hWnd, pImageWidth, pImageHeight, (BYTE*)pImageDataArray,
		L"C:\\RobotData\\OutputImageLargeJPEG.jpg",
		&pPixelObjectFromMemory);

	cout << "Reading Our Bitmap Back " << endl;
	pixelDataFile << "Reading Our Bitmap Back " << endl;


	for (PixelObject pixelObject : pPixelObjectFromMemory)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		pixelDataFile << "Index: " << pIndex << endl;
		pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}






	cout << "Printing The Output of the Simulation in RGB Pixels" << endl;
	pixelDataFile << "Printing Output" << endl;


	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;

}




HRESULT DirectXGPUDigitalLabCoreModule::ApplyCosineTransformToBlock(HINSTANCE hInstance,
	HWND hWnd, vector<YCBRPixelDataBuffer> pOutputArrayCosine,
	UINT pTopLeftX,
	UINT pTopLeftY,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<YCBRPixelDataBufferOutputCosine> *pCosineBlock,
	vector<float> *ppYCosineArray,
	vector<float> *ppCBCosineArray,
	vector<float> *ppbCRCosineArray)
{

	HRESULT hr = S_OK;
	SYSTEMTIME st1, lt1;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	vector<float> pYCompEighttArray = vector<float>();
	vector<float> pCBComponentArray = vector<float>();
	vector<float> pCRCompEighttArray = vector<float>();

	
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageRestorationUsingCosineTransformPreloaded.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	for (YCBRPixelDataBuffer pPixelObject : pOutputArrayCosine)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "Subtracting 128 from every Value" << endl;
	cbSubtractionBuffer pSubtractionBuffer;
	pSubtractionBuffer.pItemToSubtract = 128;;

	vector<YCBRPixelDataBuffer> pOutputDataArraySubtraction = vector<YCBRPixelDataBuffer>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageSubtraction(hInstance, hWnd,
		pOutputArrayCosine, pSubtractionBuffer,
		&pOutputDataArraySubtraction);

	for (YCBRPixelDataBuffer pPixelObject : pOutputDataArraySubtraction)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Component: " << pPixelObject.pYValue << endl;
		cout << "Cb Component: " << pPixelObject.pCbValue << endl;
		cout << "Cr Component: " << pPixelObject.pCrValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Component: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Component: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Component: " << pPixelObject.pCrValue << endl;

	}

	vector<YCBRPixelDataBufferOutputCosine> pCosineTransformArray = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;
	pixelDataFile << "Applying Dicrete Cosinte TRANSFORM ALGORITHM" << endl;


	cbCostantBufferCosine pConstantBufferCosine;
	pConstantBufferCosine.pi_var = DirectX::XM_PI;
	pConstantBufferCosine.pImageHeightVar = pImageHeight;
	pConstantBufferCosine.pImageWidthVar = pImageWidth;

	hr = ppStandardAlgorithmExecutor->ApplyDiscreteCosineTransformAlgorithm(hInstance,
		hWnd, pConstantBufferCosine, pOutputDataArraySubtraction, &pCosineTransformArray);

	cout << "Printing Output of the Cosine function:" << endl;
	pixelDataFile << "Printing Output of the Cosine function:" << endl;


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pCosineTransformArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



	}
	//Применяем Косинусное Преобразование



	//Заполняем решетку квантования
	cout << "Multiplying the YCBCR Image By A Kernel" << endl;
	pixelDataFile << "Multiplying the YCBCR Image By A Kernel" << endl;
	vector<QuantizationItem> ppQuantizationKernelArray = vector<QuantizationItem>();
	cout << "Computing the Quantization Matrix VariablE array" << endl;
	int pAmountOfItemToCompute = 8 * 8;
	int pIndex = 0;
	float pMatrixVar = 0.0f;
	float pXPositionVar = pTopLeftX;
	float pYPositionVar = pTopLeftY;

	float pQuontizationTable[64] = {
		16, 11, 10, 16, 24, 40, 51, 61,

		12, 12, 14, 19, 26, 58, 60, 55,

		14, 13, 16, 24, 40, 57, 69, 56,

		14, 17, 22, 29, 51, 87, 80, 62,

		18, 22, 37, 56, 68, 109, 103, 77,

		24, 35, 55, 64, 81, 104, 113, 92,

		49, 64, 78, 87, 103, 121, 120, 101,

		72, 92, 95, 98, 112, 100, 103, 99 };


	float pArrayMat[8][8];


	for (int pXIndex = 0; pXIndex < 8; ++pXIndex)
	{
		for (int pYIndex = 0; pYIndex < 8; ++pYIndex)
		{
			pArrayMat[pXIndex][pYIndex] = pQuontizationTable[pYIndex * 8 + pXIndex];
		}
	}
	vector<float> pQuontizationVector = vector<float>();







	pIndex = 0;
	int pPixelIndex = 0;
	int pXPosition0 = 0;
	int pYPosition0 = 0;

	do
	{
		QuantizationItem pQuontizationItem;
		pQuontizationItem.pPixelNumber = pPixelIndex;
		pQuontizationItem.pXPosition = pXPosition0;
		pQuontizationItem.pYPosition = pYPosition0;
		pQuontizationItem.pQuontizationValue = pArrayMat[pXPosition0][pYPosition0];
		pPixelIndex++;
		pXPosition0 = pXPosition0 + 1;
		if (pXPosition0 == 8)
		{
			pYPosition0 = pYPosition0 + 1;
			pXPosition0 = 0;
		}

		ppQuantizationKernelArray.push_back(pQuontizationItem);

	} while (pXPosition0 < 8 && pYPosition0 < 8);




	cout << "Printing the Kernel Gate" << endl;
	pixelDataFile << "Printing the Kernel Gate" << endl;
	for (QuantizationItem pItemInCollection : ppQuantizationKernelArray)
	{
		cout << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		cout << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		cout << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		cout << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
		pixelDataFile << "Kernel Item Id: " << pItemInCollection.pPixelNumber << endl;
		pixelDataFile << "Kernel Item X Position: " << pItemInCollection.pXPosition << endl;
		pixelDataFile << "Kernel Item Y Position: " << pItemInCollection.pYPosition << endl;
		pixelDataFile << "Kernel Item Value: " << pItemInCollection.pQuontizationValue << endl;
	}
	//Применяем дискретное косинусное Преобразование

	vector<YCBRPixelDataBufferOutputCosine> pOutputDataArrayMultiplication = vector<YCBRPixelDataBufferOutputCosine>();
	hr = ppStandardAlgorithmExecutor->QuantizeYCBCRImageDivisionCPU(hInstance,
		hWnd, pCosineTransformArray, ppQuantizationKernelArray,
		&pOutputDataArrayMultiplication);


	for (YCBRPixelDataBufferOutputCosine pPixelObject : pOutputDataArrayMultiplication)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Y Value: " << pPixelObject.pYValue << endl;
		cout << "Cb Value: " << pPixelObject.pCbValue << endl;
		cout << "Cr Value: " << pPixelObject.pCrValue << endl;
		cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Y Value: " << pPixelObject.pYValue << endl;
		pixelDataFile << "Cb Value: " << pPixelObject.pCbValue << endl;
		pixelDataFile << "Cr Value: " << pPixelObject.pCrValue << endl;
		pixelDataFile << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
		pixelDataFile << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
		pixelDataFile << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

		pYCompEighttArray.push_back((BYTE)pPixelObject.pYCosineValue);
		pCBComponentArray.push_back((BYTE)pPixelObject.pCBCosineValue);
		pCRCompEighttArray.push_back((BYTE)pPixelObject.pCRCosineValue);
	}

	//Кодирование Хаффманв






	//Умножаем на решетку






	cout << "Printing The Output of the Simulation in RGB Pixels" << endl;
	pixelDataFile << "Printing Output" << endl;


	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	*pCosineBlock = pOutputDataArrayMultiplication;
	*ppYCosineArray = pYCompEighttArray;
	*ppCBCosineArray = pCBComponentArray;
	*ppbCRCosineArray = pCRCompEighttArray;
	return hr; 
}





HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToGrayScale(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToGrayScaleFinalOutput.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScaleRestored = vector<PixelObjectGrayScale>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;
	
	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

  pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		int pixelNumberValue = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;
		
		cout << "Step: " << pIndexValue << endl;
		cout << "Pixel Number = " << pixelNumberValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
		
		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "Pixel Number = " << pixelNumberValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


	
		pIndexValue++;
	}

	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToCMYK(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToCMYKFinalOutput.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectCMYK> pPixelObjectToGrayScale = vector<OutputPixelObjectCMYK>();

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToCMYK(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (OutputPixelObjectCMYK pPixelObject : pPixelObjectToGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Cyan Value: " << pPixelObject.pCyanValue << endl;
		cout << "Magenta Value: " << pPixelObject.pMagentaValue << endl;
		cout << "Yellow Value: " << pPixelObject.pYellowColorValue << endl;
		cout << "Black Value: " << pPixelObject.pBlackKey << endl;


		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Cyan Value: " << pPixelObject.pCyanValue << endl;
		pixelDataFile << "Magenta Value: " << pPixelObject.pMagentaValue << endl;
		pixelDataFile << "Yellow Value: " << pPixelObject.pYellowColorValue << endl;
		pixelDataFile << "Black Value: " << pPixelObject.pBlackKey << endl;

	}

	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToLinkedList(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToLinkedListStructure.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectLinkedListElement> pPixelObjectToGrayScale = vector<PixelObjectLinkedListElement>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataFromSinglePixelToLinkedListModel(hInstance, hWnd,
		pImageWidth, pImageHeight, 1,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (PixelObjectLinkedListElement pPixelObject : pPixelObjectToGrayScale)
	{
		cout << "Pixel Number Eight: " << pPixelObject.pixelNumber << endl;
		cout << "X Position Eight: " << pPixelObject.xPosition << endl;
		cout << "Y Position Eight: " << pPixelObject.yPosition << endl;
		cout << "Red Component Eight: " << pPixelObject.rValue << endl;
		cout << "Green Component Eight: " << pPixelObject.gValue << endl;
		cout << "Blue Value: " << pPixelObject.bValue << endl;
		cout << "Is Pixel First: " << pPixelObject.isFirst << endl;
		cout << "Is Pixel Last: " << pPixelObject.isLast << endl;
		cout << "Next Pixel: " << pPixelObject.pNextPixelNumber << endl;


		pixelDataFile << "Pixel Number Eight: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position Eight: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position Eight: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component Eight: " << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component Eight: " << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Value: " << pPixelObject.bValue << endl;
		pixelDataFile << "Is Pixel First: " << pPixelObject.isFirst << endl;
		pixelDataFile << "Is Pixel Last: " << pPixelObject.isLast << endl;
		pixelDataFile << "Next Pixel: " << pPixelObject.pNextPixelNumber << endl;

	}



	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ConvertImageFromRGBModelToTemperatureModel(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToTemperatureModel.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectTemperature> pPixelObjectToGrayScale = vector<OutputPixelObjectTemperature>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataFromRGBModelToTemperatureModel(hInstance, hWnd, 100.0f,
		255.0f,
		0.0f, 
		1.0f,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (OutputPixelObjectTemperature pPixelObject : pPixelObjectToGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component" << pPixelObject.rValue << endl;
		cout << "Green Component" << pPixelObject.gValue << endl;
		cout << "Blue Component" << pPixelObject.bValue << endl;
		cout << "Red Value Temperature: " << pPixelObject.pTemperatureRed << endl;
		cout << "Green Value Temperature: " << pPixelObject.pTemperatureGreen << endl;
		cout << "Blue Value Temperature: " << pPixelObject.pTemperatureBlue << endl;
		cout << "Overall Temperature: " << pPixelObject.pOverallTemperature << endl;
		cout << "Region Label" << pPixelObject.pRegionMarkerValue << endl;

		pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
		pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		pixelDataFile << "Red Component" << pPixelObject.rValue << endl;
		pixelDataFile << "Green Component" << pPixelObject.gValue << endl;
		pixelDataFile << "Blue Component" << pPixelObject.bValue << endl;
		pixelDataFile << "Red Value Temperature: " << pPixelObject.pTemperatureRed << endl;
		pixelDataFile << "Green Value Temperature: " << pPixelObject.pTemperatureGreen << endl;
		pixelDataFile << "Blue Value Temperature: " << pPixelObject.pTemperatureBlue << endl;
		pixelDataFile << "Overall Temperature: " << pPixelObject.pOverallTemperature << endl;
		pixelDataFile << "Region Label" << pPixelObject.pRegionMarkerValue << endl;

	}

	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulatePathGeometryExperiment(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	hr = md2dmanager->SimulateBehaviourOfPathGeometryTools(hInstance, hWnd);

	return hr;

}





HRESULT DirectXGPUDigitalLabCoreModule::ConvertImageFromRGBModelLinkedListModel(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToLinkedListModel.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelBundleInput> pPixelBundleVector = vector<PixelBundleInput>();
	vector<PixelObjectLinkedListElement> pPixelObjectToGrayScale = vector<PixelObjectLinkedListElement>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}



		UINT pIndexValue = 0;
		cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

		hr = ppStandardAlgorithmExecutor->ConvertImageDataFromSinglePixelToLinkedListModel(hInstance,
			hWnd, pImageWidth, pImageHeight, 1, pixelObjectVector, &pPixelObjectToGrayScale);

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;
		for (PixelObjectLinkedListElement pPixelObjectClass : pPixelObjectToGrayScale)
		{
			cout << "Pixel Number Eight: " << pPixelObjectClass.pixelNumber << endl;
			cout << "X Position Eight: " << pPixelObjectClass.xPosition << endl;
			cout << "Y Position Eight: " << pPixelObjectClass.yPosition << endl;
			cout << "Red Component Eight: " << pPixelObjectClass.rValue << endl;
			cout << "Green Component Eight: " << pPixelObjectClass.gValue << endl;
			cout << "Blue Value: " << pPixelObjectClass.bValue << endl;
			cout << "Is Pixel First: " << pPixelObjectClass.isFirst << endl;
			cout << "Is Pixel Last: " << pPixelObjectClass.isLast << endl;
			cout << "Next Pixel: " << pPixelObjectClass.pNextPixelNumber << endl;


			pixelDataFile << "Pixel Number Eight: " << pPixelObjectClass.pixelNumber << endl;
			pixelDataFile << "X Position Eight: " << pPixelObjectClass.xPosition << endl;
			pixelDataFile << "Y Position Eight: " << pPixelObjectClass.yPosition << endl;
			pixelDataFile << "Red Component Eight: " << pPixelObjectClass.rValue << endl;
			pixelDataFile << "Green Component Eight: " << pPixelObjectClass.gValue << endl;
			pixelDataFile << "Blue Value: " << pPixelObjectClass.bValue << endl;
			pixelDataFile << "Is Pixel First: " << pPixelObjectClass.isFirst << endl;
			pixelDataFile << "Is Pixel Last: " << pPixelObjectClass.isLast << endl;
			pixelDataFile << "Next Pixel: " << pPixelObjectClass.pNextPixelNumber << endl;

		}
	}
	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToGrayScaleUsingInts(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToGrayScaleUsingInts.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObjectInt> pixelObjectVector = vector<PixelObjectInt>();
	vector<PixelObjectGrayScaleInt> pPixelObjectToGrayScale = vector<PixelObjectGrayScaleInt>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	SYSTEMTIME st, lt, st1, lt1;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	cout << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObjectWithInts(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObjectInt pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}

	fstream pPixelObjectWriterGrayScale("C:\\pixels\\ResultsOfGrayScaleImageAfterConverstion.ros", ios::binary);
	UINT pIndexValue = 0;
	cout << "Now We Will Save The Contents of the RGB Image To Ros File" << endl;

	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleUsingInts(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	pIndexValue = 0;

	for (PixelObjectGrayScaleInt pPixelObject : pPixelObjectToGrayScale)
	{

	
		int pixelNumberValue = pPixelObject.pixelNumber;
		int pXValue = pPixelObject.xPosition;
		int pYValue = pPixelObject.yPosition;
		int pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "Pixel Number = " << pixelNumberValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "Pixel Number = " << pixelNumberValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



		pIndexValue++;
	}

	GetSystemTime(&st1);
	GetLocalTime(&lt1);

	cout << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << st1.wHour << ":" << st1.wMinute << ":" << st1.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << lt1.wHour << ":" << lt1.wMinute << ":" << lt1.wSecond << endl;

	pixelDataFile.close();

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ConvertRGBImageToGrayScaleViaLuminosityParameters(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageConversionToGrayScaleFinalOutput.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{



		HRESULT hr = S_OK;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}
	}


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScaleLuminosity(hInstance, hWnd,
		pixelObjectVector, &pPixelObjectToGrayScale);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pixelDataFile << "Step: " << pIndexValue << endl;
		pixelDataFile << "X Value = " << pXValue << endl;
		pixelDataFile << "Y Value = " << pYValue << endl;
		pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	pixelDataFile.close();

	return hr;
}









HRESULT DirectXGPUDigitalLabCoreModule::SimulateMatrixMultiplicationSecondOption(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	cout << "This Function Will Be Uses to Simulate Matrix Multiplication of Two Matrices" << endl;


	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();
	vector<MatrixVariableType> pOutputMatrixVector = vector<MatrixVariableType>();

	float pArrayEightBegin = 0.0f;
	float pArrayEightEnd = 0.0f;
	float pArrayTwoBegin = 0.0f;
	float pArrayTwoEnd = 0.0f;
	float pMatrixAWidth = 16.0f;
	float pMatrixAHeight = 16.0;
	float pMatrixBWidth = 16.0;
	float pMatrixBHeight = 16.0;


	fstream pMatrixMultiplicationAlgorithm;
	pMatrixMultiplicationAlgorithm.open("C:\\pixels\\MatrixMultiplicationAlgorithmSecondOptionCS.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	UINT pNumberForMatrixA = 0;
	UINT pNumberForMatrixB = 0;

	cout << "The Width of the Matrix A Would Be: " << pMatrixAWidth << endl;
	cout << "The Height of the Matrix A Would Be: " << pMatrixAHeight << endl;
	cout << "The Width of the Matrix B Would Be: " << pMatrixAWidth << endl;
	cout << "The Height of the Matrix B Would Be: " << pMatrixAHeight << endl;

	pMatrixMultiplicationAlgorithm << "The Width of the Matrix A Would Be: " << pMatrixAWidth << endl;
	pMatrixMultiplicationAlgorithm << "The Height of the Matrix A Would Be: " << pMatrixAHeight << endl;
	pMatrixMultiplicationAlgorithm << "The Width of the Matrix B Would Be: " << pMatrixAWidth << endl;
	pMatrixMultiplicationAlgorithm << "The Height of the Matrix B Would Be: " << pMatrixAHeight << endl;



	UINT pMatrixEightValue = 0;
	cout << "Enter the Value for Matrix Eight" << endl;
	cin >> pMatrixEightValue;


	UINT pMatrixTwoValue = 0;
	cout << "Enter the Value for Matrix Eight" << endl;
	cin >> pMatrixTwoValue;



	pArrayEightEnd = 256;

	UINT iIndex = 0;

	do
	{
		cout << "Processing Item At Index: " << iIndex << endl;

		pArrayEightValues.push_back(pMatrixEightValue);
	} while (pArrayEightValues.size() != pArrayEightEnd);





	iIndex = 0;
	do
	{
		cout << "Processing Item At Index: " << iIndex << endl;
		pArrayTwoValues.push_back(pMatrixTwoValue);
	} while (pArrayTwoValues.size() != pArrayEightEnd);

	cout << "Now We will Ensure that our Initial Array Size = 256 by Adding null Values" << endl;


	int pIndex = 0;
	cout << "Printing the Array Eight Values " << endl;
	for (UINT pArrEightData : pArrayEightValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;

		pIndex = pIndex + 1;
	}

	pIndex = 0;
	cout << "Printing the Array Two Values " << endl;
	for (UINT pArrTwoData : pArrayTwoValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrTwoData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrTwoData << endl;

		pIndex = pIndex + 1;
	}




	cout << "Now We Will Try to Perform The Matrix Multiplication of Selelected Images" << endl;

//	hr = ppStandardAlgorithmExecutor->SimulateMatrixMultiplicationForImages(hInstance, hWnd,
//		pArrayEightValues, pArrayTwoValues, pArrayEightValues.size(), &pOutputMatrixVector);

	cout << "Printing the Results of the Matrix Multiply Operation" << endl;
	UINT pIndexValue = 0;
	float pXPoisiton = 0.0f;
	float pYPosition = 0.0f;
	for (MatrixVariableType pValue : pOutputMatrixVector)
	{


		cout << "Processing Matrix Row" << pIndexValue << endl;
		for (UINT iIndex = 0; iIndex < 16; iIndex++)
		{
			cout << "Column: " << iIndex << "Value: " << pValue.pMatrixValue[iIndex].d << endl;
			cout << "Column: " << iIndex << "Value: " << pValue.pMatrixValue[iIndex].i << endl;
			cout << "Column: " << iIndex << "Value: " << pValue.pMatrixValue[iIndex].f << endl;

			pMatrixMultiplicationAlgorithm << "Column: " << iIndex << "Value: " << pValue.pMatrixValue[iIndex].d << endl;
			pMatrixMultiplicationAlgorithm << "Column: " << iIndex << "Value: " << pValue.pMatrixValue[iIndex].i << endl;
			pMatrixMultiplicationAlgorithm << "Column: " << iIndex << "Value: " << pValue.pMatrixValue[iIndex].f << endl;

		}



	}







	pMatrixMultiplicationAlgorithm.close();


	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalParametrized(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	UINT pImageHeight = 10;
	UINT pImageWidth = 10;

	pGlobalWindow = hWnd;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, pGlobalWindow);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	UINT pIndex = 0;
	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;



	vector<PixelObject> ppImageOneRGB = vector<PixelObject>();
	vector<PixelObject> ppImageTwoRGB = vector<PixelObject>();

	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();

	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppImageOneRGB);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : ppImageOneRGB)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &ppImageTwoRGB);



	for (PixelObject pixelObject : ppImageTwoRGB)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		ppImageOneRGB, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, pGlobalWindow,
	ppImageTwoRGB, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, pGlobalWindow, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Now We will Visualize the Outcome of the simulation" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Сейчас мы представим вам визуальное представление работы чистильщика", (LPCSTR)"Message", 0);

	cout << "Creating Visualization Diagram" << endl;

	if (pDifferentPixelArrayAverage >= 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 100);
	}
	else if (pDifferentPixelArrayAverage >= 33 && pDifferentPixelArrayAverage < 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 50);
	}
	else if (pDifferentPixelArrayAverage >= 0 && pDifferentPixelArrayAverage < 33)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 0);
	}

	HWND hListBox = NULL;
	hListBox = CreateWindow(L"listbox", NULL,
		WS_CHILD | WS_VISIBLE | LBS_STANDARD |
		LBS_WANTKEYBOARDINPUT,
		30, 30, 200, 100,
		hWnd, (HMENU)ID_LIST, hInstance, NULL);

	// Отменяем режим перерисовки списка
	SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
	// Добавляем в список несколько строк

	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Green - Intensity <= 33");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Red - Intensity <= 100");

	UpdateWindow(hWnd);

	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");



	imageSegmentationDataFile.close();

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DrawRoadSign(HINSTANCE hInstance, HWND hWnd, UINT pLevelOfIdentity)
{
	HRESULT hr = S_OK;
	cout << "This Function Simulates Drawing In Direct2D" << endl;
	

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	hr = md2dmanager->DrawRoadSign(hInstance, hWnd, pLevelOfIdentity);
	
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::ThreshHoldImagePixelByCoordinatesCriteria(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageThresoldingOperationCoordinates.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectToGrayScale = vector<PixelObjectGrayScale>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;
	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMaximumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMaximumY;

	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME grayscaleTimeStartSystem;
	SYSTEMTIME grayscaleTimeStartLocal;
	SYSTEMTIME grayscaleTimeEndSystem;
	SYSTEMTIME grayscaleTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeEndLocal;





	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{



		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;

		SYSTEMTIME pClippningTime;
		GetLocalTime(&pClippningTime);
		cout << "Clipping Оf Image Stated at: " << pClippningTime.wHour << ":" << pClippningTime.wMinute << ":" << pClippningTime.wSecond << endl;
		pixelDataFile << "Clipping Оf Image Stated at: " << pClippningTime.wHour << ":" << pClippningTime.wMinute << ":" << pClippningTime.wSecond << endl;


		auto clippingStart = chrono::high_resolution_clock::now();

		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;

		auto clippingEnd = chrono::high_resolution_clock::now();
		auto clippingDuration = duration_cast<seconds>(clippingEnd - clippingStart);

		cout << "Clipping Took: " << clippingDuration.count() << " " << "seconds" << endl;
		pixelDataFile << "Clipping Took: " << clippingDuration.count() << " " << "seconds" << endl;

		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;



		GetSystemTime(&grayscaleTimeStartSystem);
		GetLocalTime(&grayscaleTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeStartSystem.wHour << ":" << grayscaleTimeStartSystem.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeStartLocal.wHour << ":" << grayscaleTimeStartLocal.wMinute << ":" << grayscaleTimeStartLocal.wSecond << endl;

		auto grayscaleStart = chrono::high_resolution_clock::now();



		hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
			pixelObjectVector, &pPixelObjectToGrayScale);


		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;
		time_t currentTime = time(0);
		pixelDataFile << "current time" << currentTime << endl;
		int pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		float pIndexValue = 0;

		cout << "Grayscale Section Begin" << endl;
		pixelDataFile << "Grayscale Section Begin" << endl;



		for (PixelObjectGrayScale pPixelObject : pPixelObjectToGrayScale)
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

			cout << "Step: " << pPixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

			pixelDataFile << "Step: " << pPixelNumber << endl;
			pixelDataFile << "X Value = " << pXValue << endl;
			pixelDataFile << "Y Value = " << pYValue << endl;
			pixelDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


			pIndexValue++;
		}


		GetSystemTime(&grayscaleTimeEndSystem);
		GetLocalTime(&grayscaleTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << grayscaleTimeEndSystem.wHour << ":" << grayscaleTimeEndSystem.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << grayscaleTimeEndLocal.wHour << ":" << grayscaleTimeEndLocal.wMinute << ":" << grayscaleTimeEndLocal.wSecond << endl;


		auto grayscaleEnd = chrono::high_resolution_clock::now();
		auto grayscaleDuration = duration_cast<seconds>(grayscaleEnd - grayscaleStart);

		cout << "Convertion to Grayscale Took: " << grayscaleDuration.count() << " " << "seconds" << endl;
		pixelDataFile << "Convertion to Grayscale Took: " << grayscaleDuration.count() << " " << "seconds" << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<OutputPixelObjectFilteredGrayScale> ppOutputPixelVector = vector<OutputPixelObjectFilteredGrayScale>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;

	

		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		auto pFilterStart = chrono::high_resolution_clock::now();




		hr = ppStandardAlgorithmExecutor->ThresoldPixelValuesByCoordinatesCriteria(hInstance, hWnd,
			pMinimumX,
			pMinimumY,
			pMaximumX,
			pMaximumY,
			pPixelObjectToGrayScale, &ppOutputPixelVector);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

		for (OutputPixelObjectFilteredGrayScale pPixelObject : ppOutputPixelVector)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pPixelObject.xPosition << endl;
			cout << "Y Value = " << pPixelObject.yPosition << endl;
			cout << "GrayScale Value = " << pPixelObject.pGrayScaleValue << endl;
			cout << "Is Pixel Valid = " << pPixelObject.pIsPixelValid << endl;


			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Value = " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Value = " << pPixelObject.yPosition << endl;
			pixelDataFile << "GrayScale Value = " << pPixelObject.pGrayScaleValue << endl;
			pixelDataFile << "Is Pixel Valid = " << pPixelObject.pIsPixelValid << endl;



			pIndexValue++;
		}

		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


		auto pFilterEnd = chrono::high_resolution_clock::now();
		auto pFilterDuration = duration_cast<seconds>(pFilterEnd - pFilterStart);

		cout << "Convertion to Grayscale Took: " << grayscaleDuration.count() << " " << "seconds" << endl;
		pixelDataFile << "Convertion to Grayscale Took: " << grayscaleDuration.count() << " " << "seconds" << endl;

	}





	pixelDataFile.close();
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SearchForBorderControlWithinImages(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageBorderControlFunctionCS.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	SYSTEMTIME st, lt;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	printf("The system time is: %02d:%02d\n", st.wHour, st.wMinute, st.wSecond);
	printf(" The local time is: %02d:%02d\n", lt.wHour, lt.wMinute, lt.wSecond );

	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << lt.wHour << ":" << lt.wMinute << ":" << lt.wSecond << endl;

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

    


	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	SYSTEMTIME pClippningTime;
	GetLocalTime(&pClippningTime);
	cout << "Clipping Оf Image Stated at: " << pClippningTime.wHour << ":" << pClippningTime.wMinute << ":" << pClippningTime.wSecond << endl;
	imageSegmentationDataFile << "Clipping Оf Image Stated at: " << pClippningTime.wHour << ":" << pClippningTime.wMinute << ":" << pClippningTime.wSecond << endl;
	auto clippingStart = chrono::high_resolution_clock::now();



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	auto clippingEnd = chrono::high_resolution_clock::now();
	auto clippingDuration = duration_cast<seconds>(clippingEnd - clippingStart);

	cout << "Clipping Took: " << clippingDuration.count() << " " << "seconds" << endl;
	imageSegmentationDataFile << "Clipping Took: " << clippingDuration.count() << " " << "seconds" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	SYSTEMTIME pGrayscaleTimeImageEight;
	GetLocalTime(&pGrayscaleTimeImageEight);
	cout << "GrayScale Conversion of Image One Started at: " << pGrayscaleTimeImageEight.wHour << ":" << pGrayscaleTimeImageEight.wMinute << ":" << pGrayscaleTimeImageEight.wSecond << endl;
	imageSegmentationDataFile << "GrayScale Conversion of Image One Started at: " << pGrayscaleTimeImageEight.wHour << ":" << pGrayscaleTimeImageEight.wMinute << ":" << pGrayscaleTimeImageEight.wSecond << endl;


	auto grayscaleStart = chrono::high_resolution_clock::now();



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelNumber << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	auto grayscaleEnd = chrono::high_resolution_clock::now();
	auto grayscaleDuration = duration_cast<seconds>(grayscaleEnd - grayscaleStart);

	cout << "Conversion to Grayscale Took: " << grayscaleDuration.count() << " " << "seconds" << endl;
	imageSegmentationDataFile << "Conversion to Grayscale Took: " << grayscaleDuration.count() << " " << "seconds" << endl;




	SYSTEMTIME pGrayscaleTimeImageTwo;
	GetLocalTime(&pGrayscaleTimeImageTwo);
	cout << "GrayScale Conversion of Image One Started at: " << pGrayscaleTimeImageTwo.wHour << ":" << pGrayscaleTimeImageTwo.wMinute << ":" << pGrayscaleTimeImageTwo.wSecond << endl;
	imageSegmentationDataFile << "GrayScale Conversion of Image One Started at: " << pGrayscaleTimeImageTwo.wHour << ":" << pGrayscaleTimeImageTwo.wMinute << ":" << pGrayscaleTimeImageTwo.wSecond << endl;


	auto grayscaleStartImageTwo = chrono::high_resolution_clock::now();




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

	    int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Pixel Number: " << pPixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelNumber << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	auto grayscaleEndImageTwo = chrono::high_resolution_clock::now();
	auto grayscaleDurationImageTwo = duration_cast<seconds>(grayscaleEndImageTwo - grayscaleStartImageTwo);

	cout << "Conversion to Grayscale Took: " << grayscaleDurationImageTwo.count() << " " << "seconds" << endl;
	imageSegmentationDataFile << "Conversion to Grayscale Took: " << grayscaleDurationImageTwo.count() << " " << "seconds" << endl;




	SYSTEMTIME pBorderSearchTime;
	GetLocalTime(&pBorderSearchTime);
	cout << "Border Search Started at: " << pGrayscaleTimeImageTwo.wHour << ":" << pGrayscaleTimeImageTwo.wMinute << ":" << pGrayscaleTimeImageTwo.wSecond << endl;
	imageSegmentationDataFile << "Border Search Started at:  " << pGrayscaleTimeImageTwo.wHour << ":" << pGrayscaleTimeImageTwo.wMinute << ":" << pGrayscaleTimeImageTwo.wSecond << endl;
	auto imageFilterStart = chrono::high_resolution_clock::now();



	vector<BorderOutputStructure> ppBorderOutputStructureValues = vector<BorderOutputStructure>();

	hr = ppStandardAlgorithmExecutor->SearchForBordersWithinImages(hInstance,
		hWnd,
		ppImageOneGrayScale,
		ppImageTwoGrayScale,
		&ppBorderOutputStructureValues);

	cout << "Prinitng the Contents of the output buffer" << endl;


	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (BorderOutputStructure ppOutputPixelValue : ppBorderOutputStructureValues)
	{
		cout << "Pixel Number " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position Eight" << " = " << ppOutputPixelValue.xPosition0 << endl;
		cout << "Y Position Eight " << " = " << ppOutputPixelValue.yPosition0 << endl;
		cout << "X Position Two" << " = " << ppOutputPixelValue.xPosition0 << endl;
		cout << "Y Position Two " << " = " << ppOutputPixelValue.yPosition0 << endl;
		cout << "GrayScale Value0 " << " = " << ppOutputPixelValue.pGrayScaleValue0 << endl;
		cout << "GrayScale Value1 " << " = " << ppOutputPixelValue.pGrayScaleValue1 << endl;
		cout << "Output GrayScale Value " << " = " << ppOutputPixelValue.pOutputPixelValue << endl;
		cout << "Is Pixel Border " << ppOutputPixelValue.pIsBorderValue << endl;


		imageSegmentationDataFile << "Pixel Number " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position Eight" << " = " << ppOutputPixelValue.xPosition0 << endl;
		imageSegmentationDataFile << "Y Position Eight " << " = " << ppOutputPixelValue.yPosition0 << endl;
		imageSegmentationDataFile << "X Position Two" << " = " << ppOutputPixelValue.xPosition0 << endl;
		imageSegmentationDataFile << "Y Position Two " << " = " << ppOutputPixelValue.yPosition0 << endl;
		imageSegmentationDataFile << "GrayScale Value0 " << " = " << ppOutputPixelValue.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "GrayScale Value1 " << " = " << ppOutputPixelValue.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output GrayScale Value " << " = " << ppOutputPixelValue.pOutputPixelValue << endl;
		imageSegmentationDataFile << "Is Pixel Border " << ppOutputPixelValue.pIsBorderValue << endl;



		pIndex++;
	}

	auto imageFilterEnd = chrono::high_resolution_clock::now();
	auto imageFilterDuration = duration_cast<seconds>(imageFilterEnd - imageFilterStart);

	cout << "Image Filter Took: " << grayscaleDurationImageTwo.count() << " " << "seconds" << endl;
	imageSegmentationDataFile << "Image Filter Took: " << grayscaleDurationImageTwo.count() << " " << "seconds" << endl;



	imageSegmentationDataFile.close();

	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::ClipImageAgainstABitmapMask(HINSTANCE hInstance,
	HWND hWnd)
{


	HRESULT hr = S_OK;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\BitmapMasksObject.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();
	LPWSTR szFileNameEight = nullptr;
	LPWSTR szFileNameTwo = nullptr;

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);



	// Show the File Open dialog.
	wchar_t path0[MAX_PATH];
	path0[0] = L'\0';

	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path0;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn1))
	{
		szFileNameEight = ofn1.lpstrFile;

	}


	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path1;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		// Open the file with the playback object.
		szFileNameTwo = ofn.lpstrFile;

	}




	vector<PixelObject> pOutputPixelObjectVector = vector<PixelObject>();

	hr = md2dmanager->ClipImageAgainstABitmapMask(hInstance,
		hWnd,
		szFileNameEight,
		szFileNameTwo,
		pTopLeftX,
		pTopLeftY,
		pImageWidth,
		pImageHeight,
		&pOutputPixelObjectVector);

	cout << "Printing pixel object vector" << endl;

	for (PixelObject pixelObject : pOutputPixelObjectVector)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	
	return hr;

}



HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdentical(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	

	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);



	SYSTEMTIME clippingTimeStartLocal;
	GetLocalTime(&clippingTimeStartLocal);

	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	SYSTEMTIME direct2DTimeStartLocal;
	GetLocalTime(&direct2DTimeStartLocal);

	cout << " Direct2D Boot Started System Local\n" << direct2DTimeStartLocal.wHour << ":" <<
		direct2DTimeStartLocal.wMinute << ":" << direct2DTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Direct2D Boot Started System Local\n" << direct2DTimeStartLocal.wHour << ":" <<
		direct2DTimeStartLocal.wMinute << ":" << direct2DTimeStartLocal.wSecond << endl;





	SYSTEMTIME direct2DTimeEndLocal;
	GetLocalTime(&direct2DTimeEndLocal);

	cout << " Direct2D Boot End System Local\n" << direct2DTimeEndLocal.wHour << ":" <<
		direct2DTimeEndLocal.wMinute << ":" << direct2DTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Direct2D Boot End System Local\n" << direct2DTimeEndLocal.wHour << ":" <<
		direct2DTimeEndLocal.wMinute << ":" << direct2DTimeEndLocal.wSecond << endl;




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;

	SYSTEMTIME clippingImageOneStartLocal;
	GetLocalTime(&clippingImageOneStartLocal);

	auto start = high_resolution_clock::now();





	cout << " Clipping of First Image Started  Local\n" << clippingImageOneStartLocal.wHour << ":" <<
		clippingImageOneStartLocal.wMinute << ":" << clippingImageOneStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of First Image Started Local\n" << clippingImageOneStartLocal.wHour << ":" <<
		clippingImageOneStartLocal.wMinute << ":" << clippingImageOneStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	SYSTEMTIME clippingImageOneEndLocal;
	GetLocalTime(&clippingImageOneEndLocal);

	cout << " Clipping of First Image Ended  Local\n" << clippingImageOneEndLocal.wHour << ":" <<
		clippingImageOneEndLocal.wMinute << ":" << clippingImageOneEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of First Image Ended Local\n" << clippingImageOneEndLocal.wHour << ":" <<
		clippingImageOneEndLocal.wMinute << ":" << clippingImageOneEndLocal.wSecond << endl;



	SYSTEMTIME clippingImageTwoStartLocal;
	GetLocalTime(&clippingImageTwoStartLocal);



	cout << " Clipping of Second Image Started  Local\n" << clippingImageTwoStartLocal.wHour << ":" <<
		clippingImageTwoStartLocal.wMinute << ":" << clippingImageTwoStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of Second Image Started Local\n" << clippingImageTwoStartLocal.wHour << ":" <<
		clippingImageTwoStartLocal.wMinute << ":" << clippingImageTwoStartLocal.wSecond << endl;



	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	SYSTEMTIME clippingImageTwoEndLocal;
	GetLocalTime(&clippingImageTwoEndLocal);



	cout << " Clipping of Second Image End  Local\n" << clippingImageTwoEndLocal.wHour << ":" <<
		clippingImageTwoEndLocal.wMinute << ":" << clippingImageTwoEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of Second Image End Local\n" << clippingImageTwoEndLocal.wHour << ":" <<
		clippingImageTwoEndLocal.wMinute << ":" << clippingImageTwoEndLocal.wSecond << endl;


	SYSTEMTIME grayScaleImageOneStartLocal;
	GetLocalTime(&grayScaleImageOneStartLocal);



	cout << " Conversion to GrayScale for Image One Started  Local\n" << grayScaleImageOneStartLocal.wHour << ":" <<
		grayScaleImageOneStartLocal.wMinute << ":" << grayScaleImageOneStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image One Local\n" << grayScaleImageOneStartLocal.wHour << ":" <<
		grayScaleImageOneStartLocal.wMinute << ":" << grayScaleImageOneStartLocal.wSecond << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance,
		hWnd,
		pixelObjectImageEight,
		&ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	SYSTEMTIME grayScaleImageOneEndLocal;
	GetLocalTime(&grayScaleImageOneEndLocal);



	cout << " Conversion to GrayScale for Image One Ended  Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image One Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;





	SYSTEMTIME grayScaleImageTwoStartLocal;
	GetLocalTime(&grayScaleImageTwoStartLocal);



	cout << " Conversion to GrayScale for Image Two Started  Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image Two Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;





	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	SYSTEMTIME grayScaleImageTwoEndLocal;
	GetLocalTime(&grayScaleImageTwoEndLocal);



	cout << " Conversion to GrayScale for Image Two End Local\n" << grayScaleImageTwoEndLocal.wHour << ":" <<
		grayScaleImageTwoEndLocal.wMinute << ":" << grayScaleImageTwoEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image Two End Local\n" << grayScaleImageTwoEndLocal.wHour << ":" <<
		grayScaleImageTwoEndLocal.wMinute << ":" << grayScaleImageTwoEndLocal.wSecond << endl;







	SYSTEMTIME imageComparisonStartLocal;
	GetLocalTime(&imageComparisonStartLocal);



	cout << " Image Comparison Started  Local\n" << imageComparisonStartLocal.wHour << ":" <<
		imageComparisonStartLocal.wMinute << ":" << imageComparisonStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Image Comparison Started  Local\n" << imageComparisonStartLocal.wHour << ":" <<
		imageComparisonStartLocal.wMinute << ":" << imageComparisonStartLocal.wSecond << endl;






	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	 pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	 pIdenticalPixelOutputArraySum = 0.0f;
	 pIdenticalPixelArrayAverage = 0.0f;
	 pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);

		UpdateWindow(hWnd);
	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}


	SYSTEMTIME imageComparisonEndLocal;
	GetLocalTime(&imageComparisonEndLocal);

	cout << " Image Comparison End  Local\n" << imageComparisonEndLocal.wHour << ":" <<
		imageComparisonStartLocal.wMinute << ":" << imageComparisonEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Image Comparison Started  Local\n" << imageComparisonEndLocal.wHour << ":" <<
		imageComparisonStartLocal.wMinute << ":" << imageComparisonEndLocal.wSecond << endl;



	// Get ending timepoint 
	auto stop = high_resolution_clock::now();

	// Get duration. Substart timepoints to  
	// get durarion. To cast it to proper unit 
	// use duration cast method 
	auto duration = duration_cast<seconds>(stop - start);

	cout << "Time taken by Comparison function : "
		<< duration.count() << " seconds" << endl;

	imageSegmentationDataFile << "Time taken by Comparison  function: "
		<< duration.count() << " seconds" << endl;


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}




HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalDecomposedVersion(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFileDecomposedVersion.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	SYSTEMTIME clippingTimeStartLocal;
	GetLocalTime(&clippingTimeStartLocal);
	
	cout << " Clipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " TClipping Started System Local\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	SYSTEMTIME direct2DTimeStartLocal;
	GetLocalTime(&direct2DTimeStartLocal);

	cout << " Direct2D Boot Started System Local\n" << direct2DTimeStartLocal.wHour << ":" <<
		direct2DTimeStartLocal.wMinute << ":" << direct2DTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Direct2D Boot Started System Local\n" << direct2DTimeStartLocal.wHour << ":" <<
		direct2DTimeStartLocal.wMinute << ":" << direct2DTimeStartLocal.wSecond << endl;




	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	SYSTEMTIME direct2DTimeEndLocal;
	GetLocalTime(&direct2DTimeEndLocal);

	cout << " Direct2D Boot End System Local\n" << direct2DTimeEndLocal.wHour << ":" <<
		direct2DTimeEndLocal.wMinute << ":" << direct2DTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Direct2D Boot End System Local\n" << direct2DTimeEndLocal.wHour << ":" <<
		direct2DTimeEndLocal.wMinute << ":" << direct2DTimeEndLocal.wSecond << endl;




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;

	SYSTEMTIME clippingImageOneStartLocal;
	GetLocalTime(&clippingImageOneStartLocal);

	auto start = high_resolution_clock::now();





	cout << " Clipping of First Image Started  Local\n" << clippingImageOneStartLocal.wHour << ":" <<
		clippingImageOneStartLocal.wMinute << ":" << clippingImageOneStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of First Image Started Local\n" << clippingImageOneStartLocal.wHour << ":" <<
		clippingImageOneStartLocal.wMinute << ":" << clippingImageOneStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	SYSTEMTIME clippingImageOneEndLocal;
	GetLocalTime(&clippingImageOneEndLocal);

	cout << " Clipping of First Image Ended  Local\n" << clippingImageOneEndLocal.wHour << ":" <<
		clippingImageOneEndLocal.wMinute << ":" << clippingImageOneEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of First Image Ended Local\n" << clippingImageOneEndLocal.wHour << ":" <<
		clippingImageOneEndLocal.wMinute << ":" << clippingImageOneEndLocal.wSecond << endl;



	SYSTEMTIME clippingImageTwoStartLocal;
	GetLocalTime(&clippingImageTwoStartLocal);



	cout << " Clipping of Second Image Started  Local\n" << clippingImageTwoStartLocal.wHour << ":" <<
		clippingImageTwoStartLocal.wMinute << ":" << clippingImageTwoStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of Second Image Started Local\n" << clippingImageTwoStartLocal.wHour << ":" <<
		clippingImageTwoStartLocal.wMinute << ":" << clippingImageTwoStartLocal.wSecond << endl;



	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	SYSTEMTIME clippingImageTwoEndLocal;
	GetLocalTime(&clippingImageTwoEndLocal);



	cout << " Clipping of Second Image End  Local\n" << clippingImageTwoEndLocal.wHour << ":" <<
		clippingImageTwoEndLocal.wMinute << ":" << clippingImageTwoEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Clipping of Second Image End Local\n" << clippingImageTwoEndLocal.wHour << ":" <<
		clippingImageTwoEndLocal.wMinute << ":" << clippingImageTwoEndLocal.wSecond << endl;


	SYSTEMTIME grayScaleImageOneStartLocal;
	GetLocalTime(&grayScaleImageOneStartLocal);



	cout << " Conversion to GrayScale for Image One Started  Local\n" << grayScaleImageOneStartLocal.wHour << ":" <<
		grayScaleImageOneStartLocal.wMinute << ":" << grayScaleImageOneStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image One Local\n" << grayScaleImageOneStartLocal.wHour << ":" <<
		grayScaleImageOneStartLocal.wMinute << ":" << grayScaleImageOneStartLocal.wSecond << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance,
		hWnd,
		pixelObjectImageEight,
		&ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	SYSTEMTIME grayScaleImageOneEndLocal;
	GetLocalTime(&grayScaleImageOneEndLocal);



	cout << " Conversion to GrayScale for Image One Ended  Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image One Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;





	SYSTEMTIME grayScaleImageTwoStartLocal;
	GetLocalTime(&grayScaleImageTwoStartLocal);



	cout << " Conversion to GrayScale for Image Two Started  Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image Two Local\n" << grayScaleImageOneEndLocal.wHour << ":" <<
		grayScaleImageOneEndLocal.wMinute << ":" << grayScaleImageOneEndLocal.wSecond << endl;





	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	SYSTEMTIME grayScaleImageTwoEndLocal;
	GetLocalTime(&grayScaleImageTwoEndLocal);



	cout << " Conversion to GrayScale for Image Two End Local\n" << grayScaleImageTwoEndLocal.wHour << ":" <<
		grayScaleImageTwoEndLocal.wMinute << ":" << grayScaleImageTwoEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Conversion to GrayScale for Image Two End Local\n" << grayScaleImageTwoEndLocal.wHour << ":" <<
		grayScaleImageTwoEndLocal.wMinute << ":" << grayScaleImageTwoEndLocal.wSecond << endl;







	SYSTEMTIME imageComparisonStartLocal;
	GetLocalTime(&imageComparisonStartLocal);



	cout << " Image Comparison Started  Local\n" <<  imageComparisonStartLocal.wHour << ":" <<
		 imageComparisonStartLocal.wMinute << ":" <<  imageComparisonStartLocal.wSecond << endl;
	imageSegmentationDataFile << " Image Comparison Started  Local\n" <<  imageComparisonStartLocal.wHour << ":" <<
		 imageComparisonStartLocal.wMinute << ":" <<  imageComparisonStartLocal.wSecond << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppOutputArrayRestored = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalDecomposed(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppOutputArrayRestored,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);

		UpdateWindow(hWnd);
	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}


	SYSTEMTIME imageComparisonEndLocal;
	GetLocalTime(&imageComparisonEndLocal);



	cout << " Image Comparison End  Local\n" <<imageComparisonEndLocal.wHour << ":" <<
		imageComparisonStartLocal.wMinute << ":" <<imageComparisonEndLocal.wSecond << endl;
	imageSegmentationDataFile << " Image Comparison Started  Local\n" <<imageComparisonEndLocal.wHour << ":" <<
		imageComparisonStartLocal.wMinute << ":" <<imageComparisonEndLocal.wSecond << endl;



	// Get ending timepoint 
	auto stop = high_resolution_clock::now();

	// Get duration. Substart timepoints to  
	// get durarion. To cast it to proper unit 
	// use duration cast method 
	auto duration = duration_cast<seconds>(stop - start);

	cout << "Time taken by function: "
		<< duration.count() << " seconds" << endl;

	imageSegmentationDataFile << "Time taken by Comparison  function: "
		<< duration.count() << " seconds" << endl;


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}




HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalAgainstLargeImageParts(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список


	float pStepX = 0.0f;
	float pStepY = 0.0f;


	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageOnePartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageOnePartTwo = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwoPartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwoPartTwo = vector<PixelObject>();

	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();

	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	pStepX = 200;
	pStepY = 200;


	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectImageOnePartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageOnePartOne)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectImageOnePartTwo);



	for (PixelObject pixelObject : pixelObjectImageOnePartTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	pixelObjectImageOnePartOne.insert(pixelObjectImageOnePartOne.end(), pixelObjectImageOnePartTwo.begin(), pixelObjectImageOnePartTwo.end());

	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectImageTwoPartOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageTwoPartOne)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectImageTwoPartTwo);


	for (PixelObject pixelObject : pixelObjectImageTwoPartTwo)
	{
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	
	pixelObjectImageTwoPartOne.insert(pixelObjectImageTwoPartOne.end(), pixelObjectImageTwoPartTwo.begin(), pixelObjectImageTwoPartTwo.end());





	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance,
		hWnd,
		pixelObjectImageOnePartOne,
		&ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}







	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwoPartOne, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}













	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	pOutputArrayIntensitySum = 0.0f;
	pOutputArrayAverage = 0.0f;
	pIdenticalPixelOutputArraySum = 0.0f;
	pIdenticalPixelArrayAverage = 0.0f;
	pDifferentPixelArraySum = 0.0f;
	pDifferentPixelArrayAverage = 0.0f;

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;

		md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, ppOutputPixelValue.pAmountOfIdenticalPixels, ppOutputPixelValue.pAmountOfDifferentPixels);

		UpdateWindow(hWnd);
	}

	pOutputArrayAverage = pOutputArrayIntensitySum / ppVerificationOutputArray.size();

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
		pIdenticalPixelOutputArraySum = pIdenticalPixelOutputArraySum + pIdenticalPixelObject.pGreyLevel;
	}

	if (ppIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelOutputArraySum / ppIdenticalPixelOutputArray.size();
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
		pDifferentPixelArraySum = pDifferentPixelArraySum + pDifferentPixelObject.pGreyLevel;
	}
	if (ppDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pDifferentPixelArraySum / ppDifferentPixelOutputArray.size();
	}



	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	cout << "Creating Visualization Diagram" << endl;




	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}




HRESULT  DirectXGPUDigitalLabCoreModule::DetectMotionInRGBImages(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DetectMotionInRGBImages.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<MotionPixelObjectRGB> ppVerificationOutputArray = vector<MotionPixelObjectRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;




	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



	hr = ppStandardAlgorithmExecutor->DetectMotionInRGBImage(hInstance, hWnd, pixelObjectImageEight,
		pixelObjectImageTwo, &ppVerificationOutputArray,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (MotionPixelObjectRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
		cout << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
		imageSegmentationDataFile << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

		BOOL pIsMotionDetected = FALSE;

		if (pOutputPixelValue.pRedComponentDifference > 0 | pOutputPixelValue.pGreenComponentDifference > 0 | pOutputPixelValue.pBlueComponentDifference > 0)
		{
			pIsMotionDetected = TRUE;
			
		}
		else
		{
			pIsMotionDetected = FALSE;
		}
		
		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pIsMotionDetected);

	}



	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;







	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}







HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalRGBWithBundleCreation(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	vector<OutputPixelBundleWithValidations> pOutputPixelDataBufferArray = vector<OutputPixelBundleWithValidations>();

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RGBComparisonOfDigitalImagesWithBundleCreation.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	UINT pRedComponentLimit = 0;
	UINT pGreenComponentLimit = 0;
	UINT pBlueComponentLimit = 0;

	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the Limit for the Red Component of the Pixel" << endl;
	cin >> pRedComponentLimit;

	cout << "Enter the Limit for the Green Component of the Pixel" << endl;
	cin >> pGreenComponentLimit;

	cout << "Enter the Limit for the Blue Component of the Pixel" << endl;
	cin >> pBlueComponentLimit;


	cout << "Top Left X: " << pTopLeftX << endl;
	cout << "Top Left Y: " << pTopLeftY << endl;
	cout << "Image Width: " << pImageWidth << endl;
	cout << "Image Height: " << pImageHeight << endl;
	cout << "Red Component Limit: " << pRedComponentLimit << endl;
	cout << "Green Component Limit: " << pGreenComponentLimit << endl;
	cout << "Blue Component Limit: " << pBlueComponentLimit << endl;

	imageSegmentationDataFile << "Top Left X: " << pTopLeftX << endl;
	imageSegmentationDataFile << "Top Left Y: " << pTopLeftY << endl;
	imageSegmentationDataFile << "Image Width: " << pImageWidth << endl;
	imageSegmentationDataFile << "Image Height: " << pImageHeight << endl;
	imageSegmentationDataFile << "Red Component Limit: " << pRedComponentLimit << endl;
	imageSegmentationDataFile << "Green Component Limit: " << pGreenComponentLimit << endl;
	imageSegmentationDataFile << "Blue Component Limit: " << pBlueComponentLimit << endl;






	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObjectWithoutD2D(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;




	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGB(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	
	vector<PixelBundle> pBundleArrayObject = vector<PixelBundle>();

	cout << "Splitting the Output Material into Pixel bundles for further analysis" << endl;
	imageSegmentationDataFile << "Splitting the Output Material into Pixel bundles for further analysis" << endl;

	hr = ppStandardAlgorithmExecutor->SplitResultsOfImageComparisonIntoBundles(hInstance,
		hWnd, pImageWidth, pImageHeight,
		ppVerificationOutputArray,
		&pBundleArrayObject);

	vector <PixelObject> pOutputPixelVector = vector<PixelObject>();

	for (PixelBundle pPixelBundleObject : pBundleArrayObject)
	{





		cout << "Bundle id:" << pPixelBundleObject.pBundleId << endl;
		cout << "Pixel Eight Details: " << endl;
		cout << "X Position: " << pPixelBundleObject.xPosition << endl;
		cout << "Y Position: " << pPixelBundleObject.yPosition << endl;
		cout << "Red Component Image One: " << pPixelBundleObject.pRedValue0 << endl;
		cout << "Green Component Image One: " << pPixelBundleObject.pGreenValue0 << endl;
		cout << "Blue Component Image One" << pPixelBundleObject.pBlueValue0 << endl;
	
    	cout << "Red Component Image Two: " << pPixelBundleObject.pRedValue1 << endl;
		cout << "Green Component Image Two: " << pPixelBundleObject.pGreenValue1 << endl;
		cout << "Blue Component Image Two" << pPixelBundleObject.pBlueValue1 << endl;
		cout << "Output Pixel Details" << endl;
		
        cout << "Red Component Output: " << pPixelBundleObject.pRedValue2 << endl;
		cout << "Green Component Output: " << pPixelBundleObject.pGreenValue2 << endl;
		cout << "Blue Component Output: " << pPixelBundleObject.pBlueValue2 << endl;
		cout << "Is Bundle Equal: " << pPixelBundleObject.pIsBundleValid << endl;

		imageSegmentationDataFile << "Bundle id:" << pPixelBundleObject.pBundleId << endl;
		imageSegmentationDataFile << "Pixel Eight Details: " << endl;
		imageSegmentationDataFile << "X Position: " << pPixelBundleObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelBundleObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component Image One: " << pPixelBundleObject.pRedValue0 << endl;
		imageSegmentationDataFile << "Green Component Image One: " << pPixelBundleObject.pGreenValue0 << endl;
		imageSegmentationDataFile << "Blue Component Image One" << pPixelBundleObject.pBlueValue0 << endl;

		imageSegmentationDataFile << "Red Component Image Two: " << pPixelBundleObject.pRedValue1 << endl;
		imageSegmentationDataFile << "Green Component Image Two: " << pPixelBundleObject.pGreenValue1 << endl;
		imageSegmentationDataFile << "Blue Component Image Two" << pPixelBundleObject.pBlueValue1 << endl;
		imageSegmentationDataFile << "Output Pixel Details" << endl;

		imageSegmentationDataFile << "Red Component Output: " << pPixelBundleObject.pRedValue2 << endl;
		imageSegmentationDataFile << "Green Component Output: " << pPixelBundleObject.pGreenValue2 << endl;
		imageSegmentationDataFile << "Blue Component Output: " << pPixelBundleObject.pBlueValue2 << endl;
		imageSegmentationDataFile << "Is Bundle Equal: " << pPixelBundleObject.pIsBundleValid << endl;


		PixelObject pPixelObjectVar = PixelObject(pPixelBundleObject.pBundleId,
			pPixelBundleObject.xPosition, pPixelBundleObject.yPosition, pPixelBundleObject.pRedValue2, pPixelBundleObject.pGreenValue2, pPixelBundleObject.pBlueValue2);
		pOutputPixelVector.push_back(pPixelObjectVar);
	}
	
	vector<OutputPixelObjectClassified> pOutputBinaryFilterArray = vector<OutputPixelObjectClassified>();
	
	CBBinaryClassifierConstantBuffer pBinaryClassifierCB;
	
	cout << "Validating Pixel Buffer Against a Threshold" << endl;
	hr = ppStandardAlgorithmExecutor->ApplyBinaryClassifierForImagePixels(hInstance, hWnd,
		pRedComponentLimit,
		pGreenComponentLimit,
		pBlueComponentLimit,
		1.0f,
		0.0f,
		pOutputPixelVector, &pOutputBinaryFilterArray);


	for (OutputPixelObjectClassified pPixelObject : pOutputBinaryFilterArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
		cout << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
		cout << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
		cout << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.rValue << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.gValue << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.bValue << endl;
		imageSegmentationDataFile << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
		imageSegmentationDataFile << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
		imageSegmentationDataFile << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
		imageSegmentationDataFile << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;



	}


	imageSegmentationDataFile << "Validating Pixel Buffer Against a Threshold" << endl;




	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;







	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}


HRESULT  DirectXGPUDigitalLabCoreModule::MultiplyImageIntensityByANumber(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\MultiplyImageRGBPixelByANumber.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageOne)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	float pColorToSubtractRed = 0.0f;
	float pColorToSubtractGreen = 0.0f;
	float pColorToSubtractBlue = 0.0f;

	cout << "Enter the Value for Synthetic Red Color" << endl;
	cin >> pColorToSubtractRed;

	cout << "Enter the Value for Synthetic Green Color" << endl;
	cin >> pColorToSubtractGreen;

	cout << "Enter the Value for Synhtetic BLue Color" << endl;
	cin >> pColorToSubtractBlue;

	vector<PixelObject> pSyntheticImage = vector<PixelObject>();

	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;





	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



	hr = ppStandardAlgorithmExecutor->MultiplyImagePixelValuesByAColor(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageOne,
		pColorToSubtractRed,
		pColorToSubtractGreen,
		pColorToSubtractBlue,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);



	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	vector<PixelObject> pOutputImage = vector<PixelObject>();


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	vector<PixelObject> pOutputImageNonZeroElements = vector<PixelObject>();
	vector<PixelObject> pOutputImageZeroElements = vector<PixelObject>();




	cout << "Restoring Image Pixel Data for Filter Non-Zero  Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompation(hInstance, hWnd,
		ppVerificationOutputArray, &pOutputImageNonZeroElements);

	cout << "Printing the Results of the Output" << endl;

	vector<float> pXPositionValues = vector<float>();
	vector<float> pYPositionValues = vector<float>();

	for (PixelObject pixelObject : pOutputImageNonZeroElements)
	{

		float pColorSum = 0.0f;
		pColorSum = pixelObject.RMask + pixelObject.GMask + pixelObject.BMask;
		if (pColorSum != 765.0f)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}



	cout << "Restoring Image Pixel Data for Filter Non-Zero  Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompationInitialPixels(hInstance, hWnd,
		ppVerificationOutputArray, &pOutputImageZeroElements);

	cout << "Printing the Results of the Output" << endl;

	for (PixelObject pixelObject : pOutputImageNonZeroElements)
	{

		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}

	imageSegmentationDataFile.close();

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pOutputImageNonZeroElements, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);




	imageSegmentationDataFile.close();

	return hr;
}



HRESULT  DirectXGPUDigitalLabCoreModule::DivideImageIntensityByANumber(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\DivideImagePixelDataByANumber.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageOne)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	float pColorToSubtractRed = 0.0f;
	float pColorToSubtractGreen = 0.0f;
	float pColorToSubtractBlue = 0.0f;

	cout << "Enter the Value for Synthetic Red Color" << endl;
	cin >> pColorToSubtractRed;

	cout << "Enter the Value for Synthetic Green Color" << endl;
	cin >> pColorToSubtractGreen;

	cout << "Enter the Value for Synhtetic BLue Color" << endl;
	cin >> pColorToSubtractBlue;

	vector<PixelObject> pSyntheticImage = vector<PixelObject>();

	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;








	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;


	hr = ppStandardAlgorithmExecutor->DivideImagePixelValuesByAColor(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageOne,
		pColorToSubtractRed,
		pColorToSubtractGreen,
		pColorToSubtractBlue,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);



	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	vector<PixelObject> pOutputImage = vector<PixelObject>();


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	vector<PixelObject> pOutputImageNonZeroElements = vector<PixelObject>();
	vector<PixelObject> pOutputImageZeroElements = vector<PixelObject>();




	cout << "Restoring Image Pixel Data for Filter Non-Zero  Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompation(hInstance, hWnd,
		ppVerificationOutputArray, &pOutputImageNonZeroElements);

	cout << "Printing the Results of the Output" << endl;

	vector<float> pXPositionValues = vector<float>();
	vector<float> pYPositionValues = vector<float>();

	for (PixelObject pixelObject : pOutputImageNonZeroElements)
	{

		float pColorSum = 0.0f;
		pColorSum = pixelObject.RMask + pixelObject.GMask + pixelObject.BMask;
		if (pColorSum != 765.0f)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}



	cout << "Restoring Image Pixel Data for Filter Non-Zero  Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreZeroRGBPixelsFromImageCompation(hInstance, hWnd,
		ppVerificationOutputArray, &pOutputImageZeroElements);

	cout << "Printing the Results of the Output" << endl;

	for (PixelObject pixelObject : pOutputImageNonZeroElements)
	{

		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}

	imageSegmentationDataFile.close();

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pOutputImageNonZeroElements, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);




	imageSegmentationDataFile.close();

	return hr;
}


HRESULT  DirectXGPUDigitalLabCoreModule::AddInternsityValuesToColorsOfRGBImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\AddumbersToPixelsOfRGBImage.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageOne);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageOne)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	float pColorToSubtractRed = 0.0f;
	float pColorToSubtractGreen = 0.0f;
	float pColorToSubtractBlue = 0.0f;

	cout << "Enter the Value for Synthetic Red Color" << endl;
	cin >> pColorToSubtractRed;

	cout << "Enter the Value for Synthetic Green Color" << endl;
	cin >> pColorToSubtractGreen;

	cout << "Enter the Value for Synhtetic BLue Color" << endl;
	cin >> pColorToSubtractBlue;

	vector<PixelObject> pSyntheticImage = vector<PixelObject>();

	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;




	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


	hr = ppStandardAlgorithmExecutor->AddColorToImagePixelsFromRGBImage(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageOne,
		pColorToSubtractRed,
		pColorToSubtractGreen,
		pColorToSubtractBlue,
		&ppVerificationOutputArray);



	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	vector<PixelObject> pOutputImage = vector<PixelObject>();


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	vector<PixelObject> pOutputImageNonZeroElements = vector<PixelObject>();
	vector<PixelObject> pOutputImageZeroElements = vector<PixelObject>();




	cout << "Restoring Image Pixel Data for Filter Non-Zero  Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreNonZeroRGBPixelsFromImageCompation(hInstance, hWnd,
		ppVerificationOutputArray, &pOutputImageNonZeroElements);

	cout << "Printing the Results of the Output" << endl;

	vector<float> pXPositionValues = vector<float>();
	vector<float> pYPositionValues = vector<float>();

	for (PixelObject pixelObject : pOutputImageNonZeroElements)
	{

		float pColorSum = 0.0f;
		pColorSum = pixelObject.RMask + pixelObject.GMask + pixelObject.BMask;
		if (pColorSum != 765.0f)
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}



	cout << "Restoring Image Pixel Data for Filter Non-Zero  Output" << endl;
	hr = ppStandardAlgorithmExecutor->RestoreZeroRGBPixelsFromImageCompation(hInstance, hWnd,
		ppVerificationOutputArray, &pOutputImageZeroElements);

	cout << "Printing the Results of the Output" << endl;

for (PixelObject pixelObject : pOutputImageNonZeroElements)
	{

		if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;


			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			pXPositionValues.push_back(pixelObject.xPosition);
			pYPositionValues.push_back(pixelObject.yPosition);
		}
	}

	imageSegmentationDataFile.close();

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pOutputImageNonZeroElements, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);




	imageSegmentationDataFile.close();

	return hr;
}




HRESULT  DirectXGPUDigitalLabCoreModule::SubtractValuesFromColorsOfRGBImage(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\SubtractNumberFromRGBImage.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	vector<PixelObject> pixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorTwo = vector<PixelObject>();

	UINT pStepX = 0;
	UINT pStepY = 0;
	UINT pIndex = 0;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepX, &pixelObjectVectorOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorOne)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}

		cout << "Verifying Container for Identical Elements" << endl;



		stop = high_resolution_clock::now();
		// Get duration. Substart timepoints to
		// get durarion. To cast it to proper unit
		// use duration cast method
		duration = duration_cast<microseconds>(stop - start);
		cout << "Time taken by Clip One: "
			<< duration.count() << " microseconds" << endl;
		cout << "Time taken by Clip One: "
			<< duration.count() / 10000000 << " seconds" << endl;
		cout << "Performing the Second scan of the image" << endl;
		auto start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorTwo);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for Y Axis" << endl;

		pIndex = 0;
		for (PixelObject pixelObject : pixelObjectVectorTwo)
		{
			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255.0f) && (pixelObject.BMask != 255.0f))
			{
				cout << "Index: " << pIndex << endl;
				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				imageSegmentationDataFile << "Index: " << pIndex << endl;
				imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
				imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
				imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
				imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
				imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}
		}
	}
		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorOne.end();
		pixelObjectVectorOne.insert(pVectorOneIt, pixelObjectVectorTwo.begin(), pixelObjectVectorTwo.end());






	float pColorToSubtractRed = 0.0f;
	float pColorToSubtractGreen = 0.0f;
	float pColorToSubtractBlue = 0.0f;

	cout << "Enter the Value for Synthetic Red Color" << endl;
	cin >> pColorToSubtractRed;

	cout << "Enter the Value for Synthetic Green Color" << endl;
	cin >> pColorToSubtractGreen;

	cout << "Enter the Value for Synhtetic BLue Color" << endl;
	cin >> pColorToSubtractBlue;

	vector<PixelObject> pSyntheticImage = vector<PixelObject>();

	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;




	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


	hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImage(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectVectorOne,
		pColorToSubtractRed,
		pColorToSubtractGreen,
		pColorToSubtractBlue,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);



	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	vector<PixelObject> pOutputImage = vector<PixelObject>();


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		PixelObject pOutputPixel = PixelObject(pOutputPixelValue.pixelNumber, pOutputPixelValue.xPosition, pOutputPixelValue.yPosition, pOutputPixelValue.pOutputComparisonValueRed,
			pOutputPixelValue.pOutputComparisonValueGreen, pOutputPixelValue.pOutputComparisonValueBlue);
			pOutputImage.push_back(pOutputPixel);


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}





	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->DrawPixelBuffer(hInstance, hWnd, pOutputImage, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight);





	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}





HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalRGB(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RGBComparisonOfDigitalImagesWithBundleCreation.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;




	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGB(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}





	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;







	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}



HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalRGBAgainstSyntheticImages(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RGBComparisonOfADigitalImgeAndSyntheticImage.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectVectorOnePartOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorOnePartTwo = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageOne = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	UINT pStepX = 0;
	UINT pStepY = 0;
	float pSyntheticRed = 0.0f;
	float pSyntheticGreen = 0.0f;
	float pSyntheticBlue = 0.0f;




	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;



	cout << "Enter the Red Value of Synthetic Image" << endl;
	cin >> pSyntheticRed;


	cout << "Enter the Green Value of Synthetic Image" << endl;
	cin >> pSyntheticGreen;


	cout << "Enter the Blue Value of Synthetic Image" << endl;
	cin >> pSyntheticBlue;


	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;
	LPWSTR path = nullptr;

	cout << "Synthetic Image: " << endl;
	cout << "Image Width: " << pImageWidth << endl;
	cout << "Image Height: " << pImageHeight << endl;

	cout << "Enter the step for the X Clip " << endl;
	cin >> pStepX;
	cout << "Enter the step for the Y Clip " << endl;
	cin >> pStepY;
	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);
	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" <<
		clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" <<
		clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;
	if (GetOpenFileNameW(&ofn))
	{
		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		cout << "New Image Clip" << endl;
		// Get starting timepoint
		start = high_resolution_clock::now();
		// Call the function, here sort()
		// Get ending timepointE:\С\Parametrized Simulations Kernel Exhibition ...\Kernel Final\DirectXGPUDigitalLabCoreModule.cpp 105
		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageOne);
		cout << "Printing the Contents of Clipped Area" << endl;
		imageSegmentationDataFile << "Clipping Image for X Axis" << endl;
		int pIndex = 0;
		for (PixelObject pixelObject : pixelObjectImageOne)
		{


			BOOL pIsWhite = FALSE;
			pIsWhite = (pixelObject.RMask == 255.0f) && (pixelObject.GMask == 255.0f) && (pixelObject.BMask == 255.0f);




			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


		}

		cout << "Verifying Container for Identical Elements" << endl;

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;
		hr = md2dmanager->GenerateSyntheticImageOfDefinedColor(hInstance, hWnd, pTopLeftX, pTopLeftY,
			pImageWidth, pImageHeight, pSyntheticRed, pSyntheticGreen, pSyntheticBlue, pStepX, pStepY, &pixelObjectImageTwo);



		for (PixelObject pixelObject : pixelObjectImageTwo)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			imageSegmentationDataFile << "Index: " << pIndex << endl;
			imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}



		GetSystemTime(&clippingTimeEndSystem);
		GetLocalTime(&clippingTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;










		int pAmountOfIdenticalPixels = 0;
		int pAmountOfDifferentPixels = 0;

		float pImageOneIntensitySumRedVar = 0.0f;
		float pImageOneIntensitySumGreenVar = 0.0f;
		float pImageOneIntensitySumBlueVar = 0.0f;
		float pImageOneIntensityAverageRedVar = 0.0f;
		float pImageOneIntensityAverageGreenVar = 0.0f;
		float pImageOneIntensityAverageBlueVar = 0.0f;

		float pImageTwoIntensitySumRedVar = 0.0f;
		float pImageTwoIntensitySumGreenVar = 0.0f;
		float pImageTwoIntensitySumBlueVar = 0.0f;
		float pImageTwoIntensityAverageRedVar = 0.0f;
		float pImageTwoIntensityAverageGreenVar = 0.0f;
		float pImageTwoIntensityAverageBlueVar = 0.0f;

		float pOutputArrayIntensitySumRedVar = 0.0f;
		float pOutputArrayIntensitySumGreenVar = 0.0f;
		float pOutputArrayIntensitySumBlueVar = 0.0f;
		float pOutputArrayIntensityAverageRedVar = 0.0f;
		float pOutputArrayIntensityAverageGreenVar = 0.0f;
		float pOutputArrayIntensityAverageBlueVar = 0.0f;

		float pIdenticalArrayIntensitySumRedVar = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

		float pDifferentArrayIntensitySumRedVar = 0.0f;
		float pDifferentArrayIntensitySumGreenVar = 0.0f;
		float pDifferentArrayIntensitySumBlueVar = 0.0f;
		float pDifferentArrayIntensityAverageRedVar = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar = 0.0f;

		BOOL pAreImagesIdentical = FALSE;

		cout << "RGB Section End" << endl;
		imageSegmentationDataFile << "RGB Section End" << endl;




		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



		hr = ppStandardAlgorithmExecutor->SubtractColorFromRGBImage(hInstance, hWnd, pImageWidth,
			pImageHeight,
			pixelObjectImageOne,
			pSyntheticRed,
			pSyntheticGreen,
			pSyntheticBlue,
			&pAmountOfIdenticalPixels,
			&pAmountOfDifferentPixels,
			&ppVerificationOutputArray,
			&ppIdenticalPixelOutputArray,
			&ppDifferentPixelOutputArray,
			&pImageOneIntensitySumRedVar,
			&pImageOneIntensitySumGreenVar,
			&pImageOneIntensitySumBlueVar,
			&pOutputArrayIntensitySumRedVar,
			&pOutputArrayIntensitySumGreenVar,
			&pOutputArrayIntensitySumBlueVar,
			&pIdenticalArrayIntensitySumRedVar,
			&pIdenticalArrayIntensitySumGreenVar,
			&pIdenticalArrayIntensitySumBlueVar,
			&pDifferentArrayIntensitySumRedVar,
			&pDifferentArrayIntensitySumGreenVar,
			&pDifferentArrayIntensitySumBlueVar,
			&pImageOneIntensityAverageRedVar,
			&pImageOneIntensityAverageGreenVar,
			&pImageOneIntensityAverageBlueVar,
			&pOutputArrayIntensityAverageRedVar,
			&pOutputArrayIntensityAverageGreenVar,
			&pOutputArrayIntensityAverageBlueVar,
			&pIdenticalArrayIntensityAverageRedVar,
			&pIdenticalArrayIntensityAverageGreenVar,
			&pIdenticalArrayIntensityAverageBlueVar,
			&pDifferentArrayIntensityAverageRedVar,
			&pDifferentArrayIntensityAverageGreenVar,
			&pDifferentArrayIntensityAverageBlueVar,
			&pAreImagesIdentical);




		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << " " << endl;
		imageSegmentationDataFile << "New Operation Begin" << endl;

		cout << "Printing the Output Buffer Of Comparison Operation" << endl;
		imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

		int pIntensitySummation = 0;
		pIndex = 0;
		cout << "Printing out the Output the Experiment" << endl;


		for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


			hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


			pIndex++;
		}

		cout << "Printing the output of Identical Pixel Vector" << endl;
		imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

		for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
		{




			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




		}


		cout << "Printing the output of Different Pixel Vector" << endl;
		imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



		for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
		{



			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
			imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
			imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




		}

		md2dmanager->DrawPixelArray(hInstance, hWnd, ppDifferentPixelOutputArray);



		GetSystemTime(&filterTimeEndSystem);
		GetLocalTime(&filterTimeEndLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
		imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;



	}



	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}






HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalRGBThreaded(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RGBComparisonOfDigitalImagesThreaded.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;




	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;



	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}





	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;







	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}





HRESULT  DirectXGPUDigitalLabCoreModule::CheckIfTwoImagesAreIdenticalRGBThreadedUsingSemaphores(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	// Перерисовываем список

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeEndSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME filterTimeEndLocal;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RGBComparisonOfDigitalImagesThreadedUsingSemaphores.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();


	int pIntensitySum = 0;

	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

	std::chrono::system_clock::time_point start;
	std::chrono::system_clock::time_point stop;
	std::chrono::system_clock::duration duration;


	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);



	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	GetSystemTime(&clippingTimeEndSystem);
	GetLocalTime(&clippingTimeEndLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << clippingTimeEndSystem.wHour << ":" << clippingTimeEndSystem.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << clippingTimeEndLocal.wHour << ":" << clippingTimeEndLocal.wMinute << ":" << clippingTimeEndLocal.wSecond << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;


	start = std::chrono::system_clock::now();

	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;

	SYSTEMTIME pCreateTimeVar;
	SYSTEMTIME pExitTimeVar;
	SYSTEMTIME pKernelTimeVar;
	SYSTEMTIME pUserTimeVar;
	BOOL pAreIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreadedUsingSemaphores(hInstance, hWnd, pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray,
		&ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreIdentical,
		&pCreateTimeVar,
		&pExitTimeVar,
		&pKernelTimeVar,
		&pUserTimeVar);

	stop = std::chrono::system_clock::now();


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		hr = md2dmanager->DrawRoadSignImageComparison(hInstance, hWnd, pOutputPixelValue.pAmountOfIdenticalPixels, pOutputPixelValue.pAmountOfDifferentPixels);


		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}





	GetSystemTime(&filterTimeEndSystem);
	GetLocalTime(&filterTimeEndLocal);



	duration = duration_cast<seconds>(stop - start);
	


	cout << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << "The system time is: %02d:%02d\n" << filterTimeEndSystem.wHour << ":" << filterTimeEndSystem.wMinute << ":" << filterTimeEndLocal.wSecond << endl;
	imageSegmentationDataFile << " The local time is: %02d:%02d\n" << filterTimeEndLocal.wHour << ":" << filterTimeEndLocal.wMinute << ":" << filterTimeEndLocal.wSecond << endl;

	cout << "Time taken by Code Execution: "
		<< duration.count() / 10000000 << " seconds" << endl;
	

	imageSegmentationDataFile << "Time taken by Clip One: "
		<< duration.count() / 10000000 << " seconds" << endl;

	cout << "Start of procedure: " << pCreateTimeVar.wHour << ":" << pCreateTimeVar.wMinute << ":" << pCreateTimeVar.wSecond << endl;
	cout << "End of procedure: " << pExitTimeVar.wHour << ":" << pExitTimeVar.wMinute << ":" << pExitTimeVar.wSecond << endl;
	cout << "Kernel time of procedure: " << pKernelTimeVar.wHour << ":" << pKernelTimeVar.wMinute << ":" << pKernelTimeVar.wSecond << endl;
	cout << "User of procedure: " << pUserTimeVar.wHour << ":" << pUserTimeVar.wMinute << ":" << pUserTimeVar.wSecond << endl;


	imageSegmentationDataFile << "Start of procedure: " << pCreateTimeVar.wHour << ":" << pCreateTimeVar.wMinute << ":" << pCreateTimeVar.wSecond << endl;
	imageSegmentationDataFile << "End of procedure: " << pExitTimeVar.wHour << ":" << pExitTimeVar.wMinute << ":" << pExitTimeVar.wSecond << endl;
	imageSegmentationDataFile << "Kernel time of procedure: " << pKernelTimeVar.wHour << ":" << pKernelTimeVar.wMinute << ":" << pKernelTimeVar.wSecond << endl;
	imageSegmentationDataFile << "User of procedure: " << pUserTimeVar.wHour << ":" << pUserTimeVar.wMinute << ":" << pUserTimeVar.wSecond << endl;



	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");

	imageSegmentationDataFile.close();

	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageProcessingFiniteStateMachine(HINSTANCE hInstance, HWND hWnd)
{


	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageFiniteStateMachineFSM.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Funnction allows to Interpret Images as a finite state Machine" << endl;
	cout << "We Must Load Up An Image Clip and Convert it Into State Machine for Physics Interpretation" << endl;















	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	CBImageIntensityConstants pImageIntensityConstants;
	pImageIntensityConstants.pBlackColor = 0;
	pImageIntensityConstants.pExtremlyDark = 25;
	pImageIntensityConstants.pDarkVar = 50;
	pImageIntensityConstants.pCloseToBlack = 75;
	pImageIntensityConstants.pBarelyLit = 100;
	pImageIntensityConstants.pSemyLit = 125;
	pImageIntensityConstants.pLitVar = 150;
	pImageIntensityConstants.pExtraLit = 175;
	pImageIntensityConstants.pWhiteVar = 255;
	pImageIntensityConstants.pUndefinedColoer = 66;
	pImageIntensityConstants.pBarelyLitState = 1;
	pImageIntensityConstants.pBlackColorState = 2;
	pImageIntensityConstants.pCloseToBlackState = 3;
	pImageIntensityConstants.pDarkVarState = 4;
	pImageIntensityConstants.pExtraListState = 5;
	pImageIntensityConstants.pExtremlyDarkState = 6;
	pImageIntensityConstants.pLitVarState = 7;
	pImageIntensityConstants.pSemyLitState = 8;
	pImageIntensityConstants.pWhiteState = 9;
	pImageIntensityConstants.pUndefinedState = 66;
	

	cout << "Black State Has Id Value: " << pImageIntensityConstants.pBlackColor << endl;
	cout << "Extremly Dark State Has Id Value: " << pImageIntensityConstants.pExtremlyDark << endl;
	cout << "Dark State State Has Id Value: " << pImageIntensityConstants.pDarkVar << endl;
	cout << "Close To Black State Has Id Value: " << pImageIntensityConstants.pCloseToBlack << endl;
	cout << "Barely Lit State Has Id Value: " << pImageIntensityConstants.pBarelyLit << endl;
	cout << "Semi Lit State Has Id Value: " << pImageIntensityConstants.pSemyLit << endl;
	cout << "Lit State Has Id Value: " << pImageIntensityConstants.pLitVar << endl;
	cout << "Extra Lit State Has Id Value: " << pImageIntensityConstants.pExtraLit << endl;
	cout << "White State Has Id Value: " << pImageIntensityConstants.pWhiteVar << endl;

	imageSegmentationDataFile << "Black State Has Id Value: " << pImageIntensityConstants.pBlackColor << endl;
	imageSegmentationDataFile << "Extremly Dark State Has Id Value: " << pImageIntensityConstants.pExtremlyDark << endl;
	imageSegmentationDataFile << "Dark State State Has Id Value: " << pImageIntensityConstants.pDarkVar << endl;
	imageSegmentationDataFile << "Close To Black State Has Id Value: " << pImageIntensityConstants.pCloseToBlack << endl;
	imageSegmentationDataFile << "Barely Lit State Has Id Value: " << pImageIntensityConstants.pBarelyLit << endl;
	imageSegmentationDataFile << "Semi Lit State Has Id Value: " << pImageIntensityConstants.pSemyLit << endl;
	imageSegmentationDataFile << "Lit State Has Id Value: " << pImageIntensityConstants.pLitVar << endl;
	imageSegmentationDataFile << "Extra Lit State Has Id Value: " << pImageIntensityConstants.pExtraLit << endl;
	imageSegmentationDataFile << "White State Has Id Value: " << pImageIntensityConstants.pWhiteVar << endl;



	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

	cout << "Printing the Contents of Clipped Area" << endl;
	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectVector)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
	
	
		
	}

	cout << "Loading Image Two" << endl;
	vector<PixelObject> pSecondVectorObject = vector<PixelObject>();
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pSecondVectorObject);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	for (PixelObject pixelObject : pSecondVectorObject)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
		
	

	}


	cout << "Now We Will Try To Interpret the Image Intensity function as a State Machine" << endl;
	imageSegmentationDataFile << "Now We Will Try To Interpret the Image Intensity function as a State Machine" << endl;
	vector<OutputPixelObjectGrayScaleWithState> pOutputPixelObjectGrayScaleVectorEight = vector<OutputPixelObjectGrayScaleWithState>();



	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachine(hInstance,
		hWnd, pImageIntensityConstants, pixelObjectVector,
		&pOutputPixelObjectGrayScaleVectorEight);

	for (OutputPixelObjectGrayScaleWithState pPixelObject : pOutputPixelObjectGrayScaleVectorEight)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " <<  pPixelObject.pGrayScaleValue << endl;
		cout << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;
		cout << "Current State = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " <<  pPixelObject.pGrayScaleValue << endl;
		imageSegmentationDataFile << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;
		imageSegmentationDataFile << "Current State = " << pPixelObject.pCurrentState << endl;


		
	}

	
	vector<OutputPixelObjectGrayScaleWithState> pOutputPixelObjectGrayScaleVectorTwo = vector<OutputPixelObjectGrayScaleWithState>();

	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachine(hInstance,
		hWnd, pImageIntensityConstants, pSecondVectorObject,
		&pOutputPixelObjectGrayScaleVectorTwo);

	for (OutputPixelObjectGrayScaleWithState pPixelObject : pOutputPixelObjectGrayScaleVectorTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " <<  pPixelObject.pGrayScaleValue << endl;
		cout << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;
		cout << "Current State = " << pPixelObject.pCurrentState << endl;


		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " <<  pPixelObject.pGrayScaleValue << endl;
		imageSegmentationDataFile << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;
		imageSegmentationDataFile << "Current State = " << pPixelObject.pCurrentState << endl;

	
	}
	


	MessageBoxA(hWnd, (LPCSTR)"Работа Симулятора Image Processing State-Machine", (LPCSTR)"Message", 0);
	cout << "State Machine Simulation Stage Eight Has Been Completed" << endl;
	cout << "Now We Will Simulate the Second Part of the Simulation Object" << endl;


	cbImageProcessingFSMStageTwo pImageInstensityConstantVariables;
	pImageInstensityConstantVariables.pDifferentImageLabel = -100;
	pImageInstensityConstantVariables.pDifferentStateLabel = -1;
	pImageInstensityConstantVariables.pIdenticalImageLabel = 100;
	pImageInstensityConstantVariables.pIdenticalStateLabel = 1;
	pImageInstensityConstantVariables.pUndefinedImageLabel = 55;
	pImageInstensityConstantVariables.pUndefinedStateLabel = 55;


	vector<OutputPixelObjectGrayScaleWithStateChange> pOutputGrayScaleVectorAfterStateMachine = vector<OutputPixelObjectGrayScaleWithStateChange>();
	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineStageTwo(hInstance, hWnd,
		pImageInstensityConstantVariables,
		pOutputPixelObjectGrayScaleVectorEight,
		pOutputPixelObjectGrayScaleVectorTwo,
		&pOutputGrayScaleVectorAfterStateMachine);

	for (OutputPixelObjectGrayScaleWithStateChange pPixelObject : pOutputGrayScaleVectorAfterStateMachine)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGrayScaleValueOutput << endl;
		cout << "Previous Level of Darkness = " << pPixelObject.pPreviousLevelOfDarkness << endl;
		cout << "Current Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
		cout << "Previous State = " << pPixelObject.pPreviousState << endl;
		cout << "Current State = " << pPixelObject.pCurrentState << endl;
		cout << "Did Pixel State Change Occured" << pPixelObject.pDidStateChange << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValueOutput << endl;
		imageSegmentationDataFile << "Previous Level of Darkness = " << pPixelObject.pPreviousLevelOfDarkness << endl;
		imageSegmentationDataFile << "Current Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
		imageSegmentationDataFile << "Previous State = " << pPixelObject.pPreviousState << endl;
		imageSegmentationDataFile << "Current State = " << pPixelObject.pCurrentState << endl;
		imageSegmentationDataFile << "Did Pixel State Change Occured" << pPixelObject.pDidStateChange << endl;

		

		if (pPixelObject.pDidStateChange == 255)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 100);
		}
		else if (pPixelObject.pDidStateChange == 0)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 0);
		}
		

	}


	imageSegmentationDataFile.close();


	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateStandardDeviationExperiment(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<float> pInputDataBuffer = vector<float>();
	vector<InputItemType> pInputBufferObjectEight = vector<InputItemType>();
	vector<CStandardDeviationOutputType> pOutputDataBufferP = vector<CStandardDeviationOutputType>();
	UINT pIndex = 0;
	int pArrayStart = 0;
	int pArrayEnd = 0;
	int pFunctionStep = 0;
	fstream pStream;
	pStream.open("C:\\pixels\\StandardDeviation.txt", std::ios::out);

	cout << "enter the beginning of array" << endl;
	cin >> pArrayStart;

	cout << "enter the beginning of array" << endl;
	cin >> pArrayEnd;


	cout << "Enter the Step of the Function" << endl;
	cin >> pFunctionStep;


	for (int pVariable = pArrayStart; pVariable <= pArrayEnd; pVariable + pFunctionStep)
	{
		pInputDataBuffer.push_back(pVariable);
	}


	for (float pArrayValue : pInputDataBuffer)
	{
		InputItemType pInputItemObject;
		pInputItemObject.pItemId = pIndex;
		pInputItemObject.pItemValue = pArrayValue;

		cout << "Item Id " << pIndex << " = " << pInputItemObject.pItemId << endl;
		cout << "Value : " << pIndex << " = " << pInputItemObject.pItemValue << endl;

		pInputBufferObjectEight.push_back(pInputItemObject);
		pIndex = pIndex + 1;
	}

	int pOutputValue = 0;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	

	hr = ppStandardAlgorithmExecutor->SimulateStandardDeviationComputationP(hInstance, hWnd,
		pInputBufferObjectEight, &pOutputDataBufferP,
		&pOutputValue);

	pIndex = 0;
	float pSumValueFinal = 0;
	float pAverageValue = 0;

	UINT iIndex = 0;
	for (CStandardDeviationOutputType pNumberData : pOutputDataBufferP)
	{
		cout << "Item Index: " << pNumberData.pItemIndex << endl;
		cout << "input Value: " << pNumberData.pInputValue << endl;
		cout << "Output Value: " << pNumberData.pOutputValue << endl;

		pStream << "Item Index: " << pNumberData.pItemIndex << endl;
		pStream << "input Value: " << pNumberData.pInputValue << endl;
		pStream << "Output Value: " << pNumberData.pOutputValue << endl;

		pSumValueFinal = pSumValueFinal + pNumberData.pOutputValue;

	}


	cout << "Computing the Mean Standard Deviation Output" << endl;
	cout << "Standard Deviation Sum: " << pSumValueFinal << endl;
	pAverageValue = sqrt(pSumValueFinal / pOutputDataBufferP.size());
	cout << "Standard Deviation Value: " << pAverageValue << endl;
	pStream << "Standard Deviation Value: " << pAverageValue << endl;

	pStream.close();
	return hr;




}







HRESULT DirectXGPUDigitalLabCoreModule::SimulateOddEvenFSM(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	vector<float> pInputDataArray = vector<float>();
	vector<OutputArrayOddEventStruct> pOutputArrayBufferOdd = vector<OutputArrayOddEventStruct>();
	vector<OutputArrayOddEventStruct> pOutputArrayBufferEven = vector<OutputArrayOddEventStruct>();
	vector<OutputArrayOddEvenFinalStruct> pOutputArrayOddEvenFinalArray = vector<OutputArrayOddEvenFinalStruct>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\OddEvenFiniteStaMachineFSM.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Simulation of a Finite State Machine" << endl;
	UINT pInputArrayStart = 0;
	UINT pInputArrayEnd = 0;

	cout << "Enter the Beginning Of the Input Array" << endl;
	cin >> pInputArrayStart;

	cout << "Enter the End Of the Input Array" << endl;
	cin >> pInputArrayEnd;


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	float pDivisorValue = 0.0f;




	UINT pIndex = 0;
	float pCurrentNumberVar = pInputArrayStart;
	for (UINT pArrayElement = pInputArrayStart; pArrayElement <= pInputArrayEnd; ++pArrayElement)
	{

		cout << "Current Array Element At Index: " << pIndex << " = " << pArrayElement << endl;
		imageSegmentationDataFile << "Current Array Element At Index: " << pIndex << " = " << pArrayElement << endl;
		pInputDataArray.push_back(pArrayElement);
		pIndex++;
	}


	std::sort(std::begin(pInputDataArray), std::end(pInputDataArray));


	cout << "Enter The Value For Selected Divisor" << endl;
	cin >> pDivisorValue;

	cout << "Simulating the Odd Event Finite State Machine" << endl;
	imageSegmentationDataFile << "Simulating the Odd Event Finite State Machine" << endl;



	cout << "Enter The Value For Selected Divisor" << endl;
	cin >> pDivisorValue;

	cout << "Computing First Vector Element" << endl;
	imageSegmentationDataFile << "Computing First Vector Element" << endl;

	float pRemainderVar = 0.0f;
	int pOddNumberState = 1;
	int pEvenNumberState = 0;
	int pUndefinedNumberState = -1;
	int pDefaultKindOfNumber = 0;
	int pDefaultState = 0;
	int pKindOfNumberEvenVar = 100;
	int pKindOfNumberOddVar = -100;
	int pKindOfNumberUnknownVar = 255;


	float pFirstElement = pInputDataArray[0];
	pRemainderVar = remainderf(pFirstElement, pDivisorValue);
	int pCurrentStateVar = 0;
	if (pRemainderVar > 0)
	{
		pCurrentStateVar = pOddNumberState;
		pDefaultState = pCurrentStateVar;
		pDefaultKindOfNumber = pKindOfNumberOddVar;

	}
	if (pRemainderVar == 0)
	{
		pCurrentStateVar = pEvenNumberState;
		pDefaultState = pCurrentStateVar;
		pDefaultKindOfNumber = pKindOfNumberEvenVar;

	}


	cout << "Simulating the Odd Event Finite State Machine" << endl;
	imageSegmentationDataFile << "Simulating the Odd Event Finite State Machine" << endl;



	pCurrentStateVar = pUndefinedNumberState;
	pKindOfNumberEvenVar = 100;
	pKindOfNumberOddVar = -100;
	pKindOfNumberUnknownVar = 255;


	cout << "Simulating the Odd Event Finite State Machine" << endl;
	imageSegmentationDataFile << "Simulating the Odd Event Finite State Machine" << endl;


	OddNumberCB pOddEvenNumberCBBuffer;
	pOddEvenNumberCBBuffer.Undefined = pUndefinedNumberState;
	pOddEvenNumberCBBuffer.OddNumber = pOddNumberState;
	pOddEvenNumberCBBuffer.EvenNumber = pEvenNumberState;
	pOddEvenNumberCBBuffer.pDivisorValue = pDivisorValue;
	pOddEvenNumberCBBuffer.pKindOfNumberEven = pKindOfNumberEvenVar;
	pOddEvenNumberCBBuffer.pKindOfNumberOdd = pKindOfNumberOddVar;
	pOddEvenNumberCBBuffer.pKindOfNumberUnknown = pKindOfNumberUnknownVar;


	cout << "State For Undefined Number: " << pOddEvenNumberCBBuffer.Undefined << endl;
	cout << "State For Odd Number: " << pOddEvenNumberCBBuffer.OddNumber << endl;
	cout << "State For Even Number: " << pOddEvenNumberCBBuffer.EvenNumber << endl;
	cout << "Kind of Undefined Number: " << pOddEvenNumberCBBuffer.pKindOfNumberUnknown << endl;
	cout << "Kind of Odd Number: " << pOddEvenNumberCBBuffer.pKindOfNumberOdd << endl;
	cout << "Kind of Even Number: " << pOddEvenNumberCBBuffer.pKindOfNumberEven << endl;


	imageSegmentationDataFile << "State For Undefined Number: " << pOddEvenNumberCBBuffer.Undefined << endl;
	imageSegmentationDataFile << "State For Odd Number: " << pOddEvenNumberCBBuffer.OddNumber << endl;
	imageSegmentationDataFile << "State For Even Number: " << pOddEvenNumberCBBuffer.EvenNumber << endl;
	imageSegmentationDataFile << "Kind of Undefined Number: " << pOddEvenNumberCBBuffer.pKindOfNumberUnknown << endl;
	imageSegmentationDataFile << "Kind of Odd Number: " << pOddEvenNumberCBBuffer.pKindOfNumberOdd << endl;
	imageSegmentationDataFile << "Kind of Even Number: " << pOddEvenNumberCBBuffer.pKindOfNumberEven << endl;
	imageSegmentationDataFile << "Kind of Even Number: " << pOddEvenNumberCBBuffer.pKindOfNumberEven << endl;




	hr = ppStandardAlgorithmExecutor->SimulateOddEvenNumberFSM(hInstance, hWnd,
		pOddEvenNumberCBBuffer,
		pInputDataArray, &pOutputArrayBufferEven,
		&pOutputArrayBufferOdd,
		&pOutputArrayOddEvenFinalArray);

	int iIndex = 0;

	for (OutputArrayOddEventStruct pOutputArrayObjectEven : pOutputArrayBufferEven)
	{
		cout << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pItemIndex << endl;
		imageSegmentationDataFile << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pItemIndex << endl;

		cout << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pInputNumberVar << endl;
		imageSegmentationDataFile << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pInputNumberVar << endl;

		cout << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.kindOfNumber << endl;
		imageSegmentationDataFile << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.kindOfNumber << endl;


		cout << "Item At Index: " << iIndex << "Is Even" << endl;
		imageSegmentationDataFile << "Item At Index: " << iIndex << "Is Even" << endl;
		iIndex++;
	}

	for (OutputArrayOddEventStruct pOutputArrayObjectOdd : pOutputArrayBufferOdd)
	{
		cout << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pItemIndex << endl;
		imageSegmentationDataFile << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pItemIndex << endl;

		cout << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pInputNumberVar << endl;
		imageSegmentationDataFile << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pInputNumberVar << endl;

		cout << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.kindOfNumber << endl;
		imageSegmentationDataFile << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.kindOfNumber << endl;


		cout << "Item At Index: " << iIndex << "Is Odd" << endl;
		imageSegmentationDataFile << "Item At Index: " << iIndex << "Is Odd" << endl;


	}

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	for (OutputArrayOddEvenFinalStruct pOutputVectorFinal : pOutputArrayOddEvenFinalArray)
	{
		cout << "Index: " << pOutputVectorFinal.pItemIndex << endl;
		cout << "Item Value: " << pOutputVectorFinal.pInputNumberVar << endl;
		cout << "Item Type: " << pOutputVectorFinal.kindOfNumber << endl;
		cout << "Current State = " << pOutputVectorFinal.pCurrentState << endl;
		cout << "Previous State = " << pOutputVectorFinal.pPreviousState << endl;
		cout << "Did State Change= " << pOutputVectorFinal.didStateChange << endl;

		imageSegmentationDataFile << "Index: " << pOutputVectorFinal.pItemIndex << endl;
		imageSegmentationDataFile << "Item Value: " << pOutputVectorFinal.pInputNumberVar << endl;
		imageSegmentationDataFile << "Item Type: " << pOutputVectorFinal.kindOfNumber << endl;
		imageSegmentationDataFile << "Current State = " << pOutputVectorFinal.pCurrentState << endl;
		imageSegmentationDataFile << "Previous State = " << pOutputVectorFinal.pPreviousState << endl;
		imageSegmentationDataFile << "Did State Change= " << pOutputVectorFinal.didStateChange << endl;

		if (pOutputVectorFinal.kindOfNumber == pOddEvenNumberCBBuffer.pKindOfNumberOdd)
		{
			md2dmanager->DrawRoadSignOddEven(hInstance, hWnd, pOutputVectorFinal.pInputNumberVar, 100);
		}
		else if (pOutputVectorFinal.kindOfNumber == pOddEvenNumberCBBuffer.pKindOfNumberEven)
		{
			md2dmanager->DrawRoadSignOddEven(hInstance, hWnd, pOutputVectorFinal.pInputNumberVar, 0);

		}
	
		Sleep(1000);
	}



	
	imageSegmentationDataFile.close();
	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\OddEvenNumberStateMachines.jpg");

	return hr;

}
	
	

HRESULT DirectXGPUDigitalLabCoreModule::SimulateOddEvenFSMWithManualInput(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	vector<float> pInputDataArray = vector<float>();
	vector<OutputArrayOddEventStruct> pOutputArrayBufferOdd = vector<OutputArrayOddEventStruct>();
	vector<OutputArrayOddEventStruct> pOutputArrayBufferEven = vector<OutputArrayOddEventStruct>();
	vector<OutputArrayOddEvenFinalStruct> pOutputArrayOddEvenFinalArray = vector<OutputArrayOddEvenFinalStruct>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\OddEvenFiniteStaMachineFSM.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Simulation of a Finite State Machine" << endl;
	UINT pInputArrayStart = 0;
	UINT pInputArrayEnd = 0;

	cout << "Enter the Amount of Integers that will be used" << endl;
	cin >> pInputArrayStart;



	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	float pDivisorValue = 0.0f;




	UINT pIndex = 0;
	float pCurrentNumberVar = pInputArrayStart;
	for (UINT pIndex = 0; pIndex < pInputArrayStart; ++pIndex)
	{
		float pArrayElement = 0.0f;
		cout << "Enter New Array Element" << endl;
		cin >> pArrayElement;

		cout << "Current Array Element At Index: " << pIndex << " = " << pArrayElement << endl;
		imageSegmentationDataFile << "Current Array Element At Index: " << pIndex << " = " << pArrayElement << endl;
		pInputDataArray.push_back(pArrayElement);
		
	}


	std::sort(std::begin(pInputDataArray), std::end(pInputDataArray));


	cout << "Enter The Value For Selected Divisor" << endl;
	cin >> pDivisorValue;

	cout << "Computing First Vector Element" << endl;
	imageSegmentationDataFile << "Computing First Vector Element" << endl;

	float pRemainderVar = 0.0f;
	int pOddNumberState = 1;
	int pEvenNumberState = 0;
	int pUndefinedNumberState = -1;

	float pFirstElement = pInputDataArray[0];
	pRemainderVar = remainderf(pFirstElement, pDivisorValue);
	int pCurrentStateVar = 0;
	if (pRemainderVar > 0)
	{
		pCurrentStateVar = pOddNumberState;
	}
	if (pRemainderVar == 0)
	{
		pCurrentStateVar = pEvenNumberState;
	}
	pCurrentStateVar = pUndefinedNumberState;
	int pKindOfNumberEvenVar = 100;
	int pKindOfNumberOddVar = -100;
	int pKindOfNumberUnknownVar = 255;


	cout << "Simulating the Odd Event Finite State Machine" << endl;
	imageSegmentationDataFile << "Simulating the Odd Event Finite State Machine" << endl;


	OddNumberCB pOddEvenNumberCBBuffer;
	pOddEvenNumberCBBuffer.Undefined = pUndefinedNumberState;
	pOddEvenNumberCBBuffer.OddNumber = pOddNumberState;
	pOddEvenNumberCBBuffer.EvenNumber = pEvenNumberState;
	pOddEvenNumberCBBuffer.pDivisorValue = pDivisorValue;
	pOddEvenNumberCBBuffer.pKindOfNumberEven = pKindOfNumberEvenVar;
	pOddEvenNumberCBBuffer.pKindOfNumberOdd = pKindOfNumberOddVar;
	pOddEvenNumberCBBuffer.pKindOfNumberUnknown = pKindOfNumberUnknownVar;


	cout << "State For Undefined Number: " << pOddEvenNumberCBBuffer.Undefined << endl;
	cout << "State For Odd Number: " << pOddEvenNumberCBBuffer.OddNumber << endl;
	cout << "State For Even Number: " << pOddEvenNumberCBBuffer.EvenNumber << endl;
	cout << "Kind of Undefined Number: " << pOddEvenNumberCBBuffer.pKindOfNumberUnknown << endl;
	cout << "Kind of Odd Number: " << pOddEvenNumberCBBuffer.pKindOfNumberOdd << endl;
	cout << "Kind of Even Number: " << pOddEvenNumberCBBuffer.pKindOfNumberEven << endl;


	imageSegmentationDataFile << "State For Undefined Number: " << pOddEvenNumberCBBuffer.Undefined << endl;
	imageSegmentationDataFile << "State For Odd Number: " << pOddEvenNumberCBBuffer.OddNumber << endl;
	imageSegmentationDataFile << "State For Even Number: " << pOddEvenNumberCBBuffer.EvenNumber << endl;
	imageSegmentationDataFile << "Kind of Undefined Number: " << pOddEvenNumberCBBuffer.pKindOfNumberUnknown << endl;
	imageSegmentationDataFile << "Kind of Odd Number: " << pOddEvenNumberCBBuffer.pKindOfNumberOdd << endl;
	imageSegmentationDataFile << "Kind of Even Number: " << pOddEvenNumberCBBuffer.pKindOfNumberEven << endl;



	hr = ppStandardAlgorithmExecutor->SimulateOddEvenNumberFSM(hInstance, hWnd,
		pOddEvenNumberCBBuffer,
		pInputDataArray, &pOutputArrayBufferEven,
		&pOutputArrayBufferOdd,
		&pOutputArrayOddEvenFinalArray);

	int iIndex = 0;

	for (OutputArrayOddEventStruct pOutputArrayObjectEven : pOutputArrayBufferEven)
	{
		cout << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pItemIndex << endl;
		imageSegmentationDataFile << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pItemIndex << endl;

		cout << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pInputNumberVar << endl;
		imageSegmentationDataFile << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.pInputNumberVar << endl;

		cout << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.kindOfNumber << endl;
		imageSegmentationDataFile << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectEven.kindOfNumber << endl;


		cout << "Item At Index: " << iIndex << "Is Even" << endl;
		imageSegmentationDataFile << "Item At Index: " << iIndex << "Is Even" << endl;
		iIndex++;
	}

	for (OutputArrayOddEventStruct pOutputArrayObjectOdd : pOutputArrayBufferOdd)
	{
		cout << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pItemIndex << endl;
		imageSegmentationDataFile << "Item Index: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pItemIndex << endl;

		cout << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pInputNumberVar << endl;
		imageSegmentationDataFile << "Item Float Value: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.pInputNumberVar << endl;

		cout << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.kindOfNumber << endl;
		imageSegmentationDataFile << "Kind of Number: " << " " << iIndex << " " << "=" << " " << pOutputArrayObjectOdd.kindOfNumber << endl;


		cout << "Item At Index: " << iIndex << "Is Odd" << endl;
		imageSegmentationDataFile << "Item At Index: " << iIndex << "Is Odd" << endl;


	}

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	for (OutputArrayOddEvenFinalStruct pOutputVectorFinal : pOutputArrayOddEvenFinalArray)
	{
		cout << "Index: " << pOutputVectorFinal.pItemIndex << endl;
		cout << "Item Value: " << pOutputVectorFinal.pInputNumberVar << endl;
		cout << "Item Type: " << pOutputVectorFinal.kindOfNumber << endl;
		cout << "Current State = " << pOutputVectorFinal.pCurrentState << endl;
		cout << "Previous State = " << pOutputVectorFinal.pPreviousState << endl;
		cout << "Did State Change= " << pOutputVectorFinal.didStateChange << endl;

		imageSegmentationDataFile << "Index: " << pOutputVectorFinal.pItemIndex << endl;
		imageSegmentationDataFile << "Item Value: " << pOutputVectorFinal.pInputNumberVar << endl;
		imageSegmentationDataFile << "Item Type: " << pOutputVectorFinal.kindOfNumber << endl;
		imageSegmentationDataFile << "Current State = " << pOutputVectorFinal.pCurrentState << endl;
		imageSegmentationDataFile << "Previous State = " << pOutputVectorFinal.pPreviousState << endl;
		imageSegmentationDataFile << "Did State Change= " << pOutputVectorFinal.didStateChange << endl;


		if (pOutputVectorFinal.kindOfNumber == pOddEvenNumberCBBuffer.EvenNumber)
		{
			md2dmanager->DrawRoadSignOddEven(hInstance, hWnd, pOutputVectorFinal.pInputNumberVar, 100);
		}
		else if (pOutputVectorFinal.kindOfNumber == pOddEvenNumberCBBuffer.OddNumber)
		{
			md2dmanager->DrawRoadSignOddEven(hInstance, hWnd, pOutputVectorFinal.pInputNumberVar, 0);
		}


		Sleep(1000);

	}
	imageSegmentationDataFile.close();
	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\OddEvenNumberStateMachines.jpg");

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageProcessingFiniteStateMachineIntensityFunction(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageIntensityFunctionStateMachineSimulation.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate State Machire intensity Function For A set of Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageThree = vector<PixelObject>();

	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageThreeGrayScale = vector<PixelObjectGrayScale>();

	vector<OutputPixelBufferStateMachineData> ppImageOneStateArray = vector<OutputPixelBufferStateMachineData>();
	vector<OutputPixelBufferStateMachineData> ppImageTwoStateArray = vector<OutputPixelBufferStateMachineData>();

	vector<OutputPixelObjectGrayScaleStateChange> ppOutputStateMachineFinalArray = vector<OutputPixelObjectGrayScaleStateChange>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Three" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageThree);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageThree)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Three Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Three Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageThree, &ppImageThreeGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageThreeGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Simulating Intensity Function For First Two Images" << endl;
	imageSegmentationDataFile << "Simulating Intensity Function For First Two Images" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(hInstance,
		hWnd, 1, 0, ppImageOneGrayScale, ppImageTwoGrayScale, &ppImageOneStateArray);
	
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the first Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the first Level of State Machine Simulation" << endl;
		return hr;
	}


	for (OutputPixelBufferStateMachineData pPixelObject : ppImageOneStateArray)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


	}

	cout << "Simulating Intensity Function for Second and Third Images" << endl;
	imageSegmentationDataFile << "Simulating Intensity Function for Second and Third Images" << endl;
	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(hInstance,
		hWnd, 1, 0, ppImageTwoGrayScale, ppImageThreeGrayScale, &ppImageTwoStateArray);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the first Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the first Level of State Machine Simulation" << endl;
		return hr;
	}

	for (OutputPixelBufferStateMachineData pPixelObject : ppImageTwoStateArray)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


	}

	cbImageProcessingFSMStageTwo pConstantBufferData;
	pConstantBufferData.pDifferentImageLabel = 1;
	pConstantBufferData.pDifferentStateLabel = 1;
	pConstantBufferData.pIdenticalImageLabel = 0;
	pConstantBufferData.pIdenticalStateLabel = 0;
	pConstantBufferData.pUndefinedStateLabel = 55;
	pConstantBufferData.pUndefinedImageLabel = 55;

	cout << "Simulating the final Stage of the State Machine Engine" << endl;
	imageSegmentationDataFile << "Simulating the final Stage of the State Machine Engine" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensitySimulator(hInstance,
		hWnd,
		pConstantBufferData,
		ppImageOneStateArray,
		ppImageTwoStateArray,
		&ppOutputStateMachineFinalArray);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the Second Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the Second Level of State Machine Simulation" << endl;
		return hr;
	}

	cout << "Priniting the Output of the Computer Simulation" << endl;

	for (OutputPixelObjectGrayScaleStateChange pPixelObject : ppOutputStateMachineFinalArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
		cout << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
		cout << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
		cout << "Current Image State = " << pPixelObject.pCurrentStateOne << endl;
		cout << "Previous Image State = " << pPixelObject.pCurrentStateTwo << endl;
		cout << "Did State Change = " << pPixelObject.pDidStateChange << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
		imageSegmentationDataFile << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
		imageSegmentationDataFile << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
		imageSegmentationDataFile << "Current Image State = " << pPixelObject.pCurrentStateOne << endl;
		imageSegmentationDataFile << "Previous Image State = " << pPixelObject.pCurrentStateTwo << endl;
		imageSegmentationDataFile << "Did State Change = " << pPixelObject.pDidStateChange << endl;


		if (pPixelObject.pDidStateChange == 255)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 100);
		}
		else if (pPixelObject.pDidStateChange == 0)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 0);
		}

		

	}

	cout << "Simulation Has Been Completed" << endl;
	imageSegmentationDataFile << "Simulation Has Been Completed" << endl;
	imageSegmentationDataFile.close();
	return hr;
}
	


HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageProcessingFiniteStateMachineIntensityFunctionCrossTab(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageIntensityFunctionStateMachineSimulationCrossTab.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate State Machire intensity Function For A set of Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageThree = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageFour = vector<PixelObject>();

	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageThreeGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageFourGrayScale = vector<PixelObjectGrayScale>();

	vector<OutputPixelBufferStateMachineData> ppImageOneStateArray = vector<OutputPixelBufferStateMachineData>();
	vector<OutputPixelBufferStateMachineData> ppImageTwoStateArray = vector<OutputPixelBufferStateMachineData>();

	vector<OutputPixelObjectGrayScaleStateChange> ppOutputStateMachineFinalArray = vector<OutputPixelObjectGrayScaleStateChange>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Three" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageThree);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageThree)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Three" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageFour);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageFour)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Three Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Three Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageThree, &ppImageThreeGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageThreeGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Three Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Three Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageFour, &ppImageFourGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageFourGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Simulating Intensity Function For First Two Images" << endl;
	imageSegmentationDataFile << "Simulating Intensity Function For First Two Images" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(hInstance,
		hWnd, 1, 0, ppImageOneGrayScale, ppImageTwoGrayScale, &ppImageOneStateArray);

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the first Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the first Level of State Machine Simulation" << endl;
		return hr;
	}


	for (OutputPixelBufferStateMachineData pPixelObject : ppImageOneStateArray)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


	}

	cout << "Simulating Intensity Function for Second and Third Images" << endl;
	imageSegmentationDataFile << "Simulating Intensity Function for Second and Third Images" << endl;
	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(hInstance,
		hWnd, 1, 0, ppImageThreeGrayScale, ppImageFourGrayScale, &ppImageTwoStateArray);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the first Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the first Level of State Machine Simulation" << endl;
		return hr;
	}

	for (OutputPixelBufferStateMachineData pPixelObject : ppImageTwoStateArray)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


	}

	cbImageProcessingFSMStageTwo pConstantBufferData;
	pConstantBufferData.pDifferentImageLabel = 1;
	pConstantBufferData.pDifferentStateLabel = 1;
	pConstantBufferData.pIdenticalImageLabel = 0;
	pConstantBufferData.pIdenticalStateLabel = 0;
	pConstantBufferData.pUndefinedStateLabel = 55;
	pConstantBufferData.pUndefinedImageLabel = 55;

	cout << "Simulating the final Stage of the State Machine Engine" << endl;
	imageSegmentationDataFile << "Simulating the final Stage of the State Machine Engine" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensitySimulator(hInstance,
		hWnd,
		pConstantBufferData,
		ppImageOneStateArray,
		ppImageTwoStateArray,
		&ppOutputStateMachineFinalArray);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the Second Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the Second Level of State Machine Simulation" << endl;
		return hr;
	}

	cout << "Priniting the Output of the Computer Simulation" << endl;

	for (OutputPixelObjectGrayScaleStateChange pPixelObject : ppOutputStateMachineFinalArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
		cout << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
		cout << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
		cout << "Current Image State = " << pPixelObject.pCurrentStateOne << endl;
		cout << "Previous Image State = " << pPixelObject.pCurrentStateTwo << endl;
		cout << "Did State Change = " << pPixelObject.pDidStateChange << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
		imageSegmentationDataFile << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
		imageSegmentationDataFile << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
		imageSegmentationDataFile << "Current Image State = " << pPixelObject.pCurrentStateOne << endl;
		imageSegmentationDataFile << "Previous Image State = " << pPixelObject.pCurrentStateTwo << endl;
		imageSegmentationDataFile << "Did State Change = " << pPixelObject.pDidStateChange << endl;


		if (pPixelObject.pDidStateChange == 255)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 100);
		}
		else if (pPixelObject.pDidStateChange == 0)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 0);
		}



	}

	cout << "Simulation Has Been Completed" << endl;
	imageSegmentationDataFile << "Simulation Has Been Completed" << endl;
	imageSegmentationDataFile.close();
	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::SimulateImageSubtractionGrayScaleOnGPU(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonGrayScaleOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;





	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;

	hr = ppStandardAlgorithmExecutor->SimulaeImageSubtractionGrayScaleOnGPU(hInstance,
		hWnd, ppImageOneGrayScale, ppImageTwoGrayScale, &ppOutputPixelDataBuffer);

	cout << "Printing the output of Computer Simulation" << endl;

	cout << "Printing Computer Simulation Output Output" << endl;
	imageSegmentationDataFile << "Printing Computer Simulation Output Output" << endl;
	pIndexValue = 0;
	float pImageTotalIntensity = 0.0f;
	float pAmountOfPixelsInArray = 0.0f;
	float pAverageImageIntensity = 0.0f;

	for (PixelObjectGrayScale pPixelObject : ppOutputPixelDataBuffer)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "Output Pixel X Value = " << pXValue << endl;
		cout << "Output Pixel Y Value = " << pYValue << endl;
		cout << "Output Pixel GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "Output Pixel X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Output Pixel Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "Output Pixel GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pImageTotalIntensity = pImageTotalIntensity + pPixeoObjectGrayScale;

		pIndexValue++;
	}

	cout << "Computing Average Image Intensity" << endl;
	cout << "Image Total Intensity = " << pImageTotalIntensity << endl;
	pAmountOfPixelsInArray = ppOutputPixelDataBuffer.size();
	cout << "Amount of Pixels In Output Buffer = " << pAmountOfPixelsInArray << endl;
	cout << "Computing Average Image Intensity" << endl;
	pAverageImageIntensity = pImageTotalIntensity / pAmountOfPixelsInArray;
	cout << "Average Image Intensity for Image Subtraction = " << pAverageImageIntensity << endl;





	imageSegmentationDataFile << "Computing Average Image Intensity" << endl;
	imageSegmentationDataFile << "Image Total Intensity = " << pImageTotalIntensity << endl;
	pAmountOfPixelsInArray = ppOutputPixelDataBuffer.size();
	imageSegmentationDataFile << "Amount of Pixels In Output Buffer = " << pAmountOfPixelsInArray << endl;
	imageSegmentationDataFile << "Computing Average Image Intensity" << endl;
	pAverageImageIntensity = pImageTotalIntensity / pAmountOfPixelsInArray;
	imageSegmentationDataFile << "Average Image Intensity for Image Subtraction = " << pAverageImageIntensity << endl;


	imageSegmentationDataFile.close();
	return hr;

}

HRESULT  DirectXGPUDigitalLabCoreModule::SimulateImageSubtractionAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	cout << "This Function Simulate Mathematical Subtraction Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObject> pOutputPixelBuffer = vector<PixelObject>();

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position " << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position " << endl;
	cin >> pYPosition;

	cout << "Enter the Image Width " << endl;
	cin >> pImageWidth;

	cout << "Enter the Image Height " << endl;
	cin >> pImageHeight;

	LPWSTR pwzFileName1 = nullptr;
	LPWSTR pwzFileName2 = nullptr;


	WCHAR path[MAX_PATH];
	path[0] = L'\0';


	float pTopLeftX = 0.0f;
	float pTopLeftY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageSubtractionOutputFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Image Clip" << endl;
	imageSegmentationDataFile.clear();


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Data for the Clipped Area for Image One" << endl;
	imageSegmentationDataFile << "Printing the Data for the Clipped Area for Image One" << endl;

	UINT pIndex = 0;
	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
		pIndex++;
	}


	cout << "Loading image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
		hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Data for the Clipped Area for Image One" << endl;
	imageSegmentationDataFile << "Printing the Data for the Clipped Area for Image One" << endl;
	pIndex = 0;
	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
		pIndex++;
	}


	hr = ppStandardAlgorithmExecutor->SubtractImageData(hInstance, hWnd, pixelObjectImageEight,
		pixelObjectImageTwo, pXPosition, pYPosition, pImageWidth, pImageHeight, &pOutputPixelBuffer);


	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;

	float pIndexValue = 0;

	do
	{

		float pXValue = pOutputPixelBuffer[pIndexValue].xPosition;
		float pYValue = pOutputPixelBuffer[pIndexValue].yPosition;
		float pRedValue = pOutputPixelBuffer[pIndexValue].RMask;
		float pGreenValue = pOutputPixelBuffer[pIndexValue].GMask;
		float pBlueValue = pOutputPixelBuffer[pIndexValue].BMask;
		cout << "Step: " << pIndexValue << endl;
		cout << "Pixel Number: " << pOutputPixelBuffer[pIndexValue].pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Component = " << pRedValue << endl;
		cout << "Green Component = " << pGreenValue << endl;
		cout << "Blue Component = " << pBlueValue << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "Red Component = " << pRedValue << endl;
		imageSegmentationDataFile << "Green Component = " << pGreenValue << endl;
		imageSegmentationDataFile << "Blue Component = " << pBlueValue << endl;

		pIndexValue++;
	} while (pIndexValue < pOutputPixelBuffer.size());

	imageSegmentationDataFile.close();

	return hr;

}










HRESULT DirectXGPUDigitalLabCoreModule::SimulateFastFourierTransformAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	cout << "This Method Performs an FFT For Quadratic Function" << endl;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;
	ofstream myfile;
	myfile.open("C:\\pixels\\FastFourierTransform.txt");
	vector<float> pInputDataArray = vector<float>();
	vector<BufType> pOutputDataArray = vector<BufType>();

	vector<BufType> pArrayEightValues = vector<BufType>();
	vector<double> pArrayTwoValues = vector<double>();
	vector<UINT> pBitReverseOutputData = vector<UINT>();
	vector<DivisionRemainder> pOutputResultData = vector<DivisionRemainder>();

	UINT pAmountOfHarmonics = 0;
	pArrayEightValues.clear();
	pArrayTwoValues.clear();
	pOutputResultData.clear();
	float pIndexMin1 = 0.0f;
	float pIndexMax1 = 0.0f;
	int pIndexMin2 = 0;
	int pIndexMax2 = 0;
	float pStep = 0.0f;
	int pJCoefficient = 0;
	int pKCoefficient = 0;
	time_t* pTime = nullptr;
	time(pTime);
	cout << "Test Time Begin" << pTime << endl;
	myfile << "Test Time Begin" << pTime << endl;

	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	float pCoefficientA = 0.0f;
	float pCoefficientB = 0.0f;
	float pCoefficientC = 0.0f;
	float pStepValue = 0.0f;

	cout << "Enter the Value For Coefficient A " << endl;
	cin >> pCoefficientA;

	cout << "Enter the Value For Coefficient B" << endl;
	cin >> pCoefficientB;

	cout << "Enter the Value For Coefficient C" << endl;
	cin >> pCoefficientC;


	cout << "Coefficent A = " << pCoefficientA << endl;
	cout << "Coefficient B = " << pCoefficientB << endl;
	cout << "Coefficient C = " << pCoefficientC << endl;


	cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;

	cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;

	cout << "Enter the Function Step Value" << endl;
	cin >> pStepValue;

	cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;


	// Specify the engine and distribution.


	cout << "Generating Initial Data" << endl;
	int pIndexVar = 0;

	float pVal = pMinimumOfRange;
	for (int pValue = pMinimumOfRange; pIndexVar <= pMaximumOfRange; ++pValue)
	{

		cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pValue << endl;
		pInputDataArray.push_back(pValue);
		pIndexVar = pIndexVar + 1;
	} 

	






	cout << "Generating Data For Array Eight" << endl;
	myfile << "Generating Data For Array Eight" << endl;

	float pVar = pIndexMin1;
	UINT iIndex = 0;

	for (BufType pDataVar : pOutputDataArray)
	{
		
	
		cout << "Computation Result int at index:" << " " << iIndex << " " << "=" << " " << pDataVar.i << endl;
		cout << "Computation Result Float at index:" << " " << iIndex << " " << "=" << " " << pDataVar.f << endl;
		cout << "Computation Result Double at index:" << " " << iIndex << " " << "=" << " " << pDataVar.d << endl;

	


		BufType pDataVarData;
		pDataVarData.f = pDataVar.f;
		pDataVarData.d = pDataVar.d;
		pDataVarData.i = pDataVar.i;
		pArrayEightValues.push_back(pDataVarData);
		iIndex++;
	} 



	cout << "Printing Input Data Array 1" << endl;
	myfile << "Printing Input Data Array 1" << endl;

	UINT pIndex = 0;

	for (BufType pVariable : pArrayEightValues)
	{
		cout << "Input Array Value At Index Float: " << pIndex << "=" << pVariable.f << endl;
		cout << "Input Array Value At Index int: " << pIndex << "=" << pVariable.i << endl;
		cout << "Input Array Value At Index Double: " << pIndex << "=" << pVariable.d << endl;

		myfile << "Input Array Value At Index Float: " << pIndex << "=" << pVariable.f << endl;
		myfile << "Input Array Value At Index int: " << pIndex << "=" << pVariable.i << endl;
		myfile << "Input Array Value At Index Double: " << pIndex << "=" << pVariable.d << endl;

		pIndex = pIndex + 1;
	}
	

	


	cout << "Printing the Data For Array Eight" << endl;
	myfile << "Printing the Data For Array Eight" << endl;
	pIndex = 0;
	
	cout << "Computing the Bit Reverse Order Buffer" << endl;






	hr = ppStandardAlgorithmExecutor->ConvertAnArrayOfNumbersToButterFlyConvert(hInstance, hWnd,
		pArrayEightValues, &pOutputResultData);


	myfile << " " << endl;
	myfile << " " << endl;
	myfile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	myfile << "current time" << currentTime << endl;
	int pOperationNumber = 0;


	cout << "Printing Y Values" << endl;
	myfile << "Printing Y Values" << endl;

	iIndex = 0;

	vector<BufType> pReverseOutput = vector<BufType>();
	pIndexVar = 0;
	for (DivisionRemainder pNumberData : pOutputResultData)
	{
		cout << "Initial Value Before Division: " << pNumberData.pDivident.f;
		float pDividentVal = pNumberData.pDivident.f;

		if (pNumberData.pDivident.f == pDividentVal)
		{
			cout << "Bit Reverse int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.i << endl;
			myfile << "Bit Reverse int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.i << endl;
			cout << "Bit Reverse int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.f << endl;
			myfile << "Bit Reverse int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.f << endl;
			cout << "Bit Reverse int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.d << endl;
			myfile << "Bit Reverse int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.d << endl;
			iIndex++;

		}
		



	}


	

	
	
	myfile.close();

	return hr;

}

HRESULT DirectXGPUDigitalLabCoreModule::ReverseBitsOfANumber(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	UINT pNumberValue = 0;
	UINT pOutputValue = 0;
	cout << "Enter the Number that you want to convert" << endl;
	cin >> pNumberValue;
	vector<UINT> pRemaindersBeforeReversal = vector<UINT>();
	vector<UINT> pRemaindersAfterReversal = vector<UINT>();
	vector<UINT> pDivisorsArray = vector<UINT>();
	hr = ppStandardAlgorithmExecutor->ConvertNumberToBinaryValueAndComputeButterFly(hInstance,
		hWnd, pNumberValue,
		&pDivisorsArray,
		&pRemaindersBeforeReversal, &pRemaindersAfterReversal, &pOutputValue);

	cout << "The Bit Reversed Number: " << pOutputValue << endl;

	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::LogoffGPUDigitalLabUser(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeComputationalTask(HINSTANCE hInstance, HWND hWnd, UINT taskId)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::EstblishAConnectionWithACloudServer(HINSTANCE hInstance, HWND hWnd, LPCSTR address, LPCSTR usernme, LPCSTR password)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeBluetoothServerSocket(HINSTANCE hInstance, HWND hWND)
{
	HRESULT hr = S_OK;

	cout << "This function will setup A TCP Server in Windows" << endl;


	DirectXNetworkPacketManagementClass* pNewtworkPacketManager = m_pGPUNetworkModule;

	if (pNewtworkPacketManager == nullptr)
	{
		pNewtworkPacketManager = new DirectXNetworkPacketManagementClass(hInstance, hWND);
	}

	cout << "Launching our tcp server" << endl;
	hr = pNewtworkPacketManager->OpenBluetoothServerConnection(hInstance, hWND);

	return hr;
}

HRESULT  DirectXGPUDigitalLabCoreModule::StartMultiagentSimulation(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::AutomateOutlookUsingCOMAPI(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	cout << "This function will setup A TCP Server in Windows" << endl;


	DirectXCloudServerConnectionManager* pCloudManager = new DirectXCloudServerConnectionManager(hInstance, hWnd);

	if (pCloudManager == nullptr)
	{
		pCloudManager = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}

	cout << "Launching our tcp server" << endl;
	hr = pCloudManager->AutomateOutlookByCOMAPI(
		hInstance, hWnd, "o_gubanov@mail.ru", "o_gubanov@mail.ru", "Test", "C:\\RobotData\\RobotCleanerFromSelectedFilesUsingStateMachines.txt");

	
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::ConvertAnArrayOfNRandomNumbersToBitReverse(HINSTANCE hInstance, HWND hWnd)
{
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;
	UINT pNumberToConvert = 0;
	UINT pOutputNumber = 0;
	UINT* pNumberFFT = nullptr;
	vector<BufType> pInputDataArray = vector<BufType>();
	vector<DivisionRemainder> pOutcomeArray = vector<DivisionRemainder>();
	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	float pStepValue = 0.0f;
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ButterflyDataConvertion.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	pixelDataFile.clear();



	UINT pOutputValues = NULL;
	cout << "Converting the Number into binary mode" << endl;



		cout << "Enter the Amount Of Numbers That You Want To Convert: " << endl;
		cin >> pMaximumOfRange;

	

		// Specify the engine and distribution.


		cout << "Generating Initial Data" << endl;
		pixelDataFile << "Generating Initial Data" << endl;

		int pIndexVar = 0;

		float pVal = 0;


		for (int pIndexVar = 0; pIndexVar <= pMaximumOfRange; ++pIndexVar)
		{
			cout << "Enter A Number Value" << endl;
			cin >> pVal;
			cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
			pixelDataFile << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;

			BufType pParameterVar;
			pParameterVar.i = pVal;
			pParameterVar.f = (float)pVal;
			pParameterVar.d = (double)pVal;
			pInputDataArray.push_back(pParameterVar);
		}

		
	




		hr = ppStandardAlgorithmExecutor->ConvertAnArrayOfNumbersToButterFlyConvert(hInstance, hWnd, pInputDataArray,
			&pOutcomeArray);


	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;


	cout << "Printing Y Values" << endl;
	pixelDataFile << "Printing Y Values" << endl;

	UINT iIndex = 0;

	vector<BufType> pReverseOutput = vector<BufType>();
	pIndexVar = 0;
	for (DivisionRemainder pNumberData : pOutcomeArray)
	{
		float pFactoryValue = pNumberData.pDivident.f;
		cout << "Output Value for Factory: " << endl;
		pixelDataFile << "Output Value for Factory: " << endl;

		if (pNumberData.pDivident.f == pFactoryValue)
		{
			cout << "Binary Result int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.i << endl;
			pixelDataFile << "Binary Result int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.i << endl;
			cout << "Binary Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.f << endl;
			pixelDataFile << "Binary Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.f << endl;
			cout << "Binary Result Double at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.d << endl;
			pixelDataFile << "Binary Result Double at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.d << endl;
		}




	}

	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();

	cout << "Cleaning the Garbage after Operation" << endl;
	pReverseOutput.clear();
	pInputDataArray.cend();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ConvertAnArrayOfNumbersToButterflyFormOnCPU(HINSTANCE hInstance, HWND hWnd)
{

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;
	UINT pNumberToConvert = 0;
	UINT pOutputNumber = 0;
	vector<UINT> pInputDataArray = vector<UINT>();
	vector<UINT> pOutputArray = vector<UINT>();
	UINT pMinimumOfRange = 0;
	UINT pMaximumOfRange = 0;
	UINT pStepValue = 0;
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ButterflyDataConvertionCPU.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pixelDataFile.clear();
	cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;

	cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;

	cout << "Enter the Function Step Value" << endl;
	cin >> pStepValue;

	cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;

	pixelDataFile << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	pixelDataFile << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;

	// Specify the engine and distribution.


	cout << "Generating Initial Data" << endl;

	pixelDataFile << "Generating Initial Data" << endl;

	int pIndexVar = 0;

	float pVal = pMinimumOfRange;



	do
	{
		cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
		pixelDataFile << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
		pInputDataArray.push_back(pVal);
		pVal = pVal + pStepValue;
	} while (pVal <= pMaximumOfRange);


	cout << "Starting Our Data Convertion" << endl;


	vector<UINT> pFinalArray = vector<UINT>();
	hr = ppStandardAlgorithmExecutor->MixArrayIntoOddAndEvenElements(hInstance, hWnd, pInputDataArray, &pFinalArray);

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
 

	cout << "Printing Y Values" << endl;
	pixelDataFile << "Printing Y Values" << endl;
	UINT iIndex = 0;

	pIndexVar = 0;
	for (UINT pIndex = 0; pIndex < pInputDataArray.size(); ++pIndex)
	{

		cout << "Step №: " << pIndex << "Array Value: " << pInputDataArray[pIndex] << "Bit Reversed Value: " << pFinalArray[pIndex] << endl;
		pixelDataFile << "Step №: " << pIndex << "Array Value: " << pInputDataArray[pIndex] << "Bit Reversed Value: " << pFinalArray[pIndex] << endl;

	}
	pixelDataFile.close();
	return hr;

}

HRESULT DirectXGPUDigitalLabCoreModule::ConvertAnArrayOfNumbersToButterflyForm(HINSTANCE hInstance, HWND hWnd)
{

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;
	UINT pNumberToConvert = 0;
	UINT pOutputNumber = 0;
	UINT* pNumberFFT = nullptr;
	vector<BufType> pInputDataArray = vector<BufType>();
	vector<DivisionOutCome> pOutputArrayStageEight = vector<DivisionOutCome>();
	vector<DivisionRemainder> pRemainderArrayStageEight = vector<DivisionRemainder>();
	vector<BufType> pOutputArrayTwo = vector<BufType>();
	vector<DivisionRemainder> pRemainderArrayStageTwo = vector<DivisionRemainder>();
	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	float pStepValue = 0.0f;
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ButterflyDataConvertion.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	pixelDataFile.clear();



	UINT pOutputValues = NULL;
	cout << "Converting the Number into binary mode" << endl;



	int pMessageResult = MessageBoxA(hWnd, (LPCSTR)"Вы хотите Попробовать Функцию Bit Reverse в Убывающей Последовательности", (LPCSTR)"Message", MB_YESNOCANCEL | MB_ICONINFORMATION);

	if (pMessageResult == IDNO)
	{
		cout << "Enter the minimum of of the input sequence: " << endl;
		cin >> pMinimumOfRange;

		cout << "Enter the maximum of the input sequence: " << endl;
		cin >> pMaximumOfRange;

		cout << "Enter the Function Step Value" << endl;
		cin >> pStepValue;

		cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
		cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;

		pixelDataFile << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
		pixelDataFile << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;

		// Specify the engine and distribution.


		cout << "Generating Initial Data" << endl;

		pixelDataFile << "Generating Initial Data" << endl;

		int pIndexVar = 0;

		float pVal = pMinimumOfRange;


		
		do
		{
			cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
			pixelDataFile << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;

			BufType pParameterVar;
			pParameterVar.i = (int)pVal;
			pParameterVar.f = (float)pVal;
			pParameterVar.d = (double)pVal;
			pInputDataArray.push_back(pParameterVar);

			pVal = pVal + pStepValue;
			pIndexVar++;

		} while (pVal <= pMaximumOfRange);

		pIndexVar = 0;
		cout << "First We Will Have to Put the Same layer of Data Into the Input Array" << endl;
		pVal = pMinimumOfRange;
		do
		{
			cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
			pixelDataFile << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;

			BufType pParameterVar;
			pParameterVar.i = (int)pVal;
			pParameterVar.f = (float)pVal;
			pParameterVar.d = (double)pVal;
			pInputDataArray.push_back(pParameterVar);

			pVal = pVal + pStepValue;
			pIndexVar++;
		}
		while (pVal <= pMaximumOfRange);
	}
	
	if (pMessageResult == IDYES)
	{
		cout << "Enter the MAXIMUM of of the input sequence: " << endl;
		cin >> pMaximumOfRange;

		cout << "Enter the MINIMUM of the input sequence: " << endl;
		cin >> pMinimumOfRange;

		cout << "Enter the Function Step Value" << endl;
		cin >> pStepValue;

		cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
		cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;
		pixelDataFile << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
		pixelDataFile << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;


		// Specify the engine and distribution.


		cout << "Generating Initial Data" << endl;
		pixelDataFile << "Generating Initial Data" << endl;

		int pIndexVar = 0;

		float pVal = pMaximumOfRange;


		do
		{
			cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
			pixelDataFile << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;

			BufType pParameterVar;
			pParameterVar.i = (int)pVal;
			pParameterVar.f = (float)pVal;
			pParameterVar.d = (double)pVal;
			pInputDataArray.push_back(pParameterVar);

			pVal = pVal - pStepValue;
			pIndexVar++;

		} while (pVal >= pMinimumOfRange);

		pIndexVar = 0;
		cout << "First We Will Have to Put the Same layer of Data Into the Input Array" << endl;
		pVal = pMaximumOfRange;
		do
		{
			cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
			pixelDataFile << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;

			BufType pParameterVar;
			pParameterVar.i = (int)pVal;
			pParameterVar.f = (float)pVal;
			pParameterVar.d = (double)pVal;
			pInputDataArray.push_back(pParameterVar);

			pVal = pVal - pStepValue;
			pIndexVar++;
		} while (pVal >= pMinimumOfRange);
	
	}





	hr = ppStandardAlgorithmExecutor->ConvertAnArrayOfNumbersToButterFlyConvert(hInstance, hWnd, pInputDataArray,
		&pRemainderArrayStageEight);
	

	UINT iIndex = 0;

	for (DivisionRemainder pNumberData : pRemainderArrayStageEight)
	{
		float pFactoryValue = pNumberData.pDivident.f;
		cout << "Output Value for Factory: " << endl;
		pixelDataFile << "Output Value for Factory: " << endl;

		if (pNumberData.pDivident.f == pFactoryValue)
		{
			cout << "Binary Result int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.i << endl;
			pixelDataFile << "Binary Result int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.i << endl;
			cout << "Binary Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.f << endl;
			pixelDataFile << "Binary Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.f << endl;
			cout << "Binary Result Double at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.d << endl;
			pixelDataFile << "Binary Result Double at index:" << " " << iIndex << " " << "=" << " " << pNumberData.pOutcome.d << endl;
		}
		

		

	}

	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();

	
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ConvertIntegerValueToBinary(HINSTANCE hInstance, HWND hWnd)
{
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;
	UINT pNumberToConvert = 0;
	UINT* pNumberFFT = nullptr;
	cout << "Enter the Initial Value To Convert" << endl;
	cin >> pNumberToConvert;
	UINT pOutputValues = NULL;
	cout << "Converting the Number into binary mode" << endl;
	vector<UINT> pDivisionNumberSet = vector<UINT>();
	vector<UINT> pInverseNumberBitSet = vector<UINT>();
	vector<UINT> pRealNumberBitSet = vector<UINT>();
	hr = ppStandardAlgorithmExecutor->ConvertNumberToBinaryValueAndComputeButterFly(hInstance, hWnd, pNumberToConvert,
		&pDivisionNumberSet, &pInverseNumberBitSet,  &pRealNumberBitSet, &pOutputValues);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\BinaryDataConcvertionTable.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pixelDataFile.clear();
	
	int pIndex = 0;

	cout << "Printing the Divisors Of the Operation" << endl;

	for (UINT pDivisorItem : pDivisionNumberSet)
	{
		cout << "Index = " << pIndex << "Divisor = : " << pDivisorItem << endl;
		pixelDataFile << "Index = " << pIndex << "Divisor = : " << pDivisorItem << endl;
		pIndex = pIndex + 1;
	}
	pIndex = 0;
	
	cout << "Printing the Remainders Object" << endl;
	for (UINT pRemainderItem : pRealNumberBitSet)
	{
		cout << "Index = " << pIndex << "Remainder = : " << pRemainderItem << endl;
		pixelDataFile << "Index = " << pIndex << "Remainder = : " << pRemainderItem << endl;
		pIndex = pIndex + 1;
	}
	pIndex = 0;
	cout << "Printing the Reversed Remainders Object" << endl;
	for (UINT pInverseRemainderItem : pInverseNumberBitSet)
	{
		cout << "Index = " << pIndex << "Inverse Number Bit Value: " << pInverseRemainderItem << endl;
		pixelDataFile << "Index = " << pIndex << "Inverse Number Bit Value: " << pInverseRemainderItem << endl;
		pIndex = pIndex + 1;
	}



	cout << "Output Binary Number = " << pOutputValues << endl;
	pixelDataFile << "Output Binary Number = " << pOutputValues << endl;

	pixelDataFile.close();

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateSortingAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	HRESULT hr = S_OK;

	vector<UINT> pArrayEightValues = vector<UINT>(NUM_ELEMENTS);
	vector<UINT> pOutputResultData = vector<UINT>(NUM_ELEMENTS);
	std::random_device rd;
	std::mt19937 mt(rd());



	random_device rnd_device;
	// Specify the engine and distribution.
	mt19937 mersenne_engine(rnd_device());
	uniform_int_distribution<int> dist(1, NUM_ELEMENTS);








	auto gen = std::bind(dist, mersenne_engine);

	cout << "Generating Initial Data" << endl;

	std::generate(pArrayEightValues.begin(), pArrayEightValues.end(), [&] { return mt(); });


	UINT pIndex = 0;
	cout << "Printing the Data For Array Eight" << endl;

	for (UINT pVariable : pArrayEightValues)
	{
		cout << "The Array Eight Element At Index: " << pIndex << " = " << pVariable << endl;
		pIndex++;
	}



	hr = ppStandardAlgorithmExecutor->SimulateSortingAlgorithm(hInstance, hWnd, pArrayEightValues, &pOutputResultData);

	cout << "Printing the Results Of The Computations" << endl;
	pIndex = 0;
	for (UINT pVariable : pOutputResultData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pVariable << endl;
		pIndex++;
	}




	return hr;
}

	



HRESULT DirectXGPUDigitalLabCoreModule::InitializeLocalTransactionServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXConnectedApplicationLauncher* pConnectionManagementClass = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	if (!pConnectionManagementClass || pConnectionManagementClass == nullptr || pConnectionManagementClass == NULL)
	{
		pConnectionManagementClass = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	}

	hr = pConnectionManagementClass->InitializeNamedPipeServerWithApp(hInstance, hWnd);
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::ComputeGasSpeedData(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	hr = ppStandardAlgorithmExecutor->ComputeGasSpeed(hInstance, hWnd);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ConnectToDataProcessingEngine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXConnectedApplicationLauncher* pConnectionManagementClass = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	if (!pConnectionManagementClass || pConnectionManagementClass == nullptr || pConnectionManagementClass == NULL)
	{
		pConnectionManagementClass = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	}

	hr = pConnectionManagementClass->ConnectToDatabaseManaagerPipe(hInstance, hWnd);
	return hr;

}





HRESULT DirectXGPUDigitalLabCoreModule::ConnectToAgentManagementServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXConnectedApplicationLauncher* pConnectionManagementClass = m_pConnectedApplicationLauncher;
	if (pConnectionManagementClass == nullptr)
	{
		pConnectionManagementClass = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	}

	

	hr = pConnectionManagementClass->ConnectToAgentPipe(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::ExecuteComputeShader(HINSTANCE hInstance, HWND hWnd, LPCSTR filename)
{
	HRESULT hr = S_OK;
	m_pGPUComputeShaderManagerClass->ExecuteComputeShader(hInstance, 0, hWnd, "AlgebraCS", 0, 0, 0);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeRenderingPipeLine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateGasDynamicsLittleAlgoritmOnCPU(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	hr = ppStandardAlgorithmExecutor->ComputeGasDynamicsFormulaOneOnCPU(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateGasDynamicsMajorAlgoritmOnCPU(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	hr = ppStandardAlgorithmExecutor->ComputeGasDynamicsFormulaTwoOnCPU(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateMatrixMultiplicationAlgorithmWithManualInput(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	cout << "This Function Will Be Uses to Simulate Matrix Multiplication of Two Matrices" << endl;
	fstream pMatrixMultiplicationAlgorithm;
	pMatrixMultiplicationAlgorithm.open("C:\\pixels\\MatrixMultiplicationAlgorithmCS.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);


	vector<float> pArrayEightValues = vector<float>();
	vector<float> pArrayTwoValues = vector<float>();
	vector<BufType> pOutputMatrixVector = vector<BufType>();

	float pArrayEightBegin = 0.0f;
	float pArrayEightEnd = 0.0f;
	float pArrayTwoBegin = 0.0f;
	float pArrayTwoEnd = 0.0f;








   double pMatrixAVal = 0;
   double pMatrixBVal = 0;




	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;
	UINT pAmountOfRowsA = 0;
	UINT pAmountOfColsA = 0;
	UINT pAmountOfRowsB = 0;
	UINT pAmountOfColsB = 0;
	UINT pAmountOfRowsOut = 0;
	UINT pAmountOfColsOut = 0;
	cout << "Enter the Amount of Rows For the Matrix A;" << endl;
	cin >> pAmountOfRowsA;

	cout << "Enter the Amount of Columns For the Matrix A;" << endl;
	cin >> pAmountOfColsA;

	cout << "Enter the Amount of Rows For the Matrix A;" << endl;
	cin >> pAmountOfRowsB;

	cout << "Enter the Amount of Columns For the Matrix A;" << endl;
	cin >> pAmountOfColsB;

	cout << "Enter the Amount of Rows For the Output Matrix" << endl;
	cin >> pAmountOfRowsOut;

	cout << "Enter the Amount of Columns For the Output Matrix" << endl;
	cin >> pAmountOfColsOut;

	if (pAmountOfRowsA != pAmountOfColsB)
	{
		cout << "According to the rules of matrix multiplication the amount of rows for Matrix A must be the same as the amount of columns for Matrix B" << endl;
		pMatrixMultiplicationAlgorithm << "According to the rules of matrix multiplication the amount of rows for Matrix A must be the same as the amount of columns for Matrix B" << endl;
		return hr;
	}




	UINT pAMatrixSize = pAmountOfColsA * pAmountOfRowsA;
	UINT pBMatrixSize = pAmountOfColsB * pAmountOfRowsB;




	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		cout << "Enter Matrix A Variable Var = " << endl;
		cin >> pMatrixAVal;
		cout << "You Entered: " << pMatrixAVal << endl;

		pArrayEightValues.push_back(pMatrixAVal);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pMatrixMultiplicationAlgorithm << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValues.size() < pAMatrixSize);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{

		cout << "Enter Matrix B Variable Var = " << endl;
		cin >> pMatrixBVal;
		cout << "You Entered: " << pMatrixBVal << endl;

		pArrayTwoValues.push_back(pMatrixBVal);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pMatrixMultiplicationAlgorithm << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValues.size() < pBMatrixSize);

	cout << "Printing Array Eight" << endl;
	pMatrixMultiplicationAlgorithm << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pMatrixMultiplicationAlgorithm << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pMatrixMultiplicationAlgorithm << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pMatrixMultiplicationAlgorithm << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}



	cout << "Now We will Ensure that our Initial Array Size = 256 by Adding null Values" << endl;


	pIndex = 0;
	cout << "Printing the Array Eight Values " << endl;
	for (double pArrEightData : pArrayEightValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;

		pIndex = pIndex + 1;
	}

	pIndex = 0;
	cout << "Printing the Array Two Values " << endl;
	for (double pArrTwoData : pArrayTwoValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrTwoData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrTwoData << endl;

		pIndex = pIndex + 1;
	}




	cout << "Now We Will Try to Perform The Matrix Multiplication of Selelected Images" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateMatrixMultiplicationForImages(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, pAmountOfColsA, pAmountOfRowsA,
		pAmountOfColsB, pAmountOfRowsB, pAmountOfColsOut, pAmountOfRowsOut, &pOutputMatrixVector);

	cout << "Printing the Results of the Matrix Multiply Operation" << endl;
	UINT pIndexValue = 0;
	float pXPoisiton = 0.0f;
	float pYPosition = 0.0f;
	for (BufType pValue : pOutputMatrixVector)
	{

	
		cout  << "Index: " << pIndexValue << "Matrix Output Value Float: " << pValue.f << endl;
		pMatrixMultiplicationAlgorithm << "Index: " << pIndexValue << "Matrix Output Value Float: " << pValue.f << endl;
		pIndexValue++;
	}


	pMatrixMultiplicationAlgorithm.close();


	return hr;
}



HRESULT  DirectXGPUDigitalLabCoreModule::ComputeMatrixDeterminantSingleNumber(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	cout << "This Function Will Be Uses to Compute Matrix Determinants" << endl;
	fstream pMatrixMultiplicationAlgorithm;
	pMatrixMultiplicationAlgorithm.open("C:\\pixels\\MatrixDeterminantComputationsCS.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);


	vector<float> pArrayEightValues = vector<float>();
	vector<float> pArrayTwoValues = vector<float>();
	vector<BufType> pOutputMatrixVector = vector<BufType>();

	float pArrayEightBegin = 0.0f;
	float pArrayEightEnd = 0.0f;
	float pArrayTwoBegin = 0.0f;
	float pArrayTwoEnd = 0.0f;








	UINT pMatrixAVal = 0;
	UINT pMatrixBVal = 0;




	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;
	UINT pAmountOfRowsA = 0;
	UINT pAmountOfColsA = 0;
	UINT pAmountOfRowsB = 0;
	UINT pAmountOfColsB = 0;
	UINT pAmountOfRowsOut = 0;
	UINT pAmountOfColsOut = 0;
	cout << "Enter the Amount of Rows For the Matrix A;" << endl;
	cin >> pAmountOfRowsA;

	cout << "Enter the Amount of Columns For the Matrix A;" << endl;
	cin >> pAmountOfColsA;

	cout << "Enter the Amount of Rows For the Output Matrix" << endl;
	cin >> pAmountOfRowsOut;

	cout << "Enter the Amount of Columns For the Output Matrix" << endl;
	cin >> pAmountOfColsOut;

	if (pAmountOfRowsA != pAmountOfColsB)
	{
		cout << "According to the rules of matrix multiplication the amount of rows for Matrix A must be the same as the amount of columns for Matrix B" << endl;
		pMatrixMultiplicationAlgorithm << "According to the rules of matrix multiplication the amount of rows for Matrix A must be the same as the amount of columns for Matrix B" << endl;
		return hr;
	}

	UINT pAMatrixSize = pAmountOfColsA * pAmountOfRowsA;
	UINT pBMatrixSize = pAmountOfColsB * pAmountOfRowsB;




	cout << "Enter Matrix A Variable Var = " << endl;
	cin >> pMatrixAVal;

	cout << "Enter Matrix B Variable Var = " << endl;
	cin >> pMatrixBVal;

	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pMatrixAVal);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pMatrixMultiplicationAlgorithm << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValues.size() < pAMatrixSize);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{

		pArrayTwoValues.push_back(pMatrixBVal);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pMatrixMultiplicationAlgorithm << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValues.size() < pBMatrixSize);

	cout << "Printing Array Eight" << endl;
	pMatrixMultiplicationAlgorithm << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pMatrixMultiplicationAlgorithm << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	



	cout << "Now We will Ensure that our Initial Array Size = 256 by Adding null Values" << endl;


	pIndex = 0;
	cout << "Printing the Array Eight Values " << endl;
	for (UINT pArrEightData : pArrayEightValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;

		pIndex = pIndex + 1;
	}

	



	cout << "Now We Will Try to Perform The Matrix Multiplication of Selelected Images" << endl;

	hr = ppStandardAlgorithmExecutor->ComputeMatrixDeterminant(hInstance, hWnd,
		pArrayEightValues, pAmountOfColsA, pAmountOfRowsA,
	   pAmountOfColsOut, pAmountOfRowsOut, &pOutputMatrixVector);

	cout << "Printing the Results of the Matrix Multiply Operation" << endl;
	UINT pIndexValue = 0;
	float pXPoisiton = 0.0f;
	float pYPosition = 0.0f;
	for (BufType pValue : pOutputMatrixVector)
	{


		cout << "Index: " << pIndexValue << "Output Value Float: " << pValue.f << endl;
		pMatrixMultiplicationAlgorithm << "Index: " << pIndexValue << "Output Value Float: " << pValue.f << endl;
		pIndexValue++;
	}



	pMatrixMultiplicationAlgorithm.close();


	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateMatrixMultiplicationAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	
	cout << "This Function Will Be Uses to Simulate Matrix Multiplication of Two Matrices" << endl;
	fstream pMatrixMultiplicationAlgorithm;
	pMatrixMultiplicationAlgorithm.open("C:\\pixels\\MatrixMultiplicationAlgorithmCS.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);


	vector<float> pArrayEightValues = vector<float>();
	vector<float> pArrayTwoValues = vector<float>();
	vector<BufType> pOutputMatrixVector = vector<BufType>();

	float pArrayEightBegin = 0.0f;
	float pArrayEightEnd = 0.0f;
	float pArrayTwoBegin = 0.0f;
	float pArrayTwoEnd = 0.0f;








	UINT pMatrixAVal = 0;
	UINT pMatrixBVal = 0;
	



	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;
	UINT pAmountOfRowsA = 0;
	UINT pAmountOfColsA = 0;
	UINT pAmountOfRowsB = 0;
	UINT pAmountOfColsB = 0;
	UINT pAmountOfRowsOut = 0;
	UINT pAmountOfColsOut = 0;
	cout << "Enter the Amount of Rows For the Matrix A;" << endl;
	cin >> pAmountOfRowsA;

	cout << "Enter the Amount of Columns For the Matrix A;" << endl;
	cin >> pAmountOfColsA;

	cout << "Enter the Amount of Rows For the Matrix B;" << endl;
	cin >> pAmountOfRowsB;

	cout << "Enter the Amount of Columns For the Matrix B;" << endl;
	cin >> pAmountOfColsB;

	cout << "Enter the Amount of Rows For the Output Matrix" << endl;
	cin >> pAmountOfRowsOut;

	cout << "Enter the Amount of Columns For the Output Matrix" << endl;
	cin >> pAmountOfColsOut;

	if (pAmountOfRowsA != pAmountOfColsB)
	{
		cout << "According to the rules of matrix multiplication the amount of rows for Matrix A must be the same as the amount of columns for Matrix B" << endl;
		pMatrixMultiplicationAlgorithm << "According to the rules of matrix multiplication the amount of rows for Matrix A must be the same as the amount of columns for Matrix B" << endl;
		return hr;
	}

	UINT pAMatrixSize = pAmountOfColsA * pAmountOfRowsA;
	UINT pBMatrixSize = pAmountOfColsB * pAmountOfRowsB;




	cout << "Enter Matrix A Variable Var = " << endl;
	cin >> pMatrixAVal;

	cout << "Enter Matrix B Variable Var = " << endl;
	cin >> pMatrixBVal;

	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pMatrixAVal);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pMatrixMultiplicationAlgorithm << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValues.size() < pAMatrixSize);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{
	
		pArrayTwoValues.push_back(pMatrixBVal);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pMatrixMultiplicationAlgorithm << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValues.size() < pBMatrixSize);

	cout << "Printing Array Eight" << endl;
	pMatrixMultiplicationAlgorithm << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pMatrixMultiplicationAlgorithm << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pMatrixMultiplicationAlgorithm << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pMatrixMultiplicationAlgorithm << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}



	cout << "Now We will Ensure that our Initial Array Size = 256 by Adding null Values" << endl;


	pIndex = 0;
	cout << "Printing the Array Eight Values " << endl;
	for (UINT pArrEightData : pArrayEightValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrEightData << endl;

		pIndex = pIndex + 1;
    }

	pIndex = 0;
	cout << "Printing the Array Two Values " << endl;
	for (UINT pArrTwoData : pArrayTwoValues)
	{
		cout << "Element of Array Eight At Index: " << pIndex << " = " << pArrTwoData << endl;
		pMatrixMultiplicationAlgorithm << "Element of Array Eight At Index: " << pIndex << " = " << pArrTwoData << endl;

		pIndex = pIndex + 1;
    }




	cout << "Now We Will Try to Perform The Matrix Multiplication of Selelected Images" << endl;

	hr = ppStandardAlgorithmExecutor->SimulateMatrixMultiplicationForImages(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, pAmountOfColsA, pAmountOfRowsA,
		pAmountOfColsB, pAmountOfRowsB, pAmountOfColsOut, pAmountOfRowsOut, &pOutputMatrixVector);

	cout << "Printing the Results of the Matrix Multiply Operation" << endl;
	UINT pIndexValue = 0;
	float pXPoisiton = 0.0f;
	float pYPosition = 0.0f;
	for (BufType pValue : pOutputMatrixVector)
	{


		cout << "Index: " << pIndexValue << "Matrix Output Value Float: " << pValue.f << endl;
		pMatrixMultiplicationAlgorithm << "Index: " << pIndexValue << "Matrix Output Value Float: " << pValue.f << endl;
		pIndexValue++;
	}



	pMatrixMultiplicationAlgorithm.close();


	return hr;
 }











	



HRESULT DirectXGPUDigitalLabCoreModule::SimulateMatrixMultiplicationOnCPU(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	ofstream pOutputLogFile("C:\\pixels\\MatrixData.txt");

	vector<float> pArrayEightValues = vector<float>();
	vector<float> pArrayTwoValues = vector<float>();
	vector<float> pOutputArrayValues = vector<float>();

	float pMinRangeValueEight = 0;
	float pMinRangeValueTwo = 0;
	float pMaxRangeValueEight = 0;
	float pMaxRangeValueTwo = 0;

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Enter the Minimum Value For Array Two Data Range" << endl;
	cin >> pMinRangeValueTwo;




	cout << "Min Value Range For Matrix Eight = " << pMinRangeValueEight << endl;
	pOutputLogFile << "Min Value Range For Matrix Eight = " << pMinRangeValueEight << endl;
	cout << "Max Value Range For Matrix Eight = " << pMaxRangeValueEight << endl;
	pOutputLogFile << "Max Value Range For Matrix Eight = " << pMaxRangeValueEight << endl;

	

	pMaxRangeValueEight = pMaxRangeValueEight + 15;
	pMaxRangeValueTwo = pMaxRangeValueTwo + 15;

	
	cout << "Min Value Range For Matrix Two = " << pMinRangeValueTwo << endl;
	pOutputLogFile << "Min Value Range For Matrix Two = " << pMinRangeValueTwo << endl;


	cout << "Max Value Range For Matrix Two = " << pMaxRangeValueTwo << endl;
	pOutputLogFile << "Max Value Range For Matrix Two = " << pMaxRangeValueTwo << endl;




	cout << "Generating Data For Array Eight" << endl;
	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pOutputLogFile << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + 1;
	} while (pArrayEightValue <= pMaxRangeValueEight);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{
		pArrayTwoValues.push_back(pArrayTwoValue);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pOutputLogFile << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + 1;

	} while (pArrayTwoValue <= pMaxRangeValueTwo);

	cout << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (float pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pOutputLogFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pIndex = 0;
	for (float pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pOutputLogFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}


	hr = ppStandardAlgorithmExecutor->SimulateMatrixMultiplicatonOnCPU(hInstance,
		hWnd, pArrayEightValues, pArrayTwoValues, &pOutputArrayValues);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	for (UINT pValue : pOutputArrayValues)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;
		pOutputLogFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;

	}

	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateArrayAdditionAlgorithmUsingAppendConsumeTechnique(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Enter the Maximum Value For Array Eight Data Range" << endl;
	cin >> pMaxValueForArrayEight;

	cout << "Enter the Minimum Value For Array Two Data Range" << endl;
	cin >> pMinRangeValueTwo;

	cout << "Enter the Maximum Value For Array Two Data Range" << endl;
	cin >> pMaxRangeValueTwo;

	cout << "Enter the function Step For the Loop" << endl;
	cin >> pFunctionStep;

	cout << "Function STEP: " << pFunctionStep << endl;

	cout << "Generating Data For Array Eight" << endl;
	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValue <= pMaxValueForArrayEight);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{
		pArrayTwoValues.push_back(pArrayTwoValue);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValue <= pMaxRangeValueTwo);

	cout << "Printing Array Eight" << endl;
	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pIndex++;
	}

	vector<UINT> pOutputArrayData = vector<UINT>();

	hr = ppStandardAlgorithmExecutor->SimulateArrayAdditionAlgorithmUsingAppendConsume(hInstance, hWnd, pArrayEightValues, pArrayTwoValues,
		&pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	for (UINT pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;
		pIndex++;

	}

	return hr;
}


HRESULT  DirectXGPUDigitalLabCoreModule::SimulateArrauSubtractionOfNRandomNumbers(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\ArrayAdditionLogFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();
	cout << "This Function Will Add Two Arrays of Random Numbers" << endl;
	int pAmountOfNumberForArray = 0;
	cout << "Enter the Amount of Numbers In Array" << endl;
	cin >> pAmountOfNumberForArray;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();


	cout << "Filling Array Eight" << endl;
	int pCounter = 0;
	int pNumberA = 0;
	do
	{
		cout << "Enter the Number for Array Eight" << endl;
		cin >> pNumberA;
		pArrayEightValues.push_back(pNumberA);
		pCounter = pCounter + 1;

	} while (pCounter < pAmountOfNumberForArray);

	cout << "Filling Array Two" << endl;

	pCounter = 0;
	int pArrayB = 0;
	do
	{
		cout << "Enter the Number for Array Eight" << endl;
		cin >> pArrayB;
		pArrayTwoValues.push_back(pArrayB);
		pCounter = pCounter + 1;

	} while (pCounter < pAmountOfNumberForArray);


	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pArrayAdditionFile << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	vector<BufType> pOutputArrayData = vector<BufType>();

	hr = ppStandardAlgorithmExecutor->SimulateSimpleGPUSubtraction(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, &pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (BufType pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index Float: " << pIndex << " = " << pValue.f << endl;
		pArrayAdditionFile << "Output Array Element At Index Float: " << pIndex << " = " << pValue.f << endl;
		cout << "Output Array Element At Index int: " << pIndex << " = " << pValue.i << endl;
		pArrayAdditionFile << "Output Array Element At Index int: " << pIndex << " = " << pValue.i << endl;
		cout << "Output Array Element At Index Double: " << pIndex << " = " << pValue.d << endl;
		pArrayAdditionFile << "Output Array Element At Index Double: " << pIndex << " = " << pValue.d << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateArrayAdditionOfNRandomNumbers(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\ArrayAdditionLogFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();
	cout << "This Function Will Add Two Arrays of Random Numbers" << endl;
	int pAmountOfNumberForArray = 0;
	cout << "Enter the Amount of Numbers In Array" << endl;
	cin >> pAmountOfNumberForArray;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();


	cout << "Filling Array Eight" << endl;
	int pCounter = 0;
	int pNumberA = 0;
	do
	{
		cout << "Enter the Number for Array Eight" << endl;
		cin >> pNumberA;
		pArrayEightValues.push_back(pNumberA);
		pCounter = pCounter + 1;
		
	} while (pCounter < pAmountOfNumberForArray);

	cout << "Filling Array Two" << endl;

	pCounter = 0;
	int pArrayB = 0;
	do
	{
		cout << "Enter the Number for Array Eight" << endl;
		cin >> pArrayB;
		pArrayTwoValues.push_back(pArrayB);
		pCounter = pCounter + 1;

	} while (pCounter < pAmountOfNumberForArray);


	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pArrayAdditionFile << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	vector<UINT> pOutputArrayData = vector<UINT>();

	hr = ppStandardAlgorithmExecutor->SimulateSimpleGPUAddition(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, &pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (UINT pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;

}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateImagePixelClassificationExperiment(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ImageClassificationReport.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<PixelObjectWithALabel> pPixelObjectWithLabels = vector<PixelObjectWithALabel>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageHeight;

	LPWSTR path = nullptr;

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;

		cout << "Clipping Image Object" << endl;
		pixelDataFile << "Clipping Image Object" << endl;



		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVector);

		cout << "Printing the Contents of Clipped Area" << endl;
		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVector)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Index: " << pIndex << endl;
			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "Simulating Our Image Classification Experiment" << endl;
		hr = ppStandardAlgorithmExecutor->ClassifyImagePixelsByCriteriaSet(hInstance,
			hWnd, pImageWidth,
			pImageHeight,
			pixelObjectVector,
			&pPixelObjectWithLabels);

		cout << "Printing the Value For the Output Array" << endl;
		
	
		for (PixelObjectWithALabel pPixelObject : pPixelObjectWithLabels)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.pXPosition << endl;
			cout << "Y Position: " << pPixelObject.pYPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Pixel Label: " << pPixelObject.pClusterLabel << endl;

			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pPixelObject.pXPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.pYPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.rValue << endl;
			pixelDataFile << "Green Component " << pPixelObject.gValue << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.bValue << endl;
			pixelDataFile << "Pixel Label: " << pPixelObject.pClusterLabel << endl;


		}
	}
	pixelDataFile.close();
	return hr;

}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateParallelReductionAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\ParallelReductionTxt.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();

	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Beginning of Array Eight For Subtraction: " << pMinRangeValueEight << endl;
	pArrayAdditionFile << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;

	cout << "Enter the Maximum Value For Array Eight Data Range" << endl;
	cin >> pMaxValueForArrayEight;

	cout << "Last Element of Array Eight For Subtraction: " << pMaxValueForArrayEight << endl;
	pArrayAdditionFile << "Last Element of  Array Eight For Summation: " << pMaxValueForArrayEight << endl;




	cout << "Enter the function Step For the Loop" << endl;
	cin >> pFunctionStep;

	cout << "Function STEP: " << pFunctionStep << endl;
	pArrayAdditionFile << "Function STEP: " << pFunctionStep << endl;

	cout << "Generating Data For Array Eight" << endl;
	pArrayAdditionFile << "Generating Data For Array Eight" << endl;

	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValue <= pMaxValueForArrayEight);

	cout << "Generating Data For Array two" << endl;

	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}



	vector<BufType> pOutputArrayData = vector<BufType>();

	hr = ppStandardAlgorithmExecutor->SimulateParrallelReduction(hInstance, hWnd,
		pArrayEightValues, &pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (BufType pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index int: " << pIndex << " = " << pValue.i << endl;
		pArrayAdditionFile << "Output Array Element At Index int: " << pIndex << " = " << pValue.i << endl;
		cout << "Output Array Element At Index Float: " << pIndex << " = " << pValue.f << endl;
		pArrayAdditionFile << "Output Array Element At Index Float: " << pIndex << " = " << pValue.f << endl;
		cout << "Output Array Element At Index Double: " << pIndex << " = " << pValue.d << endl;
		pArrayAdditionFile << "Output Array Element At Index Double: " << pIndex << " = " << pValue.d << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateArrayMultiplicationAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\ArrayMultiplicationAlgorithm.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();

	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Beginning of Array Eight For Multiplication: " << pMinRangeValueEight << endl;
	pArrayAdditionFile << "Beginning of Array Eight For Multiplication: " << pMinRangeValueEight << endl;

	cout << "Enter the Maximum Value For Array Eight Data Range" << endl;
	cin >> pMaxValueForArrayEight;

	cout << "Last Element of Array Eight For Multiplication: " << pMaxValueForArrayEight << endl;
	pArrayAdditionFile << "Last Element of  Array Eight For Multiplication: " << pMaxValueForArrayEight << endl;


	cout << "Enter the Minimum Value For Array Two Data Range" << endl;
	cin >> pMinRangeValueTwo;

	cout << "Enter the Maximum Value For Array Two Data Range" << endl;
	cin >> pMaxRangeValueTwo;

	cout << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;
	pArrayAdditionFile << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;




	cout << "Enter the function Step For the Loop" << endl;
	cin >> pFunctionStep;

	cout << "Function STEP: " << pFunctionStep << endl;
	pArrayAdditionFile << "Function STEP: " << pFunctionStep << endl;

	cout << "Generating Data For Array Eight" << endl;
	pArrayAdditionFile << "Generating Data For Array Eight" << endl;

	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValue <= pMaxValueForArrayEight);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{
		pArrayTwoValues.push_back(pArrayTwoValue);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValue <= pMaxRangeValueTwo);

	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pArrayAdditionFile << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	vector<UINT> pOutputArrayData = vector<UINT>();

	hr = ppStandardAlgorithmExecutor->SimulateSimpleGPUMultiplication(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, &pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (UINT pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateMatrixMultiplicationAlgorithmUsingAMP(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\MatrixMultiplicationLogFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();

	float pMinRangeValueEight = 0;
	float pMaxValueForArrayEight = 0;
	float pMinRangeValueTwo = 0;
	float pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;
	float pMatrixEightRows = 0;
	float pMatrixEightColumns = 0;
	float pMatrixTwoRows = 0;
	float pMatrixTwoColumns = 0;

	vector<float> pArrayEightValues = vector<float>();
	vector<float> pArrayTwoValues = vector<float>();

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;
	pArrayAdditionFile << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;

	cout << "Enter the Maximum Value For Array Eight Data Range" << endl;
	cin >> pMaxValueForArrayEight;

	cout << "Last Element of Array Eight For Summation: " << pMaxValueForArrayEight << endl;
	pArrayAdditionFile << "Last Element of  Array Eight For Summation: " << pMaxValueForArrayEight << endl;


	cout << "Enter the Minimum Value For Array Two Data Range" << endl;
	cin >> pMinRangeValueTwo;

	cout << "Enter the Maximum Value For Array Two Data Range" << endl;
	cin >> pMaxRangeValueTwo;

	cout << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;
	pArrayAdditionFile << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;




	cout << "Enter the function Step For the Loop" << endl;
	cin >> pFunctionStep;



	cout << "Function STEP: " << pFunctionStep << endl;
	pArrayAdditionFile << "Function STEP: " << pFunctionStep << endl;


	cout << "Enter the Amount Of Rows for Matrix Eight" << endl;





	cout << "Generating Data For Array Eight" << endl;
	pArrayAdditionFile << "Generating Data For Array Eight" << endl;

	float pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValue <= pMaxValueForArrayEight);

	cout << "Generating Data For Array two" << endl;

	float pArrayTwoValue = pMinRangeValueTwo;
	do
	{
		pArrayTwoValues.push_back(pArrayTwoValue);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValue <= pMaxRangeValueTwo);

	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (float pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pArrayAdditionFile << "Printing Array Two" << endl;

	pIndex = 0;
	for (float pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}



	vector<float> pOutputArrayData = vector<float>();

	hr = ppStandardAlgorithmExecutor->SimulateMatrixMultiplicationUsingAMP(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, pMatrixEightRows, pMatrixEightColumns, pMatrixTwoRows, pMatrixTwoColumns,
		&pOutputArrayData);

	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (float pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateArrayAdditionAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	
	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\ArrayAdditionLogFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();

	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;
	pArrayAdditionFile << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;

	cout << "Enter the Maximum Value For Array Eight Data Range" << endl;
	cin >> pMaxValueForArrayEight;

	cout << "Last Element of Array Eight For Summation: " << pMaxValueForArrayEight << endl;
	pArrayAdditionFile << "Last Element of  Array Eight For Summation: " << pMaxValueForArrayEight << endl;


	cout << "Enter the Minimum Value For Array Two Data Range" << endl;
	cin >> pMinRangeValueTwo;

	cout << "Enter the Maximum Value For Array Two Data Range" << endl;
	cin >> pMaxRangeValueTwo;

	cout << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;
	pArrayAdditionFile << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;




	cout << "Enter the function Step For the Loop" << endl;
	cin >> pFunctionStep;

	cout << "Function STEP: " << pFunctionStep << endl;
	pArrayAdditionFile << "Function STEP: " << pFunctionStep << endl;

	cout << "Generating Data For Array Eight" << endl;
	pArrayAdditionFile << "Generating Data For Array Eight" << endl;

	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValue <= pMaxValueForArrayEight);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{
		pArrayTwoValues.push_back(pArrayTwoValue);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValue <= pMaxRangeValueTwo);

	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pArrayAdditionFile << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	vector<UINT> pOutputArrayData = vector<UINT>();

	hr = ppStandardAlgorithmExecutor->SimulateSimpleGPUAddition(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, &pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (UINT pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Output Array Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateArraySubtractionAlgorithm(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);

	fstream pArrayAdditionFile;
	pArrayAdditionFile.open("C:\\pixels\\ArraySubtractionLogFile.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pArrayAdditionFile.clear();

	UINT pMinRangeValueEight = 0;
	UINT pMaxValueForArrayEight = 0;
	UINT pMinRangeValueTwo = 0;
	UINT pMaxRangeValueTwo = 0;
	double pFunctionStep = 0;

	vector<UINT> pArrayEightValues = vector<UINT>();
	vector<UINT> pArrayTwoValues = vector<UINT>();

	cout << "Enter the Minimum Value For Array Eight Data Range" << endl;
	cin >> pMinRangeValueEight;

	cout << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;
	pArrayAdditionFile << "Beginning of Array Eight For Summation: " << pMinRangeValueEight << endl;

	cout << "Enter the Maximum Value For Array Eight Data Range" << endl;
	cin >> pMaxValueForArrayEight;

	cout << "Last Element of Array Eight For Summation: " << pMaxValueForArrayEight << endl;
	pArrayAdditionFile << "Last Element of  Array Eight For Summation: " << pMaxValueForArrayEight << endl;


	cout << "Enter the Minimum Value For Array Two Data Range" << endl;
	cin >> pMinRangeValueTwo;

	cout << "Enter the Maximum Value For Array Two Data Range" << endl;
	cin >> pMaxRangeValueTwo;

	cout << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;
	pArrayAdditionFile << "Beginning of Array Two For Summation: " << pMinRangeValueTwo << endl;




	cout << "Enter the function Step For the Loop" << endl;
	cin >> pFunctionStep;

	cout << "Function STEP: " << pFunctionStep << endl;
	pArrayAdditionFile << "Function STEP: " << pFunctionStep << endl;

	cout << "Generating Data For Array Eight" << endl;
	pArrayAdditionFile << "Generating Data For Array Eight" << endl;

	UINT pArrayEightValue = pMinRangeValueEight;
	do
	{
		pArrayEightValues.push_back(pArrayEightValue);
		int pArraySize = pArrayEightValues.size();
		cout << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Eight Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayEightValue = pArrayEightValue + pFunctionStep;
	} while (pArrayEightValue <= pMaxValueForArrayEight);

	cout << "Generating Data For Array two" << endl;
	UINT pArrayTwoValue = pMinRangeValueTwo;
	do
	{
		pArrayTwoValues.push_back(pArrayTwoValue);
		int pArraySize = pArrayTwoValues.size();
		cout << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;
		pArrayAdditionFile << "Array Two Contains: " << pArraySize << "Amount Of Elements" << endl;

		pArrayTwoValue = pArrayTwoValue + pFunctionStep;

	} while (pArrayTwoValue <= pMaxRangeValueTwo);

	cout << "Printing Array Eight" << endl;
	pArrayAdditionFile << "Printing Array Eight" << endl;

	UINT pIndex = 0;
	for (UINT pValue : pArrayEightValues)
	{
		cout << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array Eight Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	cout << "Printing Array Two" << endl;
	pArrayAdditionFile << "Printing Array Two" << endl;

	pIndex = 0;
	for (UINT pValue : pArrayTwoValues)
	{
		cout << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;
		pArrayAdditionFile << "Array TWO Element At Index: " << pIndex << " = " << pValue << endl;

		pIndex++;
	}

	vector<BufType> pOutputArrayData = vector<BufType>();

	hr = ppStandardAlgorithmExecutor->SimulateSimpleGPUSubtraction(hInstance, hWnd,
		pArrayEightValues, pArrayTwoValues, &pOutputArrayData);
	pIndex = 0;

	cout << "Printing the Output Array" << endl;
	pArrayAdditionFile << "Printing the Output Array" << endl;


	for (BufType pValue : pOutputArrayData)
	{
		cout << "Output Array Element At Index: " << pIndex << " = " << pValue.i << endl;
		pArrayAdditionFile << "Output Array Element At Index: " << pIndex << " = " << pValue.i << endl;

		pIndex++;

	}
	pArrayAdditionFile.close();
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InititializeTCPNetworkServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


STDMETHODIMP DirectXGPUDigitalLabCoreModule::put_Visible(BOOL bVisible)
{
	HWND hWnd;
	RECT rc;
	GetClientRect(hWnd, &rc);
	BOOL pbool = FALSE;
	if (pbool == NULL)
		return E_INVALIDARG;

	pbool = bVisible;
	return NOERROR;
}



STDMETHODIMP DirectXGPUDigitalLabCoreModule::GetTypeInfo(
	UINT itInfo,
	LCID lcid,
	ITypeInfo **ppTypeInfo)
{
	HRESULT hr = S_OK;

	
	
	LPTYPEINFO ptInfo;

	if (ppTypeInfo == NULL)
	{
		hr = E_INVALIDARG;
		return hr;
	}

	*ppTypeInfo = NULL;

	if (itInfo != 0)
	{
		hr = DISP_E_BADINDEX;
		return hr;
	}

	if (lcid == LOCALE_SYSTEM_DEFAULT || lcid == 0)
	{
		lcid = GetSystemDefaultLCID();
	}

	if (lcid == LOCALE_USER_DEFAULT)
	{
		lcid = GetUserDefaultLCID();
	}

	switch (lcid)
	{
	case LCID_GERMAN:
		ptInfo = m_ptinfoGerman;
		break;
	case LCID_ENGLISH:
		ptInfo = m_ptinfoEnglish;
		break;

	default:
		hr = DISP_E_UNKNOWNLCID;
		return hr;
	}

	ptInfo->AddRef();
	*ppTypeInfo = ptInfo;
	hr = NOERROR;
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::LockServer(BOOL fLock)
{
	if (fLock)
	{
		InterlockedIncrement(&g_ServerLocks);
	}
	else
	{
		InterlockedDecrement(&g_ServerLocks);
	}
	return S_OK;
}



HRESULT DirectXGPUDigitalLabCoreModule::OpenIntertetDataStream(HINSTANCE hInstance, HWND hWnd, LPCWSTR fName)
{
	HRESULT hr = S_OK;
	DirectXNetworkPacketManagementClass* pNetworkPacketManager = m_pGPUNetworkModule;


	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::RegisterComServerObject(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	
	DWORD *pdwRegisterCF = 0;
	DWORD *pdwRegisterAcitveObject = 0;

	if (!ppGPUDigitalLabClassFactory)
	{		
			SafeReleaseA(&ppGPUDigitalLabFactory);
			hr = E_FAIL;
			return hr;
	}
	ppGPUDigitalLabFactory->AddRef();

	hr = CoRegisterClassObject(GPUDigitalLabObj,
		ppGPUDigitalLabFactory,
		CLSCTX_LOCAL_SERVER,
		REGCLS_MULTIPLEUSE,
		pdwRegisterCF);

	if (hr != NOERROR)
	{
			return hr;
		
	}

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateGasDynamicsModelsFunction(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	hr = ppStandardAlgorithmExecutor->ComputeGasSpeed(hInstance, hWnd);
	return hr;
}



STDMETHODIMP_(ULONG) DirectXGPUDigitalLabCoreModule::Release()
{

	ULONG uCount = InterlockedDecrement(&m_nRefCount);
	if (uCount == 0)
	{
		delete this;
	}
	return uCount;
}



STDMETHODIMP DirectXGPUDigitalLabCoreModule::QueryInterface(REFIID riid, void** ppv)
{
	HRESULT hr = S_OK;
	
	if (ppv == NULL)
	{
		hr = E_INVALIDARG;
		return hr;
	}
	*ppv = NULL;

	if (riid == IID_IUnknown || riid == IID_IClassFactory)
	{
		*ppv = reinterpret_cast<IUnknown*>(this);
	}
	else if (riid == IID_IDispatch)
	{
		*ppv = (IDispatch*)this;
	}
	else
	{
		*ppv = NULL;
		hr = E_NOINTERFACE;
		return hr;
	}
	AddRef();
	hr = S_OK;
	return hr;
}




void DirectXGPUDigitalLabCoreModule::ProcessWindowResize(HWND hWnd)
{
	HRESULT hr = S_OK;

	if (m_pD2DManagementClass)
	{
		m_pD2DManagementClass->ProcessWindowResize(hWnd);
	}
}


ULONG DirectXGPUDigitalLabCoreModule::AddRef()
{
	return InterlockedIncrement(&m_nRefCount);
}









HRESULT DirectXGPUDigitalLabCoreModule::ShutdownSimulationSystem(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	if (m_pCloudServerConnectionManagerClass)
	{
		SafeDelete(m_pCloudServerConnectionManagerClass);
	}
	if (m_pCloudServerConnectionManagerClass)
	{
		SafeDelete(m_pCloudServerConnectionManagerClass);
	}

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeMolecularSimulationRenderingModule(HINSTANCE hInstance, HWND hWmd)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeRenderFarmSModule(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;

}

HRESULT DirectXGPUDigitalLabCoreModule::ShutdownMolecularSimulationRenderingModule(HINSTANCE hInstance, HWND hWmd)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeUserAccountController(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeModuleProcessingWidgets(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	HANDLE pHandle = nullptr;
	


	return hr;
}

RPC_STATUS CALLBACK SecurityCallback(RPC_IF_HANDLE hInterface, void* pBindingHandle)
{
	return RPC_S_OK; // Always allow anyEight.
}

// The thread that will listen for incoming RPC calls.





HRESULT DirectXGPUDigitalLabCoreModule::InitializeRPCServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	cout << "This Function is Used to Create an RPC Server Connection" << endl;

	RPC_STATUS status;
	RPC_IF_HANDLE ContextExample_v1_0_s_ifspec = new RPC_IF_HANDLE();
	cout << "Calling RpcServerUseProtseqEp" << std::endl;

	unsigned char* pszUid = NULL;
	unsigned char* pszProtocolSequence = (unsigned char*)"ncacn_np";
	unsigned char* pszSecurity = NULL;
	unsigned char* pszEndpoint = (unsigned char*)"\\pipe\\hello";
	unsigned char* pszNetworkAddress = NULL;
	unsigned char* pszOptions = NULL;
	unsigned char* pszStringBinding = NULL;
	unsigned char* pszString = (unsigned char*)"Hello, world";
	unsigned int cMinCalls = 1;
	unsigned int cMaxCalls = 20;
	unsigned int fDontWait = FALSE;
	int iIndex;

	cout << "Composing the String Binding Object" << endl;
	status = RpcStringBindingCompose((RPC_WSTR)pszUid,
		(RPC_WSTR)pszProtocolSequence,
		(RPC_WSTR)pszNetworkAddress,
		(RPC_WSTR)pszEndpoint,
		(RPC_WSTR)pszOptions,
		(RPC_WSTR*)pszStringBinding);
	printf("RpcStringBindingCompose returned 0x%x\n", status);
	printf("pszStringBinding = %s\n", pszStringBinding);



	cout << "Registering Users Protocol Sequence" << endl;
	// remote procedure calls.
	
	if (status)
	{
		cout << "RpcServerUseProtseqEp" << status << endl;
		return hr;
		
	}
	cout  << "Calling RpcServerRegisterIf" << std::endl;
	// Registers the ContextExample interface.
	status = RpcServerRegisterIf(
		ContextExample_v1_0_s_ifspec,
		// Interface to register.
		NULL, // Use the MIDL generated entry-point vector.
		NULL); // Naive security callback.

	if (status)
	{
		cout << "RpcServerRegisterIf" << status << endl;
		
	}

	std::clog << "Creating listen thread" << std::endl;

	const HANDLE hThread = CreateThread(NULL, 0, RpcServerListenThreadProc,
		this, 0, NULL);
	if (!hThread)
		cout << "CreateThread"<< GetLastError();

	std::cout << "Press enter to stop listening" << std::endl;
	std::cin.get();

	std::cout << "Calling RpcMgmtStopServerListening" << std::endl;
	status = RpcMgmtStopServerListening(NULL);
	if (status)
		cout << "RpcMgmtStopServerListening" << status;
	return hr;

	std::cout << "Waiting for listen thread to finish";
	while (WaitForSingleObject(hThread, 1000) == WAIT_TIMEOUT)
		std::clog << '.';
	std::clog << std::endl << "Listen thread finished" << std::endl;

	DWORD dwExitCodeThread = 0;
	GetExitCodeThread(hThread, &dwExitCodeThread);
	CloseHandle(hThread);
	if (dwExitCodeThread)

		cout << "RpcServerListen", dwExitCodeThread;

	std::cout << "Press enter to exit" << std::endl;
	std::cin.get();

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonFromSelectedFiles(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	DeleteFile(constants::pImageOneForProcessing);
	DeleteFile(constants::pImageTwoForProcessing);
	DeleteFile(constants::pImageThreeForProcessing);
	DeleteFile(constants::pImageFourForProcessing);

	SYSTEMTIME st, lt;
	GetSystemTime(&st);
	GetLocalTime(&lt);

	printf("The system time is: %02d:%02d\n", st.wHour, st.wMinute, st.wSecond);
	printf(" The local time is: %02d:%02d\n", lt.wHour, lt.wMinute, st.wSecond);



	


	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerFromSelectedFiles.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	cout << "Selecting Video File № 1" << endl;
	LPWSTR pVideoFileEight = nullptr;
	// Show the File Open dialog.
	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		// Open the file with the playback object.
		pVideoFileEight = ofn.lpstrFile;
	}

	cout << "Selecting Video File № 2" << endl;
	LPWSTR pVideoFileTwo = nullptr;
	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';
	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path1;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;

	if (GetOpenFileNameW(&ofn1))
	{
		// Open the file with the playback object.
		pVideoFileTwo = ofn1.lpstrFile;
	}








	if (GetOpenFileNameW(&ofn1))
	{
		// Open the file with the playback object.
		pVideoFileTwo = ofn1.lpstrFile;
	}


	DestroyFilePermanently(hInstance, hWnd, constants::pImageOneForProcessing);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageTwoForProcessing);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageThreeForProcessing);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageFourForProcessing);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageOneForProcessingAutonomous);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageTwoForProcessingAutonomous);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageThreeForProcessingAutonomous);
	DestroyFilePermanently(hInstance, hWnd, constants::pImageFourForProcessingAutonomous);


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileEight, pVideoFileTwo, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
     md2dmanager->ClearRenderTargetContent(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;



	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

	


	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageFourForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

	

	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pIndexValue++;
	}
	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

	

		pIndexValue++;
	}

	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, ppOutputPixelValue.pAmountOfDifferentPixels, 33, 66, 100);


	


		pIndex++;
	}
	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	
		
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		

	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();


	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::app);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::app);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}


	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorId << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;


	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum<< ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;

	imageSegmentationReportFile.close();
	imageSegmentationReportFileCSV.close();

	pRobotCleanerObjectReportArray.push_back(pReportObjectOfRobotCleaner);





	char* pOutputImageCode = nullptr;

	SYSTEMTIME st1, lt1;
	GetSystemTime(&st1);
	GetLocalTime(&lt1);


	printf("The system time0 is: %02d:%02d\n", st.wHour, st.wMinute, st.wSecond);
	printf(" The local time0 is: %02d:%02d\n", lt.wHour, lt.wMinute, st.wSecond);



	printf("The system time1 is: %02d:%02d\n", st1.wHour, st1.wMinute, st1.wSecond);
	printf(" The local time1 is: %02d:%02d\n", lt1.wHour, lt1.wMinute, st1.wSecond);


	
	

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SendTestEmailObject(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	cout << "This function will setup A TCP Server in Windows" << endl;


	DirectXCloudServerConnectionManager* pCloudManager = new DirectXCloudServerConnectionManager(hInstance, hWnd);

	if (pCloudManager == nullptr)
	{
		pCloudManager = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}

	cout << "Launching our tcp server" << endl;

	LPCSTR pYourEmailAddress = nullptr;
	LPCSTR pYourName = nullptr;
	LPCSTR pClientName = nullptr;
	LPCSTR pClientEmailAddress = nullptr;
	LPCSTR pMailSubject = nullptr;
	LPCSTR pMailMessage = nullptr;
	LPWSTR pMailAttachemt = nullptr;


	string pMailAddressServer;
	string pMailAddressName;
	string pMailAddressClient;
	string pMailAddressNameClient;
	string pSubject;
	string pMessage;

	cout << "Please Enter Your Email Adress" << endl;
	cin >> pMailAddressServer;

	cout << "Please Provide Your NickName" << endl;
	cin >> pMailAddressName;

	cout << "Please Provide Client Email Address" << endl;
	cin >> pMailAddressClient;

	cout << "Please Provide Client Name" << endl;
	cin >> pMailAddressNameClient;

	cout << "Please Enter the Subject Of Your Mail" << endl;
	cin >>  pSubject;

	cout << "Please Enter your Message of Your Mail" << endl;
	cin >> pMessage;

	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileName(&ofn))
	{
		pMailAttachemt = ofn.lpstrFile;
	}

	LPSTR pMailAddressSenderVar = const_cast<LPSTR>(pMailAddressServer.c_str());
	LPSTR pMailAddressClientVar = const_cast<LPSTR>(pMailAddressServer.c_str());
	LPSTR pMailSubjectVar = const_cast<LPSTR>(pSubject.c_str());
	LPSTR pMailMessageVar = const_cast<LPSTR>(pMessage.c_str());
	LPSTR pMailAttachment = (LPSTR)pMailAttachemt;
	cout << "Creating and Sending New Message" << endl;

	hr = pCloudManager->SendAnEmailWithAttachement(hInstance,
		hWnd, pMailAddressSenderVar,
		pMailAddressClientVar,
		(LPSTR)"Recipient",
		pMailSubjectVar,
		pMailMessageVar,
		pMailAttachment,
		(LPSTR)"Attachment");

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create and Send New Mail Message: " << pLastError << endl;
		return hr;
	}

	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonFromSelectedFilesStateMachines(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerFromSelectedFilesUsingStateMachinesClassification.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	LPWSTR pFilenameEight = nullptr;
	LPWSTR pFilenameTwo = nullptr;



	cout << "Selecting Video 1" << endl;
	LPWSTR pVideoFileNameOne = nullptr;
	// Show the File Open dialog.
	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		pVideoFileNameOne = ofn.lpstrFile;
	}

	cout << "Selecting Video 2" << endl;
	LPWSTR pVideoFileNameTwo = nullptr;
	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path1;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn1))
	{
		pVideoFileNameTwo = ofn1.lpstrFile;
	}


	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		(LPWSTR)pVideoFileNameOne, (LPWSTR)pVideoFileNameTwo, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);



	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();




	CBImageIntensityConstants pImageIntensityConstants;
	pImageIntensityConstants.pBlackColor = 0;
	pImageIntensityConstants.pExtremlyDark = 31;
	pImageIntensityConstants.pDarkVar = 63;
	pImageIntensityConstants.pCloseToBlack = 95;
	pImageIntensityConstants.pBarelyLit = 127;
	pImageIntensityConstants.pSemyLit = 159;
	pImageIntensityConstants.pLitVar = 191;
	pImageIntensityConstants.pExtraLit = 223;
	pImageIntensityConstants.pWhiteVar = 255;
	pImageIntensityConstants.pUndefinedColoer = -1;
	pImageIntensityConstants.pBarelyLitState = 1;
	pImageIntensityConstants.pBlackColorState = 2;
	pImageIntensityConstants.pCloseToBlackState = 3;
	pImageIntensityConstants.pDarkVarState = 4;
	pImageIntensityConstants.pExtraListState = 5;
	pImageIntensityConstants.pExtremlyDarkState = 6;
	pImageIntensityConstants.pLitVarState = 7;
	pImageIntensityConstants.pSemyLitState = 8;
	pImageIntensityConstants.pWhiteState = 9;
	pImageIntensityConstants.pUndefinedState = -1;

	cout << "Black State Has Id Value: " << pImageIntensityConstants.pBlackColor << endl;
	cout << "Extremly Dark State Has Id Value: " << pImageIntensityConstants.pExtremlyDark << endl;
	cout << "Dark State State Has Id Value: " << pImageIntensityConstants.pDarkVar << endl;
	cout << "Close To Black State Has Id Value: " << pImageIntensityConstants.pCloseToBlack << endl;
	cout << "Barely Lit State Has Id Value: " << pImageIntensityConstants.pBarelyLit << endl;
	cout << "Semi Lit State Has Id Value: " << pImageIntensityConstants.pSemyLit << endl;
	cout << "Lit State Has Id Value: " << pImageIntensityConstants.pLitVar << endl;
	cout << "Extra Lit State Has Id Value: " << pImageIntensityConstants.pExtraLit << endl;
	cout << "White State Has Id Value: " << pImageIntensityConstants.pWhiteVar << endl;

	imageSegmentationDataFile << "Black State Has Id Value: " << pImageIntensityConstants.pBlackColor << endl;
	imageSegmentationDataFile << "Extremly Dark State Has Id Value: " << pImageIntensityConstants.pExtremlyDark << endl;
	imageSegmentationDataFile << "Dark State State Has Id Value: " << pImageIntensityConstants.pDarkVar << endl;
	imageSegmentationDataFile << "Close To Black State Has Id Value: " << pImageIntensityConstants.pCloseToBlack << endl;
	imageSegmentationDataFile << "Barely Lit State Has Id Value: " << pImageIntensityConstants.pBarelyLit << endl;
	imageSegmentationDataFile << "Semi Lit State Has Id Value: " << pImageIntensityConstants.pSemyLit << endl;
	imageSegmentationDataFile << "Lit State Has Id Value: " << pImageIntensityConstants.pLitVar << endl;
	imageSegmentationDataFile << "Extra Lit State Has Id Value: " << pImageIntensityConstants.pExtraLit << endl;
	imageSegmentationDataFile << "White State Has Id Value: " << pImageIntensityConstants.pWhiteVar << endl;


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageFourForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}



	cout << "Now We Will Try To Interpret the Image Intensity function as a State Machine" << endl;
	imageSegmentationDataFile << "Now We Will Try To Interpret the Image Intensity function as a State Machine" << endl;
	vector<OutputPixelObjectGrayScaleWithState> pOutputPixelObjectGrayScaleVectorEight = vector<OutputPixelObjectGrayScaleWithState>();



	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachine(hInstance,
		hWnd, pImageIntensityConstants, pixelObjectImageEight,
		&pOutputPixelObjectGrayScaleVectorEight);

	for (OutputPixelObjectGrayScaleWithState pPixelObject : pOutputPixelObjectGrayScaleVectorEight)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		cout << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		imageSegmentationDataFile << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;
	}
	vector<OutputPixelObjectGrayScaleWithState> pOutputPixelObjectGrayScaleVectorTwo = vector<OutputPixelObjectGrayScaleWithState>();

	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachine(hInstance,
		hWnd, pImageIntensityConstants, pixelObjectImageTwo,
		&pOutputPixelObjectGrayScaleVectorTwo);

	for (OutputPixelObjectGrayScaleWithState pPixelObject : pOutputPixelObjectGrayScaleVectorTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		cout << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		imageSegmentationDataFile << "Level Of Intensity = " << pPixelObject.pLevelOfDarkness << endl;
	}



	MessageBoxA(hWnd, (LPCSTR)"Работа Симулятора Image Processing State-Machine", (LPCSTR)"Message", 0);
	cout << "State Machine Simulation Stage Eight Has Been Completed" << endl;
	cout << "Now We Will Simulate the Second Part of the Simulation Object" << endl;


	cbImageProcessingFSMStageTwo pImageLabelConstants;
	pImageLabelConstants.pDifferentImageLabel = -100;
	pImageLabelConstants.pDifferentStateLabel - 1;
	pImageLabelConstants.pIdenticalImageLabel = 100;
	pImageLabelConstants.pIdenticalStateLabel = 1;
	pImageLabelConstants.pUndefinedImageLabel = 0;
	pImageLabelConstants.pUndefinedStateLabel = 0;

	vector<OutputPixelObjectGrayScaleWithStateChange> pOutputGrayScaleVectorAfterStateMachine = vector<OutputPixelObjectGrayScaleWithStateChange>();
	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineStageTwo(hInstance, hWnd,
		pImageLabelConstants,
		pOutputPixelObjectGrayScaleVectorEight,
		pOutputPixelObjectGrayScaleVectorTwo,
		&pOutputGrayScaleVectorAfterStateMachine);

	for (OutputPixelObjectGrayScaleWithStateChange pPixelObject : pOutputGrayScaleVectorAfterStateMachine)
	{
		md2dmanager->ClearRoadSignFSM(hInstance, hWnd);

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGrayScaleValueOutput << endl;
		cout << "Previous Level of Darkness = " << pPixelObject.pPreviousLevelOfDarkness << endl;
		cout << "Current Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
		cout << "Previous State = " << pPixelObject.pPreviousState << endl;
		cout << "Current State = " << pPixelObject.pCurrentState << endl;
		cout << "Did Pixel State Change Occured" << pPixelObject.pDidStateChange << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValueOutput << endl;
		imageSegmentationDataFile << "Previous Level of Darkness = " << pPixelObject.pPreviousLevelOfDarkness << endl;
		imageSegmentationDataFile << "Current Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
		imageSegmentationDataFile << "Previous State = " << pPixelObject.pPreviousState << endl;
		imageSegmentationDataFile << "Current State = " << pPixelObject.pCurrentState << endl;
		imageSegmentationDataFile << "Did Pixel State Change Occured" << pPixelObject.pDidStateChange << endl;





		if (pPixelObject.pDidStateChange == 255)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 100);
		}
		else if (pPixelObject.pDidStateChange == 0)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 0);
		}


	}
	imageSegmentationDataFile.close();
	imageSegmentationDataFile.close();
	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\RobotCleanerStateMachines.jpg");


	return hr;
}




void  DirectXGPUDigitalLabCoreModule::OnPlayerEvent(HWND hwnd, WPARAM pUnkPtr)
{
	HRESULT hr = S_OK;

	hr = md3dVideoManagementClass->HandleEvent(pUnkPtr);

	if (FAILED(hr))
	{
		NotifyError(hwnd, L"An error occurred.", hr);
	}
	UpdateUI(hwnd, md3dVideoManagementClass->GetState());
}

void  DirectXGPUDigitalLabCoreModule::UpdateUI(HWND hwnd, PlayerState state)
{
	BOOL bWaiting = FALSE;
	BOOL bPlayback = FALSE;

	assert(md3dVideoManagementClass != NULL);

	switch (state)
	{
	case OpenPending:
		bWaiting = TRUE;
		break;

	case Started:
		bPlayback = TRUE;
		break;

	case Paused:
		bPlayback = TRUE;
		break;
	}

	HMENU hMenu = GetMenu(hwnd);
	UINT  uEnable = MF_BYCOMMAND | (bWaiting ? MF_GRAYED : MF_ENABLED);


	if (bPlayback && md3dVideoManagementClass->HasVideo())
	{
		g_bRepaintClient = FALSE;
	}
	else
	{
		g_bRepaintClient = TRUE;
	}
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoWindowsMedia(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleaner.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerWindowsMedia(hInstance, hWnd,
		(LPCSTR)constants::pVideoFileNameOne, (LPCSTR)constants::pVideoFileNameTwo, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();


	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::app);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::app);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}


	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorId << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;


	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum<< ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;

	imageSegmentationReportFile.close();
	imageSegmentationReportFileCSV.close();

	pRobotCleanerObjectReportArray.push_back(pReportObjectOfRobotCleaner);

	cout << "Creating Visualization Diagram" << endl;

	if (pOutputArrayAverage >= 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 100);
	}
	else if (pOutputArrayAverage >= 33 && pOutputArrayAverage < 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 50);
	}
	else if (pOutputArrayAverage >= 0 && pOutputArrayAverage < 33)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 0);
	}

	HWND hListBox = NULL;
	hListBox = CreateWindow(L"listbox", NULL,
		WS_CHILD | WS_VISIBLE | LBS_STANDARD |
		LBS_WANTKEYBOARDINPUT,
		30, 30, 200, 100,
		hWnd, (HMENU)ID_LIST, hInstance, NULL);

	// Отменяем режим перерисовки списка
	SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
	// Добавляем в список несколько строк

	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Green - Intensity <= 33");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Red - Intensity <= 100");

	UpdateWindow(hWnd);

	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");





	cout << "Creating Visualization Diagram Completed" << endl;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonFromExistingFiles(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleaner.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;

	UINT iIndex = 0;

	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	DeleteFile(constants::pImageOneForProcessing);
	DeleteFile(constants::pImageTwoForProcessing);
	DeleteFile(constants::pImageThreeForProcessing);
	DeleteFile(constants::pImageFourForProcessing);



	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo,  constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
    md2dmanager->ClearRenderTargetContent(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " <<  ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " <<  ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		if (ppOutputPixelValue.outputComparisonValue <= 255 && ppOutputPixelValue.outputComparisonValue >= 168)
		{
			md2dmanager->DrawRoadSignVertical(hInstance, hWnd, ppOutputPixelValue.pixelNumber, 100);
		}
		else if (ppOutputPixelValue.outputComparisonValue <= 167 && ppOutputPixelValue.outputComparisonValue >= 84)
		{
			md2dmanager->DrawRoadSignVertical(hInstance, hWnd, ppOutputPixelValue.pixelNumber, 66);
		}
		else if (ppOutputPixelValue.outputComparisonValue <= 83 && ppOutputPixelValue.outputComparisonValue >= 0)
		{
			md2dmanager->DrawRoadSignVertical(hInstance, hWnd, ppOutputPixelValue.pixelNumber, 33);
		}


		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();


	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::app);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::app);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}


	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorId << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;


	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageOneAverage << ", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum << ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;

	imageSegmentationReportFile.close();
	imageSegmentationReportFileCSV.close();

	pRobotCleanerObjectReportArray.push_back(pReportObjectOfRobotCleaner);

	cout << "Creating Visualization Diagram" << endl;


	HWND hListBox = NULL;
	hListBox = CreateWindow(L"listbox", NULL,
		WS_CHILD | WS_VISIBLE | LBS_STANDARD |
		LBS_WANTKEYBOARDINPUT,
		30, 30, 200, 100,
		hWnd, (HMENU)ID_LIST, hInstance, NULL);

	// Отменяем режим перерисовки списка
	SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
	// Добавляем в список несколько строк

	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Green - Intensity <= 33");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Red - Intensity <= 100");

	UpdateWindow(hWnd);

	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C:\\RobotData\\ImageScreenshot.jpg");




	
	cout << "Creating Visualization Diagram Completed" << endl;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::PrintRobotCleanerReportObject(HINSTANCE hInstance, HWND hWnd,
	RobotCleanerReportObject pReportObject)
{
	HRESULT hr = S_OK;
	cout << "Printing Report Objects into exportable text File" << endl;

	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReportExports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;


	RobotCleanerReportObject pReportObjectOfRobotCleaner = pReportObject;

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorId << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;


	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageOneAverage << ", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum << ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;

	imageSegmentationReportFile.close();
	imageSegmentationReportFileCSV.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::DestroyFilePermanently(HINSTANCE hInstance, HWND hWnd, LPWSTR pFileName)
{
	HRESULT hr = S_OK;
	SHFILEOPSTRUCT sfo = { 0 };
	ZeroMemory(&sfo, sizeof(&sfo));
	sfo.wFunc = FO_DELETE;
	sfo.pFrom = pFileName;
	sfo.fFlags = FOF_ALLOWUNDO | FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_NOERRORUI | FOF_NOCONFIRMMKDIR;
	int result = SHFileOperation(&sfo);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparison(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}







	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleaner.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;
	UINT pLevelOfImpurities = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;


	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue1;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue1;

	UINT pRecordingTimeInSeconds = 0;
	UINT pWaitingIntervalInSeconds = 0;

	cout << "Enter the Lengh Of The Recoring In Seconds" << endl;
	cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	auto start = high_resolution_clock::now();



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulateRobotCleaner(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo, pHourValue0, pMinuteValue0, pHourValue1, pMinuteValue1, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pRecordingTimeInSeconds, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppOutputPixelDataBuffer = vector<OutputPixelBuffer>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
		hr = md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, ppOutputPixelValue.pAmountOfDifferentPixels, 33, 66, 100);
		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();


	cout << "Saving Cleaner Results" << endl;
	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}



	UINT pReportId = 0;
	if (pRobotCleanerObjectReportArray.size() == 0)
	{
		pReportId = 0;
	}
	else
	{
		pReportId = pRobotCleanerObjectReportArray.size();
	}
	time_t pCurrentReportNow = time(0);
	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);


	cout << "Generating Report Object" << endl;

	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);

	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum<< endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;


	auto end = high_resolution_clock::now();
	auto duration = duration_cast<seconds>(end - start);

	cout << "RobotCleaner With Recording Demo Execution Time: " << duration.count() << endl;
	imageSegmentationReportFile << "RobotCleaner With Recording Demo Execution Time: " << duration.count() << endl;



	imageSegmentationReportFile.close();

	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum<< ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;

	HWND hListBox = NULL;
	hListBox = CreateWindow(L"listbox", NULL,
		WS_CHILD | WS_VISIBLE | LBS_STANDARD |
		LBS_WANTKEYBOARDINPUT,
		30, 30, 200, 100,
		hWnd, (HMENU)ID_LIST, hInstance, NULL);

	// Отменяем режим перерисовки списка
	SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
	// Добавляем в список несколько строк

	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Green - Intensity <= 33");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Red - Intensity <= 100");

	UpdateWindow(hWnd);




	imageSegmentationReportFile.close();
	imageSegmentationReportFileCSV.close();
	pRobotCleanerObjectReportArray.push_back(pReportObjectOfRobotCleaner);

	return hr;



}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaMotionDetectionSystemFromSelectedVideos(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<MotionPixelObjectRGB> ppVerificationOutputArray = vector<MotionPixelObjectRGB>();
	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerMotionDetectionWithVideoCapture.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;


	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;
	UINT pLevelOfImpurities = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;


	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;
	int pWaitingIntervalInSeconds = 0;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	auto start = high_resolution_clock::now();


	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	cout << "Selecting Videos for Playback" << endl;

	cout << "Selecting Video 1" << endl;
	LPWSTR pVideoFileNameOne = nullptr;
	// Show the File Open dialog.
	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		pVideoFileNameOne = ofn.lpstrFile;
	}

	cout << "Selecting Video 2" << endl;
	LPWSTR pVideoFileNameTwo = nullptr;
	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path1;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn1))
	{
		pVideoFileNameTwo = ofn1.lpstrFile;
	}




	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pVideoFileNameOne, pVideoFileNameTwo, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);



	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);



	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageFourForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;





	hr = ppStandardAlgorithmExecutor->DetectMotionInRGBImage(hInstance, hWnd, pixelObjectImageEight,
		pixelObjectImageTwo, &ppVerificationOutputArray,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (MotionPixelObjectRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
		cout << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
		imageSegmentationDataFile << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

		BOOL pIsMotionDetected = FALSE;

		if (pOutputPixelValue.pRedComponentDifference > 0 | pOutputPixelValue.pGreenComponentDifference > 0 | pOutputPixelValue.pBlueComponentDifference > 0)
		{
			pIsMotionDetected = TRUE;

		}
		else
		{
			pIsMotionDetected = FALSE;
		}

		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pIsMotionDetected);

	}


	return hr;




}
















HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaMotionDetectionSystemWithCapture(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();

	vector<MotionPixelObjectRGB> ppVerificationOutputArray = vector<MotionPixelObjectRGB>();
	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerMotionDetectionWithVideoCapture.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;
	UINT pLevelOfImpurities = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;


	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue1;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue1;

	UINT pRecordingTimeInSeconds = 0;
	UINT pWaitingIntervalInSeconds = 0;

	cout << "Enter the Lengh Of The Recoring In Seconds" << endl;
	cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;

	auto start = high_resolution_clock::now();


	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySumRedVar = 0.0f;
	float pImageOneIntensitySumGreenVar = 0.0f;
	float pImageOneIntensitySumBlueVar = 0.0f;
	float pImageOneIntensityAverageRedVar = 0.0f;
	float pImageOneIntensityAverageGreenVar = 0.0f;
	float pImageOneIntensityAverageBlueVar = 0.0f;

	float pImageTwoIntensitySumRedVar = 0.0f;
	float pImageTwoIntensitySumGreenVar = 0.0f;
	float pImageTwoIntensitySumBlueVar = 0.0f;
	float pImageTwoIntensityAverageRedVar = 0.0f;
	float pImageTwoIntensityAverageGreenVar = 0.0f;
	float pImageTwoIntensityAverageBlueVar = 0.0f;

	float pOutputArrayIntensitySumRedVar = 0.0f;
	float pOutputArrayIntensitySumGreenVar = 0.0f;
	float pOutputArrayIntensitySumBlueVar = 0.0f;
	float pOutputArrayIntensityAverageRedVar = 0.0f;
	float pOutputArrayIntensityAverageGreenVar = 0.0f;
	float pOutputArrayIntensityAverageBlueVar = 0.0f;

	float pIdenticalArrayIntensitySumRedVar = 0.0f;
	float pIdenticalArrayIntensitySumGreenVar = 0.0f;
	float pIdenticalArrayIntensitySumBlueVar = 0.0f;
	float pIdenticalArrayIntensityAverageRedVar = 0.0f;
	float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
	float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

	float pDifferentArrayIntensitySumRedVar = 0.0f;
	float pDifferentArrayIntensitySumGreenVar = 0.0f;
	float pDifferentArrayIntensitySumBlueVar = 0.0f;
	float pDifferentArrayIntensityAverageRedVar = 0.0f;
	float pDifferentArrayIntensityAverageGreenVar = 0.0f;
	float pDifferentArrayIntensityAverageBlueVar = 0.0f;

	BOOL pAreImagesIdentical = FALSE;



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulateRobotCleaner(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo, pHourValue0, pMinuteValue0, pHourValue1, pMinuteValue1, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pRecordingTimeInSeconds, pWaitingIntervalInSeconds);



	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}




	cout << "RGB Section End" << endl;
	imageSegmentationDataFile << "RGB Section End" << endl;


	vector<OutputPixelBufferRGB> pOutputPixelBufferRGB = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelVector = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelVector = vector<PixelObject>();



	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance, hWnd,
		pImageWidth,
		pImageHeight,
		pixelObjectImageEight,
		pixelObjectImageTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pOutputPixelBufferRGB,
		&pIdenticalPixelVector,
		&pDifferentPixelVector,
		&pImageOneIntensitySumRedVar,
		&pImageOneIntensitySumGreenVar,
		&pImageOneIntensitySumBlueVar,
		&pImageTwoIntensitySumRedVar,
		&pImageTwoIntensitySumGreenVar,
		&pImageTwoIntensitySumBlueVar,
		&pOutputArrayIntensitySumRedVar,
		&pOutputArrayIntensitySumGreenVar,
		&pOutputArrayIntensitySumBlueVar,
		&pIdenticalArrayIntensitySumRedVar,
		&pIdenticalArrayIntensitySumGreenVar,
		&pIdenticalArrayIntensitySumBlueVar,
		&pDifferentArrayIntensitySumRedVar,
		&pDifferentArrayIntensitySumGreenVar,
		&pDifferentArrayIntensitySumBlueVar,
		&pImageOneIntensityAverageRedVar,
		&pImageOneIntensityAverageGreenVar,
		&pImageOneIntensityAverageBlueVar,
		&pImageTwoIntensityAverageRedVar,
		&pImageTwoIntensityAverageGreenVar,
		&pImageTwoIntensityAverageBlueVar,
		&pOutputArrayIntensityAverageRedVar,
		&pOutputArrayIntensityAverageGreenVar,
		&pOutputArrayIntensityAverageBlueVar,
		&pIdenticalArrayIntensityAverageRedVar,
		&pIdenticalArrayIntensityAverageGreenVar,
		&pIdenticalArrayIntensityAverageBlueVar,
		&pDifferentArrayIntensityAverageRedVar,
		&pDifferentArrayIntensityAverageGreenVar,
		&pDifferentArrayIntensityAverageBlueVar,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;


	for (OutputPixelBufferRGB pOutputPixelValue : pOutputPixelBufferRGB)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1<< endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Images Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Images Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		BOOL pIsMotionDetected = FALSE;

		if (pOutputPixelValue.pOutputComparisonValueRed > 0 | pOutputPixelValue.pOutputComparisonValueGreen > 0 | pOutputPixelValue.pOutputComparisonValueBlue > 0)
		{
			pIsMotionDetected = TRUE;

		}
		else
		{
			pIsMotionDetected = FALSE;
		}

		md2dmanager->DrawRoadSignMotionDetectedVertical(hInstance, hWnd, pIsMotionDetected);

	}


	return hr;




}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageSubtraction(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleaner.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;


	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue0;

	cout << "Enter the hour to execute the timer for session Eight" << endl;
	cin >> pHourValue1;
	cout << "Enter the minute to execute the timer for session Eight " << endl;
	cin >> pMinuteValue1;

	UINT pRecordingTimeInSeconds = 0;
	UINT pWaitingIntervalInSeconds = 0;

	cout << "Enter the Length Of The Recording In Seconds" << endl;
	cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulateRobotCleaner(hInstance, hWnd,
		constants::pVideoFileNameOne, constants::pVideoFileNameTwo, pHourValue0, pMinuteValue0, pHourValue1, pMinuteValue1, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pRecordingTimeInSeconds, pWaitingIntervalInSeconds);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppOutputPixelDataBuffer = vector<PixelObjectGrayScale>();




	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);




	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;











	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<PixelObjectGrayScale> ppVerificationOutputArray = vector<PixelObjectGrayScale>();

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->SimulaeImageSubtractionGrayScaleOnGPU(hInstance, hWnd,
		ppImageOneGrayScale, ppImageTwoGrayScale, &ppVerificationOutputArray);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (PixelObjectGrayScale pOutputPixelObject : ppVerificationOutputArray)
	{


		cout << "Pixel Number: " << pOutputPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelObject.yPosition << endl;
		cout << "Final Output Intensity Value: " << pIndex << " = " << pOutputPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Pixel Number: " << pOutputPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << pIndex << " = " << pOutputPixelObject.pGreyLevel << endl;


		pIndex++;
	}


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;

	pArraySize = ppVerificationOutputArray.size();
	UINT pImageAverage = pTotalImageIntensitySum / pArraySize;

	cout << "Total Intensity Sum = " << pTotalImageIntensitySum << endl;
	cout << "Computing the Average Image Intensity" << endl;
	cout << "Output Array Contains: " << pArraySize << "Amount of Elements" << endl;
	cout << "Average Image Intensity = " << pImageAverage << endl;

	imageSegmentationDataFile << "Total Intensity Sum = " << pTotalImageIntensitySum << endl;
	imageSegmentationDataFile << "Computing the Average Image Intensity" << endl;
	imageSegmentationDataFile << "Output Array Contains: " << pArraySize << "Amount of Elements" << endl;
	imageSegmentationDataFile << "Average Image Intensity = " << pImageAverage << endl;


	float pPercentageValue = 0.0f;

	if (pImageAverage <= 230)
	{
		pPercentageValue = 10;
		cout << "Your Room Is Slightly Dirty" << endl;
		imageSegmentationDataFile << "Your Room Is Slightly Dirty" << endl;
		cout << "The Amount of dirty area in percents = " << pPercentageValue << endl;
		imageSegmentationDataFile << "The Amount of dirty area in percents = " << pPercentageValue << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(NULL, (LPCSTR)"Ваше помещение слегка загрязнено", (LPCSTR)"Message", 0);
		}
	}


	else if (pImageAverage <= 125)
	{
		pPercentageValue = 50;
		imageSegmentationDataFile << "Your Room Is Slightly Dirty" << endl;
		cout << "The Amount of dirty area in percents = " << pPercentageValue << endl;
		cout << "Light Cleaning is necessary" << endl;
		imageSegmentationDataFile << "The Amount of dirty area in percents = " << pPercentageValue << endl;
		imageSegmentationDataFile << "Light Cleaning is necessary" << endl;

		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(NULL, (LPCSTR)"Вам Требуется Легкая Уборка", (LPCSTR)"Message", 0);
		}
	}

	else if (pImageAverage <= 25)
	{
		pPercentageValue = 90;
		imageSegmentationDataFile << "Your Room Is very Dirty" << endl;
		cout << "The Amount of dirty area in percents = " << pPercentageValue << endl;
		cout << "Immediate Cleaning is necessary" << endl;
		imageSegmentationDataFile << "The Amount of dirty area in percents = " << pPercentageValue << endl;
		imageSegmentationDataFile << "Immediate Cleaning is necessary" << endl;

		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(NULL, (LPCSTR)"Вам Требуется Немедленная Уборка", (LPCSTR)"Message", 0);
		}
	}


	return hr;


}







HRESULT DirectXGPUDigitalLabCoreModule::OpenVideoFileForProcessing(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	if (pVideoAnalyticsManagementClass)
	{
		 pVideoAnalyticsManagementClass->OpenMediaFileForPlayback(hInstance, hWnd);
	}

	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::PauseVideo(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	

	if (pVideoAnalyticsManagementClass)
	{
		pVideoAnalyticsManagementClass->PauseVideo();
	}
	
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::StopVideo(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	if (pVideoAnalyticsManagementClass)
	{
		pVideoAnalyticsManagementClass->StopVideo();
	}

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::PlayVideo(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	if (pVideoAnalyticsManagementClass)
	{
		pVideoAnalyticsManagementClass->PlayVideo();
	}
	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::InitializePipeServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	HANDLE pPipeHandle = INVALID_HANDLE_VALUE;
	HANDLE pThreadHande = INVALID_HANDLE_VALUE;

	char* pFileName = NULL;
	
	if (!m_pConnectedApplicationLauncher)
	{
		m_pConnectedApplicationLauncher = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	}
	
	hr = m_pConnectedApplicationLauncher->InitializeNamedPipeServerWithApp(hInstance, hWnd);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeOverlappedNamedPipeServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	HANDLE pPipeHandle = INVALID_HANDLE_VALUE;
	HANDLE pThreadHande = INVALID_HANDLE_VALUE;

	if (!m_pConnectedApplicationLauncher)
	{
		m_pConnectedApplicationLauncher = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
	}

	hr = m_pConnectedApplicationLauncher->InitializeNamedPipeServerOverlapped(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeMailSlot(HINSTANCE hInstance, HWND hWnd, HANDLE hSlot, LPTSTR lpszSlotName)
{
	HRESULT hr = S_OK;

	HANDLE hMailSlot = INVALID_HANDLE_VALUE;

	hMailSlot = CreateMailslot(lpszSlotName,
		0,
		MAILSLOT_WAIT_FOREVER,

		
		(LPSECURITY_ATTRIBUTES)NULL);

	if (hMailSlot == INVALID_HANDLE_VALUE)
	{
		MessageBoxA(NULL, (LPCSTR)"Не удалось создать mailslot", (LPCSTR)"Message", 0);
		hr = E_FAIL;
		return hr;
	}

	else
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Новый Mailslot", (LPCSTR)"Message", 0);
		hr = S_OK;
	}

	return hr;
}






BOOL DirectXGPUDigitalLabCoreModule::IsUserInAdminGroup()
{
	BOOL fInAdminGroup = FALSE;
	DWORD dwError = ERROR_SUCCESS;
	HANDLE hToken = NULL;
	HANDLE hTokenToCheck = NULL;
	DWORD cbSize = 0;
	OSVERSIONINFO osver = { sizeof(osver) };

	// Open the primary access token of the process for query and duplicate.
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE,
		&hToken))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Determine whether system is running Windows Vista or later operating 
	// systems (major version >= 6) because they support linked tokens, but 
	// previous versions (major version < 6) do not.
	

	BOOL pOSResult = FALSE;
	pOSResult = IsWindows8OrGreater();
	
	if (pOSResult == TRUE)
	{
		// Running Windows Vista or later (major version >= 6). 
		// Determine token type: limited, elevated, or default. 
		TOKEN_ELEVATION_TYPE elevType;
		if (!GetTokenInformation(hToken, TokenElevationType, &elevType,
			sizeof(elevType), &cbSize))
		{
			dwError = GetLastError();
			goto Cleanup;
		}

		// If limited, get the linked elevated token for further check.
		if (TokenElevationTypeLimited == elevType)
		{
			if (!GetTokenInformation(hToken, TokenLinkedToken, &hTokenToCheck,
				sizeof(hTokenToCheck), &cbSize))
			{
				dwError = GetLastError();
				goto Cleanup;
			}
		}
	}

	// CheckTokenMembership requires an impersonation token. If we just got a 
	// linked token, it already is an impersonation token.  If we did not get 
	// a linked token, duplicate the original into an impersonation token for 
	// CheckTokenMembership.
	if (!hTokenToCheck)
	{
		if (!DuplicateToken(hToken, SecurityIdentification, &hTokenToCheck))
		{
			dwError = GetLastError();
			goto Cleanup;
		}
	}

	// Create the SID corresponding to the Administrators group.
	BYTE adminSID[SECURITY_MAX_SID_SIZE];
	cbSize = sizeof(adminSID);
	if (!CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, &adminSID,
		&cbSize))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Check if the token to be checked contains admin SID.
	// http://msdn.microsoft.com/en-us/library/aa379596(VS.85).aspx:
	// To determine whether a SID is enabled in a token, that is, whether it 
	// has the SE_GROUP_ENABLED attribute, call CheckTokenMembership.
	if (!CheckTokenMembership(hTokenToCheck, &adminSID, &fInAdminGroup))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

Cleanup:
	// Centralized cleanup for all allocated resources.
	if (hToken)
	{
		CloseHandle(hToken);
		hToken = NULL;
	}
	if (hTokenToCheck)
	{
		CloseHandle(hTokenToCheck);
		hTokenToCheck = NULL;
	}

	// Throw the error if something failed in the function.
	if (ERROR_SUCCESS != dwError)
	{
		throw dwError;
	}

	return fInAdminGroup;
}




// 
//   FUNCTION: IsRunAsAdmin()
//
//   PURPOSE: The function checks whether the current process is run as 
//   administrator. In other words, it dictates whether the primary access 
//   token of the process belongs to user account that is a member of the 
//   local Administrators group and it is elevated.
//
//   RETURN VALUE: Returns TRUE if the primary access token of the process 
//   belongs to user account that is a member of the local Administrators 
//   group and it is elevated. Returns FALSE if the token does not.
//
//   EXCEPTION: If this function fails, it throws a C++ DWORD exception which 
//   contains the Win32 error code of the failure.
//
//   EXAMPLE CALL:
//     try 
//     {
//         if (IsRunAsAdmin())
//             wprintf (L"Process is run as administrator\n");
//         else
//             wprintf (L"Process is not run as administrator\n");
//     }
//     catch (DWORD dwError)
//     {
//         wprintf(L"IsRunAsAdmin failed w/err %lu\n", dwError);
//     }
//






BOOL DirectXGPUDigitalLabCoreModule::IsRunAsAdmin()
{
	BOOL fIsRunAsAdmin = FALSE;
	DWORD dwError = ERROR_SUCCESS;
	PSID pAdministratorsGroup = NULL;

	// Allocate and initialize a SID of the administrators group.
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
	if (!AllocateAndInitializeSid(
		&NtAuthority, 
		2, 
		SECURITY_BUILTIN_DOMAIN_RID, 
		DOMAIN_ALIAS_RID_ADMINS, 
		0, 0, 0, 0, 0, 0, 
		&pAdministratorsGroup))
	{
		dwError = GetLastError();
		if (pAdministratorsGroup)
		{
			FreeSid(pAdministratorsGroup);
			pAdministratorsGroup = NULL;
		}

		// Throw the error if something failed in the function.
		if (ERROR_SUCCESS != dwError)
		{
			throw dwError;
		}

		return fIsRunAsAdmin;
	}

	// Determine whether the SID of administrators group is enabled in 
	// the primary access token of the process.
	if (!CheckTokenMembership(NULL, pAdministratorsGroup, &fIsRunAsAdmin))
	{
		dwError = GetLastError();
		if (pAdministratorsGroup)
		{
			FreeSid(pAdministratorsGroup);
			pAdministratorsGroup = NULL;
		}

		// Throw the error if something failed in the function.
		if (ERROR_SUCCESS != dwError)
		{
			throw dwError;
		}

		return fIsRunAsAdmin;
	}
	// Centralized cleanup for all allocated resources.

	return fIsRunAsAdmin;
}


//
//   FUNCTION: IsProcessElevated()
//
//   PURPOSE: The function gets the elevation information of the current 
//   process. It dictates whether the process is elevated or not. Token 
//   elevation is only available on Windows Vista and newer operating 
//   systems, thus IsProcessElevated throws a C++ exception if it is called 
//   on systems prior to Windows Vista. It is not appropriate to use this 
//   function to determine whether a process is run as administartor.
//
//   RETURN VALUE: Returns TRUE if the process is elevated. Returns FALSE if 
//   it is not.
//
//   EXCEPTION: If this function fails, it throws a C++ DWORD exception 
//   which contains the Win32 error code of the failure. For example, if 
//   IsProcessElevated is called on systems prior to Windows Vista, the error 
//   code will be ERROR_INVALID_PARAMETER.
//
//   NOTE: TOKEN_INFORMATION_CLASS provides TokenElevationType to check the 
//   elevation type (TokenElevationTypeDefault / TokenElevationTypeLimited /
//   TokenElevationTypeFull) of the process. It is different from 
//   TokenElevation in that, when UAC is turned off, elevation type always 
//   returns TokenElevationTypeDefault even though the process is elevated 
//   (Integrity Level == High). In other words, it is not safe to say if the 
//   process is elevated based on elevation type. Instead, we should use 
//   TokenElevation.
//
//   EXAMPLE CALL:
//     try 
//     {
//         if (IsProcessElevated())
//             wprintf (L"Process is elevated\n");
//         else
//             wprintf (L"Process is not elevated\n");
//     }
//     catch (DWORD dwError)
//     {
//         wprintf(L"IsProcessElevated failed w/err %lu\n", dwError);
//     }
//


//
//   FUNCTION: GetProcessIntegrityLevel()
//
//   PURPOSE: The function gets the integrity level of the current process. 
//   Integrity level is only available on Windows Vista and newer operating 
//   systems, thus GetProcessIntegrityLevel throws a C++ exception if it is 
//   called on systems prior to Windows Vista.
//
//   RETURN VALUE: Returns the integrity level of the current process. It is 
//   usually Eight of these values:
//
//     SECURITY_MANDATORY_UNTRUSTED_RID (SID: S-1-16-0x0)
//     Means untrusted level. It is used by processes started by the 
//     Anonymous group. Blocks most write access. 
//
//     SECURITY_MANDATORY_LOW_RID (SID: S-1-16-0x1000)
//     Means low integrity level. It is used by Protected Mode Internet 
//     Explorer. Blocks write acess to most objects (such as files and 
//     registry keys) on the system. 
//
//     SECURITY_MANDATORY_MEDIUM_RID (SID: S-1-16-0x2000)
//     Means medium integrity level. It is used by normal applications 
//     being launched while UAC is enabled. 
//
//     SECURITY_MANDATORY_HIGH_RID (SID: S-1-16-0x3000)
//     Means high integrity level. It is used by administrative applications 
//     launched through elevation when UAC is enabled, or normal 
//     applications if UAC is disabled and the user is an administrator. 
//
//     SECURITY_MANDATORY_SYSTEM_RID (SID: S-1-16-0x4000)
//     Means system integrity level. It is used by services and other 
//     system-level applications (such as Wininit, Winlogon, Smss, etc.)  
//
//   EXCEPTION: If this function fails, it throws a C++ DWORD exception 
//   which contains the Win32 error code of the failure. For example, if 
//   GetProcessIntegrityLevel is called on systems prior to Windows Vista, 
//   the error code will be ERROR_INVALID_PARAMETER.
//
//   EXAMPLE CALL:
//     try 
//     {
//         DWORD dwIntegrityLevel = GetProcessIntegrityLevel();
//     }
//     catch (DWORD dwError)
//     {
//         wprintf(L"GetProcessIntegrityLevel failed w/err %lu\n", dwError);
//     }
//
DWORD DirectXGPUDigitalLabCoreModule::GetProcessIntegrityLevel()
{
	DWORD dwIntegrityLevel = 0;
	DWORD dwError = ERROR_SUCCESS;
	HANDLE hToken = NULL;
	DWORD cbTokenIL = 0;
	PTOKEN_MANDATORY_LABEL pTokenIL = NULL;

	// Open the primary access token of the process with TOKEN_QUERY.
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Query the size of the token integrity level information. Note that 
	// we expect a FALSE result and the last error ERROR_INSUFFICIENT_BUFFER
	// from GetTokenInformation because we have given it a NULL buffer. On 
	// exit cbTokenIL will tell the size of the integrity level information.
	if (!GetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &cbTokenIL))
	{
		if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
		{
			// When the process is run on operating systems prior to Windows 
			// Vista, GetTokenInformation returns FALSE with the 
			// ERROR_INVALID_PARAMETER error code because TokenElevation 
			// is not supported on those operating systems.
			dwError = GetLastError();
			goto Cleanup;
		}
	}

	// Now we allocate a buffer for the integrity level information.
	pTokenIL = (TOKEN_MANDATORY_LABEL *)LocalAlloc(LPTR, cbTokenIL);
	if (pTokenIL == NULL)
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Retrieve token integrity level information.
	if (!GetTokenInformation(hToken, TokenIntegrityLevel, pTokenIL, 
		cbTokenIL, &cbTokenIL))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Integrity Level SIDs are in the form of S-1-16-0xXXXX. (e.g. 
	// S-1-16-0x1000 stands for low integrity level SID). There is Eight and 
	// only Eight subauthority.
	dwIntegrityLevel = *GetSidSubAuthority(pTokenIL->Label.Sid, 0);

Cleanup:
	// Centralized cleanup for all allocated resources.
	if (hToken)
	{
		CloseHandle(hToken);
		hToken = NULL;
	}
	if (pTokenIL)
	{
		LocalFree(pTokenIL);
		pTokenIL = NULL;
		cbTokenIL = 0;
	}

	// Throw the error if something failed in the function.
	if (ERROR_SUCCESS != dwError)
	{
		throw dwError;
	}

	return dwIntegrityLevel;
}

#pragma endregion


//
//   FUNCTION: ReportError(LPWSTR, DWORD)
//
//   PURPOSE: Display an error dialog for the failure of a certain function.
//
//   PARAMETERS:
//   * pszFunction - the name of the function that failed.
//   * dwError - the Win32 error code. Its default value is the calling 
//   thread's last-error code value.
//
//   NOTE: The failing function must be immediately followed by the call of 
//   ReportError if you do not explicitly specify the dwError parameter of 
//   ReportError. This is to ensure that the calling thread's last-error code 
//   value is not overwritten by any calls of API between the failing 
//   function and ReportError.
//
void DirectXGPUDigitalLabCoreModule::ReportError(LPCWSTR pszFunction)
{
	 DWORD dwError = GetLastError();
	wchar_t szMessage[200];
	if (SUCCEEDED(StringCchPrintf(szMessage, ARRAYSIZE(szMessage), 
		L"%s failed w/err 0x%08lx", pszFunction, dwError)))
	{
		MessageBox(NULL, szMessage, NULL, MB_OK);
	}
}


// 
//   FUNCTION: OnInitDialog(HWND, HWND, LPARAM)
//
//   PURPOSE: Process the WM_INITDIALOG message. Check and display the 
//   "run as administrator" status, the elevation information, and the 
//   integrity level of the current process.
//


BOOL DirectXGPUDigitalLabCoreModule::IsProcessElevated()
{
	BOOL fIsElevated = FALSE;
	DWORD dwError = ERROR_SUCCESS;
	HANDLE hToken = NULL;

	// Open the primary access token of the process with TOKEN_QUERY.
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		dwError = GetLastError();
		goto Cleanup;
	}

	// Retrieve token elevation information.
	TOKEN_ELEVATION elevation;
	DWORD dwSize;
	if (!GetTokenInformation(hToken, TokenElevation, &elevation, 
		sizeof(elevation), &dwSize))
	{
		// When the process is run on operating systems prior to Windows 
		// Vista, GetTokenInformation returns FALSE with the 
		// ERROR_INVALID_PARAMETER error code because TokenElevation is 
		// not supported on those operating systems.
		dwError = GetLastError();
		goto Cleanup;
	}

	fIsElevated = elevation.TokenIsElevated;

Cleanup:
	// Centralized cleanup for all allocated resources.
	if (hToken)
	{
		CloseHandle(hToken);
		hToken = NULL;
	}

	// Throw the error if something failed in the function.
	if (ERROR_SUCCESS != dwError)
	{
		throw dwError;
	}

	return fIsElevated;
}

void DirectXGPUDigitalLabCoreModule::InitializeSharedMemory(HINSTANCE hInstance, HWND hWnd, UINT amountOfBytes)
{
	HANDLE hMapFile;
	LPCTSTR pBuf;

	hMapFile = CreateFileMapping(
		INVALID_HANDLE_VALUE,    // use paging file
		NULL,                    // default security
		PAGE_READWRITE,          // read/write access
		0,                       // maximum object size (high-order DWORD)
		BUF_SIZE,                // maximum object size (low-order DWORD)
		 (LPCWSTR)szDefaultName);                 // name of mapping object

	if (hMapFile == NULL)
	{
		_tprintf(TEXT("Could not create file mapping object (%d).\n"),
			GetLastError());
		return;
	}
	pBuf = (LPTSTR) MapViewOfFile(hMapFile,   // handle to map object
		FILE_MAP_ALL_ACCESS, // read/write permission
		0,
		0,
		BUF_SIZE);

	if (pBuf == NULL)
	{
		_tprintf(TEXT("Could not map view of file (%d).\n"),
			GetLastError());

		CloseHandle(hMapFile);

		return;
	}


//	CopyMemory((PVOID)pBuf, (LPCWSTR)szDefaultMsg, (_tcslen(szDefaultMsg) * sizeof(TCHAR)));
	

	UnmapViewOfFile(pBuf);

	CloseHandle(hMapFile);
}

void DirectXGPUDigitalLabCoreModule::EleveteProcessStatus(HWND hWnd)
{
	DWORD dwErrr = 0;
	BOOL fIsRunAsAdmin;
	try
	{
		fIsRunAsAdmin = IsRunAsAdmin();
	}
	catch (DWORD dwError)
	{

		ReportError(L"IsRunAsAdmin");
	}

	// Elevate the process if it is not run as administrator.
	if (!fIsRunAsAdmin)
	{
		wchar_t szPath[MAX_PATH];
		if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)))
		{
			// Launch itself as administrator.
			SHELLEXECUTEINFO sei = { sizeof(sei) };
			sei.lpVerb = L"runas";
			sei.lpFile = szPath;
			sei.hwnd = hWnd;
			sei.nShow = SW_NORMAL;

			if (!ShellExecuteEx(&sei))
			{
				DWORD dwError = GetLastError();
				if (dwError == ERROR_CANCELLED)
				{
					// The user refused the elevation.
					// Do nothing ...
				}
			}
			else
			{
				return;
			}
		}
	}
	else
	{
		MessageBox(hWnd, L"The process is running as administrator", L"UAC", MB_OK);
	}
}








HRESULT DirectXGPUDigitalLabCoreModule::StartChildProcess(HINSTANCE hInstance, HWND hWnd, LPCSTR jobName)
{
	HRESULT hr = S_OK;
	hr = m_pGPUJobManagementClass->CreateJobInstance(hInstance, hWnd, jobName, 0);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::ConnectToPipeServer(HINSTANCE hInstancem, HWND hWnd, LPCWSTR fName)
{
	HRESULT hr = S_OK;
	LPTSTR llpvMessage=TEXT("Default message from client."); 
	TCHAR  chBuf[BUFSIZE]; 
	BOOL   fSuccess = FALSE; 
	DWORD  cbRead, cbToWrite, cbWritten, dwMode; 
	BOOL result = FALSE;


	pConnectionPipe = CreateFile(fName,
		GENERIC_READ |  // read and write access 
		GENERIC_WRITE, 
		0,              // no sharing 
		NULL,           // default security attributes
		OPEN_EXISTING,  // opens existing pipe 
		0,              // default attributes 


		NULL); 

	if (pConnectionPipe != INVALID_HANDLE_VALUE)
	{
		MessageBoxA(hWnd, (LPCSTR)"Создано подключение к ядру", (LPCSTR)"Message", 0);

	}

	DWORD error = GetLastError();

	if (error == ERROR_PIPE_BUSY)
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать подключение", (LPCSTR)"Message", 0);
		hr = E_FAIL;
		return hr;
	}

	if (pConnectionPipe != INVALID_HANDLE_VALUE)
	{
		MessageBoxA(hWnd, (LPCSTR)"Установлено подключение к вычислительному ядру", (LPCSTR)"Message", 0);

	}

	error = GetLastError();

	if (error != ERROR_PIPE_BUSY)
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать подключение к ядру", (LPCSTR)"Message", 0);
	}

	result = WaitNamedPipe(fName, 20000);

	if (result == FALSE)
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось открыть подключение к ядру", (LPCSTR)"Message", 0);
		hr = E_FAIL;
	}


	dwMode = PIPE_READMODE_BYTE;
	fSuccess = SetNamedPipeHandleState(pConnectionPipe,
		&dwMode,
		NULL,
		NULL);

	if (!fSuccess)
	{
		MessageBoxA(hWnd, (LPCSTR)"SetNamedPipeHandleState failed. GLE=%d\n", (LPCSTR)"Message", 0);
		hr = E_FAIL;
	}

	cbToWrite = (lstrlen(llpvMessage)+1)*sizeof(TCHAR);
	_tprintf( TEXT("Sending %d byte message: \"%s\"\n"), cbToWrite, llpvMessage); 

	fSuccess = WriteFile(pConnectionPipe,
		llpvMessage,
		cbToWrite,
		&cbWritten,
		NULL);

	if ( ! fSuccess) 
	{
		_tprintf( TEXT("WriteFile to pipe failed. GLE=%d\n"), GetLastError() ); 
		return -1;
	}

	printf("\nMessage sent to server, receiving reply as follows:\n");

	do 
	{ 
		// Read from the pipe. 

		fSuccess = ReadFile( 
			pConnectionPipe,    // pipe handle 
			chBuf,    // buffer to receive reply 
			BUFSIZE*sizeof(TCHAR),  // size of buffer 
			&cbRead,  // number of bytes read 
			NULL);    // not overlapped 

		if ( ! fSuccess && GetLastError() != ERROR_MORE_DATA )
			break; 

		_tprintf( TEXT("\"%s\"\n"), chBuf ); 
	} while ( ! fSuccess);  // repeat loop if ERROR_MORE_DATA 

	if ( ! fSuccess)
	{
		_tprintf( TEXT("ReadFile from pipe failed. GLE=%d\n"), GetLastError() );
		return -1;
	}

	printf("\n<End of message, press ENTER to terminate connection and exit>");


	CloseHandle(pConnectionPipe); 
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeComputeShaderInstanceFromFile(HINSTANCE hInstance, HWND hWnd, LPCSTR filename)
{
	HRESULT hr = S_OK;
	DirectXComputeShaderManagementClass* m_pGPUComputeShaderManagerClass = new DirectXComputeShaderManagementClass(hInstance, hWnd);
	hr = m_pGPUComputeShaderManagerClass->InitializeD3D11Device(hWnd, 0);
	hr = m_pGPUComputeShaderManagerClass->LaunchComputeShader(hInstance, 0, hWnd, filename, (LPCSTR)"CS_Main");
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeNewJobObject(HINSTANCE hInstance, HWND hWnd, LPCSTR fileName)
{
	HRESULT hr = S_OK;
	HANDLE mut = INVALID_HANDLE_VALUE;
	DWORD result;


	mut = CreateMutex(NULL, FALSE, (LPCWSTR)fileName);
	result = WaitForSingleObject(mut, 0);

	if (result == WAIT_OBJECT_0)
	{ 
		hr = m_pGPUJobManagementClass->CreateJobInstance(hInstance, hWnd, fileName, 0);
		printf("Запушена новая задача");
		ReleaseMutex(mut);
	}
	else
	{
		cout << "fail programm running" << endl;
		CloseHandle(mut);

	}
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::OpenNetworkAccessToKernel(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	m_pGPUNetworkModule = new DirectXNetworkPacketManagementClass(hInstance, hWnd);
	hr = m_pGPUNetworkModule->OutputLocalIpAddress(hInstance, hWnd);
	hr = m_pGPUNetworkModule->OpenSocketObject(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateAddition(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	hr = m_pStandardAlgorithmExecutor->SimulateAddition(hInstance, hWnd);
	return hr;
}

void DirectXGPUDigitalLabCoreModule::InstallProcessingService()
{
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rcScreen;
	HWND hWnd = NULL;

	GetClientRect(hWnd, &rcScreen);

	InstallService();

}

void DirectXGPUDigitalLabCoreModule::StartProcessingService()
{
	StartServiceInstance();
}

void DirectXGPUDigitalLabCoreModule::StopProcessingService()
{
	RemoveService();
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeConnectionToDataEngine()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeMultiAgentSystem()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeGraphicsEngineModule()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::CreateMathematicalModelObject()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::CreateScientificExperimentObject()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SimulateArrayAdditionAlgorithm()
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SimulateSortingAlgorithm()
{
	HRESULT hr = S_OK;
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::InitializeGPUDigitalLabCore()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	hr = InitializeGPUDigitalLabCore(hInstance, hWnd);

	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeUserAccountController()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	hr = InitializeUserAccountController(hInstance, hWnd);

	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::CreateAppicationDomainManagerClass()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	hr = CreateAppicationDomainManagerClass(hInstance, hWnd);

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateApplicationDomainInstanceClass()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	hr = CreateApplicationDomainInstanceClass(hInstance, hWnd);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::CreateCloudServerConnection(LPCWSTR webConnectionName, LPCWSTR webAddress, LPCWSTR portNumber)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = CreateCloudServerConnection(hInstance, hWnd, webConnectionName, webAddress, portNumber);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeRaytracerRenderingEngine()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeRaytracerRenderingEngine(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateDMOLSimulationAnimation(LPCSTR fProgrammingScript, LPCSTR fDataArchive)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = CreateDMOLSimulationAnimation(fProgrammingScript, fDataArchive);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateFluidDynamicsAnimation(LPCSTR fName)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = CreateFluidDynamicsAnimation(hInstance, hWnd, fName);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::CreateIndustrialSimulationAnimation(LPCSTR fProgrammingScript, LPCSTR fDataArchive)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = CreateIndustrialSimulationAnimation(hInstance, hWnd, fProgrammingScript, fDataArchive);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::CreateUserProcessingSession()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = CreateUserProcessingSession(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SimulateComputationalTask(LPCSTR address, LPCSTR usernme, LPCSTR password, LPCSTR cloudServeerName)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = SimulateComputationalTask(hInstance, hWnd, address, usernme, password, cloudServeerName);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::LoadSkypeApplication(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	cout << "Checking Cloud Server Management Class Object" << endl;

	if (m_pCloudServerConnectionManagerClass == nullptr)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	hr = m_pCloudServerConnectionManagerClass->LoadSkypeLibrary(hInstance, hWnd);

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::DownloadDataPacketFromWeb(LPCSTR webAddress)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = DownloadDataPacketFromWeb(hInstance, hWnd, webAddress);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::EstablishAConnectionToHTTPServer(LPCSTR address, LPCSTR usernme, LPCSTR password)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::EstblishAConnectionWithACloudServer(LPCSTR address, LPCSTR usernme, LPCSTR password)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = EstblishAConnectionWithACloudServer(hInstance, hWnd, address, usernme, password);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeEventProcessingModule()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeEventProcessingModule(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeModuleProcessingWidgets()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeModuleProcessingWidgets(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::ShutdownUserProcessingSession()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = ShutdownUserProcessingSession(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::ExtractDataPacketFromWeb(LPCSTR dataAddress)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = ExtractDataPacketFromWeb(hInstance, hWnd, dataAddress);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::LogonGPUDigitalLabUser(LPCSTR fUserName, LPCSTR fPassword)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = LogonGPUDigitalLabUser(hWnd, fUserName, fPassword);
	return hr;
}





HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeInternalTCPServer()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	hr = InitializeInternalTCPServer(hInstance, hWnd);

	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::CreateNewComputationalAgent(LPCSTR agentReader, LPCSTR agentWriter)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);

	return hr;

}
HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::OutputLocalIpAddress()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = OutputLocalIpAddress(hInstance, hWnd);
	return hr;
}


HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::ConnectToAgentManagementServer()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = ConnectToAgentManagementServer(hInstance, hWnd);
	return hr;
}
HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeInternelAccess()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeInternelAccess(hInstance, hWnd);
	return hr;
}


HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeHTTPAccess(LPCSTR webAddress)
{

	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeHTTPAccess(hInstance, hWnd, webAddress);
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeHTTPAccessToKernel()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeHTTPAccessToKernel(hInstance, hWnd);
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::StartDataGetRequest()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = StartDataGetRequest(hInstance, hWnd);
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::StartProcessingPostRequests()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = StartProcessingPostRequests(hInstance, hWnd);
	return hr;
}
HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeComputationalTask(UINT taskId)
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	return hr;
}

HRESULT STDMETHODCALLTYPE DirectXGPUDigitalLabCoreModule::InitializeLocalTransactionServer()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	hr = InitializeLocalTransactionServer(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeSimulationSystem()
{
	HRESULT hr = S_OK;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	GetClientRect(mainWindow, &rc);
	DirectXGPUDigitalLabCoreModule* pKernelObject = nullptr;
	hr = DirectXGPUDigitalLabCoreModule::CreateInstance(hInstance, mainWindow, mainWindow, &pKernelObject);

	if (SUCCEEDED(hr))
	{
		hr = pKernelObject->InitializeGPUDigitalLabCore(hInstance, mainWindow);
	}
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::StartDataGetRequest(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::StartDataPostRequestLoop(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}





void DirectXGPUDigitalLabCoreModule::InitializeGPUDigitalLabServiceObject(HINSTANCE hInstance, HWND hWnd)
{
	
	
}


int InstallService()
{
	HRESULT hr = S_OK;
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

	LPWSTR pFileName = (LPWSTR)L"C:\\Вычислительное Ядро 2.0\\Вычислительное Ядро\\Kernel Final\\Debug\\DirectXGPUDDigitalLabProcessingKernelServer.exe";

	if (!hSCManager) {
		printf("Error: Can't open Service Control Manager");
		hr = E_FAIL;
		return hr;


		SC_HANDLE hService = CreateService(hSCManager,
			GPUDigtialLabServiceKernel,
			GPUDigtialLabServiceKernel,
			SERVICE_ALL_ACCESS,
			SERVICE_WIN32_OWN_PROCESS,
			SERVICE_DEMAND_START,
			SERVICE_ERROR_NORMAL,
			pFileName,
			NULL, NULL, NULL, NULL, NULL
			);

		if (!hService) {
			int err = GetLastError();
			switch (err) {
			case ERROR_ACCESS_DENIED:
				printf("Error: ERROR_ACCESS_DENIED");
				break;
			case ERROR_CIRCULAR_DEPENDENCY:
				printf("Error: ERROR_CIRCULAR_DEPENDENCY");
				break;
			case ERROR_DUPLICATE_SERVICE_NAME:
				printf("Error: ERROR_DUPLICATE_SERVICE_NAME");
				break;
			case ERROR_INVALID_HANDLE:
				printf("Error: ERROR_INVALID_HANDLE");
				break;
			case ERROR_INVALID_NAME:
				printf("Error: ERROR_INVALID_NAME");
				break;
			case ERROR_INVALID_PARAMETER:
				printf("Error: ERROR_INVALID_PARAMETER");
				break;
			case ERROR_INVALID_SERVICE_ACCOUNT:
				printf("Error: ERROR_INVALID_SERVICE_ACCOUNT");
				break;
			case ERROR_SERVICE_EXISTS:
				printf("Error: ERROR_SERVICE_EXISTS");
				break;
			default:
				printf("Error: Undefined");
			}
			CloseServiceHandle(hSCManager);
			return -1;
		}
		CloseServiceHandle(hService);

		CloseServiceHandle(hSCManager);
		printf("Success install service!");
		return 1;
	}
}

int RemoveService()
{
	int result = 0;
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL,
		SC_MANAGER_ALL_ACCESS);

	if (!hSCManager)
	{
		printf("Error: Cant Open Service Control Manager");
		result = -1;
		return result;
	}

	SC_HANDLE hService = OpenService(hSCManager, GPUDigtialLabServiceKernel,
		SERVICE_STOP | DELETE);

	if (!hService)
	{
		printf("Error can't remove service");
		CloseServiceHandle(hSCManager);
		result = -1;
		return result;
	}

	DeleteService(hService);
	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	printf("Success remove Service");
	return result;

}

int StartServiceInstance()
{
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	SC_HANDLE hService = OpenService(hSCManager, GPUDigtialLabServiceKernel, SERVICE_START);
	if (!StartService(hService, 0, NULL)) {
		CloseServiceHandle(hSCManager);
		printf("Error: Can't start service");
		return -1;
	}

	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	return 0;
}




void DirectXGPUDigitalLabCoreModule::ControlAgentServer(HINSTANCE hInstance, HWND hWnd)
{
	HANDLE pHandle = 0;
	DWORD dwThread = 0;

	pHandle = CreateThread(
		NULL,                   // default security attributes
		0,                      // use default stack size  
		(LPTHREAD_START_ROUTINE)ControlWindowsService,       // thread function name
		(LPVOID)L"GPUDIGITALLAB AGENT SERVER MANAGEMENT SYSTEM",          // argument to thread function 
		0,                      // use default creation flags 
		&dwThread);   // returns the thread identifier 


	// Check the return value for success.
	// If CreateThread fails, terminate execution. 
	// This will automatically clean up threads and memory. 

	if (pHandle == NULL)
	{
		printf("CreateThread");
		ExitProcess(3);
	}
 // End of main thread creation loop.

// Wait until all threads have terminated.

WaitForSingleObject(pHandle,  INFINITE);


}

HRESULT DirectXGPUDigitalLabCoreModule::StartLocalServiceControlNetwork(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	HANDLE pAgentServiceHandle = INVALID_HANDLE_VALUE;
	HANDLE  pDataEngineProcessingHandle = INVALID_HANDLE_VALUE;
	HANDLE pGraphicsEngineHandle = INVALID_HANDLE_VALUE;
	PMYDATA pDataArray[3];
	TCHAR szMessage[256];
	DWORD dwTemp, i;
	HANDLE hThreads[3];
	LPCSTR pServiceNames[3];
	DWORD   dwThreadIdArray[MAX_THREADS];
	hThreads[0] = pAgentServiceHandle;
	hThreads[1] = pDataEngineProcessingHandle;
	hThreads[2] = pGraphicsEngineHandle;
	DWORD dwCounter = 0;

	pServiceNames[0] = (LPCSTR)L"GPUDIGITALLAB AGENT SERVER MANAGEMENT SYSTEM";
	pServiceNames[1] = (LPCSTR)L"GPUDIGITALLAB KNOWLEDGE DATABASE PROCESSING SERVICE";
	pServiceNames[2] = (LPCSTR)L"Cистема Рендеринга и Трехмерной Анимации Imagine3D";
	

	CONST HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	CONST HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
	if (NULL == hMutex) {
		printf("Failed to create mutex.\r\n");
	}

	for (int i = 0; i < MAX_THREADS; i++)
	{
		// Allocate memory for thread data.

		pDataArray[i] = (PMYDATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
			sizeof(MYDATA));

		if (pDataArray[i] == NULL)
		{
			// If the array allocation fails, the system is out of memory
			// so there is no point in trying to print an error message.
			// Just terminate execution.
			ExitProcess(2);
		}

		// Generate unique data for each thread to work with.

		pDataArray[i]->pKernelHandle = INVALID_HANDLE_VALUE;
		pDataArray[i]->pServiceName = pServiceNames[i];

		// Create the thread to begin execution on its own.

		hThreads[i] = CreateThread(
			NULL,                   // default security attributes
			0,                      // use default stack size  
			(LPTHREAD_START_ROUTINE)ControlWindowsService,       // thread function name
			(LPVOID)pDataArray[i]->pServiceName,          // argument to thread function 
			0,                      // use default creation flags 
			&dwThreadIdArray[i]);   // returns the thread identifier 


		// Check the return value for success.
		// If CreateThread fails, terminate execution. 
		// This will automatically clean up threads and memory. 

		if (hThreads[i] == NULL)
		{
			printf("CreateThread");
			ExitProcess(3);
		}
	} // End of main thread creation loop.

	// Wait until all threads have terminated.

	WaitForMultipleObjects(MAX_THREADS, hThreads, TRUE, INFINITE);

	WaitForMultipleObjects(3, hThreads, TRUE, INFINITE);
	wsprintf(szMessage, TEXT("Counter = %d\r\n"), dwCounter);
	WriteConsole(hStdOut, szMessage, lstrlen(szMessage), &dwTemp, NULL);
}



		
DWORD WINAPI ControlWindowsService (LPVOID pServiceName)
{
	HRESULT hr = S_OK;
	bool bRet = true;
	bool start = true;
	int result = 0;
	TCHAR szServiceName[512];
	// open the service control manager
	SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (hSCM == NULL)
	{
		//Error: could not open SCManager
		result = -1;
		return result;
		
	}

	// open the service
	SC_HANDLE hService = OpenService(hSCM, (LPCWSTR)pServiceName, SERVICE_ALL_ACCESS);
	if (hService == NULL)
	{
		//Error: could not open service
		result = -1;
		return result;
	}

	SERVICE_STATUS ss;
	memset(&ss, 0, sizeof(ss));
	BOOL b = QueryServiceStatus(hService, &ss);

	if (start && ss.dwCurrentState == SERVICE_STOPPED)
	{

		// start the service
		b = StartService(hService, 0, NULL);
		if (!b)
		{
			//Error: could not start service
			result = -1;
			return result;

		}
		bRet = true;
	}
	else if (!start && ss.dwCurrentState == SERVICE_RUNNING)
	{

		b = ControlService(hService, SERVICE_CONTROL_STOP, &ss);
		if (!b)
		{
			//Error: could not stop service	
			result = -1;
			return result;

		}
		bRet = true;
	}

	// close the service handle
	CloseServiceHandle(hService);

	// close the service control manager handle
	CloseServiceHandle(hSCM);
	return result;
}





void DirectXGPUDigitalLabCoreModule::OpenNewLogFile(LPCSTR fName)
{
	fstream pFileObject;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	pFileObject.open(fName);
	pFileObject << "First File Record" << endl;
	hFile = CreateFile((LPCWSTR)fName,                // name of the write
		GENERIC_WRITE,          // open for writing
		0,                      // do not share
		NULL,                   // default security
		CREATE_NEW,             // create new file only
		FILE_ATTRIBUTE_NORMAL,  // normal file
		NULL);                  // no attr. template
	_tprintf(TEXT("Writing %d bytes to %s.\n"), 8, fName);


}


HRESULT DirectXGPUDigitalLabCoreModule::ReadDataFromPipeMethod(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	m_pConnectedApplicationLauncher->ReadDataFromPipe(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::WriteDataToPipeMethod(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	m_pConnectedApplicationLauncher->SendDataToPipe(hInstance, hWnd);
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::TerminateNamedPipe(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	m_pConnectedApplicationLauncher->TerminatePipe(hInstance, hWnd);
	return hr;
}



bool DirectXGPUDigitalLabCoreModule::IsRunAsAdministrator()
{
	BOOL fIsRunAsAdmin = FALSE;
	DWORD dwError = ERROR_SUCCESS;
	PSID pAdministratorsGroup = NULL;

	// Allocate and initialize a SID of the administrators group.
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
	if (!AllocateAndInitializeSid(
		&NtAuthority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 0, 0, 0, 0, 0,
		&pAdministratorsGroup))
	{
		dwError = GetLastError();
		if (pAdministratorsGroup)
		{
			FreeSid(pAdministratorsGroup);
			pAdministratorsGroup = NULL;
		}

		// Throw the error if something failed in the function.
		if (ERROR_SUCCESS != dwError)
		{
			throw dwError;
		}

		return fIsRunAsAdmin;
	}

	// Determine whether the SID of administrators group is enabled in 
	// the primary access token of the process.
	if (!CheckTokenMembership(NULL, pAdministratorsGroup, &fIsRunAsAdmin))
	{
		dwError = GetLastError();
		if (pAdministratorsGroup)
		{
			FreeSid(pAdministratorsGroup);
			pAdministratorsGroup = NULL;
		}

		// Throw the error if something failed in the function.
		if (ERROR_SUCCESS != dwError)
		{
			throw dwError;
		}

		return fIsRunAsAdmin;
	}
	// Centralized cleanup for all allocated resources.

	return fIsRunAsAdmin;
}





void DirectXGPUDigitalLabCoreModule::ElevateProcessStatus(HINSTANCE hInstance, HWND hWnd)
{
	DWORD dwErrr = 0;
	BOOL fIsRunAsAdmin;
	try
	{
		fIsRunAsAdmin = IsRunAsAdministrator();
	}
	catch (DWORD dwError)
	{

		ReportError(L"IsRunAsAdmin");
	}

	// Elevate the process if it is not run as administrator.
	if (!fIsRunAsAdmin)
	{
		wchar_t szPath[MAX_PATH];
		if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)))
		{
			// Launch itself as administrator.
			SHELLEXECUTEINFO sei = { sizeof(sei) };
			sei.lpVerb = L"runas";
			sei.lpFile = szPath;
			sei.hwnd = hWnd;
			sei.nShow = SW_NORMAL;

			if (!ShellExecuteEx(&sei))
			{
				DWORD dwError = GetLastError();
				if (dwError == ERROR_CANCELLED)
				{
					// The user refused the elevation.
					// Do nothing ...
				}
			}
			else
			{
				return;
			}
		}
	}

}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeGPUDigitalLabCore(HINSTANCE hInstance, HWND hWnd)
{




	HRESULT hr = S_OK;
	BOOL result = TRUE;
	HANDLE pInputHandle = nullptr;
	HANDLE pOutputHandle = nullptr;
	ElevateProcessStatus(hInstance, hWnd);

	HMODULE hModuleObject = LoadLibrary(L"C:\DirectXGPUDigitalLabSoftwareKernel 3.0\DirectXGPUDigitalLabSoftware\Debug\DirectXGPUDigtialLabSoftware.dll");

    RedirectIOToConsole();
	int pVar = 0;

	printf("Writing to the txt file...");



	try
	{

		cout << "Let Us try To connect our Kernel Application to Kernel ATL Server" << endl;

		int iVar = 0;
		printf("First We Open our DirectX Engine");
		cout << "First We Open our DirectX Engine" << endl;
	
		DirectXComputeShaderManagementClass* m_pGPUComputeShaderManagerClass = new DirectXComputeShaderManagementClass(hInstance, hWnd);
		m_pStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
		pAlgorithmManagerInternal = m_pStandardAlgorithmExecutor;

		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);

		if (SUCCEEDED(hr))
		{
			hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		}
		if (SUCCEEDED(hr))
		{
			hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
		}
		Direct2DImageProcessingManager* pImageProcessingManager = new Direct2DImageProcessingManager(hInstance, hWnd);
		hr = pImageProcessingManager->CreateDeviceIndependentResources(hInstance, hWnd);

		if (SUCCEEDED(hr))
		{
			hr = pImageProcessingManager->CreateDeviceResources(hInstance, hWnd);
		}

	


		cout << "Our Next Step is To Start Algoritm Executor\n" << endl;
		hr = m_pGPUComputeShaderManagerClass->InitializeD3D11Device(hWnd, 0);


	




		DirectXTexturingManager* md3dterrainClass = new DirectXTexturingManager(hInstance, hWnd);
		hr = md3dterrainClass->Initialize(hInstance, hWnd);





	

		if (FAILED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Unable to Initialize  Direct3D11", (LPCSTR)"Message", 0);
		}

		md3dterrainClass->Render();


	

		DirectXConnectedApplicationLauncher* pConnectedApplicationLauncher = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
		hr = pConnectedApplicationLauncher->InitializeDirectAndAlgorithmExecutor(hInstance, hWnd, md2dmanager,
			m_pStandardAlgorithmExecutor);

		cout << "We have a class to manage connected apps\n" << endl;
	



		m_pGPUNetworkModule = new DirectXNetworkPacketManagementClass(hInstance, hWnd, md2dmanager,
        m_pStandardAlgorithmExecutor);
			cout << "We have initialized System Task Management Class Class\n" << endl;
		m_pConnectedApplicationLauncher = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
		cout << "We have created connection application management class\n" << endl;

		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
		
		
		hr = DirectXVideoAnalyticsManagementEngineClass::CreateInstance(hInstance, hWnd, hWnd, &pVideoAnalyticsManagementClass);

	
	}

	catch (std::bad_alloc ba)
	{
		std::cerr << "bad_alloc caught: " << ba.what() << '\n';
	}
	return hr;

}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeConnectionApplicationServerProcessor(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXConnectedApplicationLauncher* pConnectionApplicationLauncher = m_pConnectedApplicationLauncher;
	if (pConnectionApplicationLauncher == nullptr)
	{	
		pConnectionApplicationLauncher = new DirectXConnectedApplicationLauncher(hInstance, hWnd);
		hr = pConnectionApplicationLauncher->InitializeConnectedApplicationDataLoop(hInstance, hWnd);
	}
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::DownloadDataFromInternetServiceObject(HINSTANCE hInstance, HWND hWnd, LPCSTR webAddress)
{
	HRESULT hr = S_OK;
	DirectXNetworkPacketManagementClass* pNetworkPacketManager = m_pGPUNetworkModule;
	if (!pNetworkPacketManager)
	{
		pNetworkPacketManager = new DirectXNetworkPacketManagementClass(hInstance, hWnd);
	}
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeInternalTCPServer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	int pPortNumber = 0;
	cout << "Enter the Port Number for your Server" << endl;
	cin >> pPortNumber;
	DirectXNetworkPacketManagementClass* pNetworkPacketManager = m_pGPUNetworkModule;
	if (!pNetworkPacketManager)
	{
		pNetworkPacketManager = new DirectXNetworkPacketManagementClass(hInstance, hWnd);
	}
	hr = pNetworkPacketManager->InitializeServerSocket(hInstance, hWnd, L"192.168.1.1", L"27035");

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::OpenWebBrowserApplication(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	hr = m_pCloudServerConnectionManagerClass->OpenWebBrowser(hInstance, hWnd);

	return hr;
}
HRESULT DirectXGPUDigitalLabCoreModule::InitializeInternelAccess(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	hr = m_pCloudServerConnectionManagerClass->InitializeInternetAccess(hInstance, hWnd);

	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeHTTPAccess(HINSTANCE hInstance, HWND hWnd, LPCSTR defaultUrl)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}

	hr = m_pCloudServerConnectionManagerClass->InitializeInternetAccess(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerAsyncronousMode(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	WIN32_FIND_DATA ffd;
	WIN32_FIND_DATA ffdFiles;

	LARGE_INTEGER filesize;
	TCHAR szDir[MAX_PATH];
	size_t length_of_arg;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError = 0;

	LPWSTR pDirectory = L"C:\\RobotData\\DownloadedVideos\\Videos";
	LPWSTR pFileNameEight = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pFileNameTwo = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";
	LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
	LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";


	vector<WCHAR*> pFileNames = vector<WCHAR*>();


	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pXPosition = monitorWidth / 2;
	int pYPosition = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;

	int pWaitingIntervalInSeconds = 2;

	cout << "X Position for Image Clip = " << pXPosition << endl;
	cout << "Y Position for Image Clip = " << pYPosition << endl;
	cout << "Image Width For the Clip Used = " << pImageWidth << endl;
	cout << "Image Height For the Clip Used = " << pImageHeight << endl;
	cout << "Waiting Interval = " << pWaitingIntervalInSeconds << endl;





	// If the directory is not specified as a command-line argument,
	// print usage.


	// Check that the input path plus 3 is not longer than MAX_PATH.
	// Three characters are for the "\*" plus NULL appended below.

	StringCchLength(pFileNameEight, MAX_PATH, &length_of_arg);

	if (length_of_arg > (MAX_PATH - 3))
	{
		_tprintf(TEXT("\nDirectory path is too long.\n"));
		hr = E_INVALIDARG;
		return hr;
	}

	_tprintf(TEXT("\nTarget directory is %s\n\n"), pDirectory);

	// Prepare string for use with FindFile functions.  First, copy the
	// string to a buffer, then append '\*' to the directory name.


	// Find the first file in the directory.

	hFind = FindFirstFile(pDirectory, &ffd);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
		return dwError;
	}

	// List all the files in the directory with some info about them.

	do
	{
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);
			hFind = FindFirstFile(pDirectory, &ffdFiles);
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);

		}
		else
		{
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);
		}

		BOOL pResult = PathFileExists(pFileNameEight);

		if (pResult == TRUE)
		{
			hr = SimulateRobotCleanerSystemForVideoFromFTPAutomatic(hInstance,
				hWnd,
				pFileNameEight,
				pFileNameTwo,
				pXPosition,
				pYPosition,
				pImageWidth,
				pImageHeight,
				pWaitingIntervalInSeconds);
			break;
		}


	} while (FindNextFile(hFind, &ffd) != 0);

	dwError = GetLastError();
	if (dwError != ERROR_NO_MORE_FILES)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
	}
	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, L"C\\RobotData\\RobotCleanerAsynchronousDemo.png");

	FindClose(hFind);
	return dwError;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerAsyncronousModeSkypeMotionDetection(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	cout << "We Plan TO Launch the Timer for Our Robot Cleaner" << endl;
	auto start = high_resolution_clock::now();


	WIN32_FIND_DATA ffd;
	WIN32_FIND_DATA ffdFiles;

	LARGE_INTEGER filesize;
	TCHAR szDir[MAX_PATH];
	size_t  length_of_arg;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError = 0;
	int pWaitingIntervalInSeconds = 0;

	LPWSTR pDirectory = L"C:\\RobotData\\Skype\\Videos";
	LPWSTR pFileNameEight = L"C:\\RobotData\\Skype\\Videos\\VideoFTP1.mp4";
	LPWSTR pFileNameTwo = L"C:\\RobotData\\Skype\\Videos\\VideoFTP2.mp4";
	LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
	LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";


	vector<WCHAR*> pFileNames = vector<WCHAR*>();
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };


	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pXPosition = monitorWidth / 2;
	int pYPosition = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;




	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	cout << "X Position for Image Clip = " << pXPosition << endl;
	cout << "Y Position for Image Clip = " << pYPosition << endl;
	cout << "Image Width For the Clip Used = " << pImageWidth << endl;
	cout << "Image Height For the Clip Used = " << pImageHeight << endl;
	cout << "Waiting Interval = " << pWaitingIntervalInSeconds << endl;





	// If the directory is not specified as a command-line argument,
	// print usage.


	// Check that the input path plus 3 is not longer than MAX_PATH.
	// Three characters are for the "\*" plus NULL appended below.

	StringCchLength(pFileNameEight, MAX_PATH, &length_of_arg);

	if (length_of_arg > (MAX_PATH - 3))
	{
		_tprintf(TEXT("\nDirectory path is too long.\n"));
		hr = E_INVALIDARG;
		return hr;
	}

	_tprintf(TEXT("\nTarget directory is %s\n\n"), pDirectory);

	// Prepare string for use with FindFile functions.  First, copy the
	// string to a buffer, then append '\*' to the directory name.


	// Find the first file in the directory.

	hFind = FindFirstFile(pDirectory, &ffd);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
		return dwError;
	}

	// List all the files in the directory with some info about them.

	do
	{
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);
			hFind = FindFirstFile(pDirectory, &ffdFiles);
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);

		}
		else
		{
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);
		}

		BOOL pResult = PathFileExists(pFileNameEight);

		if (pResult == TRUE)
		{

			HRESULT hr = S_OK;

			WIN32_FIND_DATA ffd;
			WIN32_FIND_DATA ffdFiles;

			LARGE_INTEGER filesize;
			TCHAR szDir[MAX_PATH];
			size_t  length_of_arg;
			HANDLE hFind = INVALID_HANDLE_VALUE;
			DWORD dwError = 0;

			LPWSTR pDirectory = L"C:\\RobotData\\Skype\\Videos";
			LPWSTR pFileNameEight = L"C:\\RobotData\\Skype\\Videos\\VideoFTP1.mp4";
			LPWSTR pFileNameTwo = L"C:\\RobotData\\Skype\\Videos\\VideoFTP2.mp4";
			LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
			LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";
			int pXPosition = 601;
			int pYPosition = 657;

			vector<WCHAR*> pFileNames = vector<WCHAR*>();

			vector<PixelObject> pRGBImageEight = vector<PixelObject>();
			vector<PixelObject> pRGBImageTwo = vector<PixelObject>();
			vector<MotionPixelObjectRGB> pMotionOutpuArrayRGB = vector<MotionPixelObjectRGB>();

			fstream imageSegmentationDataFile;
			imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerSkypeFolderWithCrtiticalSections.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
			imageSegmentationDataFile.clear();



			HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
			MONITORINFO info;
			info.cbSize = sizeof(MONITORINFO);
			GetMonitorInfo(monitor, &info);
			int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
			int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
			int pCentreX = monitorWidth / 2;
			int pCentreY = monitorHeight / 2;
			int pImageWidth = 10;
			int pImageHeight = 10;

			cout << "Your Monitor Width = " << monitorWidth << endl;
			cout << "Your Monitor Heigh = " << monitorHeight << endl;
			cout << "Centre Of The Monitor X = " << pCentreX << endl;
			cout << "Centre of the Monitor Y" << pCentreY << endl;



			int pWaitingIntervalInSeconds = 0;

			cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
			cin >> pWaitingIntervalInSeconds;

			cout << "X Position for Image Clip = " << pXPosition << endl;
			cout << "Y Position for Image Clip = " << pYPosition << endl;
			cout << "Image Width For the Clip Used = " << pImageWidth << endl;
			cout << "Image Height For the Clip Used = " << pImageHeight << endl;
			cout << "Waiting Interval = " << pWaitingIntervalInSeconds << endl;


			// If the directory is not specified as a command-line argument,
			// print usage.


			// Check that the input path plus 3 is not longer than MAX_PATH.
			// Three characters are for the "\*" plus NULL appended below.

			StringCchLength(pFileNameEight, MAX_PATH, &length_of_arg);

			if (length_of_arg > (MAX_PATH - 3))
			{
				_tprintf(TEXT("\nDirectory path is too long.\n"));
				hr = E_INVALIDARG;
				return hr;
			}

			_tprintf(TEXT("\nTarget directory is %s\n\n"), pDirectory);

			// Prepare string for use with FindFile functions.  First, copy the
			// string to a buffer, then append '\*' to the directory name.


			// Find the first file in the directory.

			hFind = FindFirstFile(pDirectory, &ffd);

			if (INVALID_HANDLE_VALUE == hFind)
			{
				DisplayErrorBox(TEXT("FindFirstFile"));
				return dwError;
			}

			// List all the files in the directory with some info about them.

			do
			{
				if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);
					hFind = FindFirstFile(pDirectory, &ffdFiles);
					filesize.LowPart = ffd.nFileSizeLow;
					filesize.HighPart = ffd.nFileSizeHigh;
					_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
					LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
					cout << "Current File Name: " << ffd.cFileName << endl;
					cout << "File Extention = " << pFileExtension << endl;


					pFileNames.push_back(ffd.cFileName);

				}
				else
				{
					filesize.LowPart = ffd.nFileSizeLow;
					filesize.HighPart = ffd.nFileSizeHigh;
					_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
					LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
					cout << "Current File Name: " << ffd.cFileName << endl;
					cout << "File Extention = " << pFileExtension << endl;


					pFileNames.push_back(ffd.cFileName);
				}

				BOOL pResult = PathFileExists(pFileNameEight);

				if (pResult == TRUE)
				{


					int pAmountOfIdenticalPixels = 0;
					int pAmountOfDifferentPixels = 0;

					float pImageOneIntensitySumRedVar = 0.0f;
					float pImageOneIntensitySumGreenVar = 0.0f;
					float pImageOneIntensitySumBlueVar = 0.0f;
					float pImageOneIntensityAverageRedVar = 0.0f;
					float pImageOneIntensityAverageGreenVar = 0.0f;
					float pImageOneIntensityAverageBlueVar = 0.0f;

					float pImageTwoIntensitySumRedVar = 0.0f;
					float pImageTwoIntensitySumGreenVar = 0.0f;
					float pImageTwoIntensitySumBlueVar = 0.0f;
					float pImageTwoIntensityAverageRedVar = 0.0f;
					float pImageTwoIntensityAverageGreenVar = 0.0f;
					float pImageTwoIntensityAverageBlueVar = 0.0f;

					float pOutputArrayIntensitySumRedVar = 0.0f;
					float pOutputArrayIntensitySumGreenVar = 0.0f;
					float pOutputArrayIntensitySumBlueVar = 0.0f;
					float pOutputArrayIntensityAverageRedVar = 0.0f;
					float pOutputArrayIntensityAverageGreenVar = 0.0f;
					float pOutputArrayIntensityAverageBlueVar = 0.0f;

					float pIdenticalArrayIntensitySumRedVar = 0.0f;
					float pIdenticalArrayIntensitySumGreenVar = 0.0f;
					float pIdenticalArrayIntensitySumBlueVar = 0.0f;
					float pIdenticalArrayIntensityAverageRedVar = 0.0f;
					float pIdenticalArrayIntensityAverageGreenVar = 0.0f;
					float pIdenticalArrayIntensityAverageBlueVar = 0.0f;

					float pDifferentArrayIntensitySumRedVar = 0.0f;
					float pDifferentArrayIntensitySumGreenVar = 0.0f;
					float pDifferentArrayIntensitySumBlueVar = 0.0f;
					float pDifferentArrayIntensityAverageRedVar = 0.0f;
					float pDifferentArrayIntensityAverageGreenVar = 0.0f;


					hr = SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPIMotionDetected(hInstance,
						hWnd,
						pFileNameEight,
						pFileNameTwo,
						pCentreX,
						pCentreY,
						pImageWidth,
						pImageHeight,
						pWaitingIntervalInSeconds,
						&pRGBImageEight,
						&pRGBImageTwo,
						&pMotionOutpuArrayRGB);


				
					cout << "RGB Array Eight" << endl;
					int pIndex = 0;

					for (PixelObject pixelObject : pRGBImageEight)
					{
						cout << "Index: " << pIndex << endl;
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Index: " << pIndex << endl;
						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
						pIndex++;


					}

					cout << "RGB Array Two" << endl;
					pIndex = 0;

					for (PixelObject pixelObject : pRGBImageTwo)
					{
						cout << "Index: " << pIndex << endl;
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						imageSegmentationDataFile << "Index: " << pIndex << endl;
						imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
						imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
						imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
						imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;
						pIndex++;



					}


					cout << "Printing the Output Buffer Of Comparison Operation" << endl;
					imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

					int pIntensitySummation = 0;
					pIndex = 0;
					cout << "Printing out the Output the Experiment" << endl;


					for (MotionPixelObjectRGB pOutputPixelValue : pMotionOutpuArrayRGB)
					{
						cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
						cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
						cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
						cout << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
						cout << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
						cout << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
						cout << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
						cout << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
						cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
						cout << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
						cout << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
						cout << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
						cout << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;

						imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
						imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
						imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
						imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.rValue0 << endl;
						imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.rValue1 << endl;
						imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.gValue0 << endl;
						imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.gValue1 << endl;
						imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.bValue0 << endl;
						imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.bValue1 << endl;
						imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pRedComponentDifference << endl;
						imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pGreenComponentDifference << endl;
						imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pBlueComponentDifference << endl;
						imageSegmentationDataFile << "Is Motion Detected =" << pOutputPixelValue.pOverallMotionDetected << endl;


					}


					imageSegmentationDataFile.close();



					break;
				}


			} while (FindNextFile(hFind, &ffd) != 0);

			dwError = GetLastError();
			if (dwError != ERROR_NO_MORE_FILES)
			{
				DisplayErrorBox(TEXT("FindFirstFile"));
			}

			FindClose(hFind);
			return dwError;



			
		
			break;
		}


	} while (FindNextFile(hFind, &ffd) != 0);

	dwError = GetLastError();
	if (dwError != ERROR_NO_MORE_FILES)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
	}

	FindClose(hFind);

	auto end = high_resolution_clock::now();
	auto duration = duration_cast<seconds>(end - start);

	cout << "RobotCleaner Skype Demo Execution Demo: " << duration.count() << endl;

	return dwError;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerAsyncronousModeSkypeDemo(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	cout << "We Plan TO Launch the Timer for Our Robot Cleaner" << endl;
	auto start = high_resolution_clock::now();


	WIN32_FIND_DATA ffd;
	WIN32_FIND_DATA ffdFiles;

	LARGE_INTEGER filesize;
	TCHAR szDir[MAX_PATH];
	size_t length_of_arg;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError = 0;
	int pWaitingIntervalInSeconds = 0;

	LPWSTR pDirectory = L"C:\\RobotData\\Skype\\Videos";
	LPWSTR pFileNameEight = L"C:\\RobotData\\Skype\\Videos\\VideoFTP1.mp4";
	LPWSTR pFileNameTwo = L"C:\\RobotData\\Skype\\Videos\\VideoFTP2.mp4";
	LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
	LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";


	vector<WCHAR*> pFileNames = vector<WCHAR*>();
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };


	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pXPosition = monitorWidth / 2;
	int pYPosition = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;

	vector<PixelObject> pPixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pPixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectImageEightGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pPixelObjectImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> pOutputPixelDataBuffer = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pIdenticalPixelDataBuffer = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentPixelDataBuffer = vector<PixelObjectGrayScale>();




	
	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	cout << "X Position for Image Clip = " << pXPosition << endl;
	cout << "Y Position for Image Clip = " << pYPosition << endl;
	cout << "Image Width For the Clip Used = " << pImageWidth << endl;
	cout << "Image Height For the Clip Used = " << pImageHeight << endl;
	cout << "Waiting Interval = " << pWaitingIntervalInSeconds << endl;





	// If the directory is not specified as a command-line argument,
	// print usage.


	// Check that the input path plus 3 is not longer than MAX_PATH.
	// Three characters are for the "\*" plus NULL appended below.

	StringCchLength(pFileNameEight, MAX_PATH, &length_of_arg);

	if (length_of_arg > (MAX_PATH - 3))
	{
		_tprintf(TEXT("\nDirectory path is too long.\n"));
		hr = E_INVALIDARG;
		return hr;
	}

	_tprintf(TEXT("\nTarget directory is %s\n\n"), pDirectory);

	// Prepare string for use with FindFile functions.  First, copy the
	// string to a buffer, then append '\*' to the directory name.


	// Find the first file in the directory.

	hFind = FindFirstFile(pDirectory, &ffd);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
		return dwError;
	}

	// List all the files in the directory with some info about them.

	do
	{
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);
			hFind = FindFirstFile(pDirectory, &ffdFiles);
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);

		}
		else
		{
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl; 
			cout << "File Extention = " << pFileExtension << endl;
			

			pFileNames.push_back(ffd.cFileName);
		}

		BOOL pResult = PathFileExists(pFileNameEight);

		if (pResult == TRUE)
		{
			hr = SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPI(hInstance,
				hWnd,
				pFileNameEight,
				pFileNameTwo,
				pXPosition,
				pYPosition,
				pImageWidth,
				pImageHeight,
				pWaitingIntervalInSeconds,
				&pPixelObjectImageEight,
				&pPixelObjectImageTwo,
				&pPixelObjectImageEightGrayScale,
				&pPixelObjectImageTwoGrayScale,
				&pOutputPixelDataBuffer,
				&pIdenticalPixelDataBuffer,
				&pDifferentPixelDataBuffer);

			break;
		}


	} while (FindNextFile(hFind, &ffd) != 0);

	dwError = GetLastError();
	if (dwError != ERROR_NO_MORE_FILES)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
	}

	FindClose(hFind);

	auto end = high_resolution_clock::now();
	auto duration = duration_cast<seconds>(end - start);

	cout << "RobotCleaner Skype Demo Execution Demo: " << duration.count() << endl;

	return dwError;
}


HRESULT DirectXGPUDigitalLabCoreModule::ClearTheScreenBuffer(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);
	return hr;

}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerAsyncronousModeDemo(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	WIN32_FIND_DATA ffd;
	WIN32_FIND_DATA ffdFiles;

	LARGE_INTEGER filesize;
	TCHAR szDir[MAX_PATH];	
	size_t length_of_arg;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError = 0;

	LPWSTR pDirectory = L"C:\\RobotData\\DownloadedVideos\\";
	LPWSTR pFileNameEight = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pFileNameTwo = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";
	LPWSTR pFileNameSingleEight = L"VideoFTP1.mp4";
	LPWSTR pFileNameSingleTwo = L"VideoFTP2.mp4";

	vector<WCHAR*> pFileNames = vector<WCHAR*>();


	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	int pXPosition = monitorWidth / 2;
	int pYPosition = monitorHeight / 2;
	int pImageWidth = 10;
	int pImageHeight = 10;

	int pWaitingIntervalInSeconds = 0;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;


	cout << "X Position for Image Clip = " << pXPosition << endl;
	cout << "Y Position for Image Clip = " << pYPosition << endl;
	cout << "Image Width For the Clip Used = " << pImageWidth << endl;
	cout << "Image Height For the Clip Used = " << pImageHeight << endl;
	cout << "Waiting Interval = " << pWaitingIntervalInSeconds << endl;


	vector<PixelObject> pPixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pPixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> pPixelObjectImageEightGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pPixelObjectImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> pOutputPixelDataBuffer = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pIdenticalPixelDataBuffer = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentPixelDataBuffer = vector<PixelObjectGrayScale>();





	// If the directory is not specified as a command-line argument,
	// print usage.


	// Check that the input path plus 3 is not longer than MAX_PATH.
	// Three characters are for the "\*" plus NULL appended below.

	StringCchLength(pFileNameEight, MAX_PATH, &length_of_arg);

	if (length_of_arg > (MAX_PATH - 3))
	{
		_tprintf(TEXT("\nDirectory path is too long.\n"));
		hr = E_INVALIDARG;
		return hr;
	}

	_tprintf(TEXT("\nTarget directory is %s\n\n"), pFileNameEight);

	// Prepare string for use with FindFile functions.  First, copy the
	// string to a buffer, then append '\*' to the directory name.




	// Find the first file in the directory.

	hFind = FindFirstFile(pFileNameEight, &ffd);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
		return dwError;
	}

	// List all the files in the directory with some info about them.

	do
	{

		SYSTEMTIME st, lt;
		GetSystemTime(&st);
		GetLocalTime(&lt);
		printf("The system time is: %02d:%02d:%02d\n", st.wHour, st.wMinute, st.wSecond);
		printf(" The local time is: %02d:%02d:%02d\n", lt.wHour, lt.wMinute, lt.wSecond);


		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);


			_tprintf(TEXT("  %s   <DIR>\n"), ffd.cFileName);
			hFind = FindFirstFile(ffd.cFileName, &ffdFiles);
			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			pFileNames.push_back(ffd.cFileName);
		}
		else
		{

			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			LPWSTR pFileExtension = PathFindExtension(ffd.cFileName);
			cout << "Current File Name: " << ffd.cFileName << endl;
			cout << "File Extention = " << pFileExtension << endl;


			filesize.LowPart = ffd.nFileSizeLow;
			filesize.HighPart = ffd.nFileSizeHigh;
			_tprintf(TEXT("  %s   %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
			cout << "Current File Name: " << ffd.cFileName << endl;
			pFileNames.push_back(ffd.cFileName);

		}

		BOOL pResult = PathFileExists(pFileNameEight);

		if (pResult == TRUE)
		{
			hr = SimulateRobotCleanerSystemForVideoFromFTPAutomaticAPI(hInstance,
				hWnd,
				pFileNameEight,
				pFileNameTwo,
				pXPosition,
				pYPosition,
				pImageWidth,
				pImageHeight,
				pWaitingIntervalInSeconds,
				&pPixelObjectImageEight,
				&pPixelObjectImageTwo,
				&pPixelObjectImageEightGrayScale,
				&pPixelObjectImageTwoGrayScale,
				&pOutputPixelDataBuffer,
				&pIdenticalPixelDataBuffer,
				&pDifferentPixelDataBuffer);

			break;
		}


	} while (FindNextFile(hFind, &ffd) != 0);

	dwError = GetLastError();
	if (dwError != ERROR_NO_MORE_FILES)
	{
		DisplayErrorBox(TEXT("FindFirstFile"));
	}

	FindClose(hFind);
	return dwError;
}




void DisplayErrorBox(LPTSTR lpszFunction)
{
	// Retrieve the system error message for the last-error code

	LPVOID lpMsgBuf;
	LPVOID lpDisplayBuf;
	DWORD dw = GetLastError();

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf,
		0, NULL);

	// Display the error message and clean up

	lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,
		(lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40)*sizeof(TCHAR));
	StringCchPrintf((LPTSTR)lpDisplayBuf,
		LocalSize(lpDisplayBuf) / sizeof(TCHAR),
		TEXT("%s failed with error %d: %s"),
		lpszFunction, dw, lpMsgBuf);

	if (DO_YOU_WANT_MESSAGES == 1)
	{

		MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);
	}
	cout << lpDisplayBuf << endl;
	LocalFree(lpMsgBuf);
	LocalFree(lpDisplayBuf);
}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateProducerConsumerSystem(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	cout << "Creating Computational Agent Manager Instance Class" << endl;
	DirectXCompuationalAgemtManager* pComputationalAgentManagerClass = new DirectXCompuationalAgemtManager(hInstance, hWnd);


	hr = pComputationalAgentManagerClass->SimulateProducerConsumerSystem(hInstance, hWnd);

	return hr;

}



HRESULT DirectXGPUDigitalLabCoreModule::SimutateQuadraticFunctionAlgorithmUsingMutexObject(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr;

	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);


	std::cout << "Simulating the Quadratic Function Graph " << endl;

	vector<InputStructureForGraph> pInputStructureArray = vector<InputStructureForGraph>();
	vector<OutputStructureForGraph> pOutputResultData = vector<OutputStructureForGraph>();

	float pMinimumOfRange = 0.0f;
	float pMaximumOfRange = 0.0f;
	float pCoefficientA = 0.0f;
	float pCoefficientB = 0.0f;
	float pCoefficientC = 0.0f;
	float pStepValue = 0.0f;
	std::cout << "Enter the Value For Coefficient A " << endl;
	cin >> pCoefficientA;
	std::cout << "Enter the Value For Coefficient B" << endl;
	cin >> pCoefficientB;
	std::cout << "Enter the Value For Coefficient C" << endl;
	cin >> pCoefficientC;

	std::cout << "Enter the minimum of of the input sequence: " << endl;
	cin >> pMinimumOfRange;
	std::cout << "Enter the maximum of the input sequence: " << endl;
	cin >> pMaximumOfRange;


	std::cout << "Enter the Function Step Value" << endl;
	cin >> pStepValue;
	std::cout << "The Minimum Value Of Selected Range = " << pMinimumOfRange << endl;
	std::cout << "The Maximum Value Of Selected Range = " << pMaximumOfRange << endl;
	// Specify the engine and distribution.
	std::cout << "Generating Initial Data" << endl;
	int pIndexVar = 0;
	float pVal = pMinimumOfRange;

	for (pVal = pMinimumOfRange; pVal <= pMaximumOfRange; ++pVal)
	{
		std::cout << "Initial Data Array Element At Index: " << pIndexVar << " = " << pVal << endl;
		InputStructureForGraph pInputStructureForGraph;
		pInputStructureForGraph.pItemIndex = pIndexVar;
		pInputStructureForGraph.pInputItemValue = pVal;
		pInputStructureArray.push_back(pInputStructureForGraph);
		pIndexVar++;
	}


	FILETIME pStartTimeVal;
	FILETIME pEndTimeVal;
	FILETIME pElapsedTime;
	FILETIME pSystemTimeVal;
	FILETIME pUserTimeVal;

	SYSTEMTIME pSystemTimeStart;
	SYSTEMTIME pLocalTimeStart;
	SYSTEMTIME pSystemTimeEnd;
	SYSTEMTIME pLocalTimeEnd;

	hr = ppStandardAlgorithmExecutor->SimulateQuadraticFunctionInAMutex(hInstance, hWnd, pCoefficientA,
		pCoefficientB, pCoefficientC,
		pInputStructureArray,
		&pOutputResultData,
		&pSystemTimeStart,
		&pLocalTimeStart,
		&pSystemTimeEnd,
		&pLocalTimeEnd);




	printf("The system time Start is: %02d:%02d:%02d\n", pSystemTimeStart.wHour, pSystemTimeStart.wMinute, pSystemTimeStart.wSecond);
	printf(" The local time Start is: %02d:%02d:%02d\n", pLocalTimeStart.wHour, pLocalTimeStart.wMinute, pLocalTimeStart.wSecond);

	printf("The system time End is: %02d:%02d:%02d\n", pSystemTimeEnd.wHour, pSystemTimeEnd.wMinute, pSystemTimeEnd.wSecond);
	printf(" The local time End is: %02d:%02d:%02d\n", pLocalTimeEnd.wHour, pLocalTimeEnd.wMinute, pLocalTimeEnd.wSecond);




	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\QuadraticFunctionTxt.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	pixelDataFile.clear();
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	pixelDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;

	pixelDataFile << "Time Start System: " << pSystemTimeStart.wHour << ":" << pSystemTimeStart.wMinute << ":" << pSystemTimeStart.wSecond << endl;
	pixelDataFile << "Local Time Start: " << pLocalTimeStart.wHour << ":" << pLocalTimeStart.wMinute << ":" << pLocalTimeStart.wSecond << endl;
	pixelDataFile << "Time End System: " << pSystemTimeEnd.wHour << ":" << pSystemTimeEnd.wMinute << ":" << pSystemTimeEnd.wSecond << endl;
	pixelDataFile << "Local Time End: " << pLocalTimeEnd.wHour << ":" << pLocalTimeEnd.wMinute << ":" << pLocalTimeEnd.wSecond << endl;


	std::cout << "We are Simulating the function y = a*x^2 + b*x + c" << endl;
	std::cout << "Coefficient A: " << pCoefficientA << endl;
	std::cout << "Coefficient B: " << pCoefficientB << endl;
	std::cout << "Coefficient C: " << pCoefficientC << endl;

	pixelDataFile << "We are Simulating the function y = a*x^2 + b*x + c" << endl;
	pixelDataFile << "Coefficient A: " << pCoefficientA << endl;
	pixelDataFile << "Coefficient B: " << pCoefficientB << endl;
	pixelDataFile << "Coefficient C: " << pCoefficientC << endl;
	std::cout << "Printing X Values" << endl;
	pixelDataFile << "Printing X Values" << endl;

	vector<OutputStructureForGraph2D> ppOutputGraphFor2DArray = vector<OutputStructureForGraph2D>();


	for (OutputStructureForGraph pOutputStructure : pOutputResultData)
	{
		cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
		cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		pixelDataFile << "Item Index = " << pOutputStructure.pItemIndex << endl;
		pixelDataFile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		pixelDataFile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;

		OutputStructureForGraph2D pOutputStructure2D;
		pOutputStructure2D.pItemIndex = pOutputStructure.pItemIndex;
		pOutputStructure2D.pInputStructureForGraph = pOutputStructure.pInputStructureForGraph;
		pOutputStructure2D.pOutputStructureForGraph = pOutputStructure.pOutputStructureForGraph;
		ppOutputGraphFor2DArray.push_back(pOutputStructure2D);


		// Create a node



	}

	cout << "Plotting Quadratic Function Graph Object" << endl;

	hr = md2dmanager->PlotAGraphGeometryForGivenQuadraticData(hInstance, hWnd,
		ppOutputGraphFor2DArray);


	pixelDataFile << "New Operation End" << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile.close();

	std::cout << "Simulation Has Been Completed" << endl;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTPAutomatic(HINSTANCE hInstance, HWND hWnd,
	LPWSTR pFileNameVideoEight, LPWSTR pFileNameVideoTwo,
	int pXPosition, int pYPosition, int pImageWidth, int pImageHeight, int pWaitingInterval)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerAsynchronousMode.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();





	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);


	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		cout << "Video File Eight for Analysis Is Not Available" << endl;
		return hr;
	}


	HANDLE pVideoPreparationState = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"VideoPreparation");
	SetEvent(pVideoPreparationState);



	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		pFileNameVideoEight, pFileNameVideoTwo, constants::pImageOneForProcessingAutonomous, constants::pImageTwoForProcessingAutonomous, constants::pImageThreeForProcessingAutonomous,
		constants::pImageFourForProcessingAutonomous, pWaitingInterval);

	CloseHandle(pVideoPreparationState);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;

	HANDLE pDirect2DDeviceCheck = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"Direct2DDeviceCheck");
	SetEvent(pDirect2DDeviceCheck);



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();

	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);

	CloseHandle(pDirect2DDeviceCheck);

	HANDLE pImageOneClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageEightClippingEvent");
	SetEvent(pImageOneClippingEvent);


	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);




	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	CloseHandle(pImageOneClippingEvent);

	HANDLE pImageTwoClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageTwoClippingEvent");
	SetEvent(pImageTwoClippingEvent);

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessingAutonomous, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	CloseHandle(pImageTwoClippingEvent);

	HANDLE pImageOneGrayScaleEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageEightGrayScaleEvent");
	SetEvent(pImageOneGrayScaleEvent);


	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	CloseHandle(pImageOneGrayScaleEvent);

	HANDLE pImageTwoGrayScaleEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageTwoGrayScaleEvent");
	SetEvent(pImageTwoGrayScaleEvent);


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	CloseHandle(pImageTwoGrayScaleEvent);

	HANDLE pImageComparisEightvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageComparisEightvent");
	SetEvent(pImageComparisEightvent);

	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;



		if (ppOutputPixelValue.outputComparisonValue > 0)
		{
			hr = md2dmanager->DrawRoadSignVertical(hInstance, hWnd, ppOutputPixelValue.pixelNumber, 100);
		}
		else if (ppOutputPixelValue.outputComparisonValue == 0)
		{
			hr = md2dmanager->DrawRoadSignVertical(hInstance, hWnd, ppOutputPixelValue.pixelNumber, 0);

		}
		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();

	CloseHandle(pImageComparisEightvent);

	HANDLE pReportCreatiEightvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ReportCreatiEightvent");
	SetEvent(pReportCreatiEightvent);


	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}



	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);


	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();

	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum << ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Creating Visualization Diagram" << endl;


	CloseHandle(pReportCreatiEightvent);
	cout << "Simulation Using Web Has Been Completed" << endl;


	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemObjectViaImageComparisonFromSelectedFilesStateMachinesIntensity(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;


	float pArraySize = 0;
	if (hWnd == NULL);
	{
		RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
		GetClientRect(hWnd, &rc);
	}






	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageThree = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageFour = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppPixelObjectEightGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppPixelObjectTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppPixelObjectThreeGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppPixelObjectFourcGrayScale = vector<PixelObjectGrayScale>();

	vector<OutputPixelBufferStateMachineData> ppImageOneStateArray = vector<OutputPixelBufferStateMachineData>();
	vector<OutputPixelBufferStateMachineData> ppImageTwoStateArray = vector<OutputPixelBufferStateMachineData>();
	vector<OutputPixelObjectGrayScaleStateChange> ppOutputStateMachineFinalArray = vector<OutputPixelObjectGrayScaleStateChange>();



	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerFromSelectedFilesUsingStateMachinesIntensityFunction.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	cout << "This is a simulation of a video inspenction Robot" << endl;
	cout << "For Our Experiment we will have to Record Two Videos and Capture Screen Shots for further analysis" << endl;



	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;



	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	MessageBoxA(hWnd, (LPCSTR)"Воспроизводим 2 видео файла и делаем по 2 скриншота для каждого видео - Всего 4 Кадра", (LPCSTR)"Message", 0);

	cout << "Selecting Video 1" << endl;
	LPWSTR pVideoFileNameOne = nullptr;
	// Show the File Open dialog.
	wchar_t path[MAX_PATH];
	path[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn))
	{
		pVideoFileNameOne = ofn.lpstrFile;
	}

	cout << "Selecting Video 2" << endl;
	LPWSTR pVideoFileNameTwo = nullptr;
	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn1;
	ZeroMemory(&ofn1, sizeof(ofn1));
	ofn1.lStructSize = sizeof(ofn1);
	ofn1.hwndOwner = hWnd;
	ofn1.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn1.lpstrFile = path1;
	ofn1.nMaxFile = MAX_PATH;
	ofn1.Flags = OFN_FILEMUSTEXIST;
	ofn1.hInstance = hInstance;


	if (GetOpenFileNameW(&ofn1))
	{
		pVideoFileNameTwo = ofn1.lpstrFile;
	}



	DeleteFile(constants::pImageOneForProcessing);
	DeleteFile(constants::pImageTwoForProcessing);
	DeleteFile(constants::pImageThreeForProcessing);
	DeleteFile(constants::pImageFourForProcessing);


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	DirectXVideoPlayer* pPrimaryPlayer = nullptr;
	hr = DirectXVideoPlayer::CreateInstance(hWnd, hWnd, &pPrimaryPlayer);



	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\VideoCompariEightxperiment.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);

	vector<PixelObject> ppImageOnePixels = vector<PixelObject>();
	vector<PixelObject> ppImageTwoPixels = vector<PixelObject>();


	HANDLE pVideoPrepararion = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"VideoPreparation");
	SetEvent(pVideoPrepararion);





	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		(LPWSTR)pVideoFileNameOne, (LPWSTR)pVideoFileNameTwo, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);

	CloseHandle(pVideoPrepararion);

	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;






	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;

	MessageBoxA(hWnd, (LPCSTR)"Проверяем состояние Графического Движка 2D", (LPCSTR)"Message", 0);

	HANDLE pDirect2DEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"Direct2D Preparation");
	SetEvent(pDirect2DEvent);




	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);
	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);

	CloseHandle(pDirect2DEvent);


	cout << "Simulating the Image Subtraction Operation" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Вырезаем Область Первого Кадра", (LPCSTR)"Message", 0);

	HANDLE pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageCliiping1");
	SetEvent(pImageClippingEvent);


	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

	}

	CloseHandle(pImageClippingEvent);
	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);


	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Вырезаем Область Первого Кадра", (LPCSTR)"Message", 0);

	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageCliiping2");
	SetEvent(pImageClippingEvent);


	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageTwoForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;

	pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;

	}
	CloseHandle(pImageClippingEvent);
	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);


	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;

	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageCliiping3");
	SetEvent(pImageClippingEvent);

	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageThree);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageThree)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;


	}
	CloseHandle(pImageClippingEvent);
	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;


	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageCliiping3");
	SetEvent(pImageClippingEvent);



	md2dmanager->ClearRenderTargetContent(hInstance, hWnd);
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageFourForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageFour);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageFour)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;




	}
	CloseHandle(pImageClippingEvent);

	MessageBoxA(hWnd, (LPCSTR)"Готовим Первый Кадр Для анализа - переводим его в черно-белый цвет", (LPCSTR)"Message", 0);


	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"GrayScale1");
	SetEvent(pImageClippingEvent);


	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppPixelObjectEightGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppPixelObjectEightGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pIndexValue++;
	}
	CloseHandle(pImageClippingEvent);


	MessageBoxA(hWnd, (LPCSTR)"Готовим Второй Кадр Для анализа - переводим его в черно-белый цвет", (LPCSTR)"Message", 0);


	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"GrayScale2");
	SetEvent(pImageClippingEvent);



	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppPixelObjectTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppPixelObjectTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	CloseHandle(pImageClippingEvent);

	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"GrayScale3");
	SetEvent(pImageClippingEvent);


	cout << "Converting Image Three Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Three Data To GrayScale" << endl;

	MessageBoxA(hWnd, (LPCSTR)"Готовим Третий Кадр Для анализа - переводим его в черно-белый цвет", (LPCSTR)"Message", 0);


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageThree, &ppPixelObjectThreeGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppPixelObjectThreeGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
		pIndexValue++;
	}
	CloseHandle(pImageClippingEvent);

	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"GrayScale4");
	SetEvent(pImageClippingEvent);



	MessageBoxA(hWnd, (LPCSTR)"Готовим Четвертый Кадр Для анализа - переводим его в черно-белый цвет", (LPCSTR)"Message", 0);


	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageFour, &ppPixelObjectFourcGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppPixelObjectFourcGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pIndexValue++;
	}


	CloseHandle(pImageClippingEvent);

	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"StateMachine1");
	SetEvent(pImageClippingEvent);




	cout << "Simulating Intensity Function For First Two Images" << endl;
	imageSegmentationDataFile << "Simulating Intensity Function For First Two Images" << endl;

	MessageBoxA(hWnd, (LPCSTR)"Машина Состояний Для Первого и Третьего кадра", (LPCSTR)"Message", 0);


	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(hInstance,
		hWnd, 1, 0, ppPixelObjectEightGrayScale, ppPixelObjectThreeGrayScale, &ppImageOneStateArray);

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the first Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the first Level of State Machine Simulation" << endl;
		return hr;
	}


	for (OutputPixelBufferStateMachineData pPixelObject : ppImageOneStateArray)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;

	}
	CloseHandle(pImageClippingEvent);


	MessageBoxA(hWnd, (LPCSTR)"Машина Состояний Для Второго и Четвертого кадра", (LPCSTR)"Message", 0);
	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"StateMachine2");
	SetEvent(pImageClippingEvent);




	cout << "Simulating Intensity Function for Second and Third Images" << endl;
	imageSegmentationDataFile << "Simulating Intensity Function for Second and Third Images" << endl;
	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(hInstance,
		hWnd, 1, 0, ppPixelObjectTwoGrayScale, ppPixelObjectFourcGrayScale, &ppImageTwoStateArray);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the first Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the first Level of State Machine Simulation" << endl;
		return hr;
	}

	for (OutputPixelBufferStateMachineData pPixelObject : ppImageTwoStateArray)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;

	}
	CloseHandle(pImageClippingEvent);

	pImageClippingEvent = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"StateMachineFinal");
	SetEvent(pImageClippingEvent);




	cbImageProcessingFSMStageTwo pConstantBufferData;
	pConstantBufferData.pDifferentImageLabel = 1;
	pConstantBufferData.pDifferentStateLabel = 1;
	pConstantBufferData.pIdenticalImageLabel = 0;
	pConstantBufferData.pIdenticalStateLabel = 0;
	pConstantBufferData.pUndefinedStateLabel = 55;
	pConstantBufferData.pUndefinedImageLabel = 55;

	cout << "Simulating the final Stage of the State Machine Engine" << endl;
	imageSegmentationDataFile << "Simulating the final Stage of the State Machine Engine" << endl;


	MessageBoxA(hWnd, (LPCSTR)"Машина Состояний Для Двух Результатов Сравнения", (LPCSTR)"Message", 0);


	hr = ppStandardAlgorithmExecutor->SimulateImageProcessingFiniteStateMachineIntensitySimulator(hInstance,
		hWnd,
		pConstantBufferData,
		ppImageOneStateArray,
		ppImageTwoStateArray,
		&ppOutputStateMachineFinalArray);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)L"Симулятор Машины Состояний Завешен с ошибкой", (LPCSTR)L"Message", 0);
		cout << "An Error Occured While the Second Level of State Machine Simulation" << endl;
		imageSegmentationDataFile << "An Error Occured While the Second Level of State Machine Simulation" << endl;
		return hr;
	}

	cout << "Priniting the Output of the Computer Simulation" << endl;

	for (OutputPixelObjectGrayScaleStateChange pPixelObject : ppOutputStateMachineFinalArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
		cout << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
		cout << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
		cout << "Current Image State = " << pPixelObject.pCurrentStateOne << endl;
		cout << "Previous Image State = " << pPixelObject.pCurrentStateTwo << endl;
		cout << "Did State Change = " << pPixelObject.pDidStateChange << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
		imageSegmentationDataFile << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
		imageSegmentationDataFile << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
		imageSegmentationDataFile << "Current Image State = " << pPixelObject.pCurrentStateOne << endl;
		imageSegmentationDataFile << "Previous Image State = " << pPixelObject.pCurrentStateTwo << endl;
		imageSegmentationDataFile << "Did State Change = " << pPixelObject.pDidStateChange << endl;


		if (pPixelObject.pDidStateChange == 255)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 100);
		}
		else if (pPixelObject.pDidStateChange == 0)
		{
			md2dmanager->DrawRoadSignImageProcessingFSM(hInstance, hWnd, 0);
		}





	}

	CloseHandle(pImageClippingEvent);

	try
	{
		//		boost::property_tree::json_parser::write_json("C:\\pixels\\RobotCleanerDataFileStateMachineClassificatorArray.json", pRobotCleanerRoot);
	}
	catch (std::exception ex)
	{
		cout << ex.what() << endl;
	}


	md2dmanager->CaptureScreenShotToFile(hInstance, hWnd, (LPCWSTR)L"C:\\RobotData\\RobotCleanerSimulationsUsingStateMachinesIntensityFunction.jpg");
	cout << "Simulation Has Been Completed" << endl;
	imageSegmentationDataFile << "Simulation Has Been Completed" << endl;
	imageSegmentationDataFile.close();


	return hr;

}



void DirectXGPUDigitalLabCoreModule::NotifyError(HWND hwnd, PCWSTR sErrorMessage, HRESULT hrErr)
{
	const int MESSAGE_LEN = 512;
	wchar_t message[MESSAGE_LEN];

	HRESULT hr = StringCchPrintf((LPWSTR)message, MESSAGE_LEN, (LPCWSTR)"%s (HRESULT = 0x%X)", sErrorMessage, hrErr);
	if (SUCCEEDED(hr))
	{
		MessageBox(hwnd, (LPCWSTR)message, NULL, MB_OK | MB_YESNO);
	}
}




HRESULT DirectXGPUDigitalLabCoreModule::SimulateRobotCleanerSystemForVideoFromFTP(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\RobotCleanerFTP.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();
	
	vector<PixelObject> pixelObjectImageEight = vector<PixelObject>();
	vector<PixelObject> pixelObjectImageTwo = vector<PixelObject>();
	vector<PixelObjectGrayScale> ppImageOneGrayScale = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppImageTwoGrayScale = vector<PixelObjectGrayScale>();
	vector<OutputPixelBuffer> ppVerificationOutputArray = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> ppIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> ppDifferentPixelOutputArray = vector<PixelObjectGrayScale>();


	int pXPosition = 0;
	int pYPosition = 0;
	int pImageWidth = 0;
	int pImageHeight = 0;

	cout << "Enter the X Position for Image Clip" << endl;
	cin >> pXPosition;

	cout << "Enter the Y Position for Image Clip" << endl;
	cin >> pYPosition;

	cout << "Enter the Width for Image Clip" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height for Image Clip" << endl;
	cin >> pImageHeight;
	float pTotalImageIntensitySum = 0;

	UINT pWaitingIntervalInSeconds = 0;


	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	pVideoAnalyticsManagementClass = new DirectXVideoAnalyticsManagementEngineClass(hInstance, hWnd);
	hr = pVideoAnalyticsManagementClass->InitializeVideoAnalysisEngine(hInstance, hWnd);
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);

	
	cout << "Download Video Number Eight" << endl;
	BOOL pResult = FALSE;

	LPWSTR pVideoEightFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRLnILWm5IhEfapJ?e=RK2NJK";
	LPWSTR pVideoTwoFileName = L"https://1drv.ms/v/s!AnPzJJgvIT1TgRGKWGam2-B7BSE_?e=teED1e";
	LPWSTR pVideoFileEightNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP1.mp4";
	LPWSTR pVideoFileTwoNameLocal = L"C:\\RobotData\\DownloadedVideos\\VideoFTP2.mp4";


	cout << "Download Video Number Eight" << endl;


	bool pFileEightExists = false;
	pFileEightExists = PathFileExists(pVideoFileEightNameLocal);

	if (pFileEightExists == false)
	{
		hr = m_pCloudServerConnectionManagerClass->DownloadSampleVideoFileFromWebViaGETRequest(hInstance,
			hWnd, pVideoEightFileName, pVideoFileEightNameLocal, pVideoFileEightNameLocal);


		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Url Download To File Terminated with Error: " << pLastError << endl;
		}


	}



	cout << "Download Video Number Two" << endl;
	bool pFileTwoExists = false;
	pFileTwoExists = PathFileExists(pVideoFileTwoNameLocal);


	if (pFileEightExists == false)
	{

		hr = m_pCloudServerConnectionManagerClass->DownloadSampleVideoFileFromWebViaGETRequest(hInstance,
			hWnd, pVideoTwoFileName, pVideoFileTwoNameLocal, pVideoFileEightNameLocal);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Url Download To File Terminated with Error: " << pLastError << endl;
		}




	}


	HANDLE pVideoPlayBack = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"Video PlayBack");
	SetEvent(pVideoPlayBack);


	cout << "We will start by recording couple of Videos and save screen shots" << endl;
	hr = pVideoAnalyticsManagementClass->LoadDataForSimulationOfRobotCleanerFromExistingFiles(hInstance, hWnd,
		(LPWSTR)pVideoFileEightNameLocal, (LPWSTR)pVideoFileTwoNameLocal, constants::pImageOneForProcessing, constants::pImageTwoForProcessing, constants::pImageThreeForProcessing,
		constants::pImageFourForProcessing, pWaitingIntervalInSeconds);

	CloseHandle(pVideoPlayBack);
	cout << "We have managed to record 2 Videos and save Two Screen Shots" << endl;
	cout << "Let us Compare First Frames from Each Video" << endl;


	cout << "This Function Simulate Mathematical Comparison Of Digital Images" << endl;
	cout << "Loading the First Image Object" << endl;




	cout << "Simulating the Image Subtraction Operation" << endl;


	HANDLE pGraphicsDeviceCheck = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"Graphics Device Check");
	SetEvent(pGraphicsDeviceCheck);

	vector<PixelObject> pixelObjectVector = vector<PixelObject>();


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	CloseHandle(pGraphicsDeviceCheck);

	HANDLE pImageOneClipping = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageClipping1");
	SetEvent(pImageOneClipping);


	cout << "Loading Image One" << endl;
	imageSegmentationDataFile << "Loading Image One" << endl;


	cout << "The Image That will be processed is" << constants::pImageOneForProcessing << endl;


	//hr = md2dmanager->CreateBitmapDrawingClipObjectWithFileNames(hInstance,
	//	hWnd, pImageOneForProcessing,  pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageOneForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageEight);

	cout << "Printing the Contents of Clipped Area" << endl;

	int pIndex = 0;

	for (PixelObject pixelObject : pixelObjectImageEight)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	CloseHandle(pImageOneClipping);

	cout << "Loading Image Two" << endl;
	imageSegmentationDataFile << "Loading Image Two" << endl;

	HANDLE pImageTwoClipping = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageClipping2");
	SetEvent(pImageTwoClipping);

	cout << "Printing the Contents of Clipped Area" << endl;
	pIndex = 0;
	hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance,
		hWnd, constants::pImageThreeForProcessing, pXPosition, pYPosition, pImageWidth, pImageHeight, &pixelObjectImageTwo);

	cout << "Printing the Contents of Clipped Area" << endl;
	imageSegmentationDataFile << "Printing the Contents of Clipped Area" << endl;


	for (PixelObject pixelObject : pixelObjectImageTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	CloseHandle(pImageTwoClipping);

	HANDLE pImageOneGrayScale = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageEightGrayScale");
	SetEvent(pImageOneGrayScale);
	
	cout << "Converting Image One Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image One Data To GrayScale" << endl;


	cout << "Ensuring Pixels Are Different" << endl;
	imageSegmentationDataFile << "Ensuring Pixels Are Different" << endl;




	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageEight, &ppImageOneGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	time_t currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	int pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;

	float pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageOneGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale =  pPixelObject.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	CloseHandle(pImageOneGrayScale);

	HANDLE pImageTwoGrayScale = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageTwoGrayScale");
	SetEvent(pImageTwoGrayScale);


	cout << "Converting Image Two Data To GrayScale" << endl;
	imageSegmentationDataFile << "Converting Image Two Data To GrayScale" << endl;



	hr = ppStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance, hWnd,
		pixelObjectImageTwo, &ppImageTwoGrayScale);


	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;
	currentTime = time(0);
	imageSegmentationDataFile << "current time" << currentTime << endl;
	pOperationNumber = 0;
	cout << "Printing Output" << endl;
	imageSegmentationDataFile << "Printing Output" << endl;
	pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObject : ppImageTwoGrayScale)
	{

		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject .pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		imageSegmentationDataFile << "Step: " << pIndexValue << endl;
		imageSegmentationDataFile << "X Value = " << pXValue << endl;
		imageSegmentationDataFile << "Y Value = " << pYValue << endl;
		imageSegmentationDataFile << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	CloseHandle(pImageTwoGrayScale);

	HANDLE pImageComparision = CreateEventA(NULL, TRUE, TRUE, (LPCSTR)L"ImageComparisonOperation");
	SetEvent(pImageComparision);

	cout << "Performing Subtraction of GrayScale Images" << endl;
	imageSegmentationDataFile << "Performing Subtraction of GrayScale Images" << endl;





	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelOutputArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;

	BOOL pAreImagesIdentical = FALSE;

	hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdentical(hInstance, hWnd, pImageWidth, pImageHeight, ppImageOneGrayScale,
		ppImageTwoGrayScale, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySum, &pImageOneAverage,
		&pImageTwoIntensitySum, &pImageTwoAverage,
		&pOutputArrayIntensitySum, &pOutputArrayAverage,
		&pIdenticalPixelOutputArraySum, &pIdenticalPixelArrayAverage,
		&pDifferentPixelArraySum, &pDifferentPixelArrayAverage,
		&pAreImagesIdentical);

	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBuffer ppOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageSegmentationDataFile << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageSegmentationDataFile << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageSegmentationDataFile << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageSegmentationDataFile << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount Of Identical Pixels = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount Of Different Pixels = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the Output of Identical Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Identical Pixels Array" << endl;
	for (PixelObjectGrayScale pIdenticalPixelObject : ppIdenticalPixelOutputArray)
	{
		cout << "Identical Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Pixel Number: " << pIdenticalPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pIdenticalPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pIdenticalPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pIdenticalPixelObject.pGreyLevel << endl;
	}

	cout << "Printing the Output of Different Pixels Array" << endl;
	imageSegmentationDataFile << "Printing the Output of Different Pixels Array" << endl;
	for (PixelObjectGrayScale pDifferentPixelObject : ppDifferentPixelOutputArray)
	{


		cout << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		cout << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		cout << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		cout << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Different Pixel Number: " << pDifferentPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pDifferentPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pDifferentPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Image One intensity Value = " << pDifferentPixelObject.pGreyLevel << endl;
	}


	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;
	imageSegmentationDataFile << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageSegmentationDataFile << "Output Array Size = " << ppVerificationOutputArray.size() << endl;
	imageSegmentationDataFile << "Output Array Average = " << pOutputArrayAverage << endl;

	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	cout << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;
	imageSegmentationDataFile << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelOutputArraySum << endl;
	imageSegmentationDataFile << "Identical Pixel Array Size = " << ppIdenticalPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;

	cout << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	cout << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;
	imageSegmentationDataFile << "Different Pixel Array Intensity Sum = " << pDifferentPixelArraySum << endl;
	imageSegmentationDataFile << "Different Pixel Array Size = " << ppDifferentPixelOutputArray.size() << endl;
	imageSegmentationDataFile << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	cout << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	cout << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	cout << "Intensity Sum = " << pIntensitySummation << endl;
	imageSegmentationDataFile << "Amount of Identical Pixels = " << pAmountOfIdenticalPixels << endl;
	imageSegmentationDataFile << "Amount of Different Pixels = " << pAmountOfDifferentPixels << endl;
	imageSegmentationDataFile << "Intensity Sum = " << pIntensitySummation << endl;

	imageSegmentationDataFile.close();
	

	fstream imageSegmentationReportFile;
	imageSegmentationReportFile.open("C:\\pixels\\RobotCleanerReports.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	fstream imageSegmentationReportFileCSV;
	imageSegmentationReportFileCSV.open("C:\\pixels\\RobotCleanerReports.csv", std::fstream::in | std::fstream::out | std::fstream::trunc);

	cout << "Generating Report Object" << endl;

	UINT pReportId = pRobotCleanerObjectReportArray.size();
	time_t pCurrentReportNow = time(0);
	float pLevelOfImpurities = 0.0f;

	cout << "Identifying The Level Of Impurities " << endl;
	if (pAmountOfDifferentPixels >= 0 && pAmountOfDifferentPixels <= 20)
	{
		pLevelOfImpurities = 1;
	}
	else if (pAmountOfDifferentPixels > 20 && pAmountOfDifferentPixels <= 40)
	{
		pLevelOfImpurities = 2;
	}
	else if (pAmountOfDifferentPixels > 40 && pAmountOfDifferentPixels <= 60)
	{
		pLevelOfImpurities = 3;
	}
	else if (pAmountOfDifferentPixels > 60 && pAmountOfDifferentPixels <= 80)
	{
		pLevelOfImpurities = 4;
	}
	else if (pAmountOfDifferentPixels > 80 && pAmountOfDifferentPixels <= 100)
	{
		pLevelOfImpurities = 5;
	}

	CloseHandle(pImageComparision);

	RobotCleanerReportObject pReportObjectOfRobotCleaner = RobotCleanerReportObject(pReportId,
		pCurrentReportNow,
		pXPosition,
		pYPosition,
		pImageWidth,
		pImageHeight,
		pImageOneIntensitySum,
		pImageOneAverage,
		pImageTwoIntensitySum,
		pImageTwoAverage,
		pOutputArrayIntensitySum,
		pOutputArrayAverage,
		pIdenticalPixelOutputArraySum,
		pIdenticalPixelArrayAverage,
		pDifferentPixelArraySum,
		pDifferentPixelArrayAverage,
		pLevelOfImpurities);


	cout << "Record Start" << endl;
	cout << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	cout << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	cout << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	cout << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	cout << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	cout << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	cout << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << endl;
	cout << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	cout << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	cout << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	cout << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	cout << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	cout << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	cout << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	cout << "Record End" << endl;

	imageSegmentationReportFile << "Record Start" << endl;
	imageSegmentationReportFile << "Report Id: " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Top Left Point X: " << pReportObjectOfRobotCleaner.pXPosition << endl;
	imageSegmentationReportFile << "Top Left Point Y: " << pReportObjectOfRobotCleaner.pYPosition << endl;
	imageSegmentationReportFile << "Sector Width " << pReportObjectOfRobotCleaner.pSectorWidth << endl;
	imageSegmentationReportFile << "Sector Height " << pReportObjectOfRobotCleaner.pSectorHeight << endl;
	imageSegmentationReportFile << "Image One Intensity Sum: " << pReportObjectOfRobotCleaner.pImageOneIntensitySum << endl;
	imageSegmentationReportFile << "Image One Intensity Average: " << pReportObjectOfRobotCleaner.pImageOneAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Sum: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Image Two Intensity Average: " << pReportObjectOfRobotCleaner.pImageTwoAverage << endl;
	imageSegmentationReportFile << "Output Array Intensity Sum: " << pReportObjectOfRobotCleaner.pOutputArraySum << endl;
	imageSegmentationReportFile << "Output Array Intensity Average: " << pReportObjectOfRobotCleaner.pOutputArrayAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Identical Array Intensity Sum: " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << endl;
	imageSegmentationReportFile << "Identical Array Intensity Average: " << pReportObjectOfRobotCleaner.pIdenticalPixelAverage << endl;
	imageSegmentationReportFile << "Different Array Intensity Sum: " << pReportObjectOfRobotCleaner.pDifferentPixelArraySum << endl;
	imageSegmentationReportFile << "Different Array Intensity Average: " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << endl;
	imageSegmentationReportFile << "Level Of Impurities: " << pReportObjectOfRobotCleaner.pLevelOfImpurities << endl;
	imageSegmentationReportFile << "Record End" << endl;
	imageSegmentationReportFile.close();

	imageSegmentationReportFileCSV << pReportObjectOfRobotCleaner.pSectorId << ", " <<
		pReportObjectOfRobotCleaner.pXPosition << "," <<
		pReportObjectOfRobotCleaner.pYPosition << "," << pReportObjectOfRobotCleaner.pSectorWidth <<
		", " << pReportObjectOfRobotCleaner.pSectorHeight << "," << pReportObjectOfRobotCleaner.pImageOneIntensitySum << ", " <<
		", " << pReportObjectOfRobotCleaner.pImageTwoIntensitySum << ", " << pReportObjectOfRobotCleaner.pImageOneAverage <<
		", " << pReportObjectOfRobotCleaner.pImageTwoAverage << ", " << pReportObjectOfRobotCleaner.pOutputArraySum<< ", " <<
		pReportObjectOfRobotCleaner.pOutputArrayAverage << ", " << pReportObjectOfRobotCleaner.pIdenticalPixelArraySum << ", " <<
		pReportObjectOfRobotCleaner.pIdenticalPixelAverage << ", " << pReportObjectOfRobotCleaner.pDifferentPixelAverage << ", " <<
		pReportObjectOfRobotCleaner.pLevelOfImpurities << endl; 
	cout << "Creating Visualization Diagram" << endl;

	if (pDifferentPixelArrayAverage >= 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 100);
	}
	else if (pDifferentPixelArrayAverage >= 33 && pDifferentPixelArrayAverage < 66)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 50);
	}
	else if (pDifferentPixelArrayAverage >= 0 && pDifferentPixelArrayAverage < 33)
	{
		md2dmanager->DrawRoadSign(hInstance, hWnd, 0);
	}

	HWND hListBox = NULL;
	hListBox = CreateWindow(L"listbox", NULL,
		WS_CHILD | WS_VISIBLE | LBS_STANDARD |
		LBS_WANTKEYBOARDINPUT,
		30, 30, 200, 100,
		hWnd, (HMENU)ID_LIST, hInstance, NULL);

	// Отменяем режим перерисовки списка
	SendMessage(hListBox, WM_SETREDRAW, TRUE, 0L);
	// Добавляем в список несколько строк

	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Green - Intensity <= 33");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Yellow - Intensity <= 66");
	SendMessage(hListBox, LB_ADDSTRING, 0,
		(LPARAM)(LPSTR)L"Red - Intensity <= 100");

	UpdateWindow(hWnd);




	cout << "Simulation Using Web Has Been Completed" << endl;


	return hr;



}



HRESULT DirectXGPUDigitalLabCoreModule::DownloadSampleFileFromWeb(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
//	hr = m_pCloudServerConnectionManagerClass->OpenWebBrowser(hInstance, hWnd);
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::InitializeHTTPAccessToKernel(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManagerClass;

	if (!m_pCloudServerConnectionManagerClass)
	{
		m_pCloudServerConnectionManagerClass = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	hr = m_pCloudServerConnectionManagerClass->InitializeInternetAccess(hInstance, hWnd);
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::OutputLocalIpAddress(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXNetworkPacketManagementClass* pGPUNetworkManagerClass = m_pGPUNetworkModule;
	if (!pGPUNetworkManagerClass)
	{
		pGPUNetworkManagerClass = new DirectXNetworkPacketManagementClass(hInstance, hWnd);
	}
	hr = pGPUNetworkManagerClass->OutputLocalIpAddress(hInstance, hWnd);
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::StartProcessingPostRequests(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXCloudServerConnectionManager* pCloudServerConnectionManager = m_pCloudServerConnectionManager;
	if (pCloudServerConnectionManager == nullptr)
	{
		pCloudServerConnectionManager = new DirectXCloudServerConnectionManager(hInstance, hWnd);
	}
	hr = pCloudServerConnectionManager->OpenPostRequestThread();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeDeamonInstance(HINSTANCE hInstance, HWND hWnd, LPCSTR filename, LPCSTR errorFile)
{
	HRESULT hr = S_OK;

	if (m_pGPUJobManagementClass != NULL)
	{
		hr = m_pGPUJobManagementClass->InitializeDeamonForComputations(hInstance, hWnd, filename, (LPCWSTR)errorFile);
	}

	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::CreateCloudServerConnection(HINSTANCE hInstance, HWND hWnd, LPCWSTR webConnectionName, LPCWSTR webAddress, LPCWSTR portNumber)
{
	HRESULT hr = S_OK;
	if (m_pCloudServerConnectionManagerClass != NULL)
	{
		hr = m_pCloudServerConnectionManagerClass->CreateDataWebRequest(hInstance, hWnd, webConnectionName, webAddress, portNumber);
	}
	return hr;
}



int DirectXGPUDigitalLabCoreModule::CreateModuleConnectionPipe(HWND hWnd, LPCWSTR fname)
{
	BOOL fConnected = FALSE;
	DWORD dwThreadId = 0;
	HANDLE hNamedPipe = INVALID_HANDLE_VALUE;
	HANDLE pThread = NULL;

	for (;;)
	{
		_tprintf( TEXT("\nPipe Server: Main thread awaiting client connection on %s\n"), fname);

		hNamedPipe = CreateNamedPipe(fname,
			PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE |
			PIPE_READMODE_MESSAGE |
			PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			BUFFER_SIZE,
			BUFFER_SIZE,
			0,






			NULL);


		if (hNamedPipe == INVALID_HANDLE_VALUE)
		{
			MessageBoxA(hWnd, (LPCSTR)"Произошла ошибка при создании канала", (LPCSTR)"Message", 0);
			return -1;

		}

		fConnected = ConnectNamedPipe(hNamedPipe, NULL);

		if (fConnected)
		{
			pThread = CreateThread(NULL,
				0,
				ProcessInstanceDataThread,
				(LPVOID)hNamedPipe,
				0,
				&dwThreadId);
		}

		if (pThread == NULL)
		{
			pDataLoggerClass->Log("CreateThread failed, GLE=%d.\n"); 
			return -1;
		}
		else
		{
			m_pConnectedPipeCollection.push_back(hNamedPipe);
			CloseHandle(pThread); 
		}
	}

	return 0;
} 


DWORD WINAPI ProcessInstanceDataThreadA(LPVOID lpvParam)
{
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HWND hWnd;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	GetClientRect(hWnd, &rc);
	DirectXGPUDigitalLabCoreModule* pGPUDigitalLabCore = new DirectXGPUDigitalLabCoreModule(hInstance, hWnd);
	pGPUDigitalLabCore->InitializeGPUDigitalLabCore(hInstance, hWnd);

	HANDLE hHeap = GetProcessHeap();
	TCHAR* pchRequest = (TCHAR*)HeapAlloc(hHeap, 0, BUFSIZE*sizeof(TCHAR));
	TCHAR* pchReply = (TCHAR*)HeapAlloc(hHeap, 0, BUFSIZE*sizeof(TCHAR));

	DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0;
	BOOL fSuccess = FALSE;
	HANDLE hPipe = NULL;

	// Do some extra error checking since the app will keep running even if this
	// thread fails.

	if (lpvParam == NULL)
	{
		printf_s("\nERROR - Pipe Server Failure:\n");
		printf_s("   InstanceThread got an unexpected NULL value in lpvParam.\n");
		printf_s("   InstanceThread exitting.\n");
		if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
		if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
		return (DWORD)-1;
	}

	if (pchRequest == NULL)
	{
		printf_s("\nERROR - Pipe Server Failure:\n");
		printf_s("   InstanceThread got an unexpected NULL heap allocation.\n");
		printf_s("   InstanceThread exitting.\n");
		if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
		return (DWORD)-1;
	}

	if (pchReply == NULL)
	{
		printf("\nERROR - Pipe Server Failure:\n");
		printf("   InstanceThread got an unexpected NULL heap allocation.\n");
		printf("   InstanceThread exitting.\n");
		if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
		return (DWORD)-1;
	}

	// Print verbose messages. In production code, this should be for debugging only.
	printf_s("InstanceThread created, receiving and processing messages.\n");

	// The thread's parameter is a handle to a pipe object instance. 

	hPipe = (HANDLE)lpvParam;

	// Loop until dEight reading
	while (1)
	{
		pGPUDigitalLabCore->CheckIfTwoImagesAreIdentical(hInstance, hWnd);
		// Read client requests from the pipe. This simplistic code only allows messages
		// up to BUFSIZE characters in length.
		fSuccess = ReadFile(
			hPipe,        // handle to pipe 
			pchRequest,    // buffer to receive data 
			BUFSIZE*sizeof(TCHAR), // size of buffer 
			&cbBytesRead, // number of bytes read 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbBytesRead == 0)
		{
			if (GetLastError() == ERROR_BROKEN_PIPE)
			{
				_tprintf(TEXT("InstanceThread: client disconnected.\n"), GetLastError());
			}
			else
			{
				_tprintf(TEXT("InstanceThread ReadFile failed, GLE=%d.\n"), GetLastError());
			}
			break;
		}

		// Process the incoming message.
		GetAnswerToRequest(pchRequest, pchReply, &cbReplyBytes);

		// Write the reply to the pipe. 
		fSuccess = WriteFile(
			hPipe,        // handle to pipe 
			pchReply,     // buffer to write from 
			cbReplyBytes, // number of bytes to write 
			&cbWritten,   // number of bytes written 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbReplyBytes != cbWritten)
		{
			_tprintf(TEXT("InstanceThread WriteFile failed, GLE=%d.\n"), GetLastError());
			break;
		}
	}

	// Flush the pipe to allow the client to read the pipe's contents 
	// before disconnecting. Then disconnect the pipe, and close the 
	// handle to this pipe instance. 

	FlushFileBuffers(hPipe);
	DisconnectNamedPipe(hPipe);





	HeapFree(hHeap, 0, pchRequest);
	HeapFree(hHeap, 0, pchReply);

	printf("InstanceThread exitting.\n");
	return 1;
}


VOID GetAnswerToRequest( LPTSTR pchRequest, 
						LPTSTR pchReply, 
						LPDWORD pchBytes )
						// This routine is a simple function to print the client request to the console
						// and populate the reply buffer with a default data string. This is where you
						// would put the actual client request processing code that runs in the context
						// of an instance thread. Keep in mind the main thread will continue to wait for
						// and receive other client connections while the instance thread is working.
{
	_tprintf( TEXT("Client Request String:\"%s\"\n"), pchRequest );

	// Check the outgoing message to make sure it's not too long for the buffer.
	if (FAILED(StringCchCopy( pchReply, BUFFER_SIZE, TEXT("default answer from server") )))
	{
		*pchBytes = 0;
		pchReply[0] = 0;
		printf("StringCchCopy failed, no outgoing message.\n");
		return;
	}
	*pchBytes = (lstrlen(pchReply)+1)*sizeof(TCHAR);
}




void DirectXGPUDigitalLabCoreModule::Garbage(HINSTANCE hInstance, HWND hWnd)
{
	BOOL result = FALSE;

	SECURITY_ATTRIBUTES secAttributes;


	secAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	secAttributes.bInheritHandle = TRUE;
	secAttributes.lpSecurityDescriptor = NULL;


	result = CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &secAttributes, 0);

	if (result == FALSE)
	{
	  ErrorExit(TEXT("StdoutRd CreatePipe")); 
	}




	result = SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0);

	if (result == FALSE)
	{
		ErrorExit(TEXT("Stdout SetHandleInformation")); 
	}

	result = CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &secAttributes, 0);
	
	if (result == FALSE)
	{
		ErrorExit(TEXT("Stdin CreatePipe")); 
	}

	result = SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0);
	
	if (result == FALSE)
	{
		 ErrorExit(TEXT("Stdin SetHandleInformation")); 
	}
/***********************************************************************************************
	char* file = "E:\DirectXGPUDigitalLabSoftware\Debug\DirectXGPUDMOLSimulatiEightngine.exe";
	try	
	{
		result = CreateChildProcess((LPCSTR)file, g_hChildStd_IN_Rd, g_hChildStd_IN_Wr);

		hInputFile = CreateFile((LPCWSTR)file,
			GENERIC_EXECUTE,
			0,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_READONLY,
			NULL);
	}
	catch (std::exception ex)
	{
		throw ex;
	}
***********************************************************************************************/


	WriteToPipe(); 
//	printf( "\n->Contents of %s written to child STDIN pipe.\n", file);

	// Read from pipe that is the standard output for child process. 

//	printf( "\n->Contents of child process STDOUT:\n\n", file);
	ReadFromPipe(); 

	printf("\n->End of parent execution.\n");


}





bool DirectXGPUDigitalLabCoreModule::CreateChildProcess(LPCSTR fName, HANDLE pInputHandle, HANDLE pOutputHandle)
{
	PROCESS_INFORMATION piProcessInfo;
	SECURITY_ATTRIBUTES sAttributes;
	SECURITY_ATTRIBUTES processAttributes;
	STARTUPINFO siStartupInfo;
	BOOL bSuccess = FALSE;

	ZeroMemory(&piProcessInfo, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&siStartupInfo, sizeof(PROCESS_INFORMATION));

	siStartupInfo.cb = sizeof(STARTUPINFO);
	siStartupInfo.hStdError = g_hChildStd_OUT_Wr;
	siStartupInfo.hStdOutput = g_hChildStd_OUT_Wr;
	siStartupInfo.hStdInput = g_hChildStd_IN_Rd;

	bSuccess = CreateProcess(NULL,
		(LPWSTR)fName,
		NULL,
		NULL,
		TRUE,
		0, 
		NULL,
		NULL,
		&siStartupInfo,
		&piProcessInfo);

	if (!bSuccess)
	{
		ErrorExit(TEXT("CreateProcess"));
	}
	else
	{
		CloseHandle(piProcessInfo.hProcess);
		CloseHandle(piProcessInfo.hThread);
	}


	return bSuccess;
}


BOOL DirectXGPUDigitalLabCoreModule::GetProcessElevation(HINSTANCE hInstance, HWND hWnd, HANDLE pProcessHandle, TOKEN_ELEVATION_TYPE* pElevationType, BOOL* pIsAdmin)
{
	HANDLE hToken = NULL;
	DWORD dwSize = 0;
	bool result = false;
	DWORD processId = 0;
	processId = GetProcessId(pProcessHandle);

	result = OpenProcessToken(pProcessHandle,
		0,
		&hToken);
	
	if (!result)
	{
		result = FALSE;
		return result;
	}

	result = GetTokenInformation(hToken, TokenElevationType,
		pElevationType, sizeof(TOKEN_ELEVATION_TYPE), &dwSize);

	if (result)
	{
		BYTE adminSID[SECURITY_MAX_SID_SIZE];
		dwSize = sizeof(adminSID);

		result = CreateWellKnownSid(WinBuiltinAdministratorsSid,
			NULL, &adminSID, &dwSize);

		if (*pElevationType == TokenElevationTypeLimited)
		{
			HANDLE hUnifiedToken = NULL;
			result = GetTokenInformation(hToken, TokenLinkedToken, (VOID*)&hUnifiedToken,
				sizeof(HANDLE), &dwSize);
			result = CheckTokenMembership(hUnifiedToken, &adminSID, pIsAdmin);
			
			if (result)
			{
				result = true;
			}

			CloseHandle(hToken);
		}
		else 
		{
			*pIsAdmin = IsUserAnAdmin();
			result = TRUE;
		} 

	}

	CloseHandle(hToken);
	return result;
}

BOOL DirectXGPUDigitalLabCoreModule::IsUserAnAdmin()
{
	return true;
}






void DirectXGPUDigitalLabCoreModule::WriteToPipe()
{
	DWORD dwRead, dwWritten;
	CHAR chBuf[BUFSIZ];
	BOOL bSuccess = FALSE;

	for (;;) 
	{ 
		bSuccess = ReadFile(g_hChildStd_OUT_Wr, chBuf, BUFSIZ, &dwRead, NULL);
		if ( ! bSuccess || dwRead == 0 ) break; 

		bSuccess = WriteFile(g_hChildStd_IN_Wr, chBuf, dwRead, &dwWritten, NULL);
		if ( ! bSuccess ) break; 
	} 

	// Close the pipe handle so the child process stops reading. 

	if ( ! CloseHandle(g_hChildStd_IN_Wr) ) 
		ErrorExit(TEXT("StdInWr CloseHandle")); 
}

void DirectXGPUDigitalLabCoreModule::ReadFromPipe()
{
	DWORD dwRead, dwWritten; 
	CHAR chBuf[BUFSIZ]; 
	BOOL bSuccess = FALSE;
	HANDLE hParentStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

	for (;;) 
	{ 
		bSuccess = ReadFile( g_hChildStd_OUT_Rd, chBuf, BUFSIZ, &dwRead, NULL);
		if( ! bSuccess || dwRead == 0 ) break; 

		bSuccess = WriteFile(hParentStdOut, chBuf, 
			dwRead, &dwWritten, NULL);
		if (! bSuccess ) break; 
	} 
}

void DirectXGPUDigitalLabCoreModule::ErrorExit(PTSTR lpszFunction)
{
	LPVOID lpMsgBuf;
	LPVOID lpDisplayBuf;
	DWORD dw = GetLastError(); 

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dw,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR) &lpMsgBuf,
		0, NULL );

	lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, 
		(lstrlen((LPCTSTR)lpMsgBuf)+lstrlen((LPCTSTR)lpszFunction)+40)*sizeof(TCHAR)); 
	StringCchPrintf((LPTSTR)lpDisplayBuf, 
		LocalSize(lpDisplayBuf) / sizeof(TCHAR),
		TEXT("%s failed with error %d: %s"), 
		lpszFunction, dw, lpMsgBuf); 
	MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK); 

	LocalFree(lpMsgBuf);
	LocalFree(lpDisplayBuf);
	ExitProcess(1);
}




void DirectXGPUDigitalLabCoreModule::AddText(PCTSTR pszFormat, DWORD lastError)
{
	OutputDebugString((LPCWSTR)pszFormat);
	va_list argList;
	va_start(argList, pszFormat);

	TCHAR sz[20 * 1024];

	_vstprintf_s(_tcschr(sz, TEXT('\0')), _countof(sz) - _tcslen(sz),
		pszFormat, argList);
	va_end(argList);

}


void DirectXGPUDigitalLabCoreModule::DumpModule()
{
	HMODULE hModule = GetModuleHandle(NULL);
	_tprintf(TEXT("with GetModuleHandle(NULL) = 0x%x\r\n"), hModule);
	_tprintf(TEXT("with __ImageBase = 0x%x\r\n"), (HINSTANCE)&__ImageBase);

	hModule = NULL;

	GetModuleHandleEx(
		GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
		(PCTSTR)hModule,
		&hModule);
	_tprintf(TEXT("with GetModuleHandleEx = 0x%x\r\n"), hModule);
}






HRESULT DirectXGPUDigitalLabCoreModule::CreateNewSystemInstance(HINSTANCE hInstance, HWND hWnd, LPCWSTR g_szBoundary, LPCWSTR szNamespace)
{
	HRESULT hr = S_OK;
	BOOL result = false;
	hBoundary = CreateBoundaryDescriptor(g_szBoundary, 0);

	BYTE localAdminSID[SECURITY_MAX_SID_SIZE];
	PSID pLocalAdminSID = &localAdminSID;
	DWORD cbSID = sizeof(localAdminSID);

	result = CreateWellKnownSid(WinBuiltinAdministratorsSid,
		NULL, &pLocalAdminSID, &cbSID);

	if (result == FALSE)
	{
		MessageBoxA(NULL, (LPCSTR)"AddSecurityDescriptor Failed %u\r\n", (LPCSTR)"Message", 0);
		hr = S_FALSE;
		return hr;
	}

	result = AddSIDToBoundaryDescriptor(&hBoundary, &pLocalAdminSID);

	if (result == FALSE)
	{
		MessageBoxA(NULL, (LPCSTR)"AddSIDToBoundaryDescriptor failed: %u\r\n", (LPCSTR)"Message", 0);
		GetLastError();
	}

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = FALSE;

	result = ConvertStringSecurityDescriptorToSecurityDescriptor(
		TEXT("D:(A;;GA;;;BA)"),
		SDDL_REVISION_1,
		&sa.lpSecurityDescriptor,
		NULL);

	

}






HRESULT DirectXGPUDigitalLabCoreModule::StartRestricedProcess(HINSTANCE hInstance, HWND hWnd, LPCSTR fName)
{
	HRESULT hr = S_OK;
	if (m_pGPUJobManagementClass)
	{
		hr = m_pGPUJobManagementClass->CreateJobInstance(hInstance, hWnd, fName, 0);
	}
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::InitializeSimulationSystem(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	MessageBoxA(hWnd, (LPCSTR)"Запускаем Среду выполнения экспериментов", (LPCSTR)"Message", 0);
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::ShutdownUserProcessingSession(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK; 


	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownRenderFarmSModule(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownRaytracerRenderingEngine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;

}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownDMOLSimulationAnimation(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}





HRESULT DirectXGPUDigitalLabCoreModule::ShutdownModuleProcessingWidgets(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}







HRESULT DirectXGPUDigitalLabCoreModule::InitializeClientSocket(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	cout << "This function will setup A TCP Server in Windows" << endl;


	DirectXNetworkPacketManagementClass* pNewtworkPacketManager = m_pGPUNetworkModule;

	if (pNewtworkPacketManager == nullptr)
	{
		pNewtworkPacketManager = new DirectXNetworkPacketManagementClass(hInstance, hWnd, pD2DManagementClass,
			m_pStandardAlgorithmExecutor);
	}

	cout << "Launching our tcp Client" << endl;
	hr = pNewtworkPacketManager->CreateNewClientSocket(hInstance, hWnd, 27015);

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeServerSocketRobotCleaner(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;

	cout << "This function will setup A TCP Server in Windows" << endl;


	DirectXNetworkPacketManagementClass* pNewtworkPacketManager = m_pGPUNetworkModule;

	if (pNewtworkPacketManager == nullptr)
	{
		pNewtworkPacketManager = new DirectXNetworkPacketManagementClass(hInstance, hWnd);
	}

	cout << "Launching our tcp server" << endl;
	hr = pNewtworkPacketManager->CreateNewServerSocket(hInstance, hWnd, 27015);

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::InitializeServerSocket(HINSTANCE hInstance, HWND hWND)
{
	HRESULT hr = S_OK;

	cout << "This function will setup A TCP Server in Windows" << endl;


	DirectXNetworkPacketManagementClass* pNewtworkPacketManager = m_pGPUNetworkModule;

	if (pNewtworkPacketManager == nullptr)
	{
		pNewtworkPacketManager = new DirectXNetworkPacketManagementClass(hInstance, hWND);
	}

	cout << "Launching our tcp server" << endl;
	hr = pNewtworkPacketManager->CreateNewServerSocket(hInstance, hWND, 27015);

	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::LogonGPUDigitalLabUser(HWND hWnd, LPCSTR fUserName, LPCSTR fPassword)
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::CreateUserProcessingSession(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::InitializeEventProcessingModule(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateAppicationDomainManagerClass(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateApplicationDomainInstanceClass(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitalizeModuleProcessingWidgets(HINSTANCE hInstance, HWND hWnd)
{

	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateFluidDynamicsAnimation(HINSTANCE hInstance, HWND hWnd, LPCSTR fName)
{

	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::CreateIndustrialSimulationAnimation(HINSTANCE hInstance, HWND hWnd, LPCSTR fProgrammingScript, LPCSTR fDataArchive)
{

	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::CreateDMOLSimulationAnimation(HINSTANCE hInstance, HWND hWnd, LPCSTR fProgrammingScript, LPCSTR fDataArchive)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeRaytracerRenderingEngine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::InitializeRenderToTextureRenderingEngine(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}












HRESULT DirectXGPUDigitalLabCoreModule::ShutdownEventProcessingModule(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownAppicationDomainManagerClass(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownApplicationDomainInstanceClass(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownFluidDynamicsAnimation(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ShutdownIndustrialSimulationAnimation(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT DirectXGPUDigitalLabCoreModule::SimulateComputationalTask(HINSTANCE hInstance, HWND hWnd, LPCSTR address, LPCSTR usernme, LPCSTR password, LPCSTR cloudServeerName)
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::TryBinaryTreeExperiment(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);


	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\HuffmanCodeExperiment.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();
	string 	pCOdeVar;
	char* pMyString = (char*)malloc(80);
	cout << "Enter A New String" << endl;
	fgets(pMyString, 80, stdin);
	char* pOutputString = nullptr;

	string pMyStringVar = string(pMyString);

	cout << "Your Selected String is: " << pMyStringVar << endl;
	imageSegmentationDataFile << "Your Selected String is: " << pMyStringVar << endl;


	size_t pAmountOfZeros = 0;
	size_t pAmountOfOne = 0;
	size_t pAmountOfTwos = 0;
	size_t pAmountOfThrees = 0;
	size_t pAmountOfFours = 0;
	size_t pAmountOfFives = 0;
	size_t pAmountOfSixes = 0;
	size_t pAmountOfSeven = 0;
	size_t pAmountOfEights = 0;
	size_t pAmountOfNines = 0;
	size_t pAmountOfA = 0;
	size_t pAmountOfB = 0;
	size_t pAmountOfC = 0;
	size_t pAmountOfD = 0;
	size_t pAmountOfE = 0;
	size_t pAmountOfF = 0;
	size_t pAmountOfG = 0;
	size_t pAmountOfH = 0;
	size_t pAmountOfI = 0;
	size_t pAmountOfJ = 0;
	size_t pAmountOfK = 0;
	size_t pAmountOfL = 0;
	size_t pAmountOfM = 0;
	size_t pAmountOfN = 0;
	size_t pAmountOfO = 0;
	size_t pAmountOfP = 0;
	size_t pAmountOfQ = 0;
	size_t pAmountOfR = 0;
	size_t pAmountOfS = 0;
	size_t pAmountOfT = 0;
	size_t pAmountOfU = 0;
	size_t pAmountOfV = 0;
	size_t pAmountOfW = 0;
	size_t pAmountOfX = 0;
	size_t pAmountOfY = 0;
	size_t  pAmountOfZ = 0;
	size_t pAmountOfACapital = 0;
	size_t pAmountOfBCapital = 0;
	size_t pAmountOfCCapital = 0;
	size_t pAmountOfDCapital = 0;
	size_t pAmountOfECapital = 0;
	size_t pAmountOfFCapital = 0;
	size_t pAmountOfGCapital = 0;
	size_t pAmountOfHCapital = 0;
	size_t pAmountOfICapital = 0;
	size_t pAmountOfJCapital = 0;
	size_t pAmountOfKCapital = 0;
	size_t pAmountOfLCapital = 0;
	size_t pAmountOfMCapital = 0;
	size_t pAmountOfNCapital = 0;
	size_t pAmountOfOCapital = 0;
	size_t pAmountOfPCapital = 0;
	size_t pAmountOfQCapital = 0;
	size_t pAmountOfRCapital = 0;
	size_t pAmountOfSCapital = 0;
	size_t pAmountOfTCapital = 0;
	size_t pAmountOfUCapital = 0;
	size_t pAmountOfVCapital = 0;
	size_t pAmountOfWCapital = 0;
	size_t  pAmountOfXCapital = 0;
	size_t  pAmountOfYCapital = 0;
	size_t  pAmountOfZCapital = 0;



	size_t pArraySizeOfZeros = std::count(pMyStringVar.begin(), pMyStringVar.end(), '0');
	size_t pArraySizeOfEights = std::count(pMyStringVar.begin(), pMyStringVar.end(), '1');
	size_t pArraySizeOfTwos = std::count(pMyStringVar.begin(), pMyStringVar.end(), '2');
	size_t pArraySizeOfThrees = std::count(pMyStringVar.begin(), pMyStringVar.end(), '3');
	size_t pArraySizeOfFours = std::count(pMyStringVar.begin(), pMyStringVar.end(), '4');
	size_t pArraySizeOfFives = std::count(pMyStringVar.begin(), pMyStringVar.end(), '5');
	size_t pArraySizeOfSix = std::count(pMyStringVar.begin(), pMyStringVar.end(), '6');
	size_t pArraySizeOfSeven = std::count(pMyStringVar.begin(), pMyStringVar.end(), '7');
	size_t pArraySizeOfEight = std::count(pMyStringVar.begin(), pMyStringVar.end(), '8');
	size_t pArraySizeOfNine = std::count(pMyStringVar.begin(), pMyStringVar.end(), '9');
	pAmountOfA = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'a');
	pAmountOfB = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'b');
	pAmountOfC = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'c');
	pAmountOfD = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'd');
	pAmountOfE = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'e');
	pAmountOfF = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'f');
	pAmountOfG = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'g');
	pAmountOfH = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'h');
	pAmountOfI = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'i');
	pAmountOfJ = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'j');
	pAmountOfK = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'k');
	pAmountOfL = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'l');
	pAmountOfM = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'm');
	pAmountOfN = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'n');
	pAmountOfO = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'o');
	pAmountOfP = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'p');
	pAmountOfQ = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'q');
	pAmountOfR = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'r');
	pAmountOfS = std::count(pMyStringVar.begin(), pMyStringVar.end(), 's');
	pAmountOfT = std::count(pMyStringVar.begin(), pMyStringVar.end(), 't');
	pAmountOfU = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'u');
	pAmountOfV = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'v');
	pAmountOfW = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'w');
	pAmountOfX = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'x');
	pAmountOfY = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'y');
	pAmountOfZ = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'z');

	pAmountOfACapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'A');
	pAmountOfBCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'D');
	pAmountOfCCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'C');
	pAmountOfDCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'D');
	pAmountOfECapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'E');
	pAmountOfFCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'F');
	pAmountOfGCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'G');
	pAmountOfHCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'H');
	pAmountOfICapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'I');
	pAmountOfJCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'J');
	pAmountOfKCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'K');
	pAmountOfLCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'L');
	pAmountOfMCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'M');
	pAmountOfNCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'N');
	pAmountOfOCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'O');
	pAmountOfPCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'P');
	pAmountOfQCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'Q');
	pAmountOfRCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'R');
	pAmountOfSCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'S');
	pAmountOfTCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'T');
	pAmountOfUCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'U');
	pAmountOfVCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'V');
	pAmountOfWCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'W');
	pAmountOfXCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'X');
	pAmountOfYCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'Y');
	pAmountOfZCapital = std::count(pMyStringVar.begin(), pMyStringVar.end(), 'Z');



	cout << "0: " << pArraySizeOfZeros << endl;
	cout << "1: " << pArraySizeOfEights << endl;
	cout << "2: " << pArraySizeOfTwos << endl;
	cout << "3: " << pArraySizeOfThrees << endl;
	cout << "4: " << pArraySizeOfFours << endl;
	cout << "5: " << pArraySizeOfFives << endl;
	cout << "6: " << pArraySizeOfSix << endl;
	cout << "7: " << pArraySizeOfSeven << endl;
	cout << "8: " << pArraySizeOfEight << endl;
	cout << "9: " << pArraySizeOfNine << endl;

	std::map<string, size_t> pMyNumberMap;
	pMyNumberMap.insert(std::make_pair("0", (size_t)pArraySizeOfZeros));
	pMyNumberMap.insert(std::make_pair("1", (size_t)pArraySizeOfEights));
	pMyNumberMap.insert(std::make_pair("2", (size_t)pArraySizeOfTwos));
	pMyNumberMap.insert(std::make_pair("3", (size_t)pArraySizeOfThrees));
	pMyNumberMap.insert(std::make_pair("4", (size_t)pArraySizeOfFours));
	pMyNumberMap.insert(std::make_pair("5", (size_t)pArraySizeOfFives));
	pMyNumberMap.insert(std::make_pair("6", (size_t)pArraySizeOfSix));
	pMyNumberMap.insert(std::make_pair("7", (size_t)pArraySizeOfSeven));
	pMyNumberMap.insert(std::make_pair("8", (size_t)pArraySizeOfEight));
	pMyNumberMap.insert(std::make_pair("9", (size_t)pArraySizeOfNine));
	pMyNumberMap.insert(std::make_pair("a", (size_t)pAmountOfA));
	pMyNumberMap.insert(std::make_pair("b", (size_t)pAmountOfB));
	pMyNumberMap.insert(std::make_pair("c", (size_t)pAmountOfC));
	pMyNumberMap.insert(std::make_pair("d", (size_t)pAmountOfD));
	pMyNumberMap.insert(std::make_pair("e", (size_t)pAmountOfE));
	pMyNumberMap.insert(std::make_pair("f", (size_t)pAmountOfF));
	pMyNumberMap.insert(std::make_pair("g", (size_t)pAmountOfG));
	pMyNumberMap.insert(std::make_pair("h", (size_t)pAmountOfH));
	pMyNumberMap.insert(std::make_pair("i", (size_t)pAmountOfI));
	pMyNumberMap.insert(std::make_pair("j", (size_t)pAmountOfJ));
	pMyNumberMap.insert(std::make_pair("k", (size_t)pAmountOfK));
	pMyNumberMap.insert(std::make_pair("l", (size_t)pAmountOfL));
	pMyNumberMap.insert(std::make_pair("m", (size_t)pAmountOfM));
	pMyNumberMap.insert(std::make_pair("n", (size_t)pAmountOfN));
	pMyNumberMap.insert(std::make_pair("o", (size_t)pAmountOfO));
	pMyNumberMap.insert(std::make_pair("p", (size_t)pAmountOfP));
	pMyNumberMap.insert(std::make_pair("q", (size_t)pAmountOfQ));
	pMyNumberMap.insert(std::make_pair("r", (size_t)pAmountOfR));
	pMyNumberMap.insert(std::make_pair("s", (size_t)pAmountOfS));
	pMyNumberMap.insert(std::make_pair("t", (size_t)pAmountOfT));
	pMyNumberMap.insert(std::make_pair("u", (size_t)pAmountOfU));
	pMyNumberMap.insert(std::make_pair("v", (size_t)pAmountOfV));
	pMyNumberMap.insert(std::make_pair("w", (size_t)pAmountOfW));
	pMyNumberMap.insert(std::make_pair("x", (size_t)pAmountOfX));
	pMyNumberMap.insert(std::make_pair("y", (size_t)pAmountOfY));
	pMyNumberMap.insert(std::make_pair("z", (size_t)pAmountOfZ));
	pMyNumberMap.insert(std::make_pair("A", (size_t)pAmountOfACapital));
	pMyNumberMap.insert(std::make_pair("B", (size_t)pAmountOfBCapital));
	pMyNumberMap.insert(std::make_pair("C", (size_t)pAmountOfCCapital));
	pMyNumberMap.insert(std::make_pair("D", (size_t)pAmountOfDCapital));
	pMyNumberMap.insert(std::make_pair("E", (size_t)pAmountOfECapital));
	pMyNumberMap.insert(std::make_pair("F", (size_t)pAmountOfFCapital));
	pMyNumberMap.insert(std::make_pair("G", (size_t)pAmountOfGCapital));
	pMyNumberMap.insert(std::make_pair("H", (size_t)pAmountOfHCapital));
	pMyNumberMap.insert(std::make_pair("I", (size_t)pAmountOfICapital));
	pMyNumberMap.insert(std::make_pair("J", (size_t)pAmountOfJCapital));
	pMyNumberMap.insert(std::make_pair("K", (size_t)pAmountOfKCapital));
	pMyNumberMap.insert(std::make_pair("L", (size_t)pAmountOfLCapital));
	pMyNumberMap.insert(std::make_pair("M", (size_t)pAmountOfMCapital));
	pMyNumberMap.insert(std::make_pair("N", (size_t)pAmountOfNCapital));
	pMyNumberMap.insert(std::make_pair("O", (size_t)pAmountOfOCapital));
	pMyNumberMap.insert(std::make_pair("P", (size_t)pAmountOfPCapital));
	pMyNumberMap.insert(std::make_pair("Q", (size_t)pAmountOfQCapital));
	pMyNumberMap.insert(std::make_pair("R", (size_t)pAmountOfRCapital));
	pMyNumberMap.insert(std::make_pair("S", (size_t)pAmountOfSCapital));
	pMyNumberMap.insert(std::make_pair("T", (size_t)pAmountOfTCapital));
	pMyNumberMap.insert(std::make_pair("U", (size_t)pAmountOfUCapital));
	pMyNumberMap.insert(std::make_pair("V", (size_t)pAmountOfVCapital));
	pMyNumberMap.insert(std::make_pair("W", (size_t)pAmountOfWCapital));
	pMyNumberMap.insert(std::make_pair("X", (size_t)pAmountOfXCapital));
	pMyNumberMap.insert(std::make_pair("Y", (size_t)pAmountOfYCapital));
	pMyNumberMap.insert(std::make_pair("Z", (size_t)pAmountOfZCapital));

	


	for (auto pIterator = std::begin(pMyNumberMap); pIterator != std::end(pMyNumberMap); ++pIterator)
	{
		if (pIterator->second != 0)
		{
			cout << "Value: " << pIterator->first << "Key: " << pIterator->second << endl;
			imageSegmentationDataFile << "Value: " << pIterator->first << "Key: " << pIterator->second << endl;

		}

	}

	imageSegmentationDataFile.close();

	return hr;

}



HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundariesWithVideoCapture(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;



	HMONITOR monitor = MonitorFromWindow(hWnd, MONITOR_DEFAULTTOPRIMARY);
	MONITORINFO info;
	info.cbSize = sizeof(MONITORINFO);
	GetMonitorInfo(monitor, &info);
	int monitorWidth = info.rcMonitor.right - info.rcMonitor.left;
	int monitorHeight = info.rcMonitor.bottom - info.rcMonitor.top;
	float pCentreX =  monitorWidth / 2;
	float pCentreY = monitorHeight / 2;

	cout << "Monitor Centre Coordinates: " << endl;
	cout << "X = " << pCentreX << endl;
	cout << "Y = " << pCentreY << endl;

	pixelDataFile << "Monitor Centre Coordinates: " << endl;
	pixelDataFile << "X = " << pCentreX << endl;
	pixelDataFile << "Y = " << pCentreY << endl;


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;

	int pHourValue0 = 0;
	int pMinuteValue0 = 0;
	int pHourValue1 = 0;
	int pMinuteValue1 = 0;

	cout << "Enter the hour to execute the timer for session one" << endl;
	cin >> pHourValue0;
	cout << "Enter the minute to execute the timer for session one " << endl;
	cin >> pMinuteValue0;

	UINT pRecordingTimeInSeconds = 0;
	UINT pWaitingIntervalInSeconds = 0;

	cout << "Enter the Lengh Of The Recoring In Seconds" << endl;
	cin >> pRecordingTimeInSeconds;

	cout << "Enter the Length of the Waiting Interval In Seconds" << endl;
	cin >> pWaitingIntervalInSeconds;



	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;





		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


	

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, constants::pSpatialShapeImageOne, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
									cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
									cout << "X Position: " << pixelObject.xPosition << endl;
									cout << "Y Position: " << pixelObject.yPosition << endl;
									cout << "Red Value: " << pixelObject.RMask << endl;
									cout << "Green Value: " << pixelObject.GMask << endl;
									cout << "Blue Value: " << pixelObject.BMask << endl;

									pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
									pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
									pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
									pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
									pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
									pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, constants::pSpatialShapeImageOne, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;


			for (PixelObject pixelObject : pixelObjectVectorY)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
									cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
									cout << "X Position: " << pixelObject.xPosition << endl;
									cout << "Y Position: " << pixelObject.yPosition << endl;
									cout << "Red Value: " << pixelObject.RMask << endl;
									cout << "Green Value: " << pixelObject.GMask << endl;
									cout << "Blue Value: " << pixelObject.BMask << endl;

									pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
									pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
									pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
									pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
									pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
									pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}


			}

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}
		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObjectUsingClipperWithFileNames(hInstance, hWnd,
				constants::pSpatialShapeImageOne,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX);
		}



		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;




		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorExact(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pixelObjectVectorX, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;


		float pColorSum = 0.0f;
		for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
		{

					cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
					cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
					cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
					cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
					cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
					cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


					pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
					pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
					pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
					pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
					pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
					pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
					pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




		}

		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassOneLabel,
			pOutputFilterResult,
			&pClassOnePixelArray);

		for (PixelObject pixelObject : pClassOnePixelArray)
		{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Restoring Class 2 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 2 RGB Pixels Data" << endl;


		GetSystemTime(&classTwoRestorationSystem);
		GetLocalTime(&classTwoRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;



		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassTwoLabel,
			pOutputFilterResult,
			&pClassTwoPixelArray);

		for (PixelObject pixelObject : pClassTwoPixelArray)
		{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}




		vector<PixelObject> pClassThreePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassThreeLabel,
			pOutputFilterResult,
			&pClassThreePixelArray);

		for (PixelObject pixelObject : pClassThreePixelArray)
		{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintAreaOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintAreaTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);
		wstring  pTextToPrintClassOneCM = L"Class One Pixel Area in centimeters  = " + std::to_wstring(pImageSizeInCentimeters0);
		wstring  pTextToPrintClassTwoCM = L"Class Two Pixel Area in centimeters  = " + std::to_wstring(pImageSizeInCentimeters1);

		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;

		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintAreaOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintAreaTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		vector<WCHAR*> pMessageArray = vector<WCHAR*>();
		pMessageArray.push_back((WCHAR*)pTextToPrintAreaOne.c_str());
		pMessageArray.push_back((WCHAR*)pTextToPrintAreaTwo.c_str());
	//	pMessageArray.push_back((WCHAR*)pTextToPrintClassOneCM.c_str);
		pMessageArray.push_back((WCHAR*)pTextToPrintClassTwoCM.c_str());

		



		md2dmanager->DrawMessageArray(hInstance, hWnd, pMessageArray, 16);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;

		pixelDataFile.close();
		return hr;
	}





HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundaries(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;

	
	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;



	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path1;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;



	if (GetOpenFileNameW(&ofn))
	{
		pFileItem = ofn.lpstrFile;

		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		LPWSTR pSelectedFile = ofn.lpstrFile;

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 
		
			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, pFileItem, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
	//				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
	//				cout << "X Position: " << pixelObject.xPosition << endl;
	//				cout << "Y Position: " << pixelObject.yPosition << endl;
	//				cout << "Red Value: " << pixelObject.RMask << endl;
	//				cout << "Green Value: " << pixelObject.GMask << endl;
	//				cout << "Blue Value: " << pixelObject.BMask << endl;

	//				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
	//				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
	//				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
	//				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
	//				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
	//				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, pFileItem, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}
		

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}
		
		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObjectWithStageRecording(hInstance, hWnd,
				(LPCSTR)ofn.lpstrFile,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX, &pClippingStageVector);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;




		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorX, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;


		float pColorSum = 0.0f;
		for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
		{

			cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
					cout << "X Position: " << pValidationItem.xPosition << endl;
			cout << "Y Position: " << pValidationItem.yPosition << endl;
			cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
			cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
			cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
			cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


			pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
			pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
			pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
			pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
			pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
			pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
			pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




		}

		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassOneLabel,
			pOutputFilterResult,
			&pClassOnePixelArray);

		for (PixelObject pixelObject : pClassOnePixelArray)
		{

			cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			cout << "X Position: " << pixelObject.xPosition << endl;
			cout << "Y Position: " << pixelObject.yPosition << endl;
			cout << "Red Value: " << pixelObject.RMask << endl;
			cout << "Green Value: " << pixelObject.GMask << endl;
			cout << "Blue Value: " << pixelObject.BMask << endl;

			pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Restoring Class 2 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 2 RGB Pixels Data" << endl;


		GetSystemTime(&classTwoRestorationSystem);
		GetLocalTime(&classTwoRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;



		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassTwoLabel,
			pOutputFilterResult,
			&pClassTwoPixelArray);

		for (PixelObject pixelObject : pClassTwoPixelArray)
		{

		//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	cout << "X Position: " << pixelObject.xPosition << endl;
		//	cout << "Y Position: " << pixelObject.yPosition << endl;
		//	cout << "Red Value: " << pixelObject.RMask << endl;
		//	cout << "Green Value: " << pixelObject.GMask << endl;
		//	cout << "Blue Value: " << pixelObject.BMask << endl;

		//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}




		vector<PixelObject> pClassThreePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassThreeLabel,
			pOutputFilterResult,
			&pClassThreePixelArray);

		for (PixelObject pixelObject : pClassThreePixelArray)
		{

		//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	cout << "X Position: " << pixelObject.xPosition << endl;
		//	cout << "Y Position: " << pixelObject.yPosition << endl;
		//	cout << "Red Value: " << pixelObject.RMask << endl;
		//	cout << "Green Value: " << pixelObject.GMask << endl;
		//	cout << "Blue Value: " << pixelObject.BMask << endl;

		//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


	
		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);
		
		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);
		
	
		md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
			pOutputText1, 32);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile  << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;

	}
	pixelDataFile.close();
	return hr;
}












HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundariesSeparateRecoveries(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;



	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path1;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;



	if (GetOpenFileNameW(&ofn))
	{
		pFileItem = ofn.lpstrFile;

		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		LPWSTR pSelectedFile = ofn.lpstrFile;

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1,  &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorX)
				{

					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}



				}
			}
			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY,  &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}

		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObjectWithStageRecording(hInstance, hWnd,
				(LPCSTR)ofn.lpstrFile,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX, &pClippingStageVector);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;



		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();


		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorX, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;

		if (SUCCEEDED(hr))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance, hWnd,
				pClassOneLabel,
				pOutputFilterResult,
				&pClassOnePixelArray);
		}

		if (SUCCEEDED(hr) && (pClassOnePixelArray.size() < (pOutputFilterResult.size() - 1)))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance, hWnd,
				pClassTwoLabel,
				pOutputFilterResult,
				&pClassTwoPixelArray);
		}

		float pColorSum = 0.0f;
		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
			{

				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


				pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
				pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
				pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
				pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




			}
		}
		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassOnePixelArray)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}



		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassTwoPixelArray)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}


	


		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);

		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
			pOutputText1, 32);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;

	}
	pixelDataFile.close();
	return hr;
}






HRESULT DirectXGPUDigitalLabCoreModule::ValidatePairOfImagesUsingDescriptorAndCompareTheirResults(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();


	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();
	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();
	vector<PixelObject> pImageTwoVectorX = vector<PixelObject>();
	vector<PixelObject> pImageTwoVectorY = vector<PixelObject>();

	vector<OutputPixelObjectDescriptor> pOutputPixelObjectVectorOne = vector<OutputPixelObjectDescriptor>();
	vector<OutputPixelObjectDescriptor> pOutputPixelObjectVectorTwo = vector <OutputPixelObjectDescriptor>();

	vector<PixelObject> pClassOnePixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pClassOnePixelObjectVectorTwo = vector<PixelObject>();

	vector<PixelObject> pClassTwoPixelObjectVectorOne = vector<PixelObject>();
	vector<PixelObject> pClassTwoPixelObjectVectorTwo = vector<PixelObject>();


	vector<OutputPixelBufferRGB> pComparisonOneOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pComparisonOneIdenticalBuffer = vector<PixelObject>();
	vector<PixelObject> pComparisonOneDifferentBuffer = vector<PixelObject>();


	vector<OutputPixelBufferRGB> pComparisonTwoOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pComparisonTwoIdenticalBuffer = vector<PixelObject>();
	vector<PixelObject> pComparisonTwoDifferentBuffer = vector<PixelObject>();



	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResultOne = vector<OutputPixelObjectDescriptor>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResultTwo = vector<OutputPixelObjectDescriptor>();
	vector<PixelObject> pOutputClassOneImageOne = vector<PixelObject>();
	vector<PixelObject> pOutputClassTwoImageOne = vector<PixelObject>();
	vector<PixelObject> pOutputClassOneImageTwo = vector<PixelObject>();
	vector<PixelObject> pOutputClassTwoImageTwo = vector<PixelObject>();


	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();




	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;




		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


	
		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorX)
				{

					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}



				}
			}
			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}

			else if ((pStepX == 1) && (pStepY == 1))
			{
				hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd,
					pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX);
			}

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());
			


			vector<PixelObject> pImageTwoVectorX = vector<PixelObject>();
			vector<PixelObject> pImageTwoVectorY = vector<PixelObject>();


			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, &pImageTwoVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

		 pIndex = 0;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pImageTwoVectorX)
				{

					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

					}



				}
			}
			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStep(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, &pImageTwoVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pImageTwoVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		


			vector<PixelObject>::iterator pVectorOneIt0 = pImageTwoVectorX.end();
			pImageTwoVectorX.insert(pVectorOneIt0, pImageTwoVectorY.begin(), pImageTwoVectorY.end());



		}

		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pImageTwoVectorX);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;



	hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorX, &pOutputFilterResultOne);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;

		if (SUCCEEDED(hr))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance, hWnd,
				pClassOneLabel,
				pOutputFilterResultOne,
				&pClassOnePixelObjectVectorOne);
		}

		if (SUCCEEDED(hr) && (pClassOnePixelObjectVectorOne.size() < (pOutputFilterResultOne.size() - 1)))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance, hWnd,
				pClassTwoLabel,
				pOutputFilterResultOne,
				&pClassOnePixelObjectVectorTwo);
		}

		float pColorSum = 0.0f;
		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResultOne)
			{

				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


				pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
				pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
				pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
				pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




			}
		}
		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassOnePixelObjectVectorOne)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}



		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassTwoPixelObjectVectorOne)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}





		cout << "Amount of Class 1 Pixels = " << pClassOnePixelObjectVectorOne.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelObjectVectorOne.size() << endl;

		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelObjectVectorOne.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelObjectVectorOne.size() << endl;




		cout << "Parsing Second Vector Object" << endl;
		pixelDataFile << "Parsing Second Vector Object" << endl;




		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pImageTwoVectorX, &pOutputFilterResultTwo);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

	pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		pIndexValue = 0;

		 ppAmountOfClassOnePixels = 0;
		ppAmountOfClassTwoPixels = 0;

		if (SUCCEEDED(hr))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance, hWnd,
				pClassOneLabel,
				pOutputFilterResultTwo,
				&pClassOnePixelObjectVectorTwo);
		}

		if (SUCCEEDED(hr) && (pClassTwoPixelObjectVectorOne.size() < (pOutputFilterResultTwo.size() - 1)))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance, hWnd,
				pClassTwoLabel,
				pOutputFilterResultTwo,
				&pClassTwoPixelObjectVectorTwo);
		}

	 pColorSum = 0.0f;
		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResultTwo)
			{

				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


				pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
				pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
				pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
				pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




			}
		}


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassOnePixelObjectVectorOne)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}



		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassTwoPixelObjectVectorOne)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}

		int pAmountOfIdenticalPixelsOne = 0;
		int pAmountOfDifferentPixelsOne = 0;
		int pAmountOfIdenticalPixelsTwo = 0;
		int pAmountOfDifferentPixelsTwo = 0;


		vector<OutputPixelBufferRGB> pOutputArrayOneRGB = vector<OutputPixelBufferRGB>();
		vector<OutputPixelBufferRGB> pOutputArrayTwoRGB = vector<OutputPixelBufferRGB>();
		vector<PixelObject> pIdenticalArrayOneRGB = vector<PixelObject>();
		vector<PixelObject> pIdenticalArrayTwoRGB = vector<PixelObject>();
		vector<PixelObject> pDifferentArrayOneRGB = vector<PixelObject>();
		vector<PixelObject> pDifferentArrayTwoRGB = vector<PixelObject>();





		float pImageOneIntensitySumRedVar0 = 0.0f;
		float pImageOneIntensitySumGreenVar0 = 0.0f;
		float pImageOneIntensitySumBlueVar0 = 0.0f;
		float pImageOneIntensityAverageRedVar0 = 0.0f;
		float pImageOneIntensityAverageGreenVar0 = 0.0f;
		float pImageOneIntensityAverageBlueVar0 = 0.0f;

		float pImageTwoIntensitySumRedVar0 = 0.0f;
		float pImageTwoIntensitySumGreenVar0 = 0.0f;
		float pImageTwoIntensitySumBlueVar0 = 0.0f;
		float pImageTwoIntensityAverageRedVar0 = 0.0f;
		float pImageTwoIntensityAverageGreenVar0 = 0.0f;
		float pImageTwoIntensityAverageBlueVar0 = 0.0f;

		float pOutputArrayIntensitySumRedVar0 = 0.0f;
		float pOutputArrayIntensitySumGreenVar0 = 0.0f;
		float pOutputArrayIntensitySumBlueVar0 = 0.0f;
		float pOutputArrayIntensityAverageRedVar0 = 0.0f;
		float pOutputArrayIntensityAverageGreenVar0 = 0.0f;
		float pOutputArrayIntensityAverageBlueVar0 = 0.0f;

		float pIdenticalArrayIntensitySumRedVar0 = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar0 = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar0 = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar0 = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar0 = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar0 = 0.0f;

		float pDifferentArrayIntensitySumRedVar0 = 0.0f;
		float pDifferentArrayIntensitySumGreenVar0 = 0.0f;
		float pDifferentArrayIntensitySumBlueVar0 = 0.0f;
		float pDifferentArrayIntensityAverageRedVar0 = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar0 = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar0 = 0.0f;

		BOOL pAreImagesIdentical0 = FALSE;




		float pImageOneIntensitySumRedVar1 = 0.0f;
		float pImageOneIntensitySumGreenVar1 = 0.0f;
		float pImageOneIntensitySumBlueVar1 = 0.0f;
		float pImageOneIntensityAverageRedVar1 = 0.0f;
		float pImageOneIntensityAverageGreenVar1 = 0.0f;
		float pImageOneIntensityAverageBlueVar1 = 0.0f;

		float pImageTwoIntensitySumRedVar1 = 0.0f;
		float pImageTwoIntensitySumGreenVar1 = 0.0f;
		float pImageTwoIntensitySumBlueVar1 = 0.0f;
		float pImageTwoIntensityAverageRedVar1 = 0.0f;
		float pImageTwoIntensityAverageGreenVar1 = 0.0f;
		float pImageTwoIntensityAverageBlueVar1 = 0.0f;

		float pOutputArrayIntensitySumRedVar1 = 0.0f;
		float pOutputArrayIntensitySumGreenVar1 = 0.0f;
		float pOutputArrayIntensitySumBlueVar1 = 0.0f;
		float pOutputArrayIntensityAverageRedVar1 = 0.0f;
		float pOutputArrayIntensityAverageGreenVar1 = 0.0f;
		float pOutputArrayIntensityAverageBlueVar1 = 0.0f;

		float pIdenticalArrayIntensitySumRedVar1 = 0.0f;
		float pIdenticalArrayIntensitySumGreenVar1 = 0.0f;
		float pIdenticalArrayIntensitySumBlueVar1 = 0.0f;
		float pIdenticalArrayIntensityAverageRedVar1 = 0.0f;
		float pIdenticalArrayIntensityAverageGreenVar1 = 0.0f;
		float pIdenticalArrayIntensityAverageBlueVar1 = 0.0f;

		float pDifferentArrayIntensitySumRedVar1 = 0.0f;
		float pDifferentArrayIntensitySumGreenVar1 = 0.0f;
		float pDifferentArrayIntensitySumBlueVar1 = 0.0f;
		float pDifferentArrayIntensityAverageRedVar1 = 0.0f;
		float pDifferentArrayIntensityAverageGreenVar1 = 0.0f;
		float pDifferentArrayIntensityAverageBlueVar1 = 0.0f;

		BOOL pAreImagesIdentical1 = FALSE;

		cout << "Comparing Class One BUffers" << endl;
		pixelDataFile << "Comparing Class One BUffers" << endl;



		hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance,
			hWnd, pImageWidth,
			pImageHeight,
			pClassOnePixelObjectVectorOne,
			pClassOnePixelObjectVectorTwo,
			&pAmountOfIdenticalPixelsOne,
			&pAmountOfDifferentPixelsOne,
			&pOutputArrayOneRGB,
			&pIdenticalArrayOneRGB,
			&pDifferentArrayOneRGB,
			&pImageOneIntensitySumRedVar0,
			&pImageOneIntensitySumGreenVar0,
			&pImageOneIntensitySumBlueVar0,
			&pImageTwoIntensitySumRedVar0,
			&pImageTwoIntensitySumGreenVar0,
			&pImageTwoIntensitySumBlueVar0,
			&pOutputArrayIntensitySumRedVar0,
			&pOutputArrayIntensitySumGreenVar0,
			&pOutputArrayIntensitySumBlueVar0,
			&pIdenticalArrayIntensitySumRedVar0,
			&pIdenticalArrayIntensitySumGreenVar0,
			&pIdenticalArrayIntensitySumBlueVar0,
			&pDifferentArrayIntensitySumRedVar0,
			&pDifferentArrayIntensitySumGreenVar0,
			&pDifferentArrayIntensitySumBlueVar0,
			&pImageOneIntensityAverageRedVar0,
			&pImageOneIntensityAverageGreenVar0,
			&pImageOneIntensityAverageBlueVar0,
			&pImageTwoIntensityAverageRedVar0,
			&pImageTwoIntensityAverageGreenVar0,
			&pImageTwoIntensityAverageBlueVar0,
			&pOutputArrayIntensityAverageRedVar0,
			&pOutputArrayIntensityAverageGreenVar0,
			&pOutputArrayIntensityAverageBlueVar0,
			&pIdenticalArrayIntensityAverageRedVar0,
			&pIdenticalArrayIntensityAverageGreenVar0,
			&pIdenticalArrayIntensityAverageBlueVar0,
			&pDifferentArrayIntensityAverageRedVar0,
			&pDifferentArrayIntensityAverageGreenVar0,
			&pDifferentArrayIntensityAverageBlueVar0,
			&pAreImagesIdentical0);


		cout << "Comparing Class Two BUffers" << endl;
		pixelDataFile << "Comparing Class Two BUffers" << endl;



		hr = ppStandardAlgorithmExecutor->CheckIfImagesAreIdenticalRGBThreaded(hInstance,
			hWnd, pImageWidth,
			pImageHeight,
			pClassTwoPixelObjectVectorOne,
			pClassTwoPixelObjectVectorTwo,
			&pAmountOfIdenticalPixelsOne,
			&pAmountOfDifferentPixelsOne,
			&pOutputArrayOneRGB,
			&pIdenticalArrayTwoRGB,
			&pDifferentArrayTwoRGB,
			&pImageOneIntensitySumRedVar1,
			&pImageOneIntensitySumGreenVar1,
			&pImageOneIntensitySumBlueVar1,
			&pImageTwoIntensitySumRedVar1,
			&pImageTwoIntensitySumGreenVar1,
			&pImageTwoIntensitySumBlueVar1,
			&pOutputArrayIntensitySumRedVar1,
			&pOutputArrayIntensitySumGreenVar1,
			&pOutputArrayIntensitySumBlueVar1,
			&pIdenticalArrayIntensitySumRedVar1,
			&pIdenticalArrayIntensitySumGreenVar1,
			&pIdenticalArrayIntensitySumBlueVar1,
			&pDifferentArrayIntensitySumRedVar1,
			&pDifferentArrayIntensitySumGreenVar1,
			&pDifferentArrayIntensitySumBlueVar1,
			&pImageOneIntensityAverageRedVar1,
			&pImageOneIntensityAverageGreenVar1,
			&pImageOneIntensityAverageBlueVar1,
			&pImageTwoIntensityAverageRedVar1,
			&pImageTwoIntensityAverageGreenVar1,
			&pImageTwoIntensityAverageBlueVar1,
			&pOutputArrayIntensityAverageRedVar1,
			&pOutputArrayIntensityAverageGreenVar1,
			&pOutputArrayIntensityAverageBlueVar1,
			&pIdenticalArrayIntensityAverageRedVar1,
			&pIdenticalArrayIntensityAverageGreenVar1,
			&pIdenticalArrayIntensityAverageBlueVar1,
			&pDifferentArrayIntensityAverageRedVar1,
			&pDifferentArrayIntensityAverageGreenVar1,
			&pDifferentArrayIntensityAverageBlueVar1,
			&pAreImagesIdentical1);

		cout << "Printing Data for Simulation One " << endl;
		pixelDataFile << "Printing Data for Simulation One " << endl;


		for (OutputPixelBufferRGB pOutputPixelValue : pOutputArrayOneRGB)
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pixelDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pixelDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pixelDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pixelDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pixelDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pixelDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pixelDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pixelDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pixelDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pixelDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pixelDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pixelDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pixelDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pixelDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;



		}

		cout << "Printing the output of Identical Pixel Vector" << endl;
		pixelDataFile << "Printing the output of Identical Pixel Vector" << endl;

		for (PixelObject pPixelObject : pIdenticalArrayOneRGB)
		{




			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green Component: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.BMask << endl;




		}


		cout << "Printing the output of Different Pixel Vector" << endl;
		pixelDataFile << "Printing the output of Different Pixel Vector" << endl;



		for (PixelObject pPixelObject : pDifferentArrayTwoRGB)
		{




			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red Component: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green Component: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue Component: " << pPixelObject.BMask << endl;




		}


		cout << "Printing Data for Simulation One " << endl;
		pixelDataFile << "Printing Data for Simulation One " << endl;


		for (OutputPixelBufferRGB pOutputPixelValue : pOutputArrayTwoRGB)
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image Two Red CompTwont: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red CompTwont: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image Two Green CompTwont: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green CompTwont: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image Two Blue CompTwont: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue CompTwont: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pixelDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pixelDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pixelDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pixelDataFile << "Image Two Red CompTwont: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pixelDataFile << "Image Two Red CompTwont: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pixelDataFile << "Image Two Green CompTwont: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pixelDataFile << "Image Two Green CompTwont: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pixelDataFile << "Image Two Blue CompTwont: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pixelDataFile << "Image Two Blue CompTwont: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pixelDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pixelDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pixelDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pixelDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pixelDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pixelDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;



		}

		cout << "Printing the output of Identical Pixel Vector" << endl;
		pixelDataFile << "Printing the output of Identical Pixel Vector" << endl;

		for (PixelObject pPixelObject : pIdenticalArrayTwoRGB)
		{




			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red CompTwont: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green CompTwont: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue CompTwont: " << pPixelObject.BMask << endl;




		}


		cout << "Printing the output of Different Pixel Vector" << endl;
		pixelDataFile << "Printing the output of Different Pixel Vector" << endl;



		for (PixelObject pPixelObject : pDifferentArrayTwoRGB)
		{




			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



			pixelDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			pixelDataFile << "X Position: " << pPixelObject.xPosition << endl;
			pixelDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			pixelDataFile << "Red CompTwont: " << pPixelObject.RMask << endl;
			pixelDataFile << "Green CompTwont: " << pPixelObject.GMask << endl;
			pixelDataFile << "Blue CompTwont: " << pPixelObject.BMask << endl;




		}

		cout << "Printing Array Sizes " << endl;
		cout << "Output Array One Size = " << pOutputArrayOneRGB.size() << endl;
		cout << "Identical Array One Size = " << pIdenticalArrayOneRGB.size() << endl;
		cout << "Different Array One Size = " << pDifferentArrayOneRGB.size() << endl;


		cout << "Output Array Two Size = " << pOutputArrayTwoRGB.size() << endl;
		cout << "Identical Array Two Size = " << pIdenticalArrayTwoRGB.size() << endl;
		cout << "Different Array Two Size = " << pDifferentArrayTwoRGB.size() << endl;


		pixelDataFile << "Printing Array Sizes " << endl;
		pixelDataFile << "Output Array One Size = " << pOutputArrayOneRGB.size() << endl;
		pixelDataFile << "Identical Array One Size = " << pIdenticalArrayOneRGB.size() << endl;
		pixelDataFile << "Different Array One Size = " << pDifferentArrayOneRGB.size() << endl;


		pixelDataFile << "Output Array Two Size = " << pOutputArrayTwoRGB.size() << endl;
		pixelDataFile << "Identical Array Two Size = " << pIdenticalArrayTwoRGB.size() << endl;
		pixelDataFile << "Different Array Two Size = " << pDifferentArrayTwoRGB.size() << endl;

		pixelDataFile.close();
		return hr;

	}






HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundariesSeparateRecoveriesThreaded(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptorThreaded.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;



	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path1;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;



	if (GetOpenFileNameW(&ofn))
	{
		pFileItem = ofn.lpstrFile;

		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		LPWSTR pSelectedFile = ofn.lpstrFile;

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, pFileItem, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					//				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				cout << "X Position: " << pixelObject.xPosition << endl;
					//				cout << "Y Position: " << pixelObject.yPosition << endl;
					//				cout << "Red Value: " << pixelObject.RMask << endl;
					//				cout << "Green Value: " << pixelObject.GMask << endl;
					//				cout << "Blue Value: " << pixelObject.BMask << endl;

					//				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					//				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					//				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					//				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					//				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, pFileItem, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}

		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObjectWithStageRecording(hInstance, hWnd,
				(LPCSTR)ofn.lpstrFile,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX, &pClippingStageVector);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;



		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();


		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriersThreaded(hInstance,
			hWnd, pImageWidth,
			pImageHeight,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorX, &pOutputFilterResult,
			&pClassOnePixelArray,
			&pClassTwoPixelArray);





		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);

		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
			pOutputText1, 32);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;

	}
	pixelDataFile.close();
	return hr;
}




HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundariesSeparateRecoveriesSubtraction(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptorSubtraction> pOutputFilterResult = vector<OutputPixelObjectDescriptorSubtraction>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;



	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path1;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;



	if (GetOpenFileNameW(&ofn))
	{
		pFileItem = ofn.lpstrFile;

		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		LPWSTR pSelectedFile = ofn.lpstrFile;

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, pFileItem, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					//				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				cout << "X Position: " << pixelObject.xPosition << endl;
					//				cout << "Y Position: " << pixelObject.yPosition << endl;
					//				cout << "Red Value: " << pixelObject.RMask << endl;
					//				cout << "Green Value: " << pixelObject.GMask << endl;
					//				cout << "Blue Value: " << pixelObject.BMask << endl;

					//				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					//				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					//				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					//				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					//				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, pFileItem, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}

		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObjectWithStageRecording(hInstance, hWnd,
				(LPCSTR)ofn.lpstrFile,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX, &pClippingStageVector);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;



		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();


		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorSubtraction(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pixelObjectVectorX, &pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;

		if (SUCCEEDED(hr))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClassSubtraction(hInstance, hWnd,
				pClassOneLabel,
				pOutputFilterResult,
				&pClassOnePixelArray);
		}

		if (SUCCEEDED(hr) && (pClassOnePixelArray.size() < (pOutputFilterResult.size() - 1)))
		{
			hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClassSubtraction(hInstance, hWnd,
				pClassTwoLabel,
				pOutputFilterResult,
				&pClassTwoPixelArray);
		}

		float pColorSum = 0.0f;
		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (OutputPixelObjectDescriptorSubtraction pValidationItem : pOutputFilterResult)
			{

				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


				pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
				pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
				pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
				pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




			}
		}
		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassOnePixelArray)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}



		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pClassTwoPixelArray)
			{

				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				cout << "X Position: " << pixelObject.xPosition << endl;
				cout << "Y Position: " << pixelObject.yPosition << endl;
				cout << "Red Value: " << pixelObject.RMask << endl;
				cout << "Green Value: " << pixelObject.GMask << endl;
				cout << "Blue Value: " << pixelObject.BMask << endl;

				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



			}

		}





		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);

		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
			pOutputText1, 32);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;

	}
	pixelDataFile.close();
	return hr;
}


HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorClosedMode(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;


	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;



	// Show the File Open dialog.
	wchar_t path1[MAX_PATH];
	path1[0] = L'\0';

	OPENFILENAMEW ofn;
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"Windows Media\0*.wmv;*.wma;*.asf\0MP3\0*.mp3\0All files\0*.*\0";
	ofn.lpstrFile = path1;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_FILEMUSTEXIST;
	ofn.hInstance = hInstance;



	if (GetOpenFileNameW(&ofn))
	{
		pFileItem = ofn.lpstrFile;

		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		LPWSTR pSelectedFile = ofn.lpstrFile;

		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, pStepX, 1, pFileItem, &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					//				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				cout << "X Position: " << pixelObject.xPosition << endl;
					//				cout << "Y Position: " << pixelObject.yPosition << endl;
					//				cout << "Red Value: " << pixelObject.RMask << endl;
					//				cout << "Green Value: " << pixelObject.GMask << endl;
					//				cout << "Blue Value: " << pixelObject.BMask << endl;

					//				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					//				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					//				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					//				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					//				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, pFileItem, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}

		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObjectWithStageRecording(hInstance, hWnd,
				(LPCSTR)ofn.lpstrFile,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX, &pClippingStageVector);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


		int pClassOneLabel = 1;
		int pClassTwoLabel = 2;
		int pClassThreeLabel = 3;

		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();



		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriersClosedMode(hInstance, hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorX, &pOutputFilterResult,
			&pClassOnePixelArray,
			&pClassTwoPixelArray);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;


		float pColorSum = 0.0f;
		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
			{

				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


				pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
				pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
				pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
				pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




			}
		}
		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);

		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
			pOutputText1, 32);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;

	}
	pixelDataFile.close();
	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundariesSeparateRecoveriesWithSpecifiedThreadSize(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;

	int pClassOneLabel = 0;
	int pClassTwoLabel = 0;
	int pClassThreeLabel = 0;



	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;

	UINT pThreadSizeVar = 0;
	cout << "Specify the amount of threads for shader EXECTUTON" << endl;
	cin >> pThreadSizeVar;

	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	cout << "Thresold Value = " << pThresoldValue << endl;
	cout << "Amount of Threads for Shader Execution  = " << pThreadSizeVar << endl;

	pixelDataFile << "Thresold Value = " << pThresoldValue << endl;
	pixelDataFile << "Amount of Threads for Shader Execution  = " << pThreadSizeVar << endl;



	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;


	pFileItem = constants::pDescriptorImage;

	bool pResult = false;
	pResult = PathFileExists(pFileItem);

	if (pResult == false)
	{
		cout << "Attention File Not Found" << endl;
		MessageBoxA(NULL, (LPCSTR)L"Ошибка Файл в Директории не найден", (LPCSTR)"Error", 0);
		pixelDataFile.close();
		return hr;
	}

	vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
	vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


	Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

	pixelDataFile << "New Image Clip" << endl;



	if ((pStepX > 1) && (pStepY > 1))
	{

		pixelDataFile << "New Image Clip" << endl;

		// Get starting timepoint 

		// Call the function, here sort() 

		// Get ending timepoint 

		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		pixelDataFile << "New Image Clip" << endl;


		cout << "Performing Image Scan Eight Cliing X" << endl;
		pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
			hWnd, pMinimumX, pMinimumY, pImageWidth, pImageHeight, pStepX, 1, pFileItem, &pixelObjectVectorX);

		cout << "Clip for Image X Position" << endl;
		pixelDataFile << "Clip for Image X Position" << endl;

		int pIndex = 0;

		for (PixelObject pixelObject : pixelObjectVectorX)
		{

			if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
			{
				//				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
				//				cout << "X Position: " << pixelObject.xPosition << endl;
				//				cout << "Y Position: " << pixelObject.yPosition << endl;
				//				cout << "Red Value: " << pixelObject.RMask << endl;
				//				cout << "Green Value: " << pixelObject.GMask << endl;
				//				cout << "Blue Value: " << pixelObject.BMask << endl;

				//				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
				//				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
				//				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
				//				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
				//				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
				//				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

			}



		}

		cout << "Clip for Image X Position End" << endl;
		pixelDataFile << "Clip for Image X Position End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




		auto stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		auto duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For X End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;

		pixelDataFile << "Clipping Session For X End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Performing Image Scan Two" << endl;
		start = high_resolution_clock::now();
		hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
			hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, pFileItem, &pixelObjectVectorY);

		cout << "Printing the Contents of Clipped Area" << endl;
		pIndex = 0;

		cout << "Clip for Image Y Position" << endl;
		pixelDataFile << "Clip for Image Y Position" << endl;

		if (LOOPS_ARE_TURNED_OFF == FALSE)
		{
			for (PixelObject pixelObject : pixelObjectVectorY)
			{
				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					cout << "X Position: " << pixelObject.xPosition << endl;
					cout << "Y Position: " << pixelObject.yPosition << endl;
					cout << "Red Value: " << pixelObject.RMask << endl;
					cout << "Green Value: " << pixelObject.GMask << endl;
					cout << "Blue Value: " << pixelObject.BMask << endl;

					pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
				}


			}
		}


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

		stop = high_resolution_clock::now();

		// Get duration. Substart timepoints to  
		// get durarion. To cast it to proper unit 
		// use duration cast method 
		duration = duration_cast<microseconds>(stop - start);
		cout << "Clipping Session For Y End" << endl;
		cout << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;
		pixelDataFile << "Clipping Session For Y End" << endl;
		pixelDataFile << "Time taken by function: "
			<< duration.count() / 1000000 << " seconds" << endl;



		vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
		pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

	}

	else if ((pStepX == 1) && (pStepY == 1))
	{
		hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd,
			pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX);
	}




	cout << "RGB Section End" << endl;
	pixelDataFile << "RGB Section End" << endl;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	cout << "Grayscale Section End" << endl;
	pixelDataFile << "Grayscale Section End" << endl;


	vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
	cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
	pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


	GetSystemTime(&filterTimeStartSystem);
	GetLocalTime(&filterTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


	pClassOneLabel = 1;
	pClassTwoLabel = 2;
	pClassThreeLabel = 3;

	hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriersWithNumberOfThreads(hInstance,
		hWnd,
		pRedValueOne,
		pGreenValueOne,
		pBlueValueOne,
		pRedValueTwo,
		pGreenValueTwo,
		pBlueValueTwo,
		pClassOneLabel,
		pClassTwoLabel,
		pClassThreeLabel,
		pThresoldValue,
		pThreadSizeVar,
		pixelObjectVectorX,
		&pOutputFilterResult);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
		pixelDataFile.close();
		return hr;

	}

	pixelDataFile << " " << endl;
	pixelDataFile << " " << endl;
	pixelDataFile << "New Operation Begin" << endl;

	UINT pOperationNumber = 0;
	cout << "Printing Output" << endl;
	pixelDataFile << "Printing Output" << endl;

	UINT pIndexValue = 0;

	int ppAmountOfClassOnePixels = 0;
	int ppAmountOfClassTwoPixels = 0;


	float pColorSum = 0.0f;
	for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
	{

		//		cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
		//		cout << "X Position: " << pValidationItem.xPosition << endl;
		//	cout << "Y Position: " << pValidationItem.yPosition << endl;
		//		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
		//		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		//		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		//		cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


		//		pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
		//		pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
		//		pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
		//		pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
		//		pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		//		pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		//		pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




	}

	SYSTEMTIME pValidationEndTimeSystem;
	SYSTEMTIME pValidationEndTimeLocal;


	GetSystemTime(&pValidationEndTimeSystem);
	GetLocalTime(&pValidationEndTimeLocal);

	cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


	cout << "Restoring Class 1 RGB Pixels Data" << endl;
	pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


	GetSystemTime(&classOneRestorationSystem);
	GetLocalTime(&classOneRestorationLocal);

	cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




	vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
	hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForSelectedClassWithSpecifiedThreads(hInstance,
		hWnd,
		pClassOneLabel,
		pThreadSizeVar,
		pOutputFilterResult,
		&pClassOnePixelArray);

	for (PixelObject pixelObject : pClassOnePixelArray)
	{

		//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	cout << "X Position: " << pixelObject.xPosition << endl;
		//	cout << "Y Position: " << pixelObject.yPosition << endl;
		//	cout << "Red Value: " << pixelObject.RMask << endl;
		//	cout << "Green Value: " << pixelObject.GMask << endl;
		//	cout << "Blue Value: " << pixelObject.BMask << endl;

		//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	cout << "Restoring Class 2 RGB Pixels Data" << endl;
	pixelDataFile << "Restoring Class 2 RGB Pixels Data" << endl;


	GetSystemTime(&classTwoRestorationSystem);
	GetLocalTime(&classTwoRestorationLocal);

	cout << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;

	float pSizeDifference = 0.0f;
	pSizeDifference = pOutputFilterResult.size() - pClassOnePixelArray.size();
	vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();

	if (pSizeDifference > 3)
	{
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForSelectedClassWithSpecifiedThreads(hInstance,
			hWnd,
			pClassTwoLabel,
			pThreadSizeVar,
			pOutputFilterResult,
			&pClassTwoPixelArray);
	}



	for (PixelObject pixelObject : pClassTwoPixelArray)
	{

		//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	cout << "X Position: " << pixelObject.xPosition << endl;
		//	cout << "Y Position: " << pixelObject.yPosition << endl;
		//	cout << "Red Value: " << pixelObject.RMask << endl;
		//	cout << "Green Value: " << pixelObject.GMask << endl;
		//	cout << "Blue Value: " << pixelObject.BMask << endl;

		//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	vector<PixelObject> pClassThreePixelArray = vector<PixelObject>();


	 pSizeDifference = 0.0f;
	pSizeDifference = pOutputFilterResult.size() - pClassOnePixelArray.size() - pClassTwoPixelArray.size();

	if (pSizeDifference > 3)
	{
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForSelectedClassWithSpecifiedThreads(hInstance,
			hWnd,
			pClassThreeLabel,
			pThreadSizeVar,
			pOutputFilterResult,
			&pClassThreePixelArray);

	}


	for (PixelObject pixelObject : pClassThreePixelArray)
	{

		//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	cout << "X Position: " << pixelObject.xPosition << endl;
		//	cout << "Y Position: " << pixelObject.yPosition << endl;
		//	cout << "Red Value: " << pixelObject.RMask << endl;
		//	cout << "Green Value: " << pixelObject.GMask << endl;
		//	cout << "Blue Value: " << pixelObject.BMask << endl;

		//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
		//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
		//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
		//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
		//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
	cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
	pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
	pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



	cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
	pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
	float pOverallArea = 0.0f;
	pOverallArea = pImageWidth * pImageWidth;
	cout << "Overall Area = " << pOverallArea << endl;
	pixelDataFile << "Overall Area = " << pOverallArea << endl;

	cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
	pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

	cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
	pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

	float pAreaOneValue = pClassOnePixelArray.size();
	float pAreaTwoValue = pClassTwoPixelArray.size();


	float pPixelArrayRatioOne = 0.0f;
	float pPixelArrayRatioTwo = 0.0f;

	cout << "Computing the Area Ratio for Class 1: " << endl;
	pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

	pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
	pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

	cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
	cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


	pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
	pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



	float pDpiX = 0.0f;
	md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

	cout << "Your Monitor DPI: " << endl;
	cout << "X = " << pDpiX << endl;
	cout << "Y = " << pDpiX << endl;



	float pImageSizeInCentimeters0 = 0.0f;
	pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

	float pImageSizeInCentimeters1 = 0.0f;
	pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


	cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
	cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


	pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
	pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

	cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
	cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


	pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
	pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




	cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
	cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

	pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
	pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


	wstring pTextToPrintOne = L"Amount Of Pixels in Array One  = " + std::to_wstring(pClassOnePixelArray.size());
	wstring pTextToPrintTwo = L"Amount Of Pixels in Array Two  = " + std::to_wstring(pClassTwoPixelArray.size());


	WCHAR* pOutputText0 = nullptr;
	pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
	WCHAR* pOutputText1 = nullptr;
	pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


	md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
	md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
	md2dmanager->CreateDeviceResources(hInstance, hWnd);


	md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
		pOutputText1, 32);

	auto end = chrono::high_resolution_clock::now();
	auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

	cout << "Time taken by code execution in seconds = " << time_taken << endl;
	pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


	GetSystemTime(&experimentEndTimeSystem);
	GetLocalTime(&experimentEndTimeLocal);


	cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
	pixelDataFile.close();
	DestroyFilePermanently(hInstance, hWnd, constants::pDescriptorImage);

	return hr;
}



HRESULT DirectXGPUDigitalLabCoreModule::ValidatePixelObjectUsingABoundaryDescriptorWithBoundariesForADefinedFile(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	LPCSTR pFileObject = (LPCSTR)"C:\\pixels\\pixels5.csv";
	DirectXStandardAlgorithmExecutor* ppStandardAlgorithmExecutor = DirectXStandardAlgorithmExecutor::Instance(hInstance, hWnd);
	fstream pixelDataFile;
	pixelDataFile.open("C:\\pixels\\ValidationOfImagesUsingABoundaryDescriptor.txt", fstream::in | fstream::out | fstream::trunc);
	pixelDataFile.clear();

	SYSTEMTIME clippingTimeStartSystem;
	SYSTEMTIME clippingTimeStartLocal;
	SYSTEMTIME clippingTimeEndSystem;
	SYSTEMTIME clippingTimeEndLocal;
	SYSTEMTIME filterTimeStartSystem;
	SYSTEMTIME filterTimeStartLocal;
	SYSTEMTIME classOneRestorationSystem;
	SYSTEMTIME classOneRestorationLocal;
	SYSTEMTIME classTwoRestorationSystem;
	SYSTEMTIME classTwoRestorationLocal;
	SYSTEMTIME experimentEndTimeSystem;
	SYSTEMTIME experimentEndTimeLocal;

	int pAmountOfFilteredPixels = 0;


	vector<ClippingStage> pClippingStageVector = vector<ClippingStage>();


	vector<PixelObject> pixelObjectVector = vector<PixelObject>();
	vector<OutputPixelObjectDescriptor> pOutputFilterResult = vector<OutputPixelObjectDescriptor>();
	UINT pImageWidth = 0;
	UINT pImageHeight = 0;
	ID2D1Bitmap* pBitmapData = nullptr;
	UINT pTopLeftX = 0;
	UINT pTopLeftY = 0;
	float pStepX = 0.0f;
	float pStepY = 0.0f;

	cout << "Enter the X Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftX;
	cout << "Enter the Y Value for Top Left Position of the Image Sector" << endl;
	cin >> pTopLeftY;


	cout << "Enter the Width of Image Sector" << endl;
	cin >> pImageWidth;

	cout << "Enter the Height of Image Sector" << endl;
	cin >> pImageHeight;

	cout << "Enter the step to scan X Axis" << endl;
	cin >> pStepX;

	cout << "Enter the step to scan Y Axis" << endl;
	cin >> pStepY;


	float pMinimumX = 0.0f;
	float pMinimumY = 0.0f;
	float pMaximumX = 0.0f;
	float pMaximumY = 0.0f;
	float pThresholdIntensityMinimum = 0;
	float pThresholdIntensityMaximum = 0;


	cout << "Enter the Minimum Value for X Position" << endl;
	cin >> pMinimumX;

	cout << "Enter the Minimum Value for Y Position" << endl;
	cin >> pMinimumY;

	pMaximumX = pMinimumX + pImageWidth;
	pMaximumY = pMinimumY + pImageHeight;




	float pRedValueOne = 0.0f;
	float pGreenValueOne = 0.0f;
	float pBlueValueOne = 0.0f;

	float pRedValueTwo = 0.0f;
	float pGreenValueTwo = 0.0f;
	float pBlueValueTwo = 0.0f;


	float pRedValueThree = 0.0f;
	float pGreenValueThree = 0.0f;
	float pBlueValueThree = 0.0f;
	float pThresoldValue = 0.0f;

	int pClassOneLabel = 0;
	int pClassTwoLabel = 0;
	int pClassThreeLabel = 0;



	cout << "Enter Red 1" << endl;
	cin >> pRedValueOne;

	cout << "Enter Green 1" << endl;
	cin >> pGreenValueOne;

	cout << "Enter Blue 1" << endl;
	cin >> pBlueValueOne;



	cout << "Enter Red 2" << endl;
	cin >> pRedValueTwo;

	cout << "Enter Green 2" << endl;
	cin >> pGreenValueTwo;

	cout << "Enter Blue 2" << endl;
	cin >> pBlueValueTwo;


	cout << "Enter the Value for the Barrier Constant" << endl;
	cin >> pThresoldValue;


	cout << "Top Left X Position = " << pTopLeftX << endl;
	cout << "Top Left Y Position = " << pTopLeftY << endl;
	cout << "Image Width = " << pImageWidth << endl;
	cout << "Image Height = " << pImageWidth << endl;
	cout << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	cout << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	cout << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	pixelDataFile << "Top Left X Position = " << pTopLeftX << endl;
	pixelDataFile << "Top Left Y Position = " << pTopLeftY << endl;
	pixelDataFile << "Image Width = " << pImageWidth << endl;
	pixelDataFile << "Image Height = " << pImageWidth << endl;
	pixelDataFile << "Cropped Image Top Left X Position = " << pMinimumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMinimumY << endl;
	pixelDataFile << "Cropped Image Bottom Right X Position = " << pMaximumX << endl;
	pixelDataFile << "Cropped Image Top Left Y Position = " << pMaximumY << endl;

	auto start = high_resolution_clock::now();



	cout << "Printing RGB Clip Object" << endl;
	pixelDataFile << "Printing RGB Clip Object" << endl;





	LPWSTR path = nullptr;


	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



	GetSystemTime(&clippingTimeStartSystem);
	GetLocalTime(&clippingTimeStartLocal);

	cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
	cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
	pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;


	LPWSTR pFileItem = nullptr;


		pFileItem = constants::pDescriptorImage;

		bool pResult = false;
		pResult = PathFileExists(pFileItem);

		if (pResult == false)
		{
			cout << "Attention File Not Found" << endl;
			MessageBoxA(NULL, (LPCSTR)L"Ошибка Файл в Директории не найден", (LPCSTR)"Error", 0);
			pixelDataFile.close();
			return hr;
		}
		
		vector<PixelObject> pixelObjectVectorX = vector<PixelObject>();
		vector<PixelObject> pixelObjectVectorY = vector<PixelObject>();


		Direct2DManagementClass* md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		hr = md2dmanager->CreateDeviceResources(hInstance, hWnd);

		pixelDataFile << "New Image Clip" << endl;


		
		if ((pStepX > 1) && (pStepY > 1))
		{

			pixelDataFile << "New Image Clip" << endl;

			// Get starting timepoint 

			// Call the function, here sort() 

			// Get ending timepoint 

			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			pixelDataFile << "New Image Clip" << endl;


			cout << "Performing Image Scan Eight Cliing X" << endl;
			pixelDataFile << "Performing Image Scan Eight Cliing X" << endl;
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd,  pMinimumX, pMinimumY, pImageWidth, pImageHeight, pStepX, 1, pFileItem,  &pixelObjectVectorX);

			cout << "Clip for Image X Position" << endl;
			pixelDataFile << "Clip for Image X Position" << endl;

			int pIndex = 0;

			for (PixelObject pixelObject : pixelObjectVectorX)
			{

				if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
				{
					//				cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				cout << "X Position: " << pixelObject.xPosition << endl;
					//				cout << "Y Position: " << pixelObject.yPosition << endl;
					//				cout << "Red Value: " << pixelObject.RMask << endl;
					//				cout << "Green Value: " << pixelObject.GMask << endl;
					//				cout << "Blue Value: " << pixelObject.BMask << endl;

					//				pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
					//				pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
					//				pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
					//				pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
					//				pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
					//				pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;

				}



			}

			cout << "Clip for Image X Position End" << endl;
			pixelDataFile << "Clip for Image X Position End" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Eight End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;




			auto stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			auto duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For X End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;

			pixelDataFile << "Clipping Session For X End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two Start: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



			cout << "Performing Image Scan Two" << endl;
			start = high_resolution_clock::now();
			hr = md2dmanager->CreateBitmapDrawingClipObjectWitSpecifiedStepForASpecifiedFile(hInstance,
				hWnd, pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, 1, pStepY, pFileItem, &pixelObjectVectorY);

			cout << "Printing the Contents of Clipped Area" << endl;
			pIndex = 0;

			cout << "Clip for Image Y Position" << endl;
			pixelDataFile << "Clip for Image Y Position" << endl;

			if (LOOPS_ARE_TURNED_OFF == FALSE)
			{
				for (PixelObject pixelObject : pixelObjectVectorY)
				{
					if ((pixelObject.RMask != 255.0f) && (pixelObject.GMask != 255) && (pixelObject.BMask != 255.0f))
					{
						cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
						cout << "X Position: " << pixelObject.xPosition << endl;
						cout << "Y Position: " << pixelObject.yPosition << endl;
						cout << "Red Value: " << pixelObject.RMask << endl;
						cout << "Green Value: " << pixelObject.GMask << endl;
						cout << "Blue Value: " << pixelObject.BMask << endl;

						pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
						pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
						pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
						pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
						pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
						pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;
					}


				}
			}


			GetSystemTime(&clippingTimeStartSystem);
			GetLocalTime(&clippingTimeStartLocal);

			cout << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
			cout << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << "TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
			pixelDataFile << " TIme Clipping Two End: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;

			stop = high_resolution_clock::now();

			// Get duration. Substart timepoints to  
			// get durarion. To cast it to proper unit 
			// use duration cast method 
			duration = duration_cast<microseconds>(stop - start);
			cout << "Clipping Session For Y End" << endl;
			cout << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;
			pixelDataFile << "Clipping Session For Y End" << endl;
			pixelDataFile << "Time taken by function: "
				<< duration.count() / 1000000 << " seconds" << endl;



			vector<PixelObject>::iterator pVectorOneIt = pixelObjectVectorX.end();
			pixelObjectVectorX.insert(pVectorOneIt, pixelObjectVectorY.begin(), pixelObjectVectorY.end());

		}

		else if ((pStepX == 1) && (pStepY == 1))
		{
			hr = md2dmanager->CreateBitmapDrawingClipObject(hInstance, hWnd,
				pFileItem,
				pTopLeftX, pTopLeftY, pImageWidth, pImageHeight, &pixelObjectVectorX);
		}




		cout << "RGB Section End" << endl;
		pixelDataFile << "RGB Section End" << endl;


		GetSystemTime(&clippingTimeStartSystem);
		GetLocalTime(&clippingTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << clippingTimeStartSystem.wHour << ":" << clippingTimeStartSystem.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << clippingTimeStartLocal.wHour << ":" << clippingTimeStartLocal.wMinute << ":" << clippingTimeStartLocal.wSecond << endl;



		cout << "Grayscale Section End" << endl;
		pixelDataFile << "Grayscale Section End" << endl;


		vector<PixelObject> ppOutputPixelVector = vector<PixelObject>();
		cout << "Simulating Image Filter Operation = " << pThresholdIntensityMaximum << endl;
		pixelDataFile << "Simulating Image Filter Operation " << pThresholdIntensityMaximum << endl;


		GetSystemTime(&filterTimeStartSystem);
		GetLocalTime(&filterTimeStartLocal);

		cout << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << filterTimeStartSystem.wHour << ":" << filterTimeStartSystem.wMinute << ":" << filterTimeStartLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << filterTimeStartLocal.wHour << ":" << filterTimeStartLocal.wMinute << ":" << filterTimeStartLocal.wSecond << endl;


			pClassOneLabel = 1;
			pClassTwoLabel = 2;
			pClassThreeLabel = 3;

		hr = ppStandardAlgorithmExecutor->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance,
			hWnd,
			pRedValueOne,
			pGreenValueOne,
			pBlueValueOne,
			pRedValueTwo,
			pGreenValueTwo,
			pBlueValueTwo,
			pClassOneLabel,
			pClassTwoLabel,
			pClassThreeLabel,
			pThresoldValue,
			pixelObjectVectorX,
			&pOutputFilterResult);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile << "An Attempt To Convert Values from RGB TO Black and White failed = " << pLastError << endl;
			pixelDataFile.close();
			return hr;

		}

		pixelDataFile << " " << endl;
		pixelDataFile << " " << endl;
		pixelDataFile << "New Operation Begin" << endl;

		UINT pOperationNumber = 0;
		cout << "Printing Output" << endl;
		pixelDataFile << "Printing Output" << endl;

		UINT pIndexValue = 0;

		int ppAmountOfClassOnePixels = 0;
		int ppAmountOfClassTwoPixels = 0;


		float pColorSum = 0.0f;
		for (OutputPixelObjectDescriptor pValidationItem : pOutputFilterResult)
		{

			//		cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
			//		cout << "X Position: " << pValidationItem.xPosition << endl;
			//	cout << "Y Position: " << pValidationItem.yPosition << endl;
			//		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
			//		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
			//		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
			//		cout << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;


			//		pixelDataFile << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
			//		pixelDataFile << "X Position: " << pValidationItem.xPosition << endl;
			//		pixelDataFile << "Y Position: " << pValidationItem.yPosition << endl;
			//		pixelDataFile << "Red Component: " << pValidationItem.pRedValue0 << endl;
			//		pixelDataFile << "Green Component: " << pValidationItem.pGreenValue0 << endl;
			//		pixelDataFile << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
			//		pixelDataFile << "Pixel Class: " << pValidationItem.pClassMarkerValue << endl;




		}

		SYSTEMTIME pValidationEndTimeSystem;
		SYSTEMTIME pValidationEndTimeLocal;


		GetSystemTime(&pValidationEndTimeSystem);
		GetLocalTime(&pValidationEndTimeLocal);

		cout << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << pValidationEndTimeSystem.wHour << ":" << pValidationEndTimeSystem.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << pValidationEndTimeLocal.wHour << ":" << pValidationEndTimeLocal.wMinute << ":" << pValidationEndTimeLocal.wSecond << endl;


		cout << "Restoring Class 1 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 1 RGB Pixels Data" << endl;


		GetSystemTime(&classOneRestorationSystem);
		GetLocalTime(&classOneRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classOneRestorationSystem.wHour << ":" << classOneRestorationSystem.wMinute << ":" << classOneRestorationLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classOneRestorationLocal.wHour << ":" << classOneRestorationLocal.wMinute << ":" << classOneRestorationLocal.wSecond << endl;




		vector<PixelObject> pClassOnePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			1,
			pOutputFilterResult,
			&pClassOnePixelArray);

		for (PixelObject pixelObject : pClassOnePixelArray)
		{

			//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			//	cout << "X Position: " << pixelObject.xPosition << endl;
			//	cout << "Y Position: " << pixelObject.yPosition << endl;
			//	cout << "Red Value: " << pixelObject.RMask << endl;
			//	cout << "Green Value: " << pixelObject.GMask << endl;
			//	cout << "Blue Value: " << pixelObject.BMask << endl;

			//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}

		cout << "Restoring Class 2 RGB Pixels Data" << endl;
		pixelDataFile << "Restoring Class 2 RGB Pixels Data" << endl;


		GetSystemTime(&classTwoRestorationSystem);
		GetLocalTime(&classTwoRestorationLocal);

		cout << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
		cout << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;
		pixelDataFile << "The system time is: %02d:%02d\n" << classTwoRestorationSystem.wHour << ":" << classTwoRestorationSystem.wMinute << ":" << classTwoRestorationSystem.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << classTwoRestorationLocal.wHour << ":" << classTwoRestorationLocal.wMinute << ":" << classTwoRestorationLocal.wSecond << endl;



		vector<PixelObject> pClassTwoPixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			2,
			pOutputFilterResult,
			&pClassTwoPixelArray);

		for (PixelObject pixelObject : pClassTwoPixelArray)
		{

			//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			//	cout << "X Position: " << pixelObject.xPosition << endl;
			//	cout << "Y Position: " << pixelObject.yPosition << endl;
			//	cout << "Red Value: " << pixelObject.RMask << endl;
			//	cout << "Green Value: " << pixelObject.GMask << endl;
			//	cout << "Blue Value: " << pixelObject.BMask << endl;

			//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}




		vector<PixelObject> pClassThreePixelArray = vector<PixelObject>();
		hr = ppStandardAlgorithmExecutor->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			3,
			pOutputFilterResult,
			&pClassThreePixelArray);

		for (PixelObject pixelObject : pClassThreePixelArray)
		{

			//	cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
			//	cout << "X Position: " << pixelObject.xPosition << endl;
			//	cout << "Y Position: " << pixelObject.yPosition << endl;
			//	cout << "Red Value: " << pixelObject.RMask << endl;
			//	cout << "Green Value: " << pixelObject.GMask << endl;
			//	cout << "Blue Value: " << pixelObject.BMask << endl;

			//	pixelDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
			//	pixelDataFile << "X Position: " << pixelObject.xPosition << endl;
			//	pixelDataFile << "Y Position: " << pixelObject.yPosition << endl;
			//	pixelDataFile << "Red Value: " << pixelObject.RMask << endl;
			//	pixelDataFile << "Green Value: " << pixelObject.GMask << endl;
			//	pixelDataFile << "Blue Value: " << pixelObject.BMask << endl;



		}


		cout << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		cout << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Amount of Class 1 Pixels = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Amount of Class 2 Pixels = " << pClassTwoPixelArray.size() << endl;



		cout << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		pixelDataFile << "Now We Would Like to Compute the Area of the Overall Shape in Pixels" << endl;
		float pOverallArea = 0.0f;
		pOverallArea = pImageWidth * pImageWidth;
		cout << "Overall Area = " << pOverallArea << endl;
		pixelDataFile << "Overall Area = " << pOverallArea << endl;

		cout << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;
		pixelDataFile << "Class One Pixel Array Area = " << pClassOnePixelArray.size() << endl;

		cout << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;
		pixelDataFile << "Class Two Pixel Array Area = " << pClassTwoPixelArray.size() << endl;

		float pAreaOneValue = pClassOnePixelArray.size();
		float pAreaTwoValue = pClassTwoPixelArray.size();


		float pPixelArrayRatioOne = 0.0f;
		float pPixelArrayRatioTwo = 0.0f;

		cout << "Computing the Area Ratio for Class 1: " << endl;
		pixelDataFile << "Computing the Area Ratio for Class 1: " << endl;

		pPixelArrayRatioOne = pClassOnePixelArray.size() / pOverallArea  * 100.0f;
		pPixelArrayRatioTwo = pClassTwoPixelArray.size() / pOverallArea  * 100.0f;

		cout << "Class One Pixel Area  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area  = " << pAreaTwoValue << endl;



		float pDpiX = 0.0f;
		md2dmanager->GetDesktopDPI(hInstance, hWnd, &pDpiX, &pDpiX);

		cout << "Your Monitor DPI: " << endl;
		cout << "X = " << pDpiX << endl;
		cout << "Y = " << pDpiX << endl;



		float pImageSizeInCentimeters0 = 0.0f;
		pImageSizeInCentimeters0 = sqrt(pAreaOneValue) / 37.5;

		float pImageSizeInCentimeters1 = 0.0f;
		pImageSizeInCentimeters1 = sqrt(pAreaTwoValue) / 37.5;


		cout << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		cout << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;


		pixelDataFile << "Class One Pixel Area in pixels  = " << pAreaOneValue << endl;
		pixelDataFile << "Class Two Pixel Area in pixels  = " << pAreaTwoValue << endl;

		cout << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		cout << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;


		pixelDataFile << "Class One Pixel Area in centimeters  = " << pImageSizeInCentimeters0 << endl;
		pixelDataFile << "Class Two Pixel Area in centimeters  = " << pImageSizeInCentimeters1 << endl;




		cout << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		cout << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents  = " << pPixelArrayRatioTwo << endl;

		pixelDataFile << "The Area Ratio Of Class One Pixels to the Whole Area in Percents  = " << pPixelArrayRatioOne << endl;
		pixelDataFile << "The Area Ratio Of Class Two Pixels to the Whole Area in Percents = " << pPixelArrayRatioTwo << endl;


		wstring pTextToPrintOne = L"Area one in Percents  = " + std::to_wstring(pPixelArrayRatioOne);
		wstring pTextToPrintTwo = L"Area Two in Percents  = " + std::to_wstring(pPixelArrayRatioTwo);

		WCHAR* pOutputText0 = nullptr;
		pOutputText0 = (WCHAR*)pTextToPrintOne.c_str();
		WCHAR* pOutputText1 = nullptr;
		pOutputText1 = (WCHAR*)pTextToPrintTwo.c_str();


		md2dmanager = new Direct2DManagementClass(hInstance, hWnd);
		md2dmanager->CreateDeviceIndependentResources(hInstance, hWnd);
		md2dmanager->CreateDeviceResources(hInstance, hWnd);


		md2dmanager->DrawSampleTextOnTheScreenMultiple(hInstance, hWnd, pOutputText0,
			pOutputText1, 32);

		auto end = chrono::high_resolution_clock::now();
		auto time_taken = chrono::duration_cast<chrono::seconds>(end - start).count();

		cout << "Time taken by code execution in seconds = " << time_taken << endl;
		pixelDataFile << "Time taken by code execution in seconds = " << time_taken << endl;


		GetSystemTime(&experimentEndTimeSystem);
		GetLocalTime(&experimentEndTimeLocal);


		cout << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile << " The local time is: %02d:%02d\n" << experimentEndTimeLocal.wHour << ":" << experimentEndTimeLocal.wMinute << ":" << experimentEndTimeLocal.wSecond << endl;
		pixelDataFile.close();
		DestroyFilePermanently(hInstance, hWnd, constants::pDescriptorImage);

		return hr;
	}

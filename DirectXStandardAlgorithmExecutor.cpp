

#include "stdafx.h"
#include "DirectXStandardAlgorithmExecutor.h"
#include <cmath>
#include <iostream>

#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

vector<PixelObject> pPixelObjectGlobal;
vector<PixelObjectGrayScale> pPixelObjectGlobalGrayScaleGlobal;
const UINT DO_YOU_WANT_MESSAGES = 0;
struct ThreadPoolTaskItemComparisonGrayScale
{
	DirectXStandardAlgorithmExecutor* pStandardAlgorithmExecuror;
	vector<PixelObjectGrayScale> pVectorPixelOne;
	vector<PixelObjectGrayScale> pVectorPixelTwo;

public: 
	ThreadPoolTaskItemComparisonGrayScale(DirectXStandardAlgorithmExecutor* pClassItemv,
		vector<PixelObjectGrayScale> pVectorOne,
		vector<PixelObjectGrayScale> pVectorTwo)
	{
		pStandardAlgorithmExecuror = pClassItemv;
		pVectorPixelOne = pVectorOne;
		pVectorPixelTwo = pVectorTwo;
	}
};


vector<PixelObject> pImageOneForComparisonGlobal;
vector<PixelObject> pImageTwoForComparisonGlobal;
vector<PixelObjectGrayScale> pImageOneForComparisonGlobalGrayScale;
vector<PixelObjectGrayScale> pImageTwoForComparisonGlobalGrayScale;
vector<OutputPixelBuffer> pOutputPixelBufferOutputArrayGlobal;
vector<PixelObjectGrayScale> pOutputGrayScaleVectorGlobal;
vector<PixelObjectGrayScale> pImageComparisonIdenticalGlobal;
vector<PixelObjectGrayScale> pImageComparisonDifferentGlobal;

vector<PixelObject> pPixelObjectOneDetectorGlobal;
vector<OutputPixelObjectDescriptor> pOutputPixelObjectVectorGlobal;
vector<PixelObject> pClassOnePixelObjectVectorGlobal;
vector<PixelObject> pClassTwoPixelObjectVectorGlobal;
float pColorOneRedGlobal;
float pColorOneGreenGlobal;
float pColorOneBlueGlobal;
float pColorTwoRedGlobal;
float pColorTwoGreenGlobal;
float pColorTwoBlueGlobal;
int pClassOneGlobalVar;
int pClassTwoGlobalVar;
int pClassThreeGlobalVar;
float pThresoldValueGlobalVar;

float pImageOneIntensitySumRedGlobal = 0.0f;
float pImageOneIntensitySumGreenGlobal = 0.0f;
float pImageOneIntensitySumBlueGlobal = 0.0f;
float pImageOneArraySizeGlobal = 0.0f;
float pImageOneRedAverageGlobal = 0.0f;
float pImageOneGreenAverageGlobal = 0.0f;
float pImageOneBlueAverageGlobal = 0.0f;

float pImageTwoIntensitySumRedGlobal = 0.0f;
float pImageTwoIntensitySumGreenGlobal = 0.0f;
float pImageTwoIntensitySumBlueGlobal = 0.0f;
float pImageTwoArraySizeGlobal = 0.0f;
float pImageTwoRedAverageGlobal = 0.0f;
float pImageTwoGreenAverageGlobal = 0.0f;
float pImageTwoBlueAverageGlobal = 0.0f;


float pOutputArrayIntensitySumRedGlobal = 0.0f;
float pOutputArrayIntensitySumGreenGlobal = 0.0f;
float pOutputArrayIntensitySumBlueGlobal = 0.0f;
float pOutputArrayArraySizeGlobal = 0.0f;
float pOutputArrayRedAverageGlobal = 0.0f;
float pOutputArrayGreenAverageGlobal = 0.0f;
float pOutputArrayBlueAverageGlobal = 0.0f;



float pIdenticalArrayIntensitySumRedGlobal = 0.0f;
float pIdenticalArrayIntensitySumGreenGlobal = 0.0f;
float pIdenticalArrayIntensitySumBlueGlobal = 0.0f;
float pIdenticalArrayArraySizeGlobal = 0.0f;
float pIdenticalArrayRedAverageGlobal = 0.0f;
float pIdenticalArrayGreenAverageGlobal = 0.0f;
float pIdenticalArrayBlueAverageGlobal = 0.0f;

float pDifferentArrayIntensitySumRedGlobal = 0.0f;
float pDifferentArrayIntensitySumGreenGlobal = 0.0f;
float pDifferentArrayIntensitySumBlueGlobal = 0.0f;
float pDifferentArrayArraySizeGlobal = 0.0f;
float pDifferentArrayRedAverageGlobal = 0.0f;
float pDifferentArrayGreenAverageGlobal = 0.0f;
float pDifferentArrayBlueAverageGlobal = 0.0f;

vector<PixelObject> pImageOneForComparisonGlobalRGB;
vector<PixelObject> pImageTwoForComparisonGlobalRGB;
vector<OutputPixelBufferRGB> pOutputPixelBufferOutputArrayGlobalRGB;
vector<PixelObject> pImageComparisonIdenticalGlobalRGB;
vector<PixelObject> pImageComparisonDifferentGlobalRGB;


HANDLE pGrayScaleMutex;
HANDLE pGrayScaleMutexThread;
HANDLE pImageComparisonThreadHandleValue;
HANDLE pImageComparisonMutexObject;
HANDLE pImageComparionSemaphoreObject;


int pAmountOfIdenticalPixels;
int pAmountOfDifferentPixels;
float pImageOneSum;
float pImageOneAverage;
float pImageTwoSum;
float pImageTwoAverage;
float pOutputArraySum;
float pOutputArrayAverage;
float pIdenticalArraySum;
float pIdenticalArrayAverage;
HANDLE pQuadraticFunctionMutex;
float pAGlobalVar;
float pBGlobalVar;
float pCGlobalVar;
vector<InputStructureForGraph> pInputStructureForGraphGlobal;
vector<OutputStructureForGraph> pOutputStructureForGraphGlobal;
TCHAR* pQuadraticFunctionMutexVar = _T("__QuadraticFunctionMutex__");
DWORD WINAPI SimulateQuadraticFunctionAlgorithm(void* lParam);


std::vector<UINT> data(NUM_ELEMENTS);
std::vector<UINT> results(NUM_ELEMENTS);

ID3D11Buffer* pGasDynamicsCB;
ID3D11Buffer* pGasTemperatureBuffer;
ID3D11ShaderResourceView* pGasTemperatureBufferSRV;
ID3D11Buffer* pGasSpeedOutputBufferW;
BOOL SortOddEvenFSMValues(OutputArrayOddEvenFinalStruct itemOne, OutputArrayOddEvenFinalStruct itemTwo)
{
	BOOL pResultValue = FALSE;
	pResultValue = itemOne.pInputNumberVar < itemTwo.pInputNumberVar;
	return pResultValue;
}


OutputArrayOddEvenFinalStruct GetItemById(vector<OutputArrayOddEvenFinalStruct>  pVectorToSearch, int pIdValue)
{
	OutputArrayOddEvenFinalStruct pSelectedItem;
	for (OutputArrayOddEvenFinalStruct pStructureVar : pVectorToSearch)
	{
		if (pStructureVar.pItemIndex == pIdValue)
		{
			pSelectedItem = pStructureVar;
		}
	}
	return pSelectedItem;
}



BOOL SmallerXPosition(PixelObjectGrayScale pixelOne, PixelObjectGrayScale pixelTwo)
{
	BOOL bResult = FALSE;
	bResult = (pixelOne.xPosition < pixelTwo.xPosition) && (pixelOne.yPosition == pixelTwo.yPosition);
	return bResult;
}

BOOL SmallerYPosition(PixelObjectGrayScale pixelOne, PixelObjectGrayScale pixelTwo)
{
	BOOL bResult = FALSE;
	bResult = (pixelOne.yPosition < pixelTwo.yPosition) && (pixelOne.xPosition == pixelTwo.xPosition);
	return bResult;
}

BOOL SmallerGradientXPosition(CImageDerivativeClass pImageDerivativeOne, CImageDerivativeClass pImageDerivativeTwo)
{
	BOOL bResult = FALSE;
	bResult = (pImageDerivativeOne.xPosition < pImageDerivativeTwo.xPosition) && (pImageDerivativeOne.yPosition == pImageDerivativeTwo.yPosition);
	return bResult;
}

BOOL SmallerGradientYPosition(CImageDerivativeClass pImageDerivativeOne, CImageDerivativeClass pImageDerivativeTwo)
{
	BOOL bResult = FALSE;
	bResult = (pImageDerivativeOne.yPosition < pImageDerivativeTwo.yPosition) && (pImageDerivativeOne.xPosition == pImageDerivativeTwo.yPosition);
	return bResult;
}



BOOL SmallerGaussianXPosition(GaussianOutputVar pixelOne, GaussianOutputVar pixelTwo)
{
	BOOL bResult = FALSE;
	bResult = (pixelOne.xPosition < pixelTwo.xPosition) && (pixelOne.xPosition == pixelTwo.xPosition);
	return bResult;
}

BOOL SmallerGaussianYPosition(GaussianOutputVar pixelOne, GaussianOutputVar pixelTwo)
{
	BOOL bResult = FALSE;
	bResult = (pixelOne.xPosition < pixelTwo.xPosition) && (pixelOne.xPosition == pixelTwo.xPosition);
	return bResult;
}




#define SIZE1 102



struct less_than_image_derivative_by_x
{
	inline bool operator() (const CImageDerivativeClass& struct1, const CImageDerivativeClass& struct2)
	{
		return (struct1.xPosition < struct2.xPosition && struct1.yPosition == struct2.yPosition);
	}
};

struct less_than_image_derivative_by_y
{
	inline bool operator() (const CImageDerivativeClass& struct1, const CImageDerivativeClass& struct2)
	{
		return (struct1.yPosition < struct2.yPosition && struct1.xPosition == struct2.xPosition);
	}
};


struct less_than_grayscale_pixel_by_y
{
	inline bool operator() (const PixelObjectGrayScale& struct1, const PixelObjectGrayScale& struct2)
	{
		return (struct1.yPosition < struct2.yPosition && struct1.xPosition == struct2.xPosition);
	}
};


struct less_than_grayscale_pixel_by_x
{
	inline bool operator() (const PixelObjectGrayScale& struct1, const PixelObjectGrayScale& struct2)
	{
		return (struct1.xPosition < struct2.xPosition && struct1.yPosition == struct2.yPosition);
	}
};

struct CBThresholdImageConstantBufferGrayScale
{
	float pMinimumX;
	float pMinimumY;
	float pMaximumX;
	float pMaximumY;
	float pThreshHoldValueLower;
	float pThresHoldValueUpper;
};


struct CBThresholdImageConstantBufferCoordinatesrGrayScale
{
	float pMinimumX;
	float pMinimumY;
	float pMaximumX;
	float pMaximumY;
};








struct CBThresholdImageConstantBufferCoordinatesRGB
{
	float pMinimumX;
	float pMinimumY;
	float pMaximumX;
	float pMaximumY;
};

struct CBThresholdImageConstantBufferRGB
{
	float pMinimumX;
	float pMinimumY;
	float pMaximumX;
	float pMaximumY;
	float pMinRedValue;
	float pMaxRedValue;
	float pMinGreenValue;
	float pMaxGreenValue;
	float pMinBlueValue;
	float pMaxBlueValue;
};




BOOL pImagesIdenticalVar;


BOOL SortGradientByXPosition(CImageDerivativeClass &lhs, CImageDerivativeClass& rhs)
{
	return lhs.xPosition < rhs.xPosition && lhs.yPosition == rhs.yPosition;
}

BOOL SortGradientByYPosition(CImageDerivativeClass &lhs, CImageDerivativeClass& rhs)
{
	return lhs.yPosition < rhs.yPosition && lhs.xPosition == rhs.xPosition;
}


BOOL SortOutputPixelByX(const OutputPixelBuffer &lhs, const OutputPixelBuffer &rhs)
{
	return lhs.xPosition < rhs.xPosition && lhs.yPosition == rhs.yPosition;
}


BOOL SortByXPosition(const PixelObjectGrayScale &lhs, const PixelObjectGrayScale &rhs)
{
	return lhs.xPosition < rhs.xPosition && lhs.yPosition == rhs.yPosition; 
}
BOOL SortByYPosition(const PixelObjectGrayScale &lhs, const PixelObjectGrayScale &rhs) 
{ 
	return lhs.yPosition < rhs.yPosition && lhs.xPosition == rhs.xPosition;
}


BOOL SortArrayByClassValue(const SortedPixelOutput &lhs, const SortedPixelOutput &rhs)
{
	return lhs.pGroupLabelValue < rhs.pGroupLabelValue;
}




float ComputeHyperBolicCos(float x)
{
	float pVal = (pow(M_E, x) + (1 / pow(M_E, x))) / 2;
	return pVal;
}

float ComputeHyperBolicSin(float x)
{
	float pVal = (pow(M_E, x) - (1 / pow(M_E, x))) / 2;
	return pVal; 
}

unsigned int ReverseBits(unsigned int input)
{
	unsigned int output = input;

	output = (((output & 0xaaaaaaaa) >> 1) | ((output & 0x55555555) << 1));
	output = (((output & 0xcccccccc) >> 2) | ((output & 0x33333333) << 2));
	output = (((output & 0xf0f0f0f0) >> 4) | ((output & 0x0f0f0f0f) << 4));
	output = (((output & 0xff00ff00) >> 8) | ((output & 0x00ff00ff) << 8));
	return((output >> 16) | (output << 16));

	return output;
}

unsigned int reverseBits(unsigned int num)
{
	unsigned int  NO_OF_BITS = sizeof(num) * 8;
	unsigned int reverse_num = 0, i, temp;

	for (i = 0; i < NO_OF_BITS; i++)
	{
		temp = (num & (1 << i));
		if (temp)
			reverse_num |= (1 << ((NO_OF_BITS - 1) - i));
	}

	return reverse_num;
}




vector<TemperatureStructure> pTemperatureValues;
vector<SpeedValue> pSpeedValues;

DirectXStandardAlgorithmExecutor* DirectXStandardAlgorithmExecutor::_algorithmExecutorInstance = NULL;


static DWORD  WINAPI DescriptorThreadedFunctionOutput(LPVOID pParam)
{

	HRESULT hr = S_OK;

	HINSTANCE hInstance = GetModuleHandle(NULL);
	RECT rcRect = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	DWORD pResultValue = 0.0f;
	DirectXStandardAlgorithmExecutor* pAlgotithmExecutorVar = (DirectXStandardAlgorithmExecutor*)pParam;

	hr = pAlgotithmExecutorVar->ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(hInstance,
		hWnd,
		pColorOneRedGlobal,
		pColorOneGreenGlobal,
		pColorOneBlueGlobal,
		pColorTwoRedGlobal,
		pColorTwoGreenGlobal,
		pColorTwoBlueGlobal,
		pClassOneGlobalVar,
		pClassTwoGlobalVar,
		pClassThreeGlobalVar,
		pThresoldValueGlobalVar,
		pPixelObjectOneDetectorGlobal,
		&pOutputPixelObjectVectorGlobal);

	if (SUCCEEDED(hr))
	{
		hr = pAlgotithmExecutorVar->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd, pClassOneGlobalVar, pOutputPixelObjectVectorGlobal, &pClassOnePixelObjectVectorGlobal);
	}
	if (SUCCEEDED(hr))
	{
		hr = pAlgotithmExecutorVar->RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd,
			pClassTwoGlobalVar,
			pOutputPixelObjectVectorGlobal,
			&pClassTwoPixelObjectVectorGlobal);
	}
	return pResultValue;
	
}







HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorSubtraction(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRedOne, 
	float pSampleGreenOne, 
	float pSampleBlueOne,
	float pSampleRedTwo, 
	float pSampleGreenTwo, float pSampleBlueTwo, int pClassOneLabel, int pClassTwoLabel, int pClassThreeLabel,
	vector<PixelObject> ppPixelArrayInput, vector<OutputPixelObjectDescriptorSubtraction> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptorSubtraction> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptorSubtraction>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptorSubtraction  pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pClassThreeValue = pClassThreeLabel;
	


	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColorsViaSubtraction(hInstance,
		hWnd,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptorSubtraction* pOutputDataImages = (OutputPixelObjectDescriptorSubtraction*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{


		OutputPixelObjectDescriptorSubtraction pValidationItem = pOutputDataImages[pIndex];

		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;
			}
		}


		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptorSubtraction pValidationItem : pOutputPixelDataBuffer)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "Printing Pixel One Data" << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Red Difference Color Final: " << pValidationItem.pFinalSubtractionRed << endl;
				cout << "Green Difference Color Final: " << pValidationItem.pFinalSubtractionGreen << endl;
				cout << "Blue Difference Color Final: " << pValidationItem.pFinalSubtractionBlue << endl;
				cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "Printing Pixel One Data" << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Red Difference Color Final: " << pValidationItem.pFinalSubtractionRed << endl;
				imageMaskLog << "Green Difference Color Final: " << pValidationItem.pFinalSubtractionGreen << endl;
				imageMaskLog << "Blue Difference Color Final: " << pValidationItem.pFinalSubtractionBlue << endl;
				imageMaskLog << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;

			}
		}
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;

	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::InitializePixelsValidationUsingADescrptorColorsViaSubtraction(HINSTANCE hInstance,
	HWND hWnd,
	CBThreshHoldVarColorDescriptorSubtraction pColorThresoldStructure,
	vector<PixelObject> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	for (PixelObject pOutputData : pPixelBundleArrayStructure)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
			{

				cout << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;

				imageMaskLog << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;


			}
		}
	}


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;




	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSApplyPixelColorDescriptorViaSubtraction.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarColorDescriptorSubtraction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelObject);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelObject);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptorSubtraction);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptorSubtraction);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByPixelNumberRange(HINSTANCE hInstance, HWND hWnd,
	int pPixelNumberStart,
	int pPixelNumberEnd,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
		{

			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pIndex = pIndex + 1;
		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperationRGBAgainstPixelNumber(hInstance,
		hWnd, pPixelNumberStart,
		pPixelNumberEnd,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
			}


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromDescriptorForAGivenClass(HINSTANCE hInstance,
	HWND hWnd, 
	int pClassToRestore, 
	vector<OutputPixelObjectDescriptor> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectDescriptor pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.pRedValue0 != 255.0f) && (pPixelObject.pGreenValue0 != 255.0f) && (pPixelObject.pBlueValue0 != 255.0f))
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.pRedValue0;
			float pGreenComponent = pPixelObject.pGreenValue0;
			float pBlueComponent = pPixelObject.pBlueValue0;
			bool pIsPixelValid = pPixelObject.pClassMarkerValue;

	//		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
	//			cout << "X Value = " << pXValue << endl;
	//		cout << "Y Value = " << pYValue << endl;
			//			cout << "Red Value = " << pRedComponent << endl;
			//			cout << "Green Value = " << pGreenComponent << endl;
			//			cout << "Blue Component = " << pBlueComponent << endl;
			//		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			//		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//		pOutputFileStream << "X Value = " << pXValue << endl;
			//		pOutputFileStream << "Y Value = " << pYValue << endl;
			//		pOutputFileStream << "Red Value = " << pRedComponent << endl;
			//		pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			//		pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			//		pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesFromDescriptor(hInstance,
		hWnd,
		pClassToRestore,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromDescriptor(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].RMask != 777) && (p[i].GMask != 777) && (p[i].BMask != 777))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			//			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			//			cout << "X Position: " << pPixelObject.xPosition << endl;
			//			cout << "Y Position: " << pPixelObject.yPosition << endl;
			//			cout << "Red Component: " << pPixelObject.RMask << endl;
			//			cout << "Green Component: " << pPixelObject.GMask << endl;
			//			cout << "Blue Component: " << pPixelObject.BMask << endl;


			//			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			//			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			//			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			//			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			//		pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			//		pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromDescriptor(HINSTANCE hInstance,
	HWND hWnd,
	int pSectorNumber,
	vector<OutputPixelObjectDescriptor> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	CBRestorationStructDescriptor pConstantBufferVar;
	pConstantBufferVar.pClassObjectToRestore = pSectorNumber;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromDescriptorClass.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBRestorationStructDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferVar;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}















HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromDescriptorForSelectedClass(HINSTANCE hInstance,
	HWND hWnd,
	int pSelectedClass,
	vector<OutputPixelObjectDescriptor> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectDescriptor pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.pRedValue0 != 255.0f) && (pPixelObject.pGreenValue0 != 255.0f) && (pPixelObject.pBlueValue0 != 255.0f))
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.pRedValue0;
			float pGreenComponent = pPixelObject.pGreenValue0;
			float pBlueComponent = pPixelObject.pBlueValue0;
			bool pIsPixelValid = pPixelObject.pClassMarkerValue;

			//		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//			cout << "X Value = " << pXValue << endl;
			//		cout << "Y Value = " << pYValue << endl;
			//			cout << "Red Value = " << pRedComponent << endl;
			//			cout << "Green Value = " << pGreenComponent << endl;
			//			cout << "Blue Component = " << pBlueComponent << endl;
			//		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			//		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//		pOutputFileStream << "X Value = " << pXValue << endl;
			//		pOutputFileStream << "Y Value = " << pYValue << endl;
			//		pOutputFileStream << "Red Value = " << pRedComponent << endl;
			//		pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			//		pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			//		pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	CBRestorationStructDescriptor pRestorationStruct;
	pRestorationStruct.pClassObjectToRestore = pSelectedClass;


	hr = InitializeRGBPixelImageRestorationResourcesFromDescriptorForSelectedClass(hInstance,
		hWnd,
		pRestorationStruct,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromDescriptor(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].RMask != 777) && (p[i].GMask != 777) && (p[i].BMask != 777))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			//			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			//			cout << "X Position: " << pPixelObject.xPosition << endl;
			//			cout << "Y Position: " << pPixelObject.yPosition << endl;
			//			cout << "Red Component: " << pPixelObject.RMask << endl;
			//			cout << "Green Component: " << pPixelObject.GMask << endl;
			//			cout << "Blue Component: " << pPixelObject.BMask << endl;


			//			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			//			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			//			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			//			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			//		pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			//		pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromSubtractionDescriptorForSelectedClass(HINSTANCE hInstance,
	HWND hWnd,
	int pSelectedClass,
	vector<OutputPixelObjectDescriptorSubtraction> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectDescriptorSubtraction pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.pRedValue0 != 255.0f) && (pPixelObject.pGreenValue0 != 255.0f) && (pPixelObject.pBlueValue0 != 255.0f))
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.pRedValue0;
			float pGreenComponent = pPixelObject.pGreenValue0;
			float pBlueComponent = pPixelObject.pBlueValue0;
			bool pIsPixelValid = pPixelObject.pClassMarkerValue;

			//		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//			cout << "X Value = " << pXValue << endl;
			//		cout << "Y Value = " << pYValue << endl;
			//			cout << "Red Value = " << pRedComponent << endl;
			//			cout << "Green Value = " << pGreenComponent << endl;
			//			cout << "Blue Component = " << pBlueComponent << endl;
			//		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			//		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//		pOutputFileStream << "X Value = " << pXValue << endl;
			//		pOutputFileStream << "Y Value = " << pYValue << endl;
			//		pOutputFileStream << "Red Value = " << pRedComponent << endl;
			//		pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			//		pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			//		pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	CBRestorationStructDescriptor pRestorationStruct;
	pRestorationStruct.pClassObjectToRestore = pSelectedClass;


	hr = InitializeRGBPixelImageRestorationResourcesFromSubtractionDescriptorForSelectedClass(hInstance,
		hWnd,
		pRestorationStruct,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromDescriptor(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			float pControlSum = 0.0f;
			pControlSum = p[i].pixelNumber + p[i].xPosition + p[i].yPosition;

			if ((pControlSum > 0.0f) && (p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].RMask != 777) && (p[i].GMask != 777) && (p[i].BMask != 777))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			//			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			//			cout << "X Position: " << pPixelObject.xPosition << endl;
			//			cout << "Y Position: " << pPixelObject.yPosition << endl;
			//			cout << "Red Component: " << pPixelObject.RMask << endl;
			//			cout << "Green Component: " << pPixelObject.GMask << endl;
			//			cout << "Blue Component: " << pPixelObject.BMask << endl;


			//			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			//			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			//			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			//			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			//		pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			//		pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromDescriptorForSelectedClassWithSpecifiedThreads(HINSTANCE hInstance,
	HWND hWnd,
	int pSelectedClass,
	UINT pAmountOfThreads,
	vector<OutputPixelObjectDescriptor> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectDescriptor pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.pRedValue0 != 255.0f) && (pPixelObject.pGreenValue0 != 255.0f) && (pPixelObject.pBlueValue0 != 255.0f))
		{

			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.pRedValue0;
			float pGreenComponent = pPixelObject.pGreenValue0;
			float pBlueComponent = pPixelObject.pBlueValue0;
			bool pIsPixelValid = pPixelObject.pClassMarkerValue;

			//		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//			cout << "X Value = " << pXValue << endl;
			//		cout << "Y Value = " << pYValue << endl;
			//			cout << "Red Value = " << pRedComponent << endl;
			//			cout << "Green Value = " << pGreenComponent << endl;
			//			cout << "Blue Component = " << pBlueComponent << endl;
			//		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			//		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			//		pOutputFileStream << "X Value = " << pXValue << endl;
			//		pOutputFileStream << "Y Value = " << pYValue << endl;
			//		pOutputFileStream << "Red Value = " << pRedComponent << endl;
			//		pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			//		pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			//		pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	CBRestorationStructDescriptor pRestorationStruct;
	pRestorationStruct.pClassObjectToRestore = pSelectedClass;


	hr = InitializeRGBPixelImageRestorationResourcesFromDescriptorForSelectedClassWithNumberOfThreads(hInstance,
		hWnd,
		pAmountOfThreads,
		pRestorationStruct,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromDescriptor(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, pAmountOfThreads, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			float pControlSum = 0.0f;

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].RMask != 777) && (p[i].GMask != 777) && (p[i].BMask != 777))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			//			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			//			cout << "X Position: " << pPixelObject.xPosition << endl;
			//			cout << "Y Position: " << pPixelObject.yPosition << endl;
			//			cout << "Red Component: " << pPixelObject.RMask << endl;
			//			cout << "Green Component: " << pPixelObject.GMask << endl;
			//			cout << "Blue Component: " << pPixelObject.BMask << endl;


			//			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			//			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			//			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			//			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			//		pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			//		pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunRGBImageRestorationFromDescriptor(HINSTANCE hInstance, HWND hWnd, ID3D11ComputeShader* pImageRestorationComputeShader, 
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV, 
	UINT pNumberOfSRV, 
	UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
	
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };

	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pConstantBuff[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pConstantBuff);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;

}





HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromSubtractionDescriptorForSelectedClass(HINSTANCE hInstance, HWND hWnd,
	CBRestorationStructDescriptor pConstantBufferStruct, 
	vector<OutputPixelObjectDescriptorSubtraction> pInputFilterGrayscaleVector, 
	ID3D11ComputeShader** ppImageRestorationComputeShader, ID3D11Buffer** ppConstantBufferVar, ID3D11Buffer** ppImageRestorationInputBuffer, ID3D11Buffer** ppImageRestorationOutputBuffer, ID3D11ShaderResourceView** ppInputShaderResourceView, ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromSubtractionDecriptor.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBRestorationStructDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferStruct;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;





	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBufferVar = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromDescriptorForSelectedClass(HINSTANCE hInstance,
	HWND hWnd,
	CBRestorationStructDescriptor pDescriptorStruct,
	vector<OutputPixelObjectDescriptor> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppContstantBufffers,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromSubtractionDescriptor.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBRestorationStructDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pDescriptorStruct;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;





	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectDescriptorSubtraction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppContstantBufffers = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromDescriptorForSelectedClassWithNumberOfThreads(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfThreads,
	CBRestorationStructDescriptor pDescriptorStruct,
	vector<OutputPixelObjectDescriptor> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppContstantBufffers,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	stringstream pStringStreamVar;
	pStringStreamVar << pAmountOfThreads;
	string pThreadsParam = pStringStreamVar.str();
	cout << "Compiling the Compute SHader By Threshold" << endl;
	char* pVar = nullptr;
	pVar = (char*)pThreadsParam.c_str();

	hr = CompileD3DShaderFromFileWhithThreadMacro(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromShaderParametrizedThreads.hlsl",
		"CS_Main", pVar, "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBRestorationStructDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pDescriptorStruct;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;





	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppContstantBufffers = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromDescriptorForClassTwo(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectDescriptor> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromDescriptorClassTwo.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;





	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromCircularDescriptorForAGivenClass(HINSTANCE hInstance,
	HWND hWnd,
	int pClassToRestore,
	vector<OutputPixelObjectCircularData> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;


	for (OutputPixelObjectCircularData pPixelObject : pPixelObjectGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Centre X Oriented Coordinate = " << pPixelObject.pCentreXValue << endl;
		cout << "Centre Y Oriented Coordinate =  " << pPixelObject.pCentreYValue << endl;
		cout << "Distance To Point = " << pPixelObject.pDistanceToCentre << endl;
		cout << "Angle Tangent =  " << pPixelObject.pAngleToPixelTangent << endl;
		cout << "Angle Sine Value = " << pPixelObject.pAngleToPixelSine << endl;
		cout << "Angle Cosine Value = " << pPixelObject.pAngleToPixelCosine << endl;
		cout << "Angle To Pixel Data Radians = " << pPixelObject.pAngleValueRadians << endl;
		cout << "Angle To Pixel Data Degreed = " << pPixelObject.pAngleValueDegrees << endl;
		cout << "Class of Pixel Value = " << pPixelObject.pClassOfPixel << endl;

		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
		pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
		pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
		pOutputFileStream << "Centre X Oriented Coordinate = " << pPixelObject.pCentreXValue << endl;
		pOutputFileStream << "Centre Y Oriented Coordinate =  " << pPixelObject.pCentreYValue << endl;
		pOutputFileStream << "Distance To Point = " << pPixelObject.pDistanceToCentre << endl;
		pOutputFileStream << "Angle Tangent =  " << pPixelObject.pAngleToPixelTangent << endl;
		pOutputFileStream << "Angle Sine Value = " << pPixelObject.pAngleToPixelSine << endl;
		pOutputFileStream << "Angle Cosine Value = " << pPixelObject.pAngleToPixelCosine << endl;
		pOutputFileStream << "Angle To Pixel Data Radians = " << pPixelObject.pAngleValueRadians << endl;
		pOutputFileStream << "Angle To Pixel Data Degreed = " << pPixelObject.pAngleValueDegrees << endl;
		pOutputFileStream << "Class of Pixel Value = " << pPixelObject.pClassOfPixel << endl;


	}


	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesFromCircularEquation(hInstance,
		hWnd,
		pClassToRestore,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromDescriptor(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].RMask != 777) && (p[i].GMask != 777) && (p[i].BMask != 777))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunRGBImageRestorationFromCirclularData(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };

	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;

}





HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromCircularEquation(HINSTANCE hInstance,
	HWND hWnd,
	int pSectorNumber,
	vector<OutputPixelObjectCircularData> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	cbCircleEquationRestoration pConstantBufferVar;
	pConstantBufferVar.pClassOfPixelToRestore = pSectorNumber;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelsDataFromCircularEquation.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCircleEquationRestoration) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferVar;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectCircularData);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectCircularData);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::RestorePolarNotationOfPixels(HINSTANCE hInstance, HWND hWnd, 
	vector<OutputPixelObjectWithAngleValues> pOutputPixelVector, vector<PixelObject> *pRestorePixelVector)
{
	HRESULT hr = S_OK;




	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBufferClassOne = vector<PixelObject>();
	vector<PixelObject> ppOutputDataBufferClassTwo = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "2 Output Buffers for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "2 Unordered Access Views for Output Buffer of Pixels" << endl;
	cout << "2 Readback Data Buffers" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "2 Output Buffers for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "2 Unordered Access Views for Output Buffer of Pixels" << endl;
	pOutputFileStream << "2 Readback Data Buffers" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	pOutputFileStream << "We Will Start By Printing Out our Pixel Data" << endl;

	int pIndex = 0;

	

	cout << "Reserving Data And Preparing Resources" << endl;
	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBufferClassOne = nullptr;
	ID3D11Buffer* pOutputDataBufferClassTwo = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessViewClassOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessViewClassTwo = nullptr;
	ID3D11Buffer* pReadbackOutputBufferClassOne = nullptr;
	ID3D11Buffer* pReadbackOutputBufferClassTwo = nullptr;


	hr = InitializePolartNotationRestorationResources(hInstance,
		hWnd,
		pOutputPixelVector,
		&ppComputeShaderObject,
		&ppInputDataBuffer,
		&pOutputDataBufferClassOne,
		&pShaderResourceView,
		&pUnorderedAccessViewClassOne,
		&pReadbackOutputBufferClassOne);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPolarNotationRestoration(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessViewClassOne,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBufferClassOne, pOutputDataBufferClassOne);
		hr = m_pD3DCompContext->Map(pReadbackOutputBufferClassOne, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pOutputPixelVector.size(); ++i)
		{

			if (p[i].pixelNumber != 666)
			{

				ppOutputDataBufferClassOne.push_back(p[i]);
			}




		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBufferClassOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}






	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessViewClassOne);
	SafeReleaseA(&pReadbackOutputBufferClassOne);

	pOutputFileStream.close();
	*pRestorePixelVector = ppOutputDataBufferClassOne;

	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::RestoreInvalidRGBPixelFromClassifier(HINSTANCE hInstance,
	HWND hWnd,
	CBBinaryClassifierConstantBuffer pConstantData,
	vector<OutputPixelObjectClassified> pPixelObjectGrayScale,
	vector<PixelObject> *pClassOnePixelArray)
{
	HRESULT hr = S_OK;


	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBufferClassOne = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffers for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access Views for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffers" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffers for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access Views for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffers" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	pOutputFileStream << "We Will Start By Printing Out our Pixel Data" << endl;

	int pIndex = 0;

	for (OutputPixelObjectClassified pPixelObject : pPixelObjectGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pRedComponent = pPixelObject.rValue;
		float pGreenComponent = pPixelObject.gValue;
		float pBlueComponent = pPixelObject.gValue;
		int pClassOfPixel = 0;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Class of Pixel = " << pClassOfPixel << endl;

		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "Red Value = " << pRedComponent << endl;
		pOutputFileStream << "Green Value = " << pGreenComponent << endl;
		pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
		pOutputFileStream << "Is Pixel Valid = " << pClassOfPixel << endl;



	}

	cout << "Reserving Data And Preparing Resources" << endl;
	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBufferClassOne = nullptr;
	ID3D11Buffer* pOutputDataBufferClassTwo = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessViewClassOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessViewClassTwo = nullptr;
	ID3D11Buffer* pReadbackOutputBufferClassOne = nullptr;
	ID3D11Buffer* pReadbackOutputBufferClassTwo = nullptr;



	hr = InitializeRGBInvalidPixelImageRestorationResourcesFromClassifier(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		pConstantData,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBufferClassOne,
		&pShaderResourceView,
		&pUnorderedAccessViewClassOne,
		&pReadbackOutputBufferClassOne);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunResultsRestorationFromBinaryClassifier(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessViewClassOne,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBufferClassOne, pOutputDataBufferClassOne);
		hr = m_pD3DCompContext->Map(pReadbackOutputBufferClassOne, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{
			if ((p[i].pixelNumber != 0) && (p[i].xPosition != 0.0f) && (p[i].yPosition != 0.0f) && (p[i].RMask != 0.0f) && (p[i].GMask != 0.0f) && (p[i].BMask != 0.0f))
			{
				ppOutputDataBufferClassOne.push_back(p[i]);
			}



		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBufferClassOne)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}






	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessViewClassOne);
	SafeReleaseA(&pReadbackOutputBufferClassOne);

	pOutputFileStream.close();
	*pClassOnePixelArray = ppOutputDataBufferClassOne;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializePolartNotationRestorationResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectWithAngleValues> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBufferClassOne,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObjectOne,
	ID3D11Buffer** ppReadbackBufferOne)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePolarPixelsNotationObject.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}




	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectWithAngleValues);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectWithAngleValues);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBufferClassOne = pOutputBufferOne;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObjectOne = pOutputUAVOne;
	*ppReadbackBufferOne = pReadbackBufferOne;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RunPolarNotationRestoration(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };
	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCriteriaRGBUndiscreteBlueColor(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
		{

			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pIndex = pIndex + 1;
		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperationRGBUndiscreteBlueColor(hInstance,
		hWnd,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperationUndiscrete(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
			}


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingOperationRGBUndiscreteBlueColor(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();



	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSelectPixelsFromImageWithBluePredominance.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCriteriaRGBUndiscreteGreenColor(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
		{

			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pIndex = pIndex + 1;
		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperationRGBUndiscreteGreenColor(hInstance,
		hWnd,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperationUndiscrete(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
			}


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingOperationRGBUndiscreteGreenColor(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();



	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSelectPixelsFromImageWithGreenPredominance.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCriteriaRGBUndiscreteRedColor(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
		{

			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pIndex = pIndex + 1;
		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperationRGBUndiscreteRedColor(hInstance,
		hWnd,
		&ppComputeShaderObject,	
		ppPixelArrayInput,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperationUndiscrete(hInstance,
		hWnd,  ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{

			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
			}


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingOperationRGBUndiscreteRedColor(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppInputBuffer1, 
	ID3D11Buffer** ppOutputBuffer, 
	ID3D11ShaderResourceView** ppSRV1, 
	ID3D11UnorderedAccessView** ppUAVObject1, 
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();



	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSelectPixelsFromImageWithRedPredominance.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunImageThresholdingOperationUndiscrete(HINSTANCE hInstance, HWND hWnd,
		ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };

	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::CompareImagePixelsAgainstCoordianteValues(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	vector<OutputPixelBufferObjectCounting> *ppOutputPixelData,
	vector<PixelObject> *ppIdenticalPixelBuffer,
	vector<PixelObject> *ppDifferentPixelBuffer)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferObjectCounting> pPixelArrayOutputBuffer = vector<OutputPixelBufferObjectCounting>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;



	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;




	}








	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;

	for (PixelObject pPixelObject : pixelArrayTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;



	}






	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pInputDataBufferImageTwo = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageTwo = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	CountingCB pCountingCB;
	pCountingCB.pi_var = 22 / 7;


	hr = InitializeObjectCountingOperationResources(hInstance,
		hWnd,
		pixelArrayOne,
		pixelArrayTwo,
		pCountingCB,
		&ppComputeShaderForImageComparison,
		&pConstantBuffer,
		&pInputDataBufferImageOne,
		&pInputDataBufferImageTwo,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pInputDataSRVImageTwo,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne, pInputDataSRVImageTwo };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunObjectCountingOperation(hInstance, hWnd, ppComputeShaderForImageComparison,
		pConstantBuffer,
		pInputDataSRVImageOne,
		pInputDataSRVImageTwo,
		pOutputUnorderedView,
		2, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferObjectCounting* pOutputDataImages = (OutputPixelBufferObjectCounting*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferObjectCounting pOutputPixelValue = pOutputDataImages[pIndex];
		if (pOutputPixelValue.pArePixelsDifferent == true)
		{
			++pOutputPixelValue.pAmountOfDifferentPixels;
		}
		else if (pOutputPixelValue.pArePixelsDifferent == false)
		{
			++pOutputPixelValue.pAmountOfIdenticalPixels;
		}
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		cout << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		cout << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		cout << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;

		cout << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		cout << "Angle Tangent = " << pOutputPixelValue.pAngleTangentValue << endl;
		cout << "Angle Cosine = " << pOutputPixelValue.pAngleCosineValue << endl;
		cout << "Angle Sine = " << pOutputPixelValue.pAngleSinValue << endl;

		cout << "Angle Between Pixels Radians: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		cout << "Angle Between Pixels Degrees: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		cout << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;


		cout << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		imageMaskLog << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		imageMaskLog << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		imageMaskLog << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		imageMaskLog << "Angle Tangent = " << pOutputPixelValue.pAngleTangentValue << endl;
		imageMaskLog << "Angle Cosine = " << pOutputPixelValue.pAngleCosineValue << endl;
		imageMaskLog << "Angle Sine = " << pOutputPixelValue.pAngleSinValue << endl;

		imageMaskLog << "Angle Between Pixels Radians: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		imageMaskLog << "Angle Between Pixels Degrees: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;
		imageMaskLog << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		imageMaskLog << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageMaskLog << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);




		if (pOutputPixelValue.pArePixelsDifferent == 0 || pOutputPixelValue.pArePixelsDifferent == false)
		{
			PixelObject identicalPixel = PixelObject(pOutputPixelValue.pixelNumber,
				pOutputPixelValue.xPosition0,
				pOutputPixelValue.yPosition0,
				pOutputPixelValue.pRedValue0,
				pOutputPixelValue.pGreenValue0,
				pOutputPixelValue.pBlueValue0);
			pIdenticalPixelOutputArray.push_back(identicalPixel);

		}
		else if (pOutputPixelValue.pArePixelsDifferent == true || pOutputPixelValue.pArePixelsDifferent == 255)
		{
			PixelObject differentPixel = PixelObject(pOutputPixelValue.pixelNumber,
				pOutputPixelValue.xPosition0,
				pOutputPixelValue.yPosition0,
				pOutputPixelValue.pRedValue0,
				pOutputPixelValue.pGreenValue0,
				pOutputPixelValue.pBlueValue0);
			pDifferentPixelOutputArray.push_back(differentPixel);

		}

	}


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

	



	}





	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;




	}





	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	

	for (OutputPixelBufferObjectCounting pOutputPixelValue : pPixelArrayOutputBuffer)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		cout << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		cout << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		cout << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		cout << "X Difference: " << " = " << pOutputPixelValue.pXDifferenceValue << endl;
		cout << "Y Difference: " << " = " << pOutputPixelValue.pYDifferenceValue << endl;

		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		cout << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		cout << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		cout << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		cout << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		cout << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		cout << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position 0: " << " = " << pOutputPixelValue.xPosition0 << endl;
		imageMaskLog << "Y Position 0: " << " = " << pOutputPixelValue.yPosition0 << endl;
		imageMaskLog << "X Position 1: " << " = " << pOutputPixelValue.xPosition1 << endl;
		imageMaskLog << "Y Position 1: " << " = " << pOutputPixelValue.yPosition1 << endl;
		imageMaskLog << "X Difference: " << " = " << pOutputPixelValue.pXDifferenceValue << endl;
		imageMaskLog << "Y Difference: " << " = " << pOutputPixelValue.pYDifferenceValue << endl;

		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Distance Between Pixels: " << " = " << pOutputPixelValue.pDistanceBetweenPixels << endl;
		imageMaskLog << "Tangent Value: " << " = " << pOutputPixelValue.pAngleTangentValue << endl;
		imageMaskLog << "Cosine Value: " << " = " << pOutputPixelValue.pAngleCosineValue << endl;
		imageMaskLog << "Sine Value: " << " = " << pOutputPixelValue.pAngleSinValue << endl;

		imageMaskLog << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsRadians << endl;
		imageMaskLog << "Angle Between Pixels: " << " = " << pOutputPixelValue.pAngleBetweenPixelsDegrees << endl;

		imageMaskLog << "Are Pixels Different =" << pOutputPixelValue.pArePixelsDifferent << endl;
		imageMaskLog << "Amount Of Identical Pixels = " << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageMaskLog << "Amount Of Different Pixels = " << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing Identical Pixel Array Buffer" << endl;
	imageMaskLog << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

	}


	pIdenticalPixelAmount = pIdenticalPixelOutputArray.size();
	pDifferentPixelAmount = pDifferentPixelOutputArray.size();

	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppIdenticalPixelBuffer = pIdenticalPixelOutputArray;
	*ppDifferentPixelBuffer = pDifferentPixelOutputArray;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeObjectCountingOperationResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	CountingCB pCountingCB,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBufferImageOne,
	ID3D11Buffer** ppInputBufferImageTwo,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObjectOutput,
	ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11Buffer* pOutputIdenticalPixelBuffer = nullptr;
	ID3D11Buffer* pOutputDifferentPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSCompareImagesAgainstCoordinateValues.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CountingCB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCountingCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
				MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObject);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObject);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferObjectCounting);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferObjectCounting);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayTwo.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferObjectCounting);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferObjectCounting);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferImageOne = pInputBuffer1;
	*ppInputBufferImageTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunObjectCountingOperation(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11ShaderResourceView* ppSRV2,
	ID3D11UnorderedAccessView* pUAVObjectOutput,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1, ppSRV2 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUAVObjectOutput };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pCBBuffer[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pCBBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::LocalizePixelsUsingCircleEquatuion(HINSTANCE hInstance,
	HWND hWnd, float pCentreXValue,
	float pCentreYValue, float piVar,
	float pRadiusValue,
	int pPointLiesOnTheCircle, int pPointLiesInsideTheCircle,
	int pPointLiesOutsideOfTheCircle,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectCircularData> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\ComputePixelAngles.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCircularData> ppOutputDataBuffer = vector<OutputPixelObjectCircularData>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelLocalizationUsingCircularEquationResources(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pCentreXValue, pCentreYValue,
		piVar, pRadiusValue,
		pPointLiesOnTheCircle,
		pPointLiesInsideTheCircle,
		pPointLiesOutsideOfTheCircle,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelDeltaFunction(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCircularData* p =(OutputPixelObjectCircularData*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectCircularData pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXValue << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreXValue << endl;
			cout << "Distance To Pixel: " << pPixelObject.pDistanceToCentre << endl;
			cout << "Angle Tangent: " << pPixelObject.pAngleToPixelTangent << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleToPixelSine << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleToPixelCosine << endl;
			cout << "Angle Value Radians: " << pPixelObject.pAngleValueRadians << endl;
			cout << "Angle Value Degrees: " << pPixelObject.pAngleValueDegrees << endl;
			cout << "Pixel Quarter" << pPixelObject.pQuarterValue << endl;
			cout << "Class Of Pixel" << pPixelObject.pClassOfPixel << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "X Polar Coordinate: " << pPixelObject.pCentreXValue << endl;
			pOutputFileStream << "Y Polar Coordinate: " << pPixelObject.pCentreXValue << endl;
			pOutputFileStream << "Distance To Pixel: " << pPixelObject.pDistanceToCentre << endl;
			pOutputFileStream << "Angle Tangent: " << pPixelObject.pAngleToPixelTangent << endl;
			pOutputFileStream << "Angle Sine Value:" << pPixelObject.pAngleToPixelSine << endl;
			pOutputFileStream << "Angle Cosine Value:" << pPixelObject.pAngleToPixelCosine << endl;
			pOutputFileStream << "Angle Value Radians: " << pPixelObject.pAngleValueRadians << endl;
			pOutputFileStream << "Angle Value Degrees: " << pPixelObject.pAngleValueDegrees << endl;
			pOutputFileStream << "Pixel Quarter" << pPixelObject.pQuarterValue << endl;
			pOutputFileStream << "Class Of Pixel" << pPixelObject.pClassOfPixel << endl;



		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializePixelLocalizationUsingCircularEquationResources(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pCentreXValue,
	float pCentreYValue,
	float piVar,
	float pCircleRadius,
	int pPointLiesOnTheCircleVar,
	int pPointLiesInsideTheCircleVar,
	int pPointLiesOutsideOfTheCircleVar,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	cbCircleEquationCompute pCentrePosition;
	pCentrePosition.pCentreX = pCentreXValue;
	pCentrePosition.pCentreX = pCentreYValue;
	pCentrePosition.pCircleRadius = pCircleRadius;
	pCentrePosition.pi_var = piVar;
	pCentrePosition.pPointLiesInsideTheCircle = pPointLiesInsideTheCircleVar;
	pCentrePosition.pPointLiesOnTheCircle = pPointLiesOnTheCircleVar;
	pCentrePosition.pPointLiesOutsideOfTheCircle = pPointLiesOutsideOfTheCircleVar;

	pCentrePosition.pi_var = DirectX::XM_PI;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\LocalizationDescriptorUsingCircularEquationCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCircleEquationCompute) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCentrePosition;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCircularData);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCircularData);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCircularData);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCircularData);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromSectoringOperationForYPosition(HINSTANCE hInstance,
	HWND hWnd,
	int pSectorNumber,
	vector<FilterPixelLabel> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (FilterPixelLabel pPixelObject : pPixelObjectGrayScale)
	{

		if (pPixelObject.pIsPixelValid = true)
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.gValue;
			bool pIsPixelValid = pPixelObject.pIsPixelValid;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Value = " << pRedComponent << endl;
			cout << "Green Value = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Value = " << pXValue << endl;
			pOutputFileStream << "Y Value = " << pYValue << endl;
			pOutputFileStream << "Red Value = " << pRedComponent << endl;
			pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesFromSectoringForYPosition(hInstance,
		hWnd,
		pSectorNumber,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromSectoringFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 666) && (p[i].xPosition != 666) && (p[i].yPosition != 666) && (p[i].RMask != 666) && (p[i].GMask != 666) && (p[i].BMask != 666))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromSectoringOperationForXPosition(HINSTANCE hInstance, HWND hWnd, int pSelectedSector, vector<FilterPixelLabel> pPixelObjectGrayScale, vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (FilterPixelLabel pPixelObject : pPixelObjectGrayScale)
	{

		if (pPixelObject.pIsPixelValid = true)
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.gValue;
			bool pIsPixelValid = pPixelObject.pIsPixelValid;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Value = " << pRedComponent << endl;
			cout << "Green Value = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Value = " << pXValue << endl;
			pOutputFileStream << "Y Value = " << pYValue << endl;
			pOutputFileStream << "Red Value = " << pRedComponent << endl;
			pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesFromSectoringForXPosition(hInstance,
		hWnd,
		pSelectedSector,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromSectoringFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].RMask != 777) && (p[i].GMask != 777) && (p[i].BMask != 777))
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunRGBImageRestorationFromSectoringFilter(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };

	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;

}





HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromSectoringForXPosition(HINSTANCE hInstance,
	HWND hWnd,
	int pSectorNumber,
	vector<FilterPixelLabel> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	CBPixelSortingRestoration pConstantBufferVar;
	pConstantBufferVar.pGroupToRestore = pSectorNumber;
	

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestorePixelsFromSectoringShaderForXPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPixelSortingRestoration) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferVar;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
	//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(FilterPixelLabel);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(FilterPixelLabel);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromSectoringForYPosition(HINSTANCE hInstance,
	HWND hWnd,
	int pSectorNumber,
	vector<FilterPixelLabel> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;

	

	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	CBPixelSortingRestoration pConstantBufferVar;
	pConstantBufferVar.pGroupToRestore = pSectorNumber;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestorePixelsFromSectoringShaderForYPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPixelSortingRestorationY) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferVar;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(FilterPixelLabel);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(FilterPixelLabel);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::DetectMultiColorPixelsInImage(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeMultiColorImageDetectionResources(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY, &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;

			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeMultiColorImageDetectionResources(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThresholdImageConstantBufferCoordinatesRGB pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pMinimumX = pMinimumX;
	pBinaryImageConstantBuffer.pMinimumY = pMinimumY;
	pBinaryImageConstantBuffer.pMaximumX = pMaximumX;
	pBinaryImageConstantBuffer.pMaximumY = pMaximumY;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSIsPixelNotSingleColor.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThresholdImageConstantBufferCoordinatesRGB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::RestoreNonZeroRGBPixelsFromImageCompation(HINSTANCE hInstance, HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector, vector<PixelObject> *pPixelObjectVectorOutput)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\ResultsRestorationFromRGBImageComparison.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pInputFilterGrayscaleVector.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	float pColorSum = 0.0f;

	for (OutputPixelBufferRGB pOutputPixelValue : pInputFilterGrayscaleVector)
	{

		if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pOutputFileStream << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pOutputFileStream << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pOutputFileStream << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pOutputFileStream << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pOutputFileStream << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pOutputFileStream << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pOutputFileStream << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pOutputFileStream << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pOutputFileStream << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pOutputFileStream << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pOutputFileStream << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pOutputFileStream << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pOutputFileStream << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pOutputFileStream << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
		}

	
		pIndex++;
	}


	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeNonZeroElementsRestorationAfterSubtractionRGB(hInstance,
		hWnd,
		pInputFilterGrayscaleVector,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pInputFilterGrayscaleVector.size(); ++i)
		{

			if (p[i].pixelNumber != 777)
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObjectVectorOutput = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeNonZeroElementsRestorationAfterSubtractionRGB(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreNonZeroResultsFromImageSubtraction.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RestoreZeroRGBPixelsFromImageCompation(HINSTANCE hInstance, HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector, vector<PixelObject> *pPixelObjectVectorOutput)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\ResultsRestorationFromRGBImageComparison.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pInputFilterGrayscaleVector.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;



	for (OutputPixelBufferRGB pOutputPixelValue : pInputFilterGrayscaleVector)
	{
		if ((pOutputPixelValue.pOutputComparisonValueRed == 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen == 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue == 0.0f))
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pOutputFileStream << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pOutputFileStream << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pOutputFileStream << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pOutputFileStream << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pOutputFileStream << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pOutputFileStream << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pOutputFileStream << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pOutputFileStream << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pOutputFileStream << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pOutputFileStream << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pOutputFileStream << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pOutputFileStream << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pOutputFileStream << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pOutputFileStream << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		}
		
	}


	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeZeroElementsRestorationAfterSubtractionRGB(hInstance,
		hWnd,
		pInputFilterGrayscaleVector,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pInputFilterGrayscaleVector.size(); ++i)
		{

			
			if (p[i].pixelNumber != 777)
			{
				ppOutputDataBuffer.push_back(p[i]);

			}
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.RMask << endl;
				cout << "Green Component: " << pPixelObject.GMask << endl;
				cout << "Blue Component: " << pPixelObject.BMask << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


				if (pIndex >= 10)
				{
					break;
				}
				else
				{
					pIndex++;
				}
			}

		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObjectVectorOutput = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeZeroElementsRestorationAfterSubtractionRGB(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreZeroResultsFromImageSubtraction.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}











HRESULT DirectXStandardAlgorithmExecutor::RestoreNonZeroRGBPixelsFromImageCompationInitialPixels(HINSTANCE hInstance, HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector, vector<PixelObject> *pPixelObjectVectorOutput)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\ResultsRestorationFromRGBImageComparison.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pInputFilterGrayscaleVector.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	float pColorSum = 0.0f;

	for (OutputPixelBufferRGB pOutputPixelValue : pInputFilterGrayscaleVector)
	{

		if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pOutputFileStream << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pOutputFileStream << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pOutputFileStream << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pOutputFileStream << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pOutputFileStream << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pOutputFileStream << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pOutputFileStream << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pOutputFileStream << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pOutputFileStream << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pOutputFileStream << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pOutputFileStream << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pOutputFileStream << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pOutputFileStream << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pOutputFileStream << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
		}


		pIndex++;
	}


	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeNonZeroElementsRestorationAfterSubtractionRGBInitialPixels(hInstance,
		hWnd,
		pInputFilterGrayscaleVector,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pInputFilterGrayscaleVector.size(); ++i)
		{

			if (p[i].pixelNumber != 777)
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObjectVectorOutput = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeNonZeroElementsRestorationAfterSubtractionRGBInitialPixels(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreNonZeroResultsFromImageSubtractionInitialPixels.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RestoreZeroRGBPixelsFromImageCompationInitialPixels(HINSTANCE hInstance, HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector, vector<PixelObject> *pPixelObjectVectorOutput)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\ResultsRestorationFromRGBImageComparison.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pInputFilterGrayscaleVector.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;



	for (OutputPixelBufferRGB pOutputPixelValue : pInputFilterGrayscaleVector)
	{
		if ((pOutputPixelValue.pOutputComparisonValueRed == 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen == 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue == 0.0f))
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			pOutputFileStream << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			pOutputFileStream << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			pOutputFileStream << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			pOutputFileStream << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			pOutputFileStream << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			pOutputFileStream << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			pOutputFileStream << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			pOutputFileStream << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			pOutputFileStream << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			pOutputFileStream << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			pOutputFileStream << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			pOutputFileStream << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			pOutputFileStream << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			pOutputFileStream << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;


		}

	}


	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeZeroElementsRestorationAfterSubtractionRGBInitialPixels(hInstance,
		hWnd,
		pInputFilterGrayscaleVector,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pInputFilterGrayscaleVector.size(); ++i)
		{


			if (p[i].pixelNumber != 777)
			{
				ppOutputDataBuffer.push_back(p[i]);

			}
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.RMask << endl;
				cout << "Green Component: " << pPixelObject.GMask << endl;
				cout << "Blue Component: " << pPixelObject.BMask << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


				if (pIndex >= 10)
				{
					break;
				}
				else
				{
					pIndex++;
				}
			}

		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObjectVectorOutput = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeZeroElementsRestorationAfterSubtractionRGBInitialPixels(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBufferRGB> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreIdenticalPixelsForImageSubtractonInitialPixels.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




DirectXStandardAlgorithmExecutor::DirectXStandardAlgorithmExecutor(HINSTANCE hInstance, HWND hWnd)
	: DirectXComputeShaderManagementClass(hInstance, hWnd)
{
}


HRESULT DirectXStandardAlgorithmExecutor::ExperimentWithComplexNumbers(HINSTANCE hInstance, HWND hWnd, std::complex<float> pNumberOne, std::complex<float> pNumberTwo, std::complex<float> *ppSummationValue, std::complex<float> *ppSubtractionValue, std::complex<float> *ppMultiplicationValue, std::complex<float> *ppDivisionValue)
{
	HRESULT hr = S_OK;
	std::complex<float> pSummationValue;
	std::complex<float> pSubtractionValue;
	std::complex<float> pMultiplicationValue;
	std::complex<float> pDivisionValue;

	pSummationValue = pNumberOne + pNumberTwo;
	pSubtractionValue = pNumberOne - pNumberTwo;
	pMultiplicationValue = pNumberOne * pNumberTwo;
	pDivisionValue = pNumberOne / pNumberTwo;

	*ppSummationValue = pSummationValue;
	*ppSubtractionValue = pSubtractionValue;
	*ppMultiplicationValue = pMultiplicationValue;
	*ppDivisionValue = pDivisionValue;

	return hr;

}




float DirectXStandardAlgorithmExecutor::ComputeMin(float pVal0, float pVar1, float pVar2)
{
	float pMinVar = 0;
	
	if (pVal0 < pVar1 && pVal0 < pVar2)
	{
		pMinVar = pVal0;
	}
	if (pVar1 < pVal0 && pVar1 < pVar2)
	{
		pMinVar = pVar1;
	}
	if (pVar2 < pVar1 && pVar2 < pVal0)
	{
		pMinVar = pVar2;
	}

	return pMinVar;
}


float DirectXStandardAlgorithmExecutor::ComputeMax(float pVal0, float pVar1, float pVar2)
{
	float pMaxVar = 0;

	if (pVal0 > pVar1 && pVal0 > pVar2)
	{
		pMaxVar = pVal0;
	}
	if (pVar1 > pVal0 && pVar1 > pVar2)
	{
		pMaxVar = pVar1;
	}
	if (pVar2 > pVar1 && pVar2 > pVal0)
	{
		pMaxVar = pVar2;
	}

	return pMaxVar;
}

DWORD WINAPI ConvertImageDataToGrayscale(void* pParam)
{
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HWND hWnd = NULL;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	GetClientRect(hWnd, &rc);
	WaitForSingleObject(pGrayScaleMutex, INFINITE);

	DirectXStandardAlgorithmExecutor* pStandardAlgorithmExecutor = (DirectXStandardAlgorithmExecutor*)pParam;
	hr = pStandardAlgorithmExecutor->ConvertImageDataToGrayScale(hInstance,
		hWnd,
		pPixelObjectGlobal,
		&pPixelObjectGlobalGrayScaleGlobal);
	ReleaseMutex(pGrayScaleMutex);

	return pResult;
}


static DWORD WINAPI ComparisonFunctionThread(void* pParam)
{
	WaitForSingleObject(pImageComparisonMutexObject, INFINITE);
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);


	DirectXStandardAlgorithmExecutor* pStandardAlgorithmObject = (DirectXStandardAlgorithmExecutor*)pParam;
	pStandardAlgorithmObject->CheckIfImagesAreIdentical(hInstance,
		hWnd, 0, 0,
		pImageOneForComparisonGlobalGrayScale,
		pImageTwoForComparisonGlobalGrayScale,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pOutputPixelBufferOutputArrayGlobal,
		&pImageComparisonIdenticalGlobal,
		&pImageComparisonDifferentGlobal,
		&pImageOneSum,
		&pImageOneAverage,
		&pImageTwoSum,
		&pImageTwoAverage,
		&pOutputArraySum,
		&pOutputArrayAverage,
		&pIdenticalArraySum,
		&pIdenticalArrayAverage,
		&pDifferentArraySum,
		&pDifferentArrayAverage,
		&pImagesIdenticalVar);

	ReleaseMutex(pImageComparisonMutexObject);
	return pResult;
}



static DWORD WINAPI ComparisonFunctionThreadGPU(void* pParam)
{
	WaitForSingleObject(pImageComparisonMutexObject, INFINITE);
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);


	DirectXStandardAlgorithmExecutor* pStandardAlgorithmObject = (DirectXStandardAlgorithmExecutor*)pParam;
	pStandardAlgorithmObject->CheckIfImagesAreIdenticalDecomposed(hInstance,
		hWnd, 0, 0,
		pImageOneForComparisonGlobalGrayScale,
		pImageTwoForComparisonGlobalGrayScale,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pOutputPixelBufferOutputArrayGlobal,
		&pOutputGrayScaleVectorGlobal,
		&pImageComparisonIdenticalGlobal,
		&pImageComparisonDifferentGlobal,
		&pImageOneSum,
		&pImageOneAverage,
		&pImageTwoSum,
		&pImageTwoAverage,
		&pOutputArraySum,
		&pOutputArrayAverage,
		&pIdenticalArraySum,
		&pIdenticalArrayAverage,
		&pDifferentArraySum,
		&pDifferentArrayAverage,
		&pImagesIdenticalVar);

	ReleaseMutex(pImageComparisonMutexObject);
	return pResult;
}



VOID CALLBACK WINAPI ComparisonFunctionThreadPool(PTP_CALLBACK_INSTANCE pInstanceVar,
	PVOID pContent, PTP_WORK pWorkItems)
{
	WaitForSingleObject(pImageComparisonMutexObject, INFINITE);
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);



	ThreadPoolTaskItemComparisonGrayScale* pDataItem = (ThreadPoolTaskItemComparisonGrayScale*)pContent;
	DirectXStandardAlgorithmExecutor* pStandardAlgorithmObject = pDataItem->pStandardAlgorithmExecuror;
	vector<PixelObjectGrayScale> pArrayOne = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pArrayTwo = vector<PixelObjectGrayScale>();
	pArrayOne = pDataItem->pVectorPixelOne;
	pArrayTwo = pDataItem->pVectorPixelTwo;;

	pStandardAlgorithmObject = (DirectXStandardAlgorithmExecutor*)pContent;
	pStandardAlgorithmObject->CheckIfImagesAreIdentical(hInstance,
		hWnd, 0, 0,
		pArrayOne,
		pArrayTwo,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pOutputPixelBufferOutputArrayGlobal,
		&pImageComparisonIdenticalGlobal,
		&pImageComparisonDifferentGlobal,
		&pImageOneSum,
		&pImageOneAverage,
		&pImageTwoSum,
		&pImageTwoAverage,
		&pOutputArraySum,
		&pOutputArrayAverage,
		&pIdenticalArraySum,
		&pIdenticalArrayAverage,
		&pDifferentArraySum,
		&pDifferentArrayAverage,
		&pImagesIdenticalVar);

	ReleaseMutex(pImageComparisonMutexObject);
}





static DWORD WINAPI ComparisonFunctionThreadRGB(void* pParam)
{
	WaitForSingleObject(pImageComparisonMutexObject, INFINITE);
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	BOOL pAreImagesIdentical = FALSE;

	DirectXStandardAlgorithmExecutor* pStandardAlgorithmObject = (DirectXStandardAlgorithmExecutor*)pParam;
	pStandardAlgorithmObject->CheckIfImagesAreIdenticalRGB(hInstance,
		hWnd, 0, 0,
		pImageOneForComparisonGlobalRGB,
		pImageTwoForComparisonGlobalRGB,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pOutputPixelBufferOutputArrayGlobalRGB,
		&pImageComparisonIdenticalGlobalRGB,
		&pImageComparisonDifferentGlobalRGB,
		&pImageOneIntensitySumRedGlobal,
		&pImageOneIntensitySumGreenGlobal,
		&pImageOneIntensitySumBlueGlobal,
		&pImageTwoIntensitySumRedGlobal,
		&pImageTwoIntensitySumGreenGlobal,
		&pImageTwoIntensitySumBlueGlobal,
		&pOutputArrayIntensitySumRedGlobal,
		&pOutputArrayIntensitySumGreenGlobal,
		&pOutputArrayIntensitySumBlueGlobal,
		&pIdenticalArrayIntensitySumRedGlobal,
		&pIdenticalArrayIntensitySumGreenGlobal,
		&pIdenticalArrayIntensitySumBlueGlobal,
		&pDifferentArrayIntensitySumRedGlobal,
		&pDifferentArrayIntensitySumGreenGlobal,
		&pDifferentArrayIntensitySumBlueGlobal,
		&pImageOneRedAverageGlobal,
		&pImageOneGreenAverageGlobal,
		&pImageOneBlueAverageGlobal,
		&pImageTwoRedAverageGlobal,
		&pImageTwoGreenAverageGlobal,
		&pImageTwoBlueAverageGlobal,
		&pOutputArrayRedAverageGlobal,
		&pOutputArrayGreenAverageGlobal,
		&pOutputArrayBlueAverageGlobal,
		&pIdenticalArrayRedAverageGlobal,
		&pIdenticalArrayGreenAverageGlobal,
		&pIdenticalArrayBlueAverageGlobal,
		&pDifferentArrayRedAverageGlobal,
		&pDifferentArrayGreenAverageGlobal,
		&pDifferentArrayBlueAverageGlobal,
		&pAreImagesIdentical);



	ReleaseMutex(pImageComparisonMutexObject);
	return pResult;
}




static DWORD WINAPI ComparisonFunctionThreadRGBSemaphores(void* pParam)
{
	WaitForSingleObject(pImageComparionSemaphoreObject, INFINITE);
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	HWND hWnd = NULL;
	GetClientRect(hWnd, &rc);
	BOOL pAreImagesIdentical = FALSE;

	DirectXStandardAlgorithmExecutor* pStandardAlgorithmObject = (DirectXStandardAlgorithmExecutor*)pParam;
	pStandardAlgorithmObject->CheckIfImagesAreIdenticalRGB(hInstance,
		hWnd, 0, 0,
		pImageOneForComparisonGlobalRGB,
		pImageTwoForComparisonGlobalRGB,
		&pAmountOfIdenticalPixels,
		&pAmountOfDifferentPixels,
		&pOutputPixelBufferOutputArrayGlobalRGB,
		&pImageComparisonIdenticalGlobalRGB,
		&pImageComparisonDifferentGlobalRGB,
		&pImageOneIntensitySumRedGlobal,
		&pImageOneIntensitySumGreenGlobal,
		&pImageOneIntensitySumBlueGlobal,
		&pImageTwoIntensitySumRedGlobal,
		&pImageTwoIntensitySumGreenGlobal,
		&pImageTwoIntensitySumBlueGlobal,
		&pOutputArrayIntensitySumRedGlobal,
		&pOutputArrayIntensitySumGreenGlobal,
		&pOutputArrayIntensitySumBlueGlobal,
		&pIdenticalArrayIntensitySumRedGlobal,
		&pIdenticalArrayIntensitySumGreenGlobal,
		&pIdenticalArrayIntensitySumBlueGlobal,
		&pDifferentArrayIntensitySumRedGlobal,
		&pDifferentArrayIntensitySumGreenGlobal,
		&pDifferentArrayIntensitySumBlueGlobal,
		&pImageOneRedAverageGlobal,
		&pImageOneGreenAverageGlobal,
		&pImageOneBlueAverageGlobal,
		&pImageTwoRedAverageGlobal,
		&pImageTwoGreenAverageGlobal,
		&pImageTwoBlueAverageGlobal,
		&pOutputArrayRedAverageGlobal,
		&pOutputArrayGreenAverageGlobal,
		&pOutputArrayBlueAverageGlobal,
		&pIdenticalArrayRedAverageGlobal,
		&pIdenticalArrayGreenAverageGlobal,
		&pIdenticalArrayBlueAverageGlobal,
		&pDifferentArrayRedAverageGlobal,
		&pDifferentArrayGreenAverageGlobal,
		&pDifferentArrayBlueAverageGlobal,
		&pAreImagesIdentical);

	ReleaseSemaphore(pImageComparionSemaphoreObject, 1, NULL);
	return pResult;
}


HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesAgainstDistanceAndAngleValues(HINSTANCE hInstance, HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	float pCentreX,
	float pCentreY,
	float pRedValue,
	float pGreenValue,
	float pBlueValue,
	float pDistanceValue,
	float pAngleValue,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectColorDistanceAndAngleFilter> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectColorDistanceAndAngleFilter> ppOutputDataBuffer = vector<OutputPixelObjectColorDistanceAndAngleFilter>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{

		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeResourcesForColorDistanceAngleFilter(hInstance,
		hWnd, pImageWidth, pImageHeight,
		pCentreX, pCentreY,
		pRedValue, pGreenValue, pBlueValue,
		pDistanceValue, pAngleValue,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectColorDistanceAndAngleFilter* p = (OutputPixelObjectColorDistanceAndAngleFilter*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectColorDistanceAndAngleFilter pPixelObject : ppOutputDataBuffer)
		{


			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Distance to centre: " << pPixelObject.pDistanceToPoint << endl;
			cout << "Angle Sine: " << pPixelObject.pAngleSine << endl;
			cout << "Angle Cosine: " << pPixelObject.pAngleCosine << endl;
			cout << "Angle tangent: " << pPixelObject.pAngleTangent << endl;
			cout << "Angle to Centre: " << pPixelObject.pAngleToPixelData << endl;
			cout << "Is Color Valid: " << pPixelObject.pIsColorValid << endl;
			cout << "Is Distance Valid: " << pPixelObject.pIsDistanceValid << endl;
			cout << "Is Angle Valid: " << pPixelObject.pIsAngleValid << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Distance to centre: " << pPixelObject.pDistanceToPoint << endl;
			pOutputFileStream << "Angle Sine: " << pPixelObject.pAngleSine << endl;
			pOutputFileStream << "Angle Cosine: " << pPixelObject.pAngleCosine << endl;
			pOutputFileStream << "Angle tangent: " << pPixelObject.pAngleTangent << endl;
			pOutputFileStream << "Angle to Centre: " << pPixelObject.pAngleToPixelData << endl;
			pOutputFileStream << "Is Color Valid: " << pPixelObject.pIsColorValid << endl;
			pOutputFileStream << "Is Distance Valid: " << pPixelObject.pIsDistanceValid << endl;
			pOutputFileStream << "Is Angle Valid: " << pPixelObject.pIsAngleValid << endl;
			pOutputFileStream << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::InitializeResourcesForColorDistanceAngleFilter(HINSTANCE hInstance, HWND hWnd,
	float pImageWidth, float pImageHeight,
	float pCentreX,
	float pCentreY,
	float pSampleRed,
	float pSampleGreen,
	float pSampleBlue,
	float pDistanceValue,
	float pAngleValue,
	vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBufferOne,
	ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObjectOutput, ID3D11Buffer** ppReadbackBufferOutput)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ColorDistanceAndAngleFilterData.txt");
	imageMaskLog.clear();

	CBPointDetectorForXAndYPositionCDA pConstantBufferStruct;
	pConstantBufferStruct.pSelectedX = pCentreX;
	pConstantBufferStruct.pSelectedY = pCentreY;
	pConstantBufferStruct.pSelectedRed = pSampleRed;
	pConstantBufferStruct.pSelectedGreen = pSampleGreen;
	pConstantBufferStruct.pSelectedBlue = pSampleBlue;
	pConstantBufferStruct.pDistanceToCentreThresold = pDistanceValue;
	pConstantBufferStruct.pAngleThresold = pAngleValue;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ThresoldImagePixelsAgainstDistanceAndAngle.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPointDetectorForXAndYPositionCDA) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferStruct;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectColorDistanceAndAngleFilter);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectColorDistanceAndAngleFilter);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectColorDistanceAndAngleFilter);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectColorDistanceAndAngleFilter);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferOne = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObjectOutput = pOutputUAV;
	*ppReadbackBufferOutput = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataFromRGBModelToQRCodeModel(HINSTANCE hInstance, HWND hWnd, float pRedValueForBlack, float pGreenValueForBlack, float pBlueValueForBlack, float pRedValueForWhite,
	float pGreenValueForWhite, float pBlueValueForWhite, int pMarkerForBlackColor, int pMarkerForWhiteColor, vector<PixelObject> ppPixelArrayInput, vector<OutputPixelObjectBlackAndWhite> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectBlackAndWhite> ppOutputDataBuffer = vector<OutputPixelObjectBlackAndWhite>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageConversionFromRGBModeloQRCodeModel(hInstance,
		hWnd, ppPixelArrayInput,
		pRedValueForBlack,
		pGreenValueForBlack,
		pBlueValueForBlack,
		pRedValueForWhite,
		pGreenValueForWhite,
		pBlueValueForWhite,
		pMarkerForBlackColor,
		pMarkerForWhiteColor,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelToQRCodeModelConversion(hInstance,
		hWnd, pConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectBlackAndWhite* p = (OutputPixelObjectBlackAndWhite*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Red Value : " << p[i].rValue  << endl;
			cout << "Green Value : " << p[i].gValue << endl;
			cout << "Blue Value : " << p[i].bValue << endl;
			cout << "Color Code: " << p[i].pMarkerCode << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Red Value : " << p[i].rValue << endl;
			pOutputFileStream << "Green Value : " << p[i].gValue << endl;
			pOutputFileStream << "Blue Value : " << p[i].bValue << endl;
			pOutputFileStream << "Color Code: " << p[i].pMarkerCode << endl;

			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelObjectBlackAndWhite pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Value : " << pPixelObject.rValue << endl;
			cout << "Green Value : " << pPixelObject.gValue << endl;
			cout << "Blue Value : " << pPixelObject.bValue << endl;
			cout << "Is Black: " << pPixelObject.pMarkerCode << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Value : " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Value : " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Value : " << pPixelObject.bValue << endl;
			pOutputFileStream << "Marker Code: " << pPixelObject.pMarkerCode << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConversionFromRGBModeloQRCodeModel(
	HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObject> pPixelArrayValue,
	float pRedValueForBlack,
	float pGreenValueForBlack,
	float pBlueValueForBlack,
	float pRedValueForWhite,
	float pGreenValueForWhite,
	float pBlueValueForWhite,
	int pMarkerForBlackColor,
	int pMarkerForWhiteColor,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBQRCodeScanner pTemperatureModelConstantBuffer;
	pTemperatureModelConstantBuffer.pRedValueForBlackColor = pRedValueForBlack;
	pTemperatureModelConstantBuffer.pGreenValueForBlackColor = pGreenValueForBlack;
	pTemperatureModelConstantBuffer.pBlueValueForBlackColor = pBlueValueForBlack;
	pTemperatureModelConstantBuffer.pRedValueForWhiteColor = pRedValueForWhite;
	pTemperatureModelConstantBuffer.pGreenValueForWhiteColor = pGreenValueForWhite;
	pTemperatureModelConstantBuffer.pBlueValueForWhiteColor = pBlueValueForWhite;
	pTemperatureModelConstantBuffer.pBlackBlockMarker = 1.0f;
	pTemperatureModelConstantBuffer.pWhiteBlockMarker = 0.0f;
	pTemperatureModelConstantBuffer.pInvalidBlockMarker = -1.0f;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling thCompute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSApplyBlackAndWhiteConvertionToPixel.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBQRCodeScanner) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pTemperatureModelConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pPixelArrayValue.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pPixelArrayValue[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelArrayValue.size() * sizeof(OutputPixelObjectBlackAndWhite);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectBlackAndWhite);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelArrayValue.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pPixelArrayValue.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pPixelArrayValue.size() * sizeof(OutputPixelObjectBlackAndWhite);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectBlackAndWhite);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelToQRCodeModelConversion(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataFromQRCodeModelToRGBModel(HINSTANCE hInstance,
	HWND hWnd, 
	float pRedValueForBlack, 
	float pGreenValueForBlack,
	float pBlueValueForBlack, float pRedValueForWhite, float pGreenValueForWhite, float pBlueValueForWhite, int pMarkerForBlackColor, int pMarkerForWhiteColor, 
	vector<OutputPixelObjectBlackAndWhite> ppPixelArrayInput, vector<PixelObject> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (OutputPixelObjectBlackAndWhite pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Value: " << pOutputData.rValue << endl;
		cout << "Green Value: " << pOutputData.gValue << endl;
		cout << "Blue Value: " << pOutputData.bValue << endl;
		cout << "Color Code: " << pOutputData.pMarkerCode << endl;


	
		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Value: " << pOutputData.rValue << endl;
		pOutputFileStream << "Green Value: " << pOutputData.gValue << endl;
		pOutputFileStream << "Blue Value: " << pOutputData.bValue << endl;
		pOutputFileStream << "Color Code: " << pOutputData.pMarkerCode << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageConversionFromQRCodeModelToRGBModel(hInstance,
		hWnd, ppPixelArrayInput,
		pRedValueForBlack,
		pGreenValueForBlack,
		pBlueValueForBlack,
		pRedValueForWhite,
		pGreenValueForWhite,
		pBlueValueForWhite,
		pMarkerForBlackColor,
		pMarkerForWhiteColor,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelToQRCodeModelConversion(hInstance,
		hWnd, pConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Red Component: " << p[i].RMask << endl;
			cout << "Green Component: " << p[i].GMask << endl;
			cout << "Blue Component: " << p[i].BMask << endl;


			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Red Component: " << p[i].RMask << endl;
			pOutputFileStream << "Green Component: " << p[i].GMask << endl;
			pOutputFileStream << "Blue Component: " << p[i].BMask << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObject pOutputData : ppOutputDataBuffer)
		{
			cout << "Pixel №: " << pOutputData.pixelNumber << endl;
			cout << "X Position: " << pOutputData.xPosition << endl;
			cout << "Y Position: " << pOutputData.yPosition << endl;
			cout << "Red Component" << pOutputData.RMask << endl;
			cout << "Green Component" << pOutputData.GMask << endl;
			cout << "Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
			pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
			pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
			pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
			pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;
		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConversionFromQRCodeModelToRGBModel(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectBlackAndWhite> pPixelArrayValue,
	float pRedValueForBlack,
	float pGreenValueForBlack,
	float pBlueValueForBlack, 
	float pRedValueForWhite,
	float pGreenValueForWhite,
	float pBlueValueForWhite, 
	int pMarkerForBlackColor, 
	int pMarkerForWhiteColor,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1, 
	ID3D11Buffer** ppOutputBuffer, 
	ID3D11ShaderResourceView** ppSRV1, 
	ID3D11UnorderedAccessView** ppUAVObject1, 
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBQRCodeScanner pTemperatureModelConstantBuffer;
	pTemperatureModelConstantBuffer.pRedValueForBlackColor = pRedValueForBlack;
	pTemperatureModelConstantBuffer.pGreenValueForBlackColor = pGreenValueForBlack;
	pTemperatureModelConstantBuffer.pBlueValueForBlackColor = pBlueValueForBlack;
	pTemperatureModelConstantBuffer.pRedValueForWhiteColor = pRedValueForWhite;
	pTemperatureModelConstantBuffer.pGreenValueForWhiteColor = pGreenValueForWhite;
	pTemperatureModelConstantBuffer.pBlueValueForWhiteColor = pBlueValueForWhite;
	pTemperatureModelConstantBuffer.pBlackBlockMarker = 1.0f;
	pTemperatureModelConstantBuffer.pWhiteBlockMarker = 0.0f;
	pTemperatureModelConstantBuffer.pInvalidBlockMarker = -1.0f;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling thCompute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelValuesFromBlackAndWhiteFilter.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBQRCodeScanner) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pTemperatureModelConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pPixelArrayValue.size() * sizeof(OutputPixelObjectBlackAndWhite);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectBlackAndWhite);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pPixelArrayValue[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelArrayValue.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelArrayValue.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pPixelArrayValue.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pPixelArrayValue.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunQRCodeToPixelConvertion(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataFromQRCodeModelToQRObject(HINSTANCE hInstance,
	HWND hWnd,
	float pRedValueForBlack,
	float pGreenValueForBlack,
	float pBlueValueForBlack, float pRedValueForWhite, float pGreenValueForWhite, float pBlueValueForWhite, int pMarkerForBlackColor, int pMarkerForWhiteColor,
	vector<OutputPixelObjectBlackAndWhite> ppPixelArrayInput, vector<OutputPixelQRCode> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<OutputPixelQRCode> ppOutputDataBuffer = vector<OutputPixelQRCode>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (OutputPixelObjectBlackAndWhite pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Value: " << pOutputData.rValue << endl;
		cout << "Green Value: " << pOutputData.gValue << endl;
		cout << "Blue Value: " << pOutputData.bValue << endl;
		cout << "Color Code: " << pOutputData.pMarkerCode << endl;



		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Value: " << pOutputData.rValue << endl;
		pOutputFileStream << "Green Value: " << pOutputData.gValue << endl;
		pOutputFileStream << "Blue Value: " << pOutputData.bValue << endl;
		pOutputFileStream << "Color Code: " << pOutputData.pMarkerCode << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageConversionFromQRCodeModelToQRObject(hInstance,
		hWnd, ppPixelArrayInput,
		pRedValueForBlack,
		pGreenValueForBlack,
		pBlueValueForBlack,
		pRedValueForWhite,
		pGreenValueForWhite,
		pBlueValueForWhite,
		pMarkerForBlackColor,
		pMarkerForWhiteColor,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunQRCodeGenerationProcedure(hInstance,
		hWnd, pConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelQRCode* p = (OutputPixelQRCode*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "QR Code Value: " << p[i].pQRCodeValue << endl;
			

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "QR Code Value: " << p[i].pQRCodeValue << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelQRCode pOutputData : ppOutputDataBuffer)
		{
			cout << "Pixel №: " << pOutputData.pixelNumber << endl;
			cout << "X Position: " << pOutputData.xPosition << endl;
			cout << "Y Position: " << pOutputData.yPosition << endl;
			cout << "QR Code: " << pOutputData.pQRCodeValue << endl;
			
			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
			pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
			pOutputFileStream << "QR Code: " << pOutputData.pQRCodeValue << endl;
		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConversionFromQRCodeModelToQRObject(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectBlackAndWhite> pPixelArrayValue,
	float pRedValueForBlack,
	float pGreenValueForBlack,
	float pBlueValueForBlack,
	float pRedValueForWhite,
	float pGreenValueForWhite,
	float pBlueValueForWhite,
	int pMarkerForBlackColor,
	int pMarkerForWhiteColor,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBQRCodeScanner pTemperatureModelConstantBuffer;
	pTemperatureModelConstantBuffer.pRedValueForBlackColor = pRedValueForBlack;
	pTemperatureModelConstantBuffer.pGreenValueForBlackColor = pGreenValueForBlack;
	pTemperatureModelConstantBuffer.pBlueValueForBlackColor = pBlueValueForBlack;
	pTemperatureModelConstantBuffer.pRedValueForWhiteColor = pRedValueForWhite;
	pTemperatureModelConstantBuffer.pGreenValueForWhiteColor = pGreenValueForWhite;
	pTemperatureModelConstantBuffer.pBlueValueForWhiteColor = pBlueValueForWhite;
	pTemperatureModelConstantBuffer.pBlackBlockMarker = 1.0f;
	pTemperatureModelConstantBuffer.pWhiteBlockMarker = 0.0f;
	pTemperatureModelConstantBuffer.pInvalidBlockMarker = -1.0f;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling thCompute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\QRCodeReaderCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBQRCodeScanner) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pTemperatureModelConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pPixelArrayValue.size() * sizeof(OutputPixelObjectBlackAndWhite);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectBlackAndWhite);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pPixelArrayValue[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelArrayValue.size() * sizeof(OutputPixelQRCode);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelQRCode);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelArrayValue.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pPixelArrayValue.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pPixelArrayValue.size() * sizeof(OutputPixelQRCode);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelQRCode);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunQRCodeGenerationProcedure(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::FilterPixelsForYPositionConstantAndXBreakpoint(HINSTANCE hInstance, HWND hWnd,
	float pYConstant, float pCentreX,
	int pClassOneValue, int pClassTwoValue,
	int pInvalidPixelValue,
	vector<PixelObject> ppPixelArrayInput,
	vector<FilterPixelLabel> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterPixelsForXPositionConstantAndYBreakpointInternal.txt");

	pOutputFileStream.clear();
	vector<FilterPixelLabel> ppOutputDataBuffer = vector<FilterPixelLabel>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		if (pIndex >= 10)
		{
			break;
		}
		else
		{
			pIndex++;
		}


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeDataAquisitionAlgorithmsForXBreakpointAndYConstant(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pCentreX,
		pYConstant,
		pClassOneValue, pClassTwoValue,
		pInvalidPixelValue,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);






	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resources For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelAquisitionAlgorithmRGB(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		FilterPixelLabel* p = (FilterPixelLabel*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{




			ppOutputDataBuffer.push_back(p[i]);


		}




		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (FilterPixelLabel pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Sector Value: " << pPixelObject.pSectorNumberValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Group Number: " << pPixelObject.pIsPixelValid << endl;



		}


		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);


	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::FilterPixelsForXPositionConstantAndYBreakpoint(HINSTANCE hInstance, HWND hWnd,
	float pXConstant, float pCentreY,
	int pClassOneValue, int pClassTwoValue, 
	int pInvalidPixelValue,
	vector<PixelObject> ppPixelArrayInput,
	vector<FilterPixelLabel> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterPixelsForXPositionConstantAndYBreakpointInternal.txt");

	pOutputFileStream.clear();
	vector<FilterPixelLabel> ppOutputDataBuffer = vector<FilterPixelLabel>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		if (pIndex >= 10)
		{
			break;
		}
		else
		{
			pIndex++;
		}


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeDataAquisitionAlgorithmsFordXConstantAndYBreakPoint(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pXConstant,
		pCentreY,
		pClassOneValue, pClassTwoValue,
		pInvalidPixelValue,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);






	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resources For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelAquisitionAlgorithmRGB(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		FilterPixelLabel* p = (FilterPixelLabel*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{




			ppOutputDataBuffer.push_back(p[i]);


		}


	

		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (FilterPixelLabel pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Sector Value: " << pPixelObject.pSectorNumberValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Group Number: " << pPixelObject.pIsPixelValid << endl;



		}


		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);


	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeDataAquisitionAlgorithmsForXBreakpointAndYConstant(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pCentreX,
	float pYConstant,
	int pClassOneLabel,
	int pClassTwoLabel,
	int pInvalidPixel,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	CBPixelSortingForYPosition pSortingArrayConstantBuffer;
	pSortingArrayConstantBuffer.pCentreX = pCentreX;
	pSortingArrayConstantBuffer.pYThresold = pYConstant;
	pSortingArrayConstantBuffer.pGroupOneLabelX = pClassOneLabel;
	pSortingArrayConstantBuffer.pGroupTwoLabelX = pClassTwoLabel;
	pSortingArrayConstantBuffer.pInvalidBlockMarker = pInvalidPixel;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterPixelArrayAgainstYConstantAndXBreakpoint.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}
	if (FAILED(hr))
	{

		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPixelFilterForYPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pSortingArrayConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}








	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(FilterPixelLabel);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(FilterPixelLabel);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(FilterPixelLabel);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(FilterPixelLabel);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;

}




HRESULT DirectXStandardAlgorithmExecutor::InitializeDataAquisitionAlgorithmsFordXConstantAndYBreakPoint(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pXConstant,
	float pCentreY,
	int pClassOneLabel,
	int pClassTwoLabel,
	int pInvalidPixelLabel,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageFilterXConstantYBreakpoint.txt");
	imageMaskLog.clear();

	CBPixelFilterForXPosition pPixelFilterForXPositionAndYBreakpoint;
	pPixelFilterForXPositionAndYBreakpoint.pXConstant = pXConstant;
	pPixelFilterForXPositionAndYBreakpoint.pYThresold = pCentreY;
	pPixelFilterForXPositionAndYBreakpoint.pGroupOneLabel = pClassOneLabel;
	pPixelFilterForXPositionAndYBreakpoint.pGroupTwoLabel = pClassTwoLabel;
	pPixelFilterForXPositionAndYBreakpoint.pInvalidPixelLabel = pInvalidPixelLabel;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterPixelArrayAgainstXConstantAndYBreakpoint.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPixelFilterForXPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pPixelFilterForXPositionAndYBreakpoint;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(FilterPixelLabel);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(FilterPixelLabel);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(FilterPixelLabel);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(FilterPixelLabel);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;


	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::RunPixelAquisitionAlgorithmRGB(HINSTANCE hInstance, HWND hWnd, ID3D11Buffer* pConstantBuffer, ID3D11ComputeShader* pComputeShaderObject, ID3D11ShaderResourceView* pShaderResourceView0, ID3D11UnorderedAccessView* pUnorderedUAV, UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::DetectAStraigntLineAgainstYPosition(HINSTANCE hInstance,
	HWND hWnd,
	float pYValue,
	float pSelectedRed,
	float pSelectedGreen,
	float pSelectedBlue,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectCorrespondenceLinearFunction> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StraightLineDetectorRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCorrespondenceLinearFunction> ppOutputDataBuffer = vector<OutputPixelObjectCorrespondenceLinearFunction>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeStraigntLineDetectionFunctionForYValues(hInstance,
		hWnd,
		ppPixelArrayInput.size(),
		pSelectedRed,
		pSelectedGreen,
		pSelectedBlue,
		pYValue,
		pOnTheLineLabel,
		pAboveTheLineLabel,
		pBelowTheLineLabel,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunStraigntLineDetectionObjectAgainstX(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCorrespondenceLinearFunction* p = (OutputPixelObjectCorrespondenceLinearFunction*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Y Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			cout << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelObjectValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "X Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			pOutputFileStream << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
			pOutputFileStream << "Is Pixel Valid: " << pPixelObject.pIsPixelObjectValid << endl;





		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::DetectAStraigntLineAgainstXPosition(HINSTANCE hInstance,
	HWND hWnd,
	float pXValue,
	float pSelectedRed,
	float pSelectedGreen,
	float pSelecteBlue,
	float pOnTHeLineLabel,
	int pLeftOfTheLineLabel, int pRightOfTheLineLabel,
	vector<PixelObject> ppPixelArrayInput, vector<OutputPixelObjectCorrespondenceLinearFunction> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StraightLineDetectorRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCorrespondenceLinearFunction> ppOutputDataBuffer = vector<OutputPixelObjectCorrespondenceLinearFunction>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelDetectionAgainstXFunction(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pXValue,
		pSelectedRed,
		pSelectedGreen,
		pSelecteBlue,
		pOnTHeLineLabel,
		pLeftOfTheLineLabel,
		pRightOfTheLineLabel,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunStraigntLineDetectionObjectAgainstX(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCorrespondenceLinearFunction* p = (OutputPixelObjectCorrespondenceLinearFunction*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			cout << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
			cout << "Is Pixel Object Valid: " << pPixelObject.pIsPixelObjectValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "X Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			pOutputFileStream << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
			pOutputFileStream << "Is Pixel Object Valid: " << pPixelObject.pIsPixelObjectValid << endl;



		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SortPixelsForYPosition(HINSTANCE hInstance,
	HWND hWnd,
	float pYThresold,	
	int pClassOneValue,
	int pClassTwoValue,
	vector<PixelObject> ppPixelArrayInput,
	vector<SortedPixelOutput> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<SortedPixelOutput> ppOutputDataBuffer = vector<SortedPixelOutput>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		if (pIndex >= 10)
		{
			break;
		}
		else
		{
			pIndex++;
		}


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeArraySortingAlgorithmsForYParameter(hInstance, hWnd,
		ppPixelArrayInput.size(),
		pYThresold,
		pClassOneValue,
		pClassTwoValue,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);







	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resources For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelSortingAlgorithmRGB(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		SortedPixelOutput* p = (SortedPixelOutput*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{




			ppOutputDataBuffer.push_back(p[i]);


		}


		std::sort(begin(ppOutputDataBuffer), end(ppOutputDataBuffer), SortArrayByClassValue);



		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (SortedPixelOutput pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Group Number: " << pPixelObject.pGroupLabelValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Group Number: " << pPixelObject.pGroupLabelValue << endl;



		}


		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);


	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeArraySortingAlgorithmsForYParameter(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pXThresold,
	int pClassOneValue,
	int pClassTwoValue,
	int pInvalidPixelLabel,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	CBPixelSortingForYPosition pSortingArrayConstantBuffer;
	pSortingArrayConstantBuffer.pYThresold = pXThresold;
	pSortingArrayConstantBuffer.pGroupOneLabelX = pClassOneValue;
	pSortingArrayConstantBuffer.pGroupTwoLabelX = pClassTwoValue;
	pSortingArrayConstantBuffer.pInvalidBlockMarker = pInvalidPixelLabel;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSortPixelsForSelectedYPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}
	if (FAILED(hr))
	{

		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPixelSortingForXPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pSortingArrayConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}








	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(SortedPixelOutput);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(SortedPixelOutput);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(SortedPixelOutput);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(SortedPixelOutput);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::SortPixelsForXPosition(HINSTANCE hInstance,
	HWND hWnd,
	float pXThresold,
	int pClassOneLabel,
	int pClassTwoLabel,
	vector<PixelObject> ppPixelArrayInput,
	vector<SortedPixelOutput> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<SortedPixelOutput> ppOutputDataBuffer = vector<SortedPixelOutput>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		if (pIndex >= 10)
		{
			break;
		}
		else
		{
			pIndex++;
		}


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeArraySortingAlgorithmsForXParameter(hInstance, hWnd,
		ppPixelArrayInput.size(),
		pXThresold,
		pClassOneLabel,
		pClassTwoLabel,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);







	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resources For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelSortingAlgorithmRGB(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		SortedPixelOutput* p = (SortedPixelOutput*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{




			ppOutputDataBuffer.push_back(p[i]);


		}


		std::sort(begin(ppOutputDataBuffer), end(ppOutputDataBuffer), SortArrayByClassValue);



		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (SortedPixelOutput pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Group Number: " << pPixelObject.pGroupLabelValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Group Number: " << pPixelObject.pGroupLabelValue << endl;



		}


		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);


	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeArraySortingAlgorithmsForXParameter(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pXThresold,
	int pClassOneLabel,
	int pClassTwoLabel,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	CBPixelSortingForXPosition pSortingArrayConstantBuffer;
	pSortingArrayConstantBuffer.pXThresold = pXThresold;
	pSortingArrayConstantBuffer.pGroupOneLabelX = pClassOneLabel;
	pSortingArrayConstantBuffer.pGroupTwoLabelX = pClassTwoLabel;
	


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSortPixelsForSelectedXPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}
	if (FAILED(hr))
	{

		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPixelSortingForXPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pSortingArrayConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}








	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(SortedPixelOutput);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(SortedPixelOutput);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(SortedPixelOutput);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(SortedPixelOutput);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelSortingAlgorithmRGB(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::DetectLineBetweenPoints(HINSTANCE hInstance, 
	HWND hWnd,
	float pMinimumX, 
	float pMinimumY, 
	float pMaximumX, 
	float pMaximumY, 
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectCorrespondenceLinearFunction> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCorrespondenceLinearFunction> ppOutputDataBuffer = vector<OutputPixelObjectCorrespondenceLinearFunction>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		if (pIndex >= 10)
		{
			break;
		}
		else
		{
			pIndex++;
		}


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeLineDetectionBetweenPoints(hInstance, hWnd,
		ppPixelArrayInput.size(),
		pMinimumX, pMinimumY,
		pMaximumX, pMaximumY,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);
		






	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resources For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunStraigntLineDetectionObject(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCorrespondenceLinearFunction* p = (OutputPixelObjectCorrespondenceLinearFunction*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
			cout << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			pOutputFileStream << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
			pOutputFileStream << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;



		}


		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);


	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeLineDetectionBetweenPoints(HINSTANCE hInstance, 
	HWND hWnd,
	UINT ppAmountOfSamples, 
	float pMinimumX,
	float pMinimumY, 
	float pMaximumX, 
	float pMaximumY,
	vector<PixelObject> pixelArrayOne, 
	ID3D11ComputeShader** ppComputeShaderObject, 
	ID3D11Buffer** ppConstantBuffer, 
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer, 
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	cout << "Let Us Compute the coeffiencients for our function" << endl;
	float pKCoefficient = 0.0f;
	float pUCoefficient = 0.0;;

	pKCoefficient = (pMaximumY - pMinimumY) / (pMaximumX - pMinimumX);
	pUCoefficient = pMinimumY - (pKCoefficient * pMinimumX);



	CBPointDetectorLineFunction pPointDetectionLineFunction;
	pPointDetectionLineFunction.pACoefficientVar = pKCoefficient;
	pPointDetectionLineFunction.pBCoefficientVar = pUCoefficient;
	pPointDetectionLineFunction.pOnTheLineLabel = 1;
	pPointDetectionLineFunction.pAboveTheLineLabel = 0;
	pPointDetectionLineFunction.pBelowTheLineLabel = -1;





	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDeterminePixelLocationAgainstALine.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}
	if (FAILED(hr))
	{

		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPointDetectorLineFunction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pPointDetectionLineFunction;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}








	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::DetectAHoughTransformAgainstADefinedLine(HINSTANCE hInstance,
	HWND hWnd,
	int pLineLengthValue,
	int pAngleInRadians,
	int pOnTheLineLabel, int pAboveTheLine, int pBelowTheLine, 
	float pSelectedRed, float pSelectedGreen, 
	float pSelectedBlue,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StraightLineDetectorHoughTransformRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeHoughTransformADefinedLineParameters(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pLineLengthValue,
		pAngleInRadians,
		pOnTheLineLabel,
		pAboveTheLine,
		pBelowTheLine,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunHoughTransformFunction(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{


			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Valid: " << pPixelObject.pUsedInComputations << endl;
	
			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Is Valid: " << pPixelObject.pUsedInComputations << endl;




		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunHoughTransformFunctionCoordinates(HINSTANCE hInstance, 
	HWND hWnd, 
	ID3D11Buffer* pConstantBuffer, 
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0, 
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, 
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;


	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1};
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeHoughTransformADefinedLineParameters(HINSTANCE hInstance,
	HWND hWnd, UINT pAmountOfSamples,
	int pLineLengthValue, int pAngleInRadians, int pOnTheLineLabel, int pAboveTheLineLabel, int pBelowTheLineLabel, vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject, ID3D11Buffer** ppConstantBuffer, ID3D11Buffer** ppInputBuffer1, ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1, ID3D11UnorderedAccessView** ppUAVObject1, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	CBHoughTransformLineMagnitude pLineMagnitudeCB;
	pLineMagnitudeCB.pAngleValue0 = pAngleInRadians;
	pLineMagnitudeCB.pLineMagnitude = pLineLengthValue;
	pLineMagnitudeCB.pPixelMarkerValueAboveTheLine = pAboveTheLineLabel;
	pLineMagnitudeCB.pPixelMarkerValueBelowTheLine = pBelowTheLineLabel;
	pLineMagnitudeCB.pPixelMarkerValueOnTheLine = pOnTheLineLabel;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDeterminePixelLocationAgainstALine.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBHoughTransformLineMagnitude) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pLineMagnitudeCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::DetectAHoughTransformAgainstADefinedLineCoordinates(HINSTANCE hInstance, 
	HWND hWnd, 
	float pXPosition0, 
	float pYPosition0, 
	float pXPosition1,
	float pYPosition1,
	int pOnTheLineLabel, int pAboveTheLine, int pBelowTheLine, float pSelectedRed,
	float pSelectedGreen, float pSelectedBlue, vector<PixelObject> ppPixelArrayInput,
	vector<float> pAngleValueInDegrees,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StraightLineDetectorHoughTransformCoordinatesRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	vector<AngleItem> pAngleItemVector = vector<AngleItem>();
    
	pIndex = 0;
	for (float pAngleValue = 0; pAngleValue <= 180.0f; ++pAngleValue)
	{
		float pAngleValueInRadians = pAngleValue * XM_PI / 180.0f;
		AngleItem pAngleItemObject;
		pAngleItemObject.pAngleId = pIndex;
		pAngleItemObject.pAngleValueInRadians = pAngleValueInRadians;
		pAngleItemVector.push_back(pAngleItemObject);
		pIndex++;
	}



	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBufferPixels = nullptr;
	ID3D11Buffer* ppInputDataAngles = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewOne = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewTwo = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeLineDetectionBetweenPoints(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pXPosition0,
		pYPosition0,
		pXPosition1,
		pYPosition1,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBufferPixels,
		&pOutputDataBuffer,
		&pShaderResourceViewOne,
		&pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunHoughTransformFunction(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceViewOne,
		pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{


			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Is Pixel Valid: " << pPixelObject.pUsedInComputations << endl;



		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBufferPixels);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceViewOne);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeHoughTransformADefinedLineParametersCoordinates(HINSTANCE hInstance,
	HWND hWnd, 
	UINT pAmountOfSamples, 
	float pXPosition0, 
	float pYPosition0, 
	float pXPosition1, 
	float pYPosition1, 
	int pOnTheLineLabel,
	int pAboveTheLineLabel, 
	int pBelowTheLineLabel, 
	vector<PixelObject> pixelArrayOne, 
	vector<AngleItem> pAngelItemVector, 
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer, 
	ID3D11Buffer** ppInputBufferPixels, 
	ID3D11Buffer** ppInputBufferAngles, 
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObject1, 
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	float pTangentValue = (pYPosition1 - pYPosition0) / (pXPosition1 - pXPosition0);
	float pAngleValue = atan(pTangentValue);
	float pLineMagnitudeValue = sqrtf(pow((pXPosition1 - pXPosition0), 2.0f) + pow((pYPosition1 - pYPosition0), 2.0f));


	CBHoughTransformLineMagnitude pLineMagnitudeCB;
	pLineMagnitudeCB.pAngleValue0 = pAngleValue;
	pLineMagnitudeCB.pLineMagnitude = pLineMagnitudeValue;
	pLineMagnitudeCB.pPixelMarkerValueAboveTheLine = pAboveTheLineLabel;
	pLineMagnitudeCB.pPixelMarkerValueBelowTheLine = pBelowTheLineLabel;
	pLineMagnitudeCB.pPixelMarkerValueOnTheLine = pOnTheLineLabel;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDetectPixelsUsingHoughTransformCoordiateSet.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBHoughTransformLineMagnitude) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pLineMagnitudeCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectHoughTransform);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectHoughTransform);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectHoughTransform);
	readback_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectHoughTransform);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferAngles = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::RunStraigntLineDetectionObjectAgainstX(HINSTANCE hInstance, HWND hWnd, ID3D11Buffer* pConstantBuffer, ID3D11ComputeShader* pComputeShaderObject, ID3D11ShaderResourceView* pShaderResourceView0, ID3D11UnorderedAccessView* pUnorderedUAV, UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializePixelDetectionAgainstXFunction(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples, 
	float pXValue,
	float pSelectedRed,
	float pSelectedGreen,
	float pSelectedBlue,
	int pOnTheLineLabel, 
	int pBelowTheLineLabel,
	int pAboveTheLineLabel,
	ID3D11ComputeShader** ppComputeShaderObject, 
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer, 
	ID3D11Buffer** ppInputBuffer1, 
	ID3D11Buffer** ppOutputBuffer, 
	ID3D11ShaderResourceView** ppSRV1, 
	ID3D11UnorderedAccessView** ppUAVObject1, 
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBLinePointDetectorXPosition pLineDetectorObject;
	pLineDetectorObject.xPositionValue = pXValue;
	pLineDetectorObject.pOnTheLineLabel = pOnTheLineLabel;
	pLineDetectorObject.pLeftOfTheLineLabel = pBelowTheLineLabel;
	pLineDetectorObject.pRightOfTheLineLabel = pAboveTheLineLabel;
	pLineDetectorObject.pRedComponentVar = pSelectedRed;
	pLineDetectorObject.pGreenComponentVar = pSelectedGreen;
	pLineDetectorObject.pBlueComponentVar = pSelectedBlue;

	

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDeterminePixelLocationAgainstXPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBLinePointDetectorXPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pLineDetectorObject;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;


	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::DetectAStraigntWithinAnImage(HINSTANCE hInstance,
	HWND hWnd, 
	float pACoefficient, 
	float pBCoefficient, int pOnTheLineLabel, int pAboveTheLine, int pBelowTheLine, float pSelectedRed, float pSelectedGreen, float pSelectedBlue, vector<PixelObject> ppPixelArrayInput, vector<OutputPixelObjectCorrespondenceLinearFunction> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StraightLineDetectorRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCorrespondenceLinearFunction> ppOutputDataBuffer = vector<OutputPixelObjectCorrespondenceLinearFunction>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeStraigntLineDetectionFunction(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pSelectedRed,
		pSelectedGreen,
		pSelectedBlue,
		pACoefficient,
		pBCoefficient,
        pOnTheLineLabel,
        pAboveTheLine,
        pBelowTheLine,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunStraigntLineDetectionObject(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCorrespondenceLinearFunction* p = (OutputPixelObjectCorrespondenceLinearFunction*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{


			ppOutputDataBuffer.push_back(p[i]);
            

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
			cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
			cout << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue<< endl;
			pOutputFileStream << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
			pOutputFileStream << "Is Pixel Object Valid " << pPixelObject.pIsPixelObjectValid << endl;



		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunStraigntLineDetectionObject(HINSTANCE hInstance, HWND hWnd, ID3D11Buffer* pConstantBuffer, ID3D11ComputeShader* pComputeShaderObject, ID3D11ShaderResourceView* pShaderResourceView0, ID3D11UnorderedAccessView* pUnorderedUAV, UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;


	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunCircleDetectionObject(HINSTANCE hInstance, HWND hWnd, ID3D11Buffer* pConstantBuffer, ID3D11ComputeShader* pComputeShaderObject, ID3D11ShaderResourceView* pShaderResourceView0, ID3D11UnorderedAccessView* pUnorderedUAV, UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;


	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationFromLineDetectorAboveTheLine(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	float pACoefficient,
	float pBCoefficient,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	CBLinePointDetector  pCircularObject;
	pCircularObject.pACoefficientVar = pACoefficient;
	pCircularObject.pBCoefficientVar = pBCoefficient;
	pCircularObject.pAboveTheLineLabel = pAboveTheLineLabel;
	pCircularObject.pOnTheLineLabel = pOnTheLineLabel;
	pCircularObject.pBelowTheLineLabel = pBelowTheLineLabel;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelsFromPixelLineDetectorAboveTheLine.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBLinePointDetector) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCircularObject;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::DetectACircleWithinAnImage(HINSTANCE hInstance, HWND hWnd, float pCentreX, float pCentreY, float pRadiusVar, vector<PixelObject> ppPixelArrayInput, vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\CircleDetectorСomputeShADER.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> 	ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeCircleDetectionFunction(hInstance,
		hWnd, pCentreX, pCentreY, pRadiusVar,
		ppPixelArrayInput, &ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunCircleDetectionObject(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used for Computations: " << pPixelObject.pUsedInComputations << endl;
	


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used for Computations: " << pPixelObject.pUsedInComputations << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializeCircleDetectionFunction(HINSTANCE hInstance,
	HWND hWnd,
	float pCentreX,
	float pCentreY,
	float pRadiusVar,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cbCircleEquationCompute pCircularObject;
	pCircularObject.pCentreX = pCentreX;
	pCircularObject.pCentreY = pCentreY;
	pCircularObject.pCircleRadius = pRadiusVar;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSCircleClipperShaderObject.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCircleEquationCompute) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCircularObject;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;



	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeStraigntLineDetectionFunction(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pSelectedRed,
	float pSelectedGreen,
	float pSelectedBlue,
	float pACoefficientVar,
	float pBCoefficientVar,
	int pOnTheLineLabel,
	int pBelowTheLineLabel,
	int pAboveTheLineLabel,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	
	CBPointDetectorLineFunction pPointDetectCB;
	pPointDetectCB.pACoefficientVar = pACoefficientVar;
	pPointDetectCB.pBCoefficientVar = pBCoefficientVar;
	pPointDetectCB.pAboveTheLineLabel = -1;
	pPointDetectCB.pBelowTheLineLabel = -1;
	pPointDetectCB.pOnTheLineLabel = 1;
	




	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDeterminePixelLocationAgainstALine.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPointDetectorLineFunction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pPointDetectCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	readback_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeStraigntLineDetectionFunctionForYValues(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	float pSelectedRed,
	float pSelectedGreen,
	float pSelectedBlue,
	float pYValues,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	CBLinePointDetectorYPosition pLinePointDetector;
	pLinePointDetector.pYPositionValue = pYValues;
	pLinePointDetector.pAboveTheLine = pAboveTheLineLabel;
	pLinePointDetector.pBelowTheLine = pBelowTheLineLabel;
	pLinePointDetector.pOnTheLineLabel = pOnTheLineLabel;
	pLinePointDetector.pSelectedRed = pSelectedRed;
	pLinePointDetector.pSelectedGreen = pSelectedGreen;
	pLinePointDetector.pSelectedBlue = pSelectedBlue;






	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDetetrminePixelLocationAgainstYPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBLinePointDetectorYPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pLinePointDetector;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	readback_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::DetectPixelOrientationAgainstAPoint(HINSTANCE hInstance,
	HWND hWnd,
	float pXValue,
	float pYValue,
	int pOnTheLineLabelValueX,
	int pLeftOfTheLineLabelValueX,
	int pRightOfTheLineLabelValueX,
	int pOnTheLineLabelValueY,
	int pBottomOfTheLineLabelValueY,
	int pTopOfTheLineLabelValueY,
	int pQuarterOneLabel,
	int pQuarterTwoLabel,
	int pQuarterThreeLabel,
	int pQuarterFourLabel,
	int pAxisLabel,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectCorrespondenceLinearCluster> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StraightLineDetectorRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCorrespondenceLinearCluster> ppOutputDataBuffer = vector<OutputPixelObjectCorrespondenceLinearCluster>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeStraigntLineDetectionFunctionForXAndYPosition(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pXValue,
		pYValue,
		pOnTheLineLabelValueX,
		pLeftOfTheLineLabelValueX,
		pRightOfTheLineLabelValueX,
		pOnTheLineLabelValueY,
		pBottomOfTheLineLabelValueY,
		pTopOfTheLineLabelValueY,
		pQuarterOneLabel,
		pQuarterTwoLabel,
		pQuarterThreeLabel,
		pQuarterFourLabel,
		pAxisLabel,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunStraigntLineDetectionObjectAgainstX(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCorrespondenceLinearCluster* p = (OutputPixelObjectCorrespondenceLinearCluster*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectCorrespondenceLinearCluster pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Polar X Value: " << pPixelObject.xCentrePosition  << endl;
			cout << "Polar Y Value: " << pPixelObject.yCentrePosition << endl;
			cout << "Distance to Point: " << pPixelObject.pDistanceToPoint << endl;
			cout << "Angle Tangent: " << pPixelObject.pAngleTangent << endl;
			cout << "Angle Cosine: " << pPixelObject.pAngleCosine << endl;
			cout << "Angle Sine: " << pPixelObject.pAngleSine << endl;
			cout << "Orientation Angle: " << pPixelObject.pAngleToPixelData << endl;
			cout << "Class Of Pixel X :" << pPixelObject.pClassOfPixelValueX << endl;
			cout << "Class Of Pixel Y : " << pPixelObject.pClassOfPixelValueY << endl;
			cout << "Quarter Value = " << pPixelObject.pQuarterValue << endl;

			pOutputFileStream<< "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream<< "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream<< "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream<< "Red Component Difference: " << pPixelObject.rValue << endl;
			pOutputFileStream<< "Red Component Difference: " << pPixelObject.gValue << endl;
			pOutputFileStream<< "Red Component Difference: " << pPixelObject.bValue << endl;
			pOutputFileStream<< "Polar X Value: " << pPixelObject.xCentrePosition  << endl;
			pOutputFileStream<< "Polar Y Value: " << pPixelObject.yCentrePosition << endl;
			pOutputFileStream << "Distance to Point: " << pPixelObject.pDistanceToPoint << endl;
			pOutputFileStream << "Angle Tangent: " << pPixelObject.pAngleTangent << endl;
			pOutputFileStream << "Angle Cosine: " << pPixelObject.pAngleCosine << endl;
			pOutputFileStream << "Angle Sine: " << pPixelObject.pAngleSine << endl;
			pOutputFileStream<< "Orientation Angle: " << pPixelObject.pAngleToPixelData << endl;
			pOutputFileStream<< "Class Of Pixel X :" << pPixelObject.pClassOfPixelValueX << endl;
			pOutputFileStream<< "Class Of Pixel Y : " << pPixelObject.pClassOfPixelValueY << endl;
			pOutputFileStream<< "Quarter Value = " << pPixelObject.pQuarterValue << endl;


		
		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::InitializeStraigntLineDetectionFunctionForXAndYPosition(HINSTANCE hInstance,
	HWND hWnd, 
	UINT pAmountOfSamples,
	float pXValue, float pYValue,
	int pOnTheLineLabelValueX, int pLeftOfTheLineLabelValueX, int pRightOfTheLineLabelValueX,
	int pOnTheLineLabelValueY, int pLeftOfTheLineLabelValueY, int pRightOfTheLineLabelValueY,
	int pQuarterOneLabel, int pQuarterTwoLabel, int pQuarterThreeLabel, int pQuarterFourLabel,
	int pAxisLabel,
	vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject, ID3D11Buffer** ppConstantBuffer, ID3D11Buffer** ppInputBuffer1, ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1, ID3D11UnorderedAccessView** ppUAVObject1, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	CBPointDetectorForXAndYPosition pConstantBufferData;
	pConstantBufferData.pSelectedX = pXValue;
	pConstantBufferData.pSelectedY = pYValue;
	pConstantBufferData.pi_var = DirectX::XM_PI;
	pConstantBufferData.pOnTheLineLabelX = pOnTheLineLabelValueX;
	pConstantBufferData.pOnTheLineLabelY = pOnTheLineLabelValueY;
	pConstantBufferData.pLeftOfTheLineLabel = pLeftOfTheLineLabelValueX;
	pConstantBufferData.pRightOfTheLineLabel = pRightOfTheLineLabelValueX;
	pConstantBufferData.pAboveTheLineLabel = pRightOfTheLineLabelValueY;
	pConstantBufferData.pBelowTheLineLabel = pLeftOfTheLineLabelValueY;
	pConstantBufferData.pQuarterOneLabel = pQuarterOneLabel;
	pConstantBufferData.pQuarterTwoLabel = pQuarterTwoLabel;
	pConstantBufferData.pQuarterThreeLabel = pQuarterThreeLabel;
	pConstantBufferData.pQuarterFourLabel = pQuarterFourLabel;
	pConstantBufferData.pAxisLabel = pAxisLabel;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDeterminePixelLocationAgainstXAndYPosition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBPointDetectorForXAndYPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferData;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearCluster);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearCluster);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearCluster);
	readback_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearCluster);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataToGrayScale(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObjectGrayScale> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageGrayScaleConversionResources(hInstance,
		hWnd, pixelArrayOne.size(), pixelArrayOne, &ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageToGrayScaleConvertion(hInstance,
		hWnd, pixelArrayOne, ppInputDataBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			p[i].pixelNumber = i;
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Grey Level: " << p[i].pGreyLevel << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Grey Level: " << p[i].pGreyLevel << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Grey Level: " << pPixelObject.pGreyLevel << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;


	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataToCMYK(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector <OutputPixelObjectCMYK> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectCMYK> ppOutputDataBuffer = vector<OutputPixelObjectCMYK>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageCMYKConversionResources(hInstance,
		hWnd, pixelArrayOne.size(), pixelArrayOne, &ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageToGrayScaleConvertion(hInstance,
		hWnd, pixelArrayOne, ppInputDataBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectCMYK* p = (OutputPixelObjectCMYK*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			p[i].pixelNumber = i;
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Cyan Value: " << p[i].pCyanValue << endl;
			cout << "Magenta Value" << p[i].pMagentaValue << endl;
			cout << "Yellow Value" << p[i].pYellowColorValue << endl;
			cout << "Black Value: " << p[i].pBlackKey << endl;


			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Cyan Value: " << p[i].pCyanValue << endl;
			pOutputFileStream << "Magenta Value" << p[i].pMagentaValue << endl;
			pOutputFileStream << "Yellow Value" << p[i].pYellowColorValue << endl;
			pOutputFileStream << "Black Value: " << p[i].pBlackKey << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelObjectCMYK pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Cyan Value: " << pPixelObject.pCyanValue << endl;
			cout << "Magenta Value" << pPixelObject.pMagentaValue << endl;
			cout << "Yellow Value" << pPixelObject.pYellowColorValue << endl;
			cout << "Black Value: " << pPixelObject.pBlackKey << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Cyan Value: " << pPixelObject.pCyanValue << endl;
			pOutputFileStream << "Magenta Value" << pPixelObject.pMagentaValue << endl;
			pOutputFileStream << "Yellow Value" << pPixelObject.pYellowColorValue << endl;
			pOutputFileStream << "Black Value: " << pPixelObject.pBlackKey << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageCMYKConversionResources(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ConvertColorFromRGBToCMYK.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCMYK);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectCMYK);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCMYK);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectCMYK);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunImageToCMYKConversion(HINSTANCE hInstance,
	HWND hWnd, ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ComputePixelDeltaFunctionFromCentreDirect(HINSTANCE hInstance,
	HWND hWnd,
	float pCentreX,
	float pCentreY,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectWithAngleValues> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\ComputePixelAngles.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectWithAngleValues> ppOutputDataBuffer = vector<OutputPixelObjectWithAngleValues>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelDeltaComputationResourcesDirect(hInstance,
		hWnd, pCentreX, pCentreY,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelDeltaFunction(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectWithAngleValues* p = (OutputPixelObjectWithAngleValues*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectWithAngleValues pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pOutputFileStream << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pOutputFileStream << "Radius: " << pPixelObject.pRadiusValue << endl;
			pOutputFileStream << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pOutputFileStream << "Radius Value: " << pPixelObject.pRadiusValue << endl;
			pOutputFileStream << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pOutputFileStream << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;



		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializePixelDeltaComputationResourcesDirect(HINSTANCE hInstance,
	HWND hWnd,
	float pCentreX,
	float pCentreY,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBCentrePosiion pCentrePosition;
	pCentrePosition.pXValue = pCentreX;
	pCentrePosition.pYValue = pCentreY;
	pCentrePosition.pi_var = DirectX::XM_PI;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeImageSectionValues.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBCentrePosiion) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCentrePosition;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectWithAngleValues);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectWithAngleValues);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectWithAngleValues);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectWithAngleValues);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ComputePixelDeltaFunctionFromCentre(HINSTANCE hInstance,
	HWND hWnd,
	float pCentreX,
	float pCentreY,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectWithAngleValues> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\ComputePixelAngles.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectWithAngleValues> ppOutputDataBuffer = vector<OutputPixelObjectWithAngleValues>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelDeltaComputationResources(hInstance,
		hWnd, pCentreX, pCentreY,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelDeltaFunction(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectWithAngleValues* p = (OutputPixelObjectWithAngleValues*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right



		for (OutputPixelObjectWithAngleValues pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			cout << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			cout << "Radius: " << pPixelObject.pRadiusValue << endl;
			cout << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			cout << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			cout << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "X Polar Coordinate: " << pPixelObject.pCentreXDifference << endl;
			pOutputFileStream << "Y Polar Coordinate: " << pPixelObject.pCentreYDifference << endl;
			pOutputFileStream << "Radius: " << pPixelObject.pRadiusValue << endl;
			pOutputFileStream << "Centre Difference Ratio: " << pPixelObject.pTangentValue << endl;
			pOutputFileStream << "Angle Sine Value:" << pPixelObject.pAngleSinValue << endl;
			pOutputFileStream << "Angle Cosine Value:" << pPixelObject.pAngleCosValue << endl;


	
		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializePixelDeltaComputationResources(HINSTANCE hInstance,
	HWND hWnd,
	float pCentreX, 
	float pCentreY,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();
	
	CBCentrePosiion pCentrePosition;
	pCentrePosition.pXValue = pCentreX;
	pCentrePosition.pYValue = pCentreY;
	pCentrePosition.pi_var = DirectX::XM_PI;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputePixelDeltaFromCentre.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBCentrePosiion) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCentrePosition;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectWithAngleValues);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectWithAngleValues);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
	//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectWithAngleValues);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectWithAngleValues);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
	//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelDeltaFunction(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::DetectPixelsOnAHorizontalLine(HINSTANCE hInstance, HWND hWnd,
	float pMinimumX, float pMaximumX, float pMaximumY,
	float pRedComponentToSelect,
	float pGreenComponentToSelect,
	float pBlueComponentToSelect,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;

		if (pIndex == 10)
		{
			break;;
		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelHorizontalLineDetection(hInstance,
		hWnd, pMinimumX, pMaximumX, pMaximumY,
		pRedComponentToSelect,
		pGreenComponentToSelect,
		pBlueComponentToSelect,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
			
			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}

		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializePixelHorizontalLineDetection(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumX,
	float pMaximumX, float pMinimumY,
	float pRedComponent,
	float pGreenComponent,
	float pBlueComponent,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThreshHoldVarCoordinates pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pXPosition0 = pMinimumX;
	pBinaryImageConstantBuffer.pYPosition0 = pMinimumY;
	pBinaryImageConstantBuffer.pXPosition1 = pMaximumX;
	pBinaryImageConstantBuffer.pYPosition1 = pMinimumY;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelsByCoordinatesConditionRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarCoordinates) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
		cout << "Creating the Unordered Access View For the Output Buffer" << endl;
		imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

		D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
		ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
		uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
		uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
		uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


		hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
			cout << "The Shader Resource View For Image Two Processing Module" << endl;
			imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		}
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
			imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
			imageMaskLog.close();
			return hr;
		}

		cout << "Creating the Readback Buffer for image subtraction function" << endl;
		imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

		D3D11_BUFFER_DESC readback_buffer_desc;
		ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
		readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
		readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
		readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
		readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

		hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
			cout << "The Shader Resource View For Image Two Processing Module" << endl;
			imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		}
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
			imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
			return hr;
		}

		*ppConstantBuffer = pConstantBuffer;
		*ppComputeShaderObject = pComputeShaderObject;
		*ppInputBuffer1 = pInputBuffer1;
		*ppOutputBuffer = pOutputBuffer;
		*ppSRV1 = pInputSRV1;
		*ppUAVObject1 = pOutputUAV;
		*ppReadbackBuffer = pReadbackBuffer;

		return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::DetectPixelsOnAVerticalLine(HINSTANCE hInstance, HWND hWnd,
	float pMinimumY, float pMaximumY, float pXPosition,
	float pRedComponentToSelect,
	float pGreenComponentToSelect,
	float pBlueComponentToSelect,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		if (pIndex >= 10)
		{
			break;
		}
		else
		{
			pIndex++;
		}

		
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelVerticalLineDetection(hInstance,
		hWnd, pMinimumY, pMaximumY, pXPosition,
		pRedComponentToSelect,
		pGreenComponentToSelect,
		pBlueComponentToSelect,
		&ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);






	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{



			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		pIndex = 0;
		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}

		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);


	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializePixelVerticalLineDetection(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumY,
	float pMaximumY,
	float pXConstant,
	float pRedComponent,
	float pGreenComponent,
	float pBlueComponent,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	CBThreshHoldVarCoordinates pVerticalLineDetectorCB;
	pVerticalLineDetectorCB.pXPosition0 = pXConstant;
	pVerticalLineDetectorCB.pYPosition0 = pMinimumY;
	pVerticalLineDetectorCB.pXPosition1 = pXConstant;
	pVerticalLineDetectorCB.pYPosition1 = pMaximumY;
	
	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDetectVerticalCorrespondenseInPixels.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarCoordinates) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pVerticalLineDetectorCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::SimulateCurrencyStateMachineObject(HINSTANCE hInstance,
	HWND hWnd,
	int pStableStateVar,
	int pGrowthStateVar,
	int pDeclineStateVar,
	int pUndefinedStateVar,
	int pVolatileState,
	vector<CurrencyObjectRate> ppCurrencyObjectCollection0,
	vector<CurrencyRateStateMachineObject> *pOutputResourceObject)
{

	HRESULT hr = S_OK;
	cout << "This Function Will Simulate The Currency Relationship" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Эта Функция Моделирует Машину состояний валютного цикла", (LPCSTR)"Message", 0);

	vector<CurrencyRateStateMachineObject> pResourceOutputCollection = vector<CurrencyRateStateMachineObject>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixes\\CurrencyStateMachineObject.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	cout << "First we Will Print Out Our Parameter Objects" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Для начала мы выведем и сохраним контрольные значения", (LPCSTR)"Message", 0);

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;


	cout << "Printing Precious Metal Objects" << endl;
	imageSegmentationDataFile << "Printing Precious Metal Objects" << endl;



	for (CurrencyObjectRate pCurrencyObject0 : ppCurrencyObjectCollection0)
	{
		cout << "Currency id = " << pCurrencyObject0.pCurrencyId << endl;
		cout << "Opening Price = " << pCurrencyObject0.pOpeningPrice << endl;
		cout << "Morning Price = " << pCurrencyObject0.pMorningPrice << endl;
		cout << "Afternoon Price = " << pCurrencyObject0.pAfternoonPrice << endl;
		cout << "Evening Price = " << pCurrencyObject0.pEveningPrice << endl;
	
		imageSegmentationDataFile << "Currency id = " << pCurrencyObject0.pCurrencyId << endl;
		imageSegmentationDataFile << "Opening Price = " << pCurrencyObject0.pOpeningPrice << endl;
		imageSegmentationDataFile << "Morning Price = " << pCurrencyObject0.pMorningPrice << endl;
		imageSegmentationDataFile << "Afternoon Price = " << pCurrencyObject0.pAfternoonPrice << endl;
		imageSegmentationDataFile << "Evening Price = " << pCurrencyObject0.pEveningPrice << endl;

	}

	cout << "Printing Currency Objects" << endl;
	imageSegmentationDataFile << "Printing Currency Objects" << endl;





	cout << "Creating the Resource Objects" << endl;

	ID3D11ComputeShader* pFinancialSpaceCS = nullptr;
	ID3D11Buffer* pCurrencyMetalConstantBuffer = nullptr;
	ID3D11Buffer* pCurrencyInputBuffer = nullptr;
	ID3D11Buffer* pCurrencySpaceOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pCurrencyInputSRV = nullptr;
	ID3D11UnorderedAccessView* pFinancialSpaceOutputUAV = nullptr;
	ID3D11Buffer* pFinancialSpaceReadbackBuffer = nullptr;

	cbCurrencyStateMachineBuffer pFinancialSpaceBufferConst;
	pFinancialSpaceBufferConst.UndefinedStateVar = 1;
	pFinancialSpaceBufferConst.DeclineStateVar = 2;
	pFinancialSpaceBufferConst.StableStateVar = 3;
	pFinancialSpaceBufferConst.GrowthStateVar = 4;

	hr = InitializeCurrencyStateMachine(hInstance,
		hWnd,
		pFinancialSpaceBufferConst,
		ppCurrencyObjectCollection0,
		&pFinancialSpaceCS,
		&pCurrencyMetalConstantBuffer,
		&pCurrencyInputBuffer,
		&pCurrencySpaceOutputBuffer,
		&pCurrencyInputSRV,
		&pFinancialSpaceOutputUAV,
		&pFinancialSpaceReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunCurrencyStateMachine(hInstance, hWnd,
		pCurrencyMetalConstantBuffer,
		pFinancialSpaceCS,
		pCurrencyInputSRV,
		pFinancialSpaceOutputUAV,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pFinancialSpaceReadbackBuffer, pCurrencySpaceOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinancialSpaceReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		CurrencyRateStateMachineObject* p = (CurrencyRateStateMachineObject*)MappedResource.pData;
		for (int i = 0; i < ppCurrencyObjectCollection0.size(); ++i)
		{
			pResourceOutputCollection.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (CurrencyRateStateMachineObject pOutputObject : pResourceOutputCollection)
		{
		
			cout << "Currency id = " << pOutputObject.pCurrencyId << endl;
			cout << "Opening Price = " << pOutputObject.pOpeningPrice << endl;
			cout << "Morning Price = " << pOutputObject.pPriceInRoublesMorning << endl;
			cout << "Afternoon Price = " << pOutputObject.pPriceInRoublesAfternoon << endl;
			cout << "Evening Price = " << pOutputObject.pPriceInRoublesEvening << endl;
			cout << "Morning State = " << pOutputObject.pCurrencyStateMorning << endl;
			cout << "Morning State Change = " << pOutputObject.pMorningStateChange << endl;
			cout << "Afternoon State = " << pOutputObject.pCurrencyStateAfternoon << endl;
			cout << "Afternoon State Change = " << pOutputObject.pAfternoonStateChange << endl;
			cout << "Evening State = " << pOutputObject.pCurrencyStateEvening << endl;
			cout << "Evening State Change = " << pOutputObject.pEveningStateChange << endl;

			cout << "Currency id = " << pOutputObject.pCurrencyId << endl;
			cout << "Opening Price = " << pOutputObject.pOpeningPrice << endl;
			cout << "Morning Price = " << pOutputObject.pPriceInRoublesMorning << endl;
			cout << "Afternoon Price = " << pOutputObject.pPriceInRoublesAfternoon << endl;
			cout << "Evening Price = " << pOutputObject.pPriceInRoublesEvening << endl;
			cout << "Morning State = " << pOutputObject.pCurrencyStateMorning << endl;
			cout << "Morning State Change = " << pOutputObject.pMorningStateChange << endl;
			cout << "Afternoon State = " << pOutputObject.pCurrencyStateAfternoon << endl;
			cout << "Afternoon State Change = " << pOutputObject.pAfternoonStateChange << endl;
			cout << "Evening State = " << pOutputObject.pCurrencyStateEvening << endl;
			cout << "Evening State Change = " << pOutputObject.pEveningStateChange << endl;






		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOutputResourceObject = pResourceOutputCollection;
	return hr;



}



HRESULT DirectXStandardAlgorithmExecutor::InitializeCurrencyStateMachine(HINSTANCE hInstance,
	HWND hWnd,
	cbCurrencyStateMachineBuffer pFinancialSpaceBufferConst,
	vector<CurrencyObjectRate> ppCurrencyObjectCollection0,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppFinancialSpaceConstantBuffer,
	ID3D11Buffer** ppCurrencyBuffer0,
	ID3D11Buffer** ppFinancialSpaceOutputBuffer,
	ID3D11ShaderResourceView** ppCurrencyShaderResource0,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\CurrencyRelationship.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferCurrency0 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVCurrencyO = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CurrencyStateMachineObject.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCurrencyStateMachineBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(cbCurrencyStateMachineBuffer);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pFinancialSpaceBufferConst;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyObjectRate);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(CurrencyObjectRate);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataCurrency0;
	pDataCurrency0.pSysMem = &ppCurrencyObjectCollection0[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pDataCurrency0, &pInputBufferCurrency0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyRateStateMachineObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(CurrencyRateStateMachineObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_metals;
	ZeroMemory(&srvbuffer_desc_metals, sizeof(srvbuffer_desc_metals));
	srvbuffer_desc_metals.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_metals.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_metals.Buffer.ElementWidth = ppCurrencyObjectCollection0.size();
	srvbuffer_desc_metals.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency0, &srvbuffer_desc_metals, &pInputSRVCurrencyO);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppCurrencyObjectCollection0.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyRateStateMachineObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(CurrencyRateStateMachineObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppFinancialSpaceConstantBuffer = pConstantBuffer;
	*ppCurrencyBuffer0 = pInputBufferCurrency0;
	*ppFinancialSpaceOutputBuffer = pOutputBuffer;
	*ppCurrencyShaderResource0 = pInputSRVCurrencyO;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunCurrencyStateMachine(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11Buffer* pConstantBufferCurrency,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);

	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0};
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };


	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufferCurrency);
	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* pConstantBuffers[] = { nullptr };
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pConstantBuffers);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ConvertRGBImageToYCbCrColorSpace(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<YCBRPixelDataBuffer> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<YCBRPixelDataBuffer> ppOutputDataBuffer = vector<YCBRPixelDataBuffer>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppConstantDataBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cbConstantBufferYCbr pConstantBufferYCBR;
	pConstantBufferYCBR.pEqOneConstantOne = 0.299;
	pConstantBufferYCBR.pEqOneConstantTwo = 0.587;
	pConstantBufferYCBR.pEqOneConstantThree = 0.114;
	pConstantBufferYCBR.pEqTwoConstantOne = -0.168736;
	pConstantBufferYCBR.pEqTwoConstantTwo = -0.331264;
	pConstantBufferYCBR.pEqTwoConstantThree = 0.5;
	pConstantBufferYCBR.pEqThreeConstantOne = 0.5;
	pConstantBufferYCBR.pEqThreeConstantTwo = -0.418688;
	pConstantBufferYCBR.pEqThreeConstantThree = -0.081312;

	hr = InitializeRGBToYCBRPixelDataConversion(hInstance,
		hWnd,
        pConstantBufferYCBR,
        pixelArrayOne, &ppComputeShaderObject,
        &ppConstantDataBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView,
        &pUnorderedAccessView, 
        &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageToYCBRConversion(hInstance,
		hWnd,
		ppComputeShaderObject,
		ppConstantDataBuffer,
		pShaderResourceView,
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		YCBRPixelDataBuffer* p = (YCBRPixelDataBuffer*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Y Component: " << p[i].pYValue << endl;
			cout << "Cb Component: " << p[i].pCbValue << endl;
			cout << "Cr Component: " << p[i].pCrValue << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Y Component: " << p[i].pYValue << endl;
			pOutputFileStream << "Cb Component: " << p[i].pCbValue << endl;
			pOutputFileStream << "Cr Component: " << p[i].pCrValue << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (YCBRPixelDataBuffer pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Component: " << pPixelObject.pYValue << endl;
			cout << "Cb Component: " << pPixelObject.pCbValue << endl;
			cout << "Cr Component: " << pPixelObject.pCrValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Y Component: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "Cb Component: " << pPixelObject.pCbValue << endl;
			pOutputFileStream << "Cr Component: " << pPixelObject.pCrValue << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBToYCBRPixelDataConversion(
	HINSTANCE hInstance,
	HWND hWnd,
	cbConstantBufferYCbr pYCBRConstantBuffer,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
    ID3D11Buffer** ppYCBCrConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RGBToYCBCRImageConverter.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(YCBRPixelDataBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
    
	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pYCBRConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(YCBRPixelDataBuffer);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBuffer);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppYCBCrConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunImageToYCBRConversion(HINSTANCE hInstance,
	HWND hWnd, ID3D11ComputeShader* pComputeShaderObject,
    ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pCB = nullptr;
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pCB);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ConvertYCBRImageToRGBColorSpace(HINSTANCE hInstance, HWND hWnd,
	vector<YCBRPixelDataBuffer> pYCBRArrayToRgb,
	vector<PixelObject> *pPixelObject)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (YCBRPixelDataBuffer pOutputData : pYCBRArrayToRgb)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component" << pOutputData.pCrValue << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Y Component: " << pOutputData.pYValue << endl;
		pOutputFileStream << "Cb Component: " << pOutputData.pCbValue << endl;
		pOutputFileStream << "Cr Component" << pOutputData.pCrValue << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppConstantDataBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cbConstantBufferYCbrToRGB pConstantBufferYCBR;
	pConstantBufferYCBR.pEqOneConstantOne = 1;
	pConstantBufferYCBR.pEqOneConstantTwo = 1.402;
	pConstantBufferYCBR.pEqTwoConstantOne = 1;
	pConstantBufferYCBR.pEqTwoConstantTwo = -0.34414;
	pConstantBufferYCBR.pEqTwoConstantThree = -0.71414;
	pConstantBufferYCBR.pEqThreeConstantOne = 1;
	pConstantBufferYCBR.pEqThreeConstantTwo = -1.772;

	hr = InitializeYCBRToRGBPixelDataConversion(hInstance,
		hWnd,
		pConstantBufferYCBR,
		pYCBRArrayToRgb, &ppComputeShaderObject,
		&ppConstantDataBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunYCBRToImageConversion(hInstance,
		hWnd,
		ppComputeShaderObject,
		ppConstantDataBuffer,
		pShaderResourceView,
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;
		for (int i = 0; i < pYCBRArrayToRgb.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Red Component: " << p[i].RMask << endl;
			cout << "Green Component: " << p[i].GMask << endl;
			cout << "Blue Component: " << p[i].BMask << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Red Component: " << p[i].RMask << endl;
			pOutputFileStream << "Green Component: " << p[i].GMask << endl;
			pOutputFileStream << "Blue Component: " << p[i].BMask << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObject = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageAdditionCPU(HINSTANCE hInstance, HWND hWnd, vector<YCBRPixelDataBufferOutputCosine> pPixelObjectYCBCR, cbSubtractionBuffer pSubtractionBuffer, vector<YCBRPixelDataBufferOutputCosine> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<YCBRPixelDataBufferOutputCosine> pOutputDataBuffer = vector<YCBRPixelDataBufferOutputCosine>();
	for (YCBRPixelDataBufferOutputCosine pYCBCRData : pPixelObjectYCBCR)
	{
		pYCBCRData.pYValue = pYCBCRData.pYCosineValue + pSubtractionBuffer.pItemToSubtract;
		pYCBCRData.pCbValue = pYCBCRData.pCBCosineValue + pSubtractionBuffer.pItemToSubtract;
		pYCBCRData.pCrValue = pYCBCRData.pCRCosineValue + pSubtractionBuffer.pItemToSubtract;

		pOutputDataBuffer.push_back(pYCBCRData);
	}

	*ppOutputPixelObjectGrayScale = pOutputDataBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeYCBRToRGBPixelDataConversion(HINSTANCE hInstance, 
	HWND hWnd, 
	cbConstantBufferYCbrToRGB pConstantDataBuffer,
	vector<YCBRPixelDataBuffer> pInputFilterGrayscaleVector, 
	ID3D11ComputeShader** ppImageRestorationComputeShader, 
	ID3D11Buffer** ppYCBRConstantBuffer,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer, 
	ID3D11ShaderResourceView** ppInputShaderResourceView, 
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)
	
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\YCBCRToRGBConverter.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbConstantBufferYCbrToRGB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantDataBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppYCBRConstantBuffer = pConstantBuffer;
	*ppYCBRInputDataBuffer = pInputBuffer1;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunYCBRToImageConversion(HINSTANCE hInstance,
	HWND hWnd, ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pCB = nullptr;
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pCB);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}


YCBRPixelDataBuffer DirectXStandardAlgorithmExecutor::GetYCBCRPixelObjectByXAndYPosition(vector<YCBRPixelDataBuffer> pYCBCRPixelCollectionVar, float pXPosition, float pYPosition)
{
	YCBRPixelDataBuffer pSearchData = YCBRPixelDataBuffer(0,
		0.0f,
		0.0f,
		0.0f,
		0.0f,
		0.0f);
	
	for (YCBRPixelDataBuffer pYCBCRPixelItem : pYCBCRPixelCollectionVar)
	{
		if ((pYCBCRPixelItem.xPosition == pXPosition) && (pYCBCRPixelItem.pYValue == pYCBCRPixelItem.yPosition))
		{
			pSearchData = pYCBCRPixelItem;
		}
	}
	return pSearchData;
}



HRESULT DirectXStandardAlgorithmExecutor::ApplyDiscreteCosineTransformAlgorithm(HINSTANCE hInstance, HWND hWnd,
	cbCostantBufferCosine pCosineBuffer,
	vector<YCBRPixelDataBuffer> pYCBRArrayToRgb,
	vector<YCBRPixelDataBufferOutputCosine> *pPixelObject)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<YCBRPixelDataBufferOutputCosine> ppOutputDataBuffer = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (YCBRPixelDataBuffer pOutputData : pYCBRArrayToRgb)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component" << pOutputData.pCrValue << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Y Component: " << pOutputData.pYValue << endl;
		pOutputFileStream << "Cb Component: " << pOutputData.pCbValue << endl;
		pOutputFileStream << "Cr Component" << pOutputData.pCrValue << endl;

		pIndex = pIndex + 1;
	}



	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputDataBuffer0 = nullptr;
	ID3D11Buffer* pInputDataBuffer1 = nullptr;

	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView0 = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = InitializeDiscreteCosineTransform(hInstance,
		hWnd, pCosineBuffer, pYCBRArrayToRgb,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&pInputDataBuffer0,
		&pOutputDataBuffer,
		&pShaderResourceView0,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);
		
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunDiscreteCosineTransform(hInstance,
		hWnd,
		ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView0,
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		YCBRPixelDataBufferOutputCosine* p = (YCBRPixelDataBufferOutputCosine*)MappedResource.pData;
		for (int i = 0; i < pYCBRArrayToRgb.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Y Value: " << p[i].pYValue << endl;
			cout << "Cb Value: " << p[i].pCbValue << endl;
			cout << "Cr Value: " << p[i].pCrValue << endl;
			cout << "Y Coefficient: " << p[i].pYCosineValue << endl;
			cout << "Cb Coefficient: " << p[i].pCBCosineValue << endl;
			cout << "Cr Coefficient: " << p[i].pCRCosineValue << endl;



			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Y Value: " << p[i].pYValue << endl;
			pOutputFileStream << "Cb Value: " << p[i].pCbValue << endl;
			pOutputFileStream << "Cr Value: " << p[i].pCrValue << endl;
			pOutputFileStream << "Y Coefficient: " << p[i].pYCosineValue << endl;
			pOutputFileStream << "Cb Coefficient: " << p[i].pCBCosineValue << endl;
			pOutputFileStream << "Cr Coefficient: " << p[i].pCRCosineValue << endl;




			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (YCBRPixelDataBufferOutputCosine pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Value: " << pPixelObject.pYValue << endl;
			cout << "Cb Value: " << pPixelObject.pCbValue << endl;
			cout << "Cr Value: " << pPixelObject.pCrValue << endl;
			cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
			cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
			cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Y Value: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "Cb Value: " << pPixelObject.pCbValue << endl;
			pOutputFileStream << "Cr Value: " << pPixelObject.pCrValue << endl;
			pOutputFileStream << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
			pOutputFileStream << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
			pOutputFileStream << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&pInputDataBuffer0);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView0);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObject = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeDiscreteCosineTransform(HINSTANCE hInstance,
	HWND hWnd,
	cbCostantBufferCosine pCosineConstantBuffer,
	vector<YCBRPixelDataBuffer> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppcConstantBufferPtr,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView0,
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDiscreteCosineTransform.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Constant Buffer " << endl;



	cout << "Creating the Constant Buffer" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCostantBufferCosine) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCosineConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}






	cout << "Creating the Input Buffer For Image Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppcConstantBufferPtr = pConstantBuffer;
	*ppYCBRInputDataBuffer = pInputBuffer;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView0 = pInputSRV;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunDiscreteCosineTransform(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0};
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr};
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pCB[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pCB);
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ApplyDiscreteCosineTransformAlgorithmInverse(HINSTANCE hInstance, HWND hWnd,
	cbCostantBufferCosine pCosineBuffer,
	vector<YCBRPixelDataBuffer> pYCBRArrayToRgb,
	vector<YCBRPixelDataBufferOutputCosine> *pPixelObject)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<YCBRPixelDataBufferOutputCosine> ppOutputDataBuffer = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (YCBRPixelDataBuffer pOutputData : pYCBRArrayToRgb)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component" << pOutputData.pCrValue << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Y Component: " << pOutputData.pYValue << endl;
		pOutputFileStream << "Cb Component: " << pOutputData.pCbValue << endl;
		pOutputFileStream << "Cr Component" << pOutputData.pCrValue << endl;

		pIndex = pIndex + 1;
	}



	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputDataBuffer0 = nullptr;
	ID3D11Buffer* pInputDataBuffer1 = nullptr;

	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView0 = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = InitializeDiscreteCosineTransformInverse(hInstance,
		hWnd, pCosineBuffer, pYCBRArrayToRgb,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&pInputDataBuffer0,
		&pOutputDataBuffer,
		&pShaderResourceView0,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunDiscreteCosineTransformInverse(hInstance,
		hWnd,
		ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView0,
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		YCBRPixelDataBufferOutputCosine* p = (YCBRPixelDataBufferOutputCosine*)MappedResource.pData;
		for (int i = 0; i < pYCBRArrayToRgb.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Y Value: " << p[i].pYValue << endl;
			cout << "Cb Value: " << p[i].pCbValue << endl;
			cout << "Cr Value: " << p[i].pCrValue << endl;
			cout << "Y Coefficient: " << p[i].pYCosineValue << endl;
			cout << "Cb Coefficient: " << p[i].pCBCosineValue << endl;
			cout << "Cr Coefficient: " << p[i].pCRCosineValue << endl;



			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Y Value: " << p[i].pYValue << endl;
			pOutputFileStream << "Cb Value: " << p[i].pCbValue << endl;
			pOutputFileStream << "Cr Value: " << p[i].pCrValue << endl;
			pOutputFileStream << "Y Coefficient: " << p[i].pYCosineValue << endl;
			pOutputFileStream << "Cb Coefficient: " << p[i].pCBCosineValue << endl;
			pOutputFileStream << "Cr Coefficient: " << p[i].pCRCosineValue << endl;

			ppOutputDataBuffer.push_back(p[i]);


			
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (YCBRPixelDataBufferOutputCosine pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Value: " << pPixelObject.pYValue << endl;
			cout << "Cb Value: " << pPixelObject.pCbValue << endl;
			cout << "Cr Value: " << pPixelObject.pCrValue << endl;
			cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
			cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
			cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Y Value: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "Cb Value: " << pPixelObject.pCbValue << endl;
			pOutputFileStream << "Cr Value: " << pPixelObject.pCrValue << endl;
			pOutputFileStream << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
			pOutputFileStream << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
			pOutputFileStream << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&pInputDataBuffer0);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView0);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObject = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeDiscreteCosineTransformInverse(HINSTANCE hInstance,
	HWND hWnd,
	cbCostantBufferCosine pCosineConstantBuffer,
	vector<YCBRPixelDataBuffer> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppcConstantBufferPtr,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView0,
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\СSDiscreteCosineTransformInverse.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Constant Buffer " << endl;



	cout << "Creating the Constant Buffer" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCostantBufferCosine) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pCosineConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}






	cout << "Creating the Input Buffer For Image Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppcConstantBufferPtr = pConstantBuffer;
	*ppYCBRInputDataBuffer = pInputBuffer;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView0 = pInputSRV;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunDiscreteCosineTransformInverse(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pCB[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pCB);
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageDivisionCPU(HINSTANCE hInstance, HWND hWnd,
	vector<YCBRPixelDataBufferOutputCosine> pYCBRArrayToRgb,
	vector<QuantizationItem> pQuatizedDataVector,
	vector<YCBRPixelDataBufferOutputCosine> *pPixelObject)
{
	HRESULT hr = S_OK;

	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	vector<YCBRPixelDataBufferOutputCosine> pOutputDataBuffer = vector<YCBRPixelDataBufferOutputCosine>();
	for (YCBRPixelDataBufferOutputCosine pOutputData : pYCBRArrayToRgb)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component: " << pOutputData.pCrValue << endl;
		cout << "Y Component Cosine Var: " << pOutputData.pYCosineValue << endl;
		cout << "Cb Component Cosine Var: " << pOutputData.pCBCosineValue << endl;
		cout << "Cr Component Cosine Var: " << pOutputData.pCRCosineValue << endl;

		pIndex = pIndex + 1;
	}

	cout << "Printing the Kernel Data Array" << endl;
	for (QuantizationItem pQuantizationItem : pQuatizedDataVector)
	{
		cout << "Kernel Item Id: " << pQuantizationItem.pPixelNumber << endl;
		cout << "X Position: " << pQuantizationItem.pXPosition << endl;
		cout << "Y Position: " << pQuantizationItem.pYPosition << endl;
		cout << "Kernel Item Value: " << pQuantizationItem.pQuontizationValue << endl;
	}

	for (YCBRPixelDataBufferOutputCosine pCosineItem : pYCBRArrayToRgb)
	{
		for (QuantizationItem pQuantizationItem : pQuatizedDataVector)
		{
			if ((pCosineItem.xPosition == pQuantizationItem.pXPosition) && (pCosineItem.yPosition == pQuantizationItem.pYPosition))
			{
				pCosineItem.pYCosineValue = round(pCosineItem.pYCosineValue / pQuantizationItem.pQuontizationValue);
				pCosineItem.pCBCosineValue = round(pCosineItem.pCBCosineValue / pQuantizationItem.pQuontizationValue);
				pCosineItem.pCRCosineValue = round(pCosineItem.pCRCosineValue / pQuantizationItem.pQuontizationValue);
				pOutputDataBuffer.push_back(pCosineItem);
			}
		}
	}

	*pPixelObject = pOutputDataBuffer;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageMultiplicationCPU(HINSTANCE hInstance, HWND hWnd,
	vector<YCBRPixelDataBuffer> pYCBRArrayToRgb,
	vector<QuantizationItem> pQuatizedDataVector,
	vector<YCBRPixelDataBuffer> *pPixelObject)
{
	HRESULT hr = S_OK;

	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	vector<YCBRPixelDataBuffer> pOutputDataBuffer = vector<YCBRPixelDataBuffer>();

	for (YCBRPixelDataBuffer pOutputData : pYCBRArrayToRgb)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component: " << pOutputData.pCrValue << endl;
		
		pIndex = pIndex + 1;
	}

	cout << "Printing the Kernel Data Array" << endl;
	for (QuantizationItem pQuantizationItem : pQuatizedDataVector)
	{
		cout << "Kernel Item Id: " << pQuantizationItem.pPixelNumber << endl;
		cout << "X Position: " << pQuantizationItem.pXPosition << endl;
		cout << "Y Position: " << pQuantizationItem.pYPosition << endl;
		cout << "Kernel Item Value: " << pQuantizationItem.pQuontizationValue << endl;
	}

	for (YCBRPixelDataBuffer pCosineItem : pYCBRArrayToRgb)
	{
		for (QuantizationItem pQuantizationItem : pQuatizedDataVector)
		{
			if ((pCosineItem.xPosition == pQuantizationItem.pXPosition) && (pCosineItem.yPosition == pQuantizationItem.pYPosition))
			{
				pCosineItem.pYValue = round(pCosineItem.pYValue * pQuantizationItem.pQuontizationValue);
				pCosineItem.pCbValue = round(pCosineItem.pCbValue * pQuantizationItem.pQuontizationValue);
				pCosineItem.pCrValue = round(pCosineItem.pCrValue * pQuantizationItem.pQuontizationValue);
				pOutputDataBuffer.push_back(pCosineItem);
			}
		}
	}

	*pPixelObject = pOutputDataBuffer;
	return hr;
}



DWORD WINAPI SimulateQuadraticFunctionAlgorithm(void* lParam)
{
	HRESULT hr = S_OK;
	DWORD pResult = 0;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HWND hWnd = NULL;
	RECT rc = { 0.0f, 0.0f, 0.0f, 0.0f };
	GetClientRect(hWnd, &rc);
	pQuadraticFunctionMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, pQuadraticFunctionMutexVar);
	WaitForSingleObject(pQuadraticFunctionMutex, INFINITE);

	DirectXStandardAlgorithmExecutor* pStandardAlgorithmExecutor = (DirectXStandardAlgorithmExecutor*)lParam;
	cout << "A Coefficient Var = " << pAGlobalVar << endl;
	cout << "B Coefficient Var = " << pBGlobalVar << endl;
	cout << "C Coefficient Var = " << pCGlobalVar << endl;

	hr = pStandardAlgorithmExecutor->SimulateQuadraticFunction(hInstance,
		hWnd, pAGlobalVar, pBGlobalVar, pCGlobalVar,
		pInputStructureForGraphGlobal,
		&pOutputStructureForGraphGlobal);

	ReleaseMutex(pQuadraticFunctionMutex);
	return pResult;
}







HRESULT DirectXStandardAlgorithmExecutor::SimulateQuadraticFunctionInAMutex(HINSTANCE hInstance, HWND hWnd, int pACoefficient, int pBCoefficient, int pCoefficient, vector<InputStructureForGraph> pInputArrayStructure, vector<OutputStructureForGraph> *pOutputStructureForGraph,
	SYSTEMTIME *ppStartTime,
	SYSTEMTIME *ppEndTime,
	SYSTEMTIME *ppKernelTime,
	SYSTEMTIME *ppUserTime)
{
	HRESULT hr = S_OK;

	cout << "Creating the Compute Direct3D11 Device" << endl;
	cout << "Preparing the input Data" << endl;
	cout << "First Let Us Copy our Simulation Parameters to GlobalMemory" << endl;

	pAGlobalVar = pACoefficient;
	pBGlobalVar = pBCoefficient;
	pCGlobalVar = pCoefficient;
	pInputStructureForGraphGlobal = vector<InputStructureForGraph>();
	pOutputStructureForGraphGlobal = vector<OutputStructureForGraph>();
	HANDLE pQuadraticFunctionHandle = INVALID_HANDLE_VALUE;
	DWORD dwThreadId = 0;

	FILETIME pStartTime;
	FILETIME pEndTime;
	FILETIME pKernelTime;
	FILETIME pUserTime;


	fstream myfile;
	myfile.open("C:\\\pixels\\QuadraticFunctionCSFunctionSetup.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	myfile.clear();


	pInputStructureForGraphGlobal.clear();
	pOutputStructureForGraphGlobal.clear();

	cout << "Printing Out the Initial Data For Quadratic Function" << endl;

	for (InputStructureForGraph pBufTypeVar : pInputArrayStructure)
	{
		cout << "Input Structure Id = " << pBufTypeVar.pInputItemValue << endl;
		cout << "Item Value = " << pBufTypeVar.pInputItemValue << endl;
		pInputStructureForGraphGlobal.push_back(pBufTypeVar);
	}
	HANDLE pMutexHandle = NULL;
	cout << "Entering Mutex Section" << endl;

	cout << "Creating Mutex Object" << endl;
	pQuadraticFunctionMutex = CreateMutex(
		NULL,              // default security attributes
		FALSE,            // initially not owned
		pQuadraticFunctionMutexVar);             // unnamed mutex

	cout << "Starting Quadratic Function Thread" << endl;

	SYSTEMTIME stStart;
	SYSTEMTIME ltStart;
	SYSTEMTIME stEnd;
	SYSTEMTIME ltEnd;


	GetSystemTime(&stStart);
	GetLocalTime(&ltStart);

	printf("The system time is: %02d:%02d:%02d\n", stStart.wHour, stStart.wMinute, stStart.wSecond);
	printf(" The local time is: %02d:%02d:%02d\n", ltStart.wHour, ltStart.wMinute, stStart.wSecond);

	pQuadraticFunctionHandle = CreateThread(NULL,
		0,
		SimulateQuadraticFunctionAlgorithm,
		this,
		0,
		&dwThreadId);

	WaitForSingleObject(pQuadraticFunctionHandle, INFINITE);

	cout << "Getting Process Time Values" << endl;





	cout << "Closing Mutex Objects" << endl;
	CloseHandle(pQuadraticFunctionMutex);

	GetSystemTime(&stEnd);
	GetLocalTime(&ltEnd);



	printf("The system time is: %02d:%02d:%02d\n", stEnd.wHour, stEnd.wMinute, stEnd.wSecond);
	printf(" The local time is: %02d:%02d:%02d\n", ltEnd.wHour, ltEnd.wMinute, ltEnd.wSecond);





	for (OutputStructureForGraph pOutputStructure : pOutputStructureForGraphGlobal)
	{
		cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
		cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;

		myfile << "Item Index = " << pOutputStructure.pItemIndex << endl;
		myfile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
		myfile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;

	}
	myfile.close();
	*pOutputStructureForGraph = pOutputStructureForGraphGlobal;
	*ppStartTime = stStart;
	*ppEndTime = ltStart;
	*ppKernelTime = stEnd;
	*ppUserTime = ltEnd;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageDivision(HINSTANCE hInstance, HWND hWnd,
	vector<YCBRPixelDataBufferOutputCosine> pYCBRArrayToRgb,
    vector<QuantizationItem> pQuatizedDataVector,
	vector<YCBRPixelDataBufferOutputCosine> *pPixelObject)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<YCBRPixelDataBufferOutputCosine> ppOutputDataBuffer = vector<YCBRPixelDataBufferOutputCosine>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (YCBRPixelDataBufferOutputCosine pOutputData : pYCBRArrayToRgb)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component: " << pOutputData.pCrValue << endl;
		cout << "Y Component Cosine Var: " << pOutputData.pYCosineValue << endl;
		cout << "Cb Component Cosine Var: " << pOutputData.pCBCosineValue << endl;
		cout << "Cr Component Cosine Var: " << pOutputData.pCRCosineValue << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Y Component: " << pOutputData.pYValue << endl;
		pOutputFileStream << "Cb Component: " << pOutputData.pCbValue << endl;
		pOutputFileStream << "Cr Component: " << pOutputData.pCrValue << endl;
		pOutputFileStream << "Y Component Cosine Var: " << pOutputData.pYCosineValue << endl;
		pOutputFileStream << "Cb Component Cosine Var: " << pOutputData.pCBCosineValue << endl;
		pOutputFileStream << "Cr Component Cosine Var: " << pOutputData.pCRCosineValue << endl;
		pIndex = pIndex + 1;
	}

	cout << "Printing the Kernel Data Array" << endl;
	for (QuantizationItem pQuantizationItem : pQuatizedDataVector)
	{
		cout << "Kernel Item Id: " << pQuantizationItem.pPixelNumber << endl;
		cout << "Kernel Item Value: " << pQuantizationItem.pQuontizationValue << endl;
		pOutputFileStream << "Kernel Item Id: " << pQuantizationItem.pPixelNumber << endl;
		pOutputFileStream << "Kernel Item Value: " << pQuantizationItem.pQuontizationValue << endl;

    }



	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputDataBuffer0 = nullptr;
	ID3D11Buffer* pInputDataBuffer1 = nullptr;

	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView0 = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView1 = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeYCBCRDivision(hInstance,
		hWnd, pYCBRArrayToRgb, pQuatizedDataVector,
		&ppComputeShaderObject,
		&pInputDataBuffer0,
		&pInputDataBuffer1,
		&pOutputDataBuffer,
		&pShaderResourceView0,
		&pShaderResourceView1,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunYCBCRImageMDivision(hInstance,
		hWnd,
		ppComputeShaderObject,
		pShaderResourceView0,
		pShaderResourceView1,
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		YCBRPixelDataBufferOutputCosine* p = (YCBRPixelDataBufferOutputCosine*)MappedResource.pData;
		for (int i = 0; i < pYCBRArrayToRgb.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Y Value: " << p[i].pYValue << endl;
			cout << "Cb Value: " << p[i].pCbValue << endl;
			cout << "Cr Value: " << p[i].pCrValue << endl;
			cout << "Y Coefficient: " << p[i].pYCosineValue << endl;
			cout << "Cb Coefficient: " << p[i].pCBCosineValue << endl;
			cout << "Cr Coefficient: " << p[i].pCRCosineValue << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Y Value: " << p[i].pYValue << endl;
			pOutputFileStream << "Cb Value: " << p[i].pCbValue << endl;
			pOutputFileStream << "Cr Value: " << p[i].pCrValue << endl;
			pOutputFileStream << "Y Coefficient: " << p[i].pYCosineValue << endl;
			pOutputFileStream << "Cb Coefficient: " << p[i].pCBCosineValue << endl;
			pOutputFileStream << "Cr Coefficient: " << p[i].pCRCosineValue << endl;





			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (YCBRPixelDataBufferOutputCosine pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Value: " << pPixelObject.pYValue << endl;
			cout << "Cb Value: " << pPixelObject.pCbValue << endl;
			cout << "Cr Value: " << pPixelObject.pCrValue << endl;
			cout << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
			cout << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
			cout << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Y Value: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "Cb Value: " << pPixelObject.pCbValue << endl;
			pOutputFileStream << "Cr Value: " << pPixelObject.pCrValue << endl;
			pOutputFileStream << "Y Coefficient: " << pPixelObject.pYCosineValue << endl;
			pOutputFileStream << "Cb Coefficient: " << pPixelObject.pCBCosineValue << endl;
			pOutputFileStream << "Cr Coefficient: " << pPixelObject.pCRCosineValue << endl;



		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&pInputDataBuffer0);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView0);
	SafeReleaseA(&pShaderResourceView1);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pPixelObject = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeYCBCRDivision(HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBufferOutputCosine> pInputFilterGrayscaleVector,
	vector<QuantizationItem> pQuantizationItem,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppQuantizationDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView0,
	ID3D11ShaderResourceView** ppInputShaderResourceView1,
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
    ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\QuantizeYCBCRImageDivision.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}




	


	cout << "Creating the Input Buffer For Image Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Kernel Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_quantizer;
	ZeroMemory(&buffer_desc_quantizer, sizeof(buffer_desc_quantizer));
	buffer_desc_quantizer.ByteWidth = pQuantizationItem.size() * sizeof(QuantizationItem);
	buffer_desc_quantizer.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_quantizer.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_quantizer.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_quantizer.StructureByteStride = sizeof(QuantizationItem);
	buffer_desc_quantizer.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	D3D11_SUBRESOURCE_DATA pQuantizeData;
	pQuantizeData.pSysMem = &pQuantizationItem[0];


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_quantizer, &pQuantizeData, &pInputBuffer2);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppYCBRInputDataBuffer = pInputBuffer1;
	*ppQuantizationDataBuffer = pInputBuffer2;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView0 = pInputSRV1;
	*ppInputShaderResourceView1 = pInputSRV2;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunYCBCRImageMDivision(HINSTANCE hInstance,
	HWND hWnd, 
    ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeYCBCRMultiplication(HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBufferOutputCosine> pInputFilterGrayscaleVector,
	vector<QuantizationItem> pQuantizationItem,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppQuantizationDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView0,
	ID3D11ShaderResourceView** ppInputShaderResourceView1,
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\QuantizeYCBCRImageMultiply.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}







	cout << "Creating the Input Buffer For Image Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Kernel Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_quantizer;
	ZeroMemory(&buffer_desc_quantizer, sizeof(buffer_desc_quantizer));
	buffer_desc_quantizer.ByteWidth = pQuantizationItem.size() * sizeof(QuantizationItem);
	buffer_desc_quantizer.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_quantizer.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_quantizer.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_quantizer.StructureByteStride = sizeof(QuantizationItem);
	buffer_desc_quantizer.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	D3D11_SUBRESOURCE_DATA pQuantizeData;
	pQuantizeData.pSysMem = &pQuantizationItem[0];


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_quantizer, &pQuantizeData, &pInputBuffer2);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBufferOutputCosine);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBufferOutputCosine);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppYCBRInputDataBuffer = pInputBuffer1;
	*ppQuantizationDataBuffer = pInputBuffer2;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView0 = pInputSRV1;
	*ppInputShaderResourceView1 = pInputSRV2;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunYCBCRImageMultiplication(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageSubtraction(
	HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCR,
	cbSubtractionBuffer pSubtractionBuffer,
	vector<YCBRPixelDataBuffer> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<YCBRPixelDataBuffer> ppOutputDataBuffer = vector<YCBRPixelDataBuffer>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (YCBRPixelDataBuffer pOutputData : pPixelObjectYCBCR)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component" << pOutputData.pCrValue << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Y Component: " << pOutputData.pYValue << endl;
		pOutputFileStream << "Cb Component: " << pOutputData.pCbValue << endl;
		pOutputFileStream << "Cr Component" << pOutputData.pCrValue << endl;

		pIndex = pIndex + 1;
	}

	


	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView0 = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeYCBCRQuantizedSubtraction(hInstance,
		hWnd, pPixelObjectYCBCR,
		pSubtractionBuffer,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&pInputBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView0,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunYCBCRImageSubtraction(hInstance,
		hWnd,
		ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView0,	
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		YCBRPixelDataBuffer* p = (YCBRPixelDataBuffer*)MappedResource.pData;
		for (int i = 0; i < pPixelObjectYCBCR.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Y Value: " << p[i].pYValue << endl;
			cout << "Cb Value: " << p[i].pCbValue << endl;
			cout << "Cr Value: " << p[i].pCrValue << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Y Value: " << p[i].pYValue << endl;
			pOutputFileStream << "Cb Value: " << p[i].pCbValue << endl;
			pOutputFileStream << "Cr Value: " << p[i].pCrValue << endl;



			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (YCBRPixelDataBuffer pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Value: " << pPixelObject.pYValue << endl;
			cout << "Cb Value: " << pPixelObject.pCbValue << endl;
			cout << "Cr Value: " << pPixelObject.pCrValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Y Value: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "Cb Value: " << pPixelObject.pCbValue << endl;
			pOutputFileStream << "Cr Value: " << pPixelObject.pCrValue << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&pInputBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView0);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeYCBCRQuantizedSubtraction(HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBuffer> pInputFilterGrayscaleVector,
	cbSubtractionBuffer pSubtractionBufferConst,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView0,
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\QuantizeYCBRImageSubtraction.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Constant Buffer" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbSubtractionBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pSubtractionBufferConst;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}





	cout << "Creating the Input Buffer For Image Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBuffer);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppYCBRInputDataBuffer = pInputBuffer;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView0 = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunYCBCRImageSubtraction(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pConstantBufferVar[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pConstantBufferVar);
	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageAdditionCPU(
	HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCR,
	cbSubtractionBuffer pSubtractionBuffer,
	vector<YCBRPixelDataBuffer> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<YCBRPixelDataBuffer> pOutputDataBuffer = vector<YCBRPixelDataBuffer>();
	for (YCBRPixelDataBuffer pYCBCRData : pPixelObjectYCBCR)
	{
		pYCBCRData.pYValue = pYCBCRData.pYValue + pSubtractionBuffer.pItemToSubtract;
		pYCBCRData.pCbValue = pYCBCRData.pCbValue + pSubtractionBuffer.pItemToSubtract;
		pYCBCRData.pCrValue = pYCBCRData.pCrValue + pSubtractionBuffer.pItemToSubtract;

		pOutputDataBuffer.push_back(pYCBCRData);
	}

	*ppOutputPixelObjectGrayScale = pOutputDataBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::QuantizeYCBCRImageAddition(
	HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBuffer> pPixelObjectYCBCR,
	cbSubtractionBuffer pSubtractionBuffer,
	vector<YCBRPixelDataBuffer> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<YCBRPixelDataBuffer> ppOutputDataBuffer = vector<YCBRPixelDataBuffer>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (YCBRPixelDataBuffer pOutputData : pPixelObjectYCBCR)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Y Component: " << pOutputData.pYValue << endl;
		cout << "Cb Component: " << pOutputData.pCbValue << endl;
		cout << "Cr Component" << pOutputData.pCrValue << endl;
	


		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Y Component: " << pOutputData.pYValue << endl;
		pOutputFileStream << "Cb Component: " << pOutputData.pCbValue << endl;
		pOutputFileStream << "Cr Component" << pOutputData.pCrValue << endl;
	

		pIndex = pIndex + 1;
	}




	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView0 = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeYCBCRQuantizedAddition(hInstance,
		hWnd, pPixelObjectYCBCR,
		pSubtractionBuffer,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&pInputBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView0,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunYCBCRImageAddition(hInstance,
		hWnd,
		ppComputeShaderObject,
		pConstantBuffer,
		pShaderResourceView0,
		pUnorderedAccessView,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		YCBRPixelDataBuffer* p = (YCBRPixelDataBuffer*)MappedResource.pData;
		for (int i = 0; i < pPixelObjectYCBCR.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Y Value: " << p[i].pYValue << endl;
			cout << "Cb Value: " << p[i].pCbValue << endl;
			cout << "Cr Value: " << p[i].pCrValue << endl;
	

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Y Value: " << p[i].pYValue << endl;
			pOutputFileStream << "Cb Value: " << p[i].pCbValue << endl;
			pOutputFileStream << "Cr Value: " << p[i].pCrValue << endl;
		


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (YCBRPixelDataBuffer pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Y Value: " << pPixelObject.pYValue << endl;
			cout << "Cb Value: " << pPixelObject.pCbValue << endl;
			cout << "Cr Value: " << pPixelObject.pCrValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Y Value: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "Cb Value: " << pPixelObject.pCbValue << endl;
			pOutputFileStream << "Cr Value: " << pPixelObject.pCrValue << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&pInputBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView0);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeYCBCRQuantizedAddition(HINSTANCE hInstance,
	HWND hWnd,
	vector<YCBRPixelDataBuffer> pInputFilterGrayscaleVector,
	cbSubtractionBuffer pSubtractionBufferConst,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppYCBRInputDataBuffer,
	ID3D11Buffer** ppYCBROutputDataBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView0,
	ID3D11UnorderedAccessView** ppOutputUAVObject,
	ID3D11Buffer** ppReadbackBuffer)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\QuantizeYCBCRImageAddition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Constant Buffer" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbSubtractionBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pSubtractionBufferConst;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}





	cout << "Creating the Input Buffer For Image Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(YCBRPixelDataBuffer);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(YCBRPixelDataBuffer);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppYCBRInputDataBuffer = pInputBuffer;
	*ppYCBROutputDataBuffer = pOutputBuffer;
	*ppInputShaderResourceView0 = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunYCBCRImageAddition(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pConstantBufferVar[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pConstantBufferVar);
	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::ApplyKMeansFilterToRGBImage(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pPixelObjectToCompute,
	float pCentreX, float pCentreY, float pRadiusValue,
	vector<OutputPixelObjectFilteredRGBKMeans> *pFilteredInputObjectArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixelsGrayScale.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFilteredRGBKMeans> ppOutputDataBuffer = vector<OutputPixelObjectFilteredRGBKMeans>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;

	KMeansConstantBuffer pKMeansConstantBufferVar;
	pKMeansConstantBufferVar.pCenteObjectX = pCentreX;
	pKMeansConstantBufferVar.pCentreObjectY = pCentreY;
	pKMeansConstantBufferVar.pRadiusValue = pRadiusValue;



	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pPixelObjectToCompute)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component: " << pOutputData.RMask << endl;
		cout << "Green Component: " << pOutputData.GMask << endl;
		cout << "Blue Component: " << pOutputData.BMask << endl;


		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component: " << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component: " << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Component: " << pOutputData.BMask << endl;


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* pInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;


	hr = InitializeKMeansFilterRGBResources(hInstance,
		hWnd,
		pKMeansConstantBufferVar,
		pPixelObjectToCompute,
		&pComputeShaderObject,
		&pBinaryImageConstantBuffer,
		&pInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBKMeansFilter(hInstance,
		hWnd,
		pComputeShaderObject,
		pBinaryImageConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFilteredRGBKMeans* pOutputFilterArray = (OutputPixelObjectFilteredRGBKMeans*)MappedResource.pData;
		for (int i = 0; i < pPixelObjectToCompute.size(); ++i)
		{
			ppOutputDataBuffer.push_back(pOutputFilterArray[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;


		for (OutputPixelObjectFilteredRGBKMeans pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&pComputeShaderObject);
	SafeReleaseA(&pInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pFilteredInputObjectArray = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeKMeansFilterRGBResources(HINSTANCE hInstance,
	HWND hWnd,
	KMeansConstantBuffer pKMeansCB,
	vector<PixelObject> pInputPixelObjectVector,
	ID3D11ComputeShader** pKMeansComputeShader,
	ID3D11Buffer** pKMeansConstantBuffer,
	ID3D11Buffer** pKMeansInputDataBuffer,
	ID3D11Buffer** pKMeansOutputDataBuffer,
	ID3D11ShaderResourceView** pKMeansShaderResource,
	ID3D11UnorderedAccessView** pKMeansUnorderedAccess,
	ID3D11Buffer** pKMeansReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageKMeansClusterRGBSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSKMeansFilterRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(KMeansConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pKMeansCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputPixelObjectVector.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputPixelObjectVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputPixelObjectVector.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputPixelObjectVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputPixelObjectVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputPixelObjectVector.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*pKMeansConstantBuffer = pConstantBuffer;
	*pKMeansComputeShader = pComputeShaderObject;
	*pKMeansInputDataBuffer = pInputBuffer1;
	*pKMeansOutputDataBuffer = pOutputBuffer;
	*pKMeansShaderResource = pInputSRV1;
	*pKMeansUnorderedAccess = pOutputUAV;
	*pKMeansReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunRGBKMeansFilter(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBufferObject,
	ID3D11ShaderResourceView* pShaderResourceViewObject,
	ID3D11UnorderedAccessView* pUnorderedAcessViewObject,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceViewObject };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedAcessViewObject };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufferObject);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ApplyKMeansFilterToGrayScaleImage(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pPixelObjectToCompute,
	float pCentreX, float pCentreY,
	float pRadiusValue,
	vector<OutputPixelObjectFilteredGrayScaleKMeans> *pFilteredInputObjectArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixelsGrayScale.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFilteredGrayScaleKMeans> pOutputGrayScaleFilterObject = vector<OutputPixelObjectFilteredGrayScaleKMeans>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;

	KMeansConstantBuffer pKMeansConstantBufferVar;
	pKMeansConstantBufferVar.pCenteObjectX = pCentreX;
	pKMeansConstantBufferVar.pCentreObjectY = pCentreY;
	pKMeansConstantBufferVar.pRadiusValue = pRadiusValue;



	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObjectGrayScale pOutputData : pPixelObjectToCompute)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "GrayScale Value: " << pOutputData.pGreyLevel << endl;


		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component: " << pOutputData.pGreyLevel << endl;



	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* pInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = InitializeKMeansFilterGrayScaleResources(hInstance,
		hWnd,
		pKMeansConstantBufferVar,
		pPixelObjectToCompute,
		&pComputeShaderObject,
		&pBinaryImageConstantBuffer,
		&pInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunGrayScaleKMeansFilter(hInstance,
		hWnd,
		pComputeShaderObject,
		pBinaryImageConstantBuffer,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFilteredGrayScaleKMeans* pOutputFilterArray = (OutputPixelObjectFilteredGrayScaleKMeans*)MappedResource.pData;
		for (int i = 0; i < pPixelObjectToCompute.size(); ++i)
		{
			pOutputGrayScaleFilterObject.push_back(pOutputFilterArray[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;


		auto ItA = begin(pPixelObjectToCompute);
		auto ItB = begin(pOutputGrayScaleFilterObject);

		while (ItA < end(pPixelObjectToCompute) && ItB < end(pOutputGrayScaleFilterObject))
		{
			cout << "Processing Item At Index: " << pIndex << endl;
			ItB->pixelNumber = ItA->pixelNumber;
			ItB->xPosition = ItA->xPosition;
			ItB->yPosition = ItA->yPosition;
			++ItA;
			++ItB;
			pIndex = pIndex + 1;
		}


		for (OutputPixelObjectFilteredGrayScaleKMeans pPixelObject : pOutputGrayScaleFilterObject)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Grayscale Value: " << pPixelObject.pGrayScaleValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Grayscale Value: " << pPixelObject.pGrayScaleValue << endl;
			pOutputFileStream << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&pComputeShaderObject);
	SafeReleaseA(&pInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pFilteredInputObjectArray = pOutputGrayScaleFilterObject;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RestoreInterestPointsFromFilter(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectInterestPoint> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectInterestPoint pPixelObject : pPixelObjectGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pRedComponent = pPixelObject.rValue;
		float pGreenComponent = pPixelObject.gValue;
		float pBlueComponent = pPixelObject.gValue;
		float pPixelNumberRemainder = pPixelObject.pRemainderVar;
		bool pIsPixelValid = pPixelObject.pIsPixelValid;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Pixel Number Remainder: " << pPixelNumberRemainder << endl;
		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "Red Value = " << pRedComponent << endl;
		pOutputFileStream << "Green Value = " << pGreenComponent << endl;
		pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
		pOutputFileStream << "Pixel Number Remainder: " << pPixelNumberRemainder << endl;
		pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;



	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeInterestPointRestorationResources(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{
			if (p[i].pixelNumber != 0 && p[i].xPosition != 0 && p[i].yPosition != 0)
			{
				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeInterestPointRestorationResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectInterestPoint> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestoreInterestPointsFromFilter.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectInterestPoint);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectInterestPoint);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromsFromSortingGroupOne(HINSTANCE hInstance,
	HWND hWnd,
	vector<SortedPixelOutput> pPixelObjectGrayScale, 
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (SortedPixelOutput pPixelObject : pPixelObjectGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pRedComponent = pPixelObject.rValue;
		float pGreenComponent = pPixelObject.gValue;
		float pBlueComponent = pPixelObject.gValue;
		int pIsPixelValid = pPixelObject.pGroupLabelValue;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Group Index = " << pIsPixelValid << endl;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Group Index = " << pIsPixelValid << endl;


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesFromSortingGroupOne(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromSorting(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777.0f) || (p[i].yPosition != 777.0f))
			{
				ppOutputDataBuffer.push_back(p[i]);

			}


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


		


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromsFromSortingGroupTwo(HINSTANCE hInstance,
	HWND hWnd,
	vector<SortedPixelOutput> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{

	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (SortedPixelOutput pPixelObject : pPixelObjectGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pRedComponent = pPixelObject.rValue;
		float pGreenComponent = pPixelObject.gValue;
		float pBlueComponent = pPixelObject.gValue;
		int pIsPixelValid = pPixelObject.pGroupLabelValue;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Group Index = " << pIsPixelValid << endl;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Group Index = " << pIsPixelValid << endl;


	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesFromSortingGroupTwo(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromSorting(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777.0f) || (p[i].yPosition != 777.0f))
			{
				ppOutputDataBuffer.push_back(p[i]);

			}


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;





		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromSortingGroupOne(HINSTANCE hInstance,
	HWND hWnd,
	vector<SortedPixelOutput> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();




	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromSortingGroupOne.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(SortedPixelOutput);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(SortedPixelOutput);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesFromSortingGroupTwo(HINSTANCE hInstance,
	HWND hWnd,
	vector<SortedPixelOutput> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();




	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelsFromSortingGroupTwo.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(SortedPixelOutput);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(SortedPixelOutput);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RestoreOutputPixelsFromImageComparisonGrayScale(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBuffer> pPixelObjectGrayScale,
	vector<PixelObjectGrayScale> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelBuffer pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.outputComparisonValue != 255.0f))
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pGrayScaleValue0 = pPixelObject.grayScaleValue0;
			float pGrayScaleValue1 = pPixelObject.grayScaleValue0;
			float pOutputComparisonValue = pPixelObject.outputComparisonValue;
			bool pIsPixelValid = pPixelObject.arePixelsIdenticalVal;
			float amountOfIdenticalPixels = pPixelObject.pAmountOfIdenticalPixels;
			float amountOfDifferentPixels = pPixelObject.pAmountOfDifferentPixels;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value 0 = " << pGrayScaleValue0 << endl;
			cout << "GrayScale Value 1 = " << pGrayScaleValue1 << endl;
			cout << "Output GrayScale Value = " << pOutputComparisonValue << endl;
			cout << "Are Pixels Identical = " << pIsPixelValid << endl;
			cout << "Amount of Identical Pixels " << amountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels " << amountOfDifferentPixels << endl;



			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Value = " << pXValue << endl;
			pOutputFileStream << "Y Value = " << pYValue << endl;
			pOutputFileStream << "GrayScale Value 0 = " << pGrayScaleValue0 << endl;
			pOutputFileStream << "GrayScale Value 1 = " << pGrayScaleValue1 << endl;
			pOutputFileStream << "Output GrayScale Value = " << pOutputComparisonValue << endl;
			pOutputFileStream << "Are Pixels Identical = " << pIsPixelValid << endl;
			pOutputFileStream << "Amount of Identical Pixels " << amountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels " << amountOfDifferentPixels << endl;


		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeGrayScaleOutputRestorationResources(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if (p[i].pixelNumber != 777)
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RestoreIdenticalPixelsFromImageComparisonGrayScale(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBuffer> pPixelObjectGrayScale,
	vector<PixelObjectGrayScale> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelBuffer pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.outputComparisonValue != 255.0f))
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pGrayScaleValue0 = pPixelObject.grayScaleValue0;
			float pGrayScaleValue1 = pPixelObject.grayScaleValue0;
			float pOutputComparisonValue = pPixelObject.outputComparisonValue;
			bool pIsPixelValid = pPixelObject.arePixelsIdenticalVal;
			float amountOfIdenticalPixels = pPixelObject.pAmountOfIdenticalPixels;
			float amountOfDifferentPixels = pPixelObject.pAmountOfDifferentPixels;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value 0 = " << pGrayScaleValue0 << endl;
			cout << "GrayScale Value 1 = " << pGrayScaleValue1 << endl;
			cout << "Output GrayScale Value = " << pOutputComparisonValue << endl;
			cout << "Are Pixels Identical = " << pIsPixelValid << endl;
			cout << "Amount of Identical Pixels " << amountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels " << amountOfDifferentPixels << endl;



			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Value = " << pXValue << endl;
			pOutputFileStream << "Y Value = " << pYValue << endl;
			pOutputFileStream << "GrayScale Value 0 = " << pGrayScaleValue0 << endl;
			pOutputFileStream << "GrayScale Value 1 = " << pGrayScaleValue1 << endl;
			pOutputFileStream << "Output GrayScale Value = " << pOutputComparisonValue << endl;
			pOutputFileStream << "Are Pixels Identical = " << pIsPixelValid << endl;
			pOutputFileStream << "Amount of Identical Pixels " << amountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels " << amountOfDifferentPixels << endl;


		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeGrayScaleIdenticalComparisonResourcesRestoration(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if (p[i].pixelNumber != 777)
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RestoreDifferentPixelsFromImageComparison(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBuffer> pPixelObjectGrayScale,
	vector<PixelObjectGrayScale> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelBuffer pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.outputComparisonValue != 255.0f))
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pGrayScaleValue0 = pPixelObject.grayScaleValue0;
			float pGrayScaleValue1 = pPixelObject.grayScaleValue0;
			float pOutputComparisonValue = pPixelObject.outputComparisonValue;
			bool pIsPixelValid = pPixelObject.arePixelsIdenticalVal;
			float amountOfIdenticalPixels = pPixelObject.pAmountOfIdenticalPixels;
			float amountOfDifferentPixels = pPixelObject.pAmountOfDifferentPixels;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "GrayScale Value 0 = " << pGrayScaleValue0 << endl;
			cout << "GrayScale Value 1 = " << pGrayScaleValue1 << endl;
			cout << "Output GrayScale Value = " << pOutputComparisonValue << endl;
			cout << "Are Pixels Identical = " << pIsPixelValid << endl;
			cout << "Amount of Identical Pixels " << amountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels " << amountOfDifferentPixels << endl;



			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Value = " << pXValue << endl;
			pOutputFileStream << "Y Value = " << pYValue << endl;
			pOutputFileStream << "GrayScale Value 0 = " << pGrayScaleValue0 << endl;
			pOutputFileStream << "GrayScale Value 1 = " << pGrayScaleValue1 << endl;
			pOutputFileStream << "Output GrayScale Value = " << pOutputComparisonValue << endl;
			pOutputFileStream << "Are Pixels Identical = " << pIsPixelValid << endl;
			pOutputFileStream << "Amount of Identical Pixels " << amountOfIdenticalPixels << endl;
			pOutputFileStream << "Amount of Different Pixels " << amountOfDifferentPixels << endl;


		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeGrayScaleDifferentComparisonResources(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if (p[i].pixelNumber != 777)
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunGrayScaleImageRestoration(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };
	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;

}










HRESULT DirectXStandardAlgorithmExecutor::InitializeGrayScaleOutputRestorationResources(HINSTANCE hInstance, HWND hWnd,
	vector<OutputPixelBuffer> pInputFilterGrayscaleVector, 
	ID3D11ComputeShader** ppImageRestorationComputeShader, 
	ID3D11Buffer** ppImageRestorationInputBuffer, 
	ID3D11Buffer** ppImageRestorationOutputBuffer, 
	ID3D11ShaderResourceView** ppInputShaderResourceView, 
	ID3D11UnorderedAccessView** ppOutputUAVObject, 
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestoreOutputPixelsFromImageComparisonGrayscale.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBufferOne;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeGrayScaleIdenticalComparisonResourcesRestoration(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBuffer> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestoreIdenticalPixeslForImageComparisonGrayScale.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBufferOne;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::InitializeGrayScaleDifferentComparisonResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelBuffer> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestoreDifferentPixelsFromImageComparison.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBufferOne;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}













HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromFilter(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectFiltered> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	if (pPixelObjectGrayScale.size() == 0)
	{
		return hr;
	}


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectFiltered pPixelObject : pPixelObjectGrayScale)
	{

		if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.rValue != 255.0f))
		{
			int pPixelNumber = pPixelObject.pixelNumber;
			float pXValue = pPixelObject.xPosition;
			float pYValue = pPixelObject.yPosition;
			float pRedComponent = pPixelObject.rValue;
			float pGreenComponent = pPixelObject.gValue;
			float pBlueComponent = pPixelObject.gValue;
			bool pIsPixelValid = pPixelObject.pUsedInComputations;

			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Value = " << pXValue << endl;
			cout << "Y Value = " << pYValue << endl;
			cout << "Red Value = " << pRedComponent << endl;
			cout << "Green Value = " << pGreenComponent << endl;
			cout << "Blue Component = " << pBlueComponent << endl;
			cout << "Is Pixel Valid = " << pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Value = " << pXValue << endl;
			pOutputFileStream << "Y Value = " << pYValue << endl;
			pOutputFileStream << "Red Value = " << pRedComponent << endl;
			pOutputFileStream << "Green Value = " << pGreenComponent << endl;
			pOutputFileStream << "Blue Component = " << pBlueComponent << endl;
			pOutputFileStream << "Is Pixel Valid = " << pIsPixelValid << endl;
		}

	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResources(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{
			
			if (p[i].pixelNumber != 777)
			{

				ppOutputDataBuffer.push_back(p[i]);
			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;


			if (pIndex >= 10)
			{
				break;
			}
			else
			{
				pIndex++;
			}


		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunRGBImageRestorationFromFilter(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11ShaderResourceView* pImageRestorationSRV, 
	ID3D11UnorderedAccessView* pImageRestorationUAV, 
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };
	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;

}










HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBValidPixelImageRestorationResourcesFromClassifier(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectClassified> pInputFilterGrayscaleVector,
	CBBinaryClassifierConstantBuffer pBinaryClassifierConstantBuffer,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBufferClassOne,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObjectOne,
	ID3D11Buffer** ppReadbackBufferOne)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelClassifierVectorRGBValidPixels.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBBinaryClassifierConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryClassifierConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectClassified);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectClassified);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBufferClassOne = pOutputBufferOne;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObjectOne = pOutputUAVOne;
	*ppReadbackBufferOne = pReadbackBufferOne;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RunResultsRestorationFromBinaryClassifier(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };
	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromLineDetectorBelowTheLine(HINSTANCE hInstance,
	HWND hWnd,
	float pACoefficient,
	float pBCoefficient,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScaleBelowTheLine)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;





	for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pPixelObjectGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
	

		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
		pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
		pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
		pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		pOutputFileStream << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;



	}



	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cout << "First We Have to Initialize our Simulation Resources" << endl;

	hr = InitializeRGBPixelImageRestorationFromLineDetectorBelowTheLine(hInstance,
		hWnd, ppOutputDataBuffer.size(),
		pACoefficient,
		pBCoefficient, pOnTheLineLabel,
		pBelowTheLineLabel, pAboveTheLineLabel,
		&ppComputeShaderObject,
		pPixelObjectGrayScale,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		pOutputFileStream << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		return hr;
	}

	cout << "Running our Compute Shader " << endl;
	
	hr = RunStraigntLineRestorationObject(hInstance,
		hWnd, pConstantBuffer,
		ppComputeShaderObject, pShaderResourceView, pUnorderedAccessView,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{


			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScaleBelowTheLine = ppOutputDataBuffer;

	return hr;
	
}



HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromLineDetectorAboveTheLine(HINSTANCE hInstance,
	HWND hWnd,
	float pACoefficient,
	float pBCoefficient,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScaleBelowTheLine)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;





	for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pPixelObjectGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		cout << "Pixel Class Value: " << pPixelObject.pIsPixelObjectValid << endl;


		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
		pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
		pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
		pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		pOutputFileStream << "Pixel Class Value: " << pPixelObject.pIsPixelObjectValid << endl;


	}



	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cout << "First We Have to Initialize our Simulation Resources" << endl;

	hr = InitializeRGBPixelImageRestorationFromLineDetectorAboveTheLine(hInstance,
		hWnd, ppOutputDataBuffer.size(),
		pACoefficient,
		pBCoefficient, pOnTheLineLabel,
		pBelowTheLineLabel, pAboveTheLineLabel,
		&ppComputeShaderObject,
		pPixelObjectGrayScale,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		pOutputFileStream << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		return hr;
	}

	cout << "Running our Compute Shader " << endl;

	hr = RunStraigntLineRestorationObject(hInstance,
		hWnd, pConstantBuffer,
		ppComputeShaderObject, pShaderResourceView, pUnorderedAccessView,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{


			ppOutputDataBuffer.push_back(p[i]);


		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScaleBelowTheLine = ppOutputDataBuffer;

	return hr;

}







HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromLineDetectorOnTheLine(HINSTANCE hInstance,
	HWND hWnd,
	float pACoefficient,
	float pBCoefficient,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScaleOnTheLine)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;





	for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pPixelObjectGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		cout << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;

		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
		pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
		pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
		pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		pOutputFileStream << "Pixel Class Value: " << pPixelObject.pClassOfPixelValue << endl;
	}



	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cout << "First We Have to Initialize our Simulation Resources" << endl;

	hr = InitializeRGBPixelImageRestorationFromLineDetectorOnTheLine(hInstance,
		hWnd, pPixelObjectGrayScale.size(),
		pACoefficient,
		pBCoefficient, pOnTheLineLabel,
		pBelowTheLineLabel, pAboveTheLineLabel,
		&ppComputeShaderObject,
		pPixelObjectGrayScale,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		pOutputFileStream << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		return hr;
	}

	cout << "Running our Compute Shader " << endl;

	hr = RunStraigntLineRestorationObject(hInstance,
		hWnd, pConstantBuffer,
		ppComputeShaderObject, pShaderResourceView, pUnorderedAccessView,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;


		float pCoordinateSum = 0.0f;

		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if (i == 0)
			{
				ppOutputDataBuffer.push_back(p[i]);
			}
			else if (i > 0)
			{
				pCoordinateSum = p[i].xPosition + p[i].yPosition;
				if (pCoordinateSum > 0.0f)
				{
					ppOutputDataBuffer.push_back(p[i]);
				}

			}
			

		}





			std::time_t t = std::time(0);   // get time now
			std::tm* now = std::localtime(&t);
			std::cout << (now->tm_year + 1900) << '-'
				<< (now->tm_mon + 1) << '-'
				<< now->tm_mday
				<< now->tm_hour
				<< now->tm_min
				<< now->tm_sec
				<< endl;

			// Verify that if Compute Shader has done right

			for (UINT pIndex = 0; pIndex < ppOutputDataBuffer.size(); ++pIndex)
			{
				if ((pIndex > 0) && (ppOutputDataBuffer[pIndex].xPosition == 0.0f) && (ppOutputDataBuffer[pIndex].yPosition == 0.0f))
				{
					ppOutputDataBuffer.erase(begin(ppOutputDataBuffer) + (pIndex - 1));
				}
			}



			for (PixelObject pPixelObject : ppOutputDataBuffer)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.RMask << endl;
				cout << "Green Component: " << pPixelObject.GMask << endl;
				cout << "Blue Component: " << pPixelObject.BMask << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



			}
			t = std::time(0);   // get time now
			now = std::localtime(&t);
			std::cout << (now->tm_year + 1900) << '-'
				<< (now->tm_mon + 1) << '-'
				<< now->tm_mday
				<< now->tm_hour
				<< now->tm_min
				<< now->tm_sec
				<< endl;
			pOutputFileStream << (now->tm_year + 1900) << '-'
				<< (now->tm_mon + 1) << '-'
				<< now->tm_mday
				<< now->tm_hour
				<< now->tm_min
				<< now->tm_sec
				<< endl;



		}

		printf("Cleaning up...\n");

		SafeReleaseA(&ppComputeShaderObject);
		SafeReleaseA(&pConstantBuffer);
		SafeReleaseA(&ppInputDataBuffer);
		SafeReleaseA(&pOutputDataBuffer);
		SafeReleaseA(&pShaderResourceView);
		SafeReleaseA(&pUnorderedAccessView);
		SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScaleOnTheLine = ppOutputDataBuffer;

	return hr;
	}





HRESULT DirectXStandardAlgorithmExecutor::RunStraigntLineRestorationObject(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationFromLineDetectorBelowTheLine(HINSTANCE hInstance, 
	HWND hWnd,
	UINT pAmountOfSamples, 
	float pACoefficient, 
	float pBCoefficient, 
	int pOnTheLineLabel, 
	int pAboveTheLineLabel,
	int pBelowTheLineLabel, 
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBufferBelowTheLine, 
	ID3D11ShaderResourceView** ppSRV1, 
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;

	CBLinePointDetector pConstantData;
	pConstantData.pACoefficientVar = pACoefficient;
	pConstantData.pBCoefficientVar = pBCoefficient;
	pConstantData.pOnTheLineLabel = pOnTheLineLabel;
	pConstantData.pAboveTheLineLabel = pAboveTheLineLabel;
	pConstantData.pBelowTheLineLabel = pBelowTheLineLabel;
	

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelsFromPixelLineDetectorBelowTheLine.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBLinePointDetector) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantData;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBufferBelowTheLine = pOutputBufferOne;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}











HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromLineDetectorOnTheLineXPosition(HINSTANCE hInstance,
	HWND hWnd,
	float pXValue,
	float pRedComponentValue,
	float pGreenComponentValue,
	float pBlueComponentValue,
	int pOnTheLineLabel,
	int pLeftOfTheLineLabel,
	int pRightOfTheLineLabel,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScaleOnTheLine)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;





	for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pPixelObjectGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		cout << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
		cout << "Is pixel valid: " << pPixelObject.pIsPixelObjectValid << endl;


		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
		pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
		pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
		pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		pOutputFileStream << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
		pOutputFileStream << "Is pixel valid: " << pPixelObject.pIsPixelObjectValid << endl;

	
	}



	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cout << "First We Have to Initialize our Simulation Resources" << endl;

	hr = InitializeRGBPixelImageRestorationFromLineDetectorOnTheLineXPosition(hInstance,
		hWnd, pPixelObjectGrayScale.size(),
		pXValue,
		pOnTheLineLabel, pLeftOfTheLineLabel,
		pRightOfTheLineLabel,
		pRedComponentValue,
		pGreenComponentValue,
		pBlueComponentValue,
		&ppComputeShaderObject,
		pPixelObjectGrayScale,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		pOutputFileStream << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		return hr;
	}

	cout << "Running our Compute Shader " << endl;

	hr = RunStraigntLineRestorationObject(hInstance,
		hWnd, pConstantBuffer,
		ppComputeShaderObject, pShaderResourceView, pUnorderedAccessView,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{

			if ((p[i].pixelNumber != 666) && (p[i].xPosition != 666.0f) || (p[i].yPosition != 666.0f))
			{
				ppOutputDataBuffer.push_back(p[i]);

			}

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScaleOnTheLine = ppOutputDataBuffer;

	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationFromLineDetectorOnTheLineXPosition(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	float pXPositionValue,
	int pOnTheLineLabel,
	int pLeftOfTheLineLabel,
	int pRightTheLineLabel,
	float pRedComponentVar,
	float pGreenComponentVar,
	float pBlueComponentVar,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBufferBelowTheLine,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;

	CBLinePointDetectorXPosition pConstantData;
	pConstantData.xPositionValue = pXPositionValue;	
	pConstantData.pOnTheLineLabel = pOnTheLineLabel;
	pConstantData.pLeftOfTheLineLabel = pLeftOfTheLineLabel;
	pConstantData.pRightOfTheLineLabel = pRightTheLineLabel;
	pConstantData.pRedComponentVar = pRedComponentVar;
	pConstantData.pGreenComponentVar = pGreenComponentVar;
	pConstantData.pBlueComponentVar = pBlueComponentVar;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelLineDetectionOnTheLineXParam.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBLinePointDetectorXPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantData;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBufferBelowTheLine = pOutputBufferOne;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromLineDetectorOnTheLineYPosition(HINSTANCE hInstance,
	HWND hWnd,
	float pXValue,
	float pRedComponentValue,
	float pGreenComponentValue,
	float pBlueComponentValue,
	int pOnTheLineLabel,
	int pLeftOfTheLineLabel,
	int pRightOfTheLineLabel,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScaleOnTheLine)
{


	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;





	for (OutputPixelObjectCorrespondenceLinearFunction pPixelObject : pPixelObjectGrayScale)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.rValue << endl;
		cout << "Green Component: " << pPixelObject.gValue << endl;
		cout << "Blue Component: " << pPixelObject.bValue << endl;
		cout << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		cout << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
		cout << "Is Valid: " << pPixelObject.pIsPixelObjectValid << endl;



		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
		pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
		pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
		pOutputFileStream << "Line Function Value: " << pPixelObject.pLinearFunctionValue << endl;
		pOutputFileStream << "Class of Pixel: " << pPixelObject.pClassOfPixelValue << endl;
		pOutputFileStream <<  "Is Valid: " << pPixelObject.pIsPixelObjectValid << endl;

	}



	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;


	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	cout << "First We Have to Initialize our Simulation Resources" << endl;

	hr = InitializeRGBPixelImageRestorationFromLineDetectorOnTheLineYPosition(hInstance,
		hWnd, pPixelObjectGrayScale.size(),
		pXValue,
		pOnTheLineLabel, pLeftOfTheLineLabel,
		pRightOfTheLineLabel,
		pRedComponentValue,
		pGreenComponentValue,
		pBlueComponentValue,
		&ppComputeShaderObject,
		pPixelObjectGrayScale,
		&pConstantBuffer,
		&ppInputDataBuffer,
		&pOutputDataBuffer,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		pOutputFileStream << "Unable to initialize The Resources for the Simulation: " << pLastError << endl;
		return hr;
	}

	cout << "Running our Compute Shader " << endl;

	hr = RunStraigntLineRestorationObject(hInstance,
		hWnd, pConstantBuffer,
		ppComputeShaderObject, pShaderResourceView, pUnorderedAccessView,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{
			if ((p[i].pixelNumber != 666) && (p[i].xPosition != 666.0f) || (p[i].yPosition != 666.0f))
			{
				ppOutputDataBuffer.push_back(p[i]);

			}
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


			}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScaleOnTheLine = ppOutputDataBuffer;

		return hr;

	}










HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationFromLineDetectorOnTheLineYPosition(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	float pXPositionValue,
	int pOnTheLineLabel,
	int pLeftOfTheLineLabel,
	int pRightTheLineLabel,
	float pRedComponentVar,
	float pGreenComponentVar,
	float pBlueComponentVar,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBufferBelowTheLine,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;

	CBLinePointDetectorXPosition pConstantData;
	pConstantData.xPositionValue = pXPositionValue;
	pConstantData.pOnTheLineLabel = pOnTheLineLabel;
	pConstantData.pLeftOfTheLineLabel = pLeftOfTheLineLabel;
	pConstantData.pRightOfTheLineLabel = pRightTheLineLabel;
	pConstantData.pRedComponentVar = pRedComponentVar;
	pConstantData.pGreenComponentVar = pGreenComponentVar;
	pConstantData.pBlueComponentVar = pBlueComponentVar;


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelLineDetectionOnTheLineYParam.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBLinePointDetectorXPosition) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantData;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBufferBelowTheLine = pOutputBufferOne;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}





















HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationFromLineDetectorOnTheLine(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	float pACoefficient,
	float pBCoefficient,
	int pOnTheLineLabel,
	int pAboveTheLineLabel,
	int pBelowTheLineLabel,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<OutputPixelObjectCorrespondenceLinearFunction> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBufferBelowTheLine,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	CBLinePointDetector pLineDetectorCB;
	pLineDetectorCB.pACoefficientVar = pACoefficient;
	pLineDetectorCB.pBCoefficientVar = pBCoefficient;
	pLineDetectorCB.pOnTheLineLabel = pOnTheLineLabel;
	pLineDetectorCB.pBelowTheLineLabel = pBelowTheLineLabel;
	pLineDetectorCB.pAboveTheLineLabel = pAboveTheLineLabel;


	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBufferOne = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAVOne = nullptr;
	ID3D11Buffer* pReadbackBufferOne = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RestorePixelsFromPixelLineDetectorOnTheLine.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBBinaryClassifierConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pLineDetectorCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectCorrespondenceLinearFunction);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_BUFFER_DESC buffer_desc_output_one;
	ZeroMemory(&buffer_desc_output_one, sizeof(buffer_desc_output_one));
	buffer_desc_output_one.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc_output_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_one.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_one.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output_one.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_one, nullptr, &pOutputBufferOne);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer One" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer One" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc0;
	ZeroMemory(&uavbuffer_desc0, sizeof(uavbuffer_desc0));
	uavbuffer_desc0.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc0.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc0.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferOne, &uavbuffer_desc0, &pOutputUAVOne);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc0;
	ZeroMemory(&readback_buffer_desc0, sizeof(readback_buffer_desc0));
	readback_buffer_desc0.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	readback_buffer_desc0.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc0.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc0, nullptr, &pReadbackBufferOne);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}





	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBufferBelowTheLine = pOutputBufferOne;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAVOne;
	*ppReadbackBuffer = pReadbackBufferOne;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::RestoreRGBPixelFromFilterWithoutExclusion(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectFiltered> pPixelObjectGrayScale,
	vector<PixelObject> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<PixelObject> ppOutputDataBuffer = vector<PixelObject>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectFiltered pPixelObject : pPixelObjectGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pRedComponent = pPixelObject.rValue;
		float pGreenComponent = pPixelObject.gValue;
		float pBlueComponent = pPixelObject.gValue;
		bool pIsPixelValid = pPixelObject.pUsedInComputations;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "Red Value = " << pRedComponent << endl;
		cout << "Green Value = " << pGreenComponent << endl;
		cout << "Blue Component = " << pBlueComponent << endl;
		cout << "Is Pixel Valid = " << pIsPixelValid << endl;



	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeRGBPixelImageRestorationResourcesWithoutExclusion(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunRGBImageRestorationFromFilter(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;



		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{
			
			
				ppOutputDataBuffer.push_back(p[i]);
			

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObject pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.RMask << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.GMask << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.BMask << endl;



		}
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunRGBImageRestorationFromSorting(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pImageRestorationComputeShader,
	ID3D11ShaderResourceView* pImageRestorationSRV,
	ID3D11UnorderedAccessView* pImageRestorationUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;

	ID3D11ShaderResourceView* ppSRV[] = { pImageRestorationSRV };
	ID3D11UnorderedAccessView* ppUAV[] = { pImageRestorationUAV };
	m_pD3DCompContext->CSSetShader(pImageRestorationComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectFiltered> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelFromFilter.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBPixelImageRestorationResourcesWithoutExclusion(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectFiltered> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreRGBPixelFromFilterWithoutExclusion.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeKMeansFilterGrayScaleResources(HINSTANCE hInstance,
	HWND hWnd,
	KMeansConstantBuffer pKMeansBuffer,
	vector<PixelObjectGrayScale> ppResourceObjectCollection,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppShaderResourceViewObject,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageKMeansClusterRGBSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSKMeansFilterRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(KMeansConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pKMeansBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppResourceObjectCollection.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &ppResourceObjectCollection[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppResourceObjectCollection.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = ppResourceObjectCollection.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppResourceObjectCollection.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppResourceObjectCollection.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppShaderResourceViewObject = pInputSRV1;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunGrayScaleKMeansFilter(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBufferObject,
	ID3D11ShaderResourceView* pShaderResourceViewObject,
	ID3D11UnorderedAccessView* pUnorderedAcessViewObject,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceViewObject };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedAcessViewObject };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufferObject);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::DestroyWhiteFontFromGraph(HINSTANCE hInstance,
	HWND hWnd,
	float pRedValueToIgnore,
	float pGreenValueToIgnore,
	float pBlueValueToIgnore,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeWhiteFontOperationRGB(hInstance,
		hWnd, ppPixelArrayInput.size(),
		pRedValueToIgnore, pGreenValueToIgnore, pBlueValueToIgnore,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeWhiteFontOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pRedColorToIgnore,
	float pGreenColorToIgnore,
	float pBlueColorToIgnore,
	vector<PixelObject> pixelArrayOne, 
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer, 
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1, 
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThreshHoldFontKillerVarStruct pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pStandardRed0  = pRedColorToIgnore;
	pBinaryImageConstantBuffer.pStandardGreen0 = pGreenColorToIgnore;
	pBinaryImageConstantBuffer.pStandardBlue0 = pBlueColorToIgnore;
	pBinaryImageConstantBuffer.pStandardRed1 = 255.0f;
	pBinaryImageConstantBuffer.pStandardGreen1 = 255.0f;
	pBinaryImageConstantBuffer.pStandardBlue1 = 255.0f;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSWhiteFontKillerRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldFontKillerVarStruct) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SelectPixelsOfColorFromImage(HINSTANCE hInstance,
	HWND hWnd,
	float pRedValueToSelect,
	float pGreenValueToSelect,
	float pBlueValueToSelect,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		if (pIndex == 10)
		{
			break;
		}
		else
		{
			pIndex = pIndex + 1;

		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeColorSelectorOperationRGB(hInstance,
		hWnd, ppPixelArrayInput.size(), pRedValueToSelect, pGreenValueToSelect, pBlueValueToSelect,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		pIndex = 0;
		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			if (pIndex == 10)
			{
				break;
			}
			else
			{
				pIndex = pIndex + 1;

			}


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeColorSelectorOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pRedColorToIgnore,
	float pGreenColorToIgnore,
	float pBlueColorToIgnore,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThreshHoldFontSelectoVarStruct pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pRedValueToSelect = pRedColorToIgnore;
	pBinaryImageConstantBuffer.pGreenValueToSelect = pGreenColorToIgnore;
	pBinaryImageConstantBuffer.pBlueValueToSelect = pBlueColorToIgnore;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSColorSelectorRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldFontSelectoVarStruct) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::DetectPointsInRGBImage(HINSTANCE hInstance, HWND hWnd, vector<PixelObject> ppPixelArrayInput, vector<Point2D> pPointArrayToProcess, vector<OutputPixelObjectPoint2D> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectPoint2D> ppOutputDataBuffer = vector<OutputPixelObjectPoint2D>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;



	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Printing the Point Array Data" << endl;
	pOutputFileStream << "Printing the Point Array Data" << endl;
	for (Point2D pPointObject : pPointArrayToProcess)
	{
		cout << "Point Number: " << pPointObject.pPointNumber << endl;
		cout << "X Position: " << pPointObject.xPosition << endl;
		cout << "Y Position: " << pPointObject.yPosition << endl;

		pOutputFileStream << "Point Number: " << pPointObject.pPointNumber << endl;
		pOutputFileStream << "X Position: " << pPointObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPointObject.yPosition << endl;


	}



	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBufferOne = nullptr;
	ID3D11Buffer* ppInputDataBufferTwo = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewOne = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewTwo = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImagePointDetector(hInstance,
		hWnd, ppPixelArrayInput,
		pPointArrayToProcess,
		&ppComputeShaderObject,
		&ppInputDataBufferOne,
		&ppInputDataBufferTwo,
		&pOutputDataBuffer,
		&pShaderResourceViewOne,
		&pShaderResourceViewTwo,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);


	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImagePointDetector(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceViewOne,
		pShaderResourceViewTwo,
		pUnorderedAccessView,
		256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectPoint2D* p = (OutputPixelObjectPoint2D*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectPoint2D pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "X Position Point: " << pPixelObject.xPositionPoint << endl;
			cout << "Y Position Point: " << pPixelObject.xPositionPoint << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Is Point Valid: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "X Position Point: " << pPixelObject.xPositionPoint << endl;
			pOutputFileStream << "Y Position Point: " << pPixelObject.xPositionPoint << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Is Point Valid: " << pPixelObject.pIsPixelValid << endl;


		}

		

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBufferOne);
	SafeReleaseA(&ppInputDataBufferTwo);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceViewOne);
	SafeReleaseA(&pShaderResourceViewTwo);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeImagePointDetector(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<Point2D> pPointArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBufferOne,
	ID3D11Buffer** ppInputBufferTwo,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSPointDetectorRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}





	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData1, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_point;
	ZeroMemory(&buffer_desc_point, sizeof(buffer_desc_point));
	buffer_desc_point.ByteWidth = pPointArrayOne.size() * sizeof(Point2D);
	buffer_desc_point.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_point.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_point.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_point.StructureByteStride = sizeof(Point2D);
	buffer_desc_point.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData2;
	pData2.pSysMem = &pPointArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_point, &pData2, &pInputBuffer2);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}





	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectPoint2D);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectPoint2D);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_one;
	ZeroMemory(&srvbuffer_desc_one, sizeof(srvbuffer_desc_one));
	srvbuffer_desc_one.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_one.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_one.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc_one.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc_one, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_two;
	ZeroMemory(&srvbuffer_desc_two, sizeof(srvbuffer_desc_two));
	srvbuffer_desc_two.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_two.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_two.Buffer.ElementWidth = pPointArrayOne.size();
	srvbuffer_desc_two.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc_two, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectPoint2D);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectPoint2D);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferOne = pInputBuffer1;
	*ppInputBufferTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunImagePointDetector(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pInputSRVFSM1,
	ID3D11ShaderResourceView* pInputSRVFSM2,
	ID3D11UnorderedAccessView* pOutputUAVFSM, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pInputSRVFSM1, pInputSRVFSM2 };
	ID3D11UnorderedAccessView* ppUAV[] = { pOutputUAVFSM };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pOutputUAVFSM, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* pConstantBufferNull = nullptr;
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);
	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::DetectMotionInRGBImage(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	vector<MotionPixelObjectRGB> *ppOutputPixelData,
	
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	float *ppImageOneIntensitySumRed,
	float *ppImageOneIntensitySumGreen,
	float *ppImageOneIntensitySumBlue,
	float *ppImageTwoIntensitySumRed,
	float *ppImageTwoIntensitySumGreen,
	float *ppImageTwoIntensitySumBlue,
	float *ppImageOneAverageRed,
	float *ppImageOneAverageGreen,
	float *ppImageOneAverageBlue,
	float *ppImageTwoAverageRed,
	float *ppImageTwoAverageGreen,
	float *ppImageTwoAverageBlue,
	float *ppOutputArrayIntensitySumRed,
	float *ppOutputArrayIntensitySumGreen,
	float *ppOutputArrayIntensitySumBlue,
	float *ppOutputArrayIntensityAverageRed,
	float *ppOutputArrayIntensityAverageGreen,
	float *ppOutputArrayIntensityAverageBlue,
	BOOL *pAreImageIdenticalVar)

{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<MotionPixelObjectRGB> pPixelArrayOutputBuffer = vector<MotionPixelObjectRGB>();
	
	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneIntensityAverageRed = 0.0f;
	float pImageOneIntensityAverageGreen = 0.0f;
	float pImageOneIntensityAverageBlue = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoIntensityAverageRed = 0.0f;
	float pImageTwoIntensityAverageGreen = 0.0f;
	float pImageTwoIntensityAverageBlue = 0.0f;

	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayIntensityAverageRed = 0.0f;
	float pOutputArrayIntensityAverageGreen = 0.0f;
	float pOutputArrayIntensityAverageBlue = 0.0f;

	




	float pImageOneArraySize = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArraySize = 0.0f;
	float pOutputArrayAverage = 0.0f;





	fstream imageMaskLog("С:\\pixels\\ImageComparisonObjectRGB.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component : " << pPixelObject.RMask << endl;
		cout << "Green Component : " << pPixelObject.GMask << endl;
		cout << "Blue Component : " << pPixelObject.BMask << endl;

		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red Component : " << pPixelObject.RMask << endl;
		imageMaskLog << "Green Component : " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue Component : " << pPixelObject.BMask << endl;

		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
        pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;

	}
	pImageOneIntensityAverageRed = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneIntensityAverageGreen = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneIntensityAverageBlue = pImageOneIntensitySumBlue / pixelArrayOne.size();


	cout << "Image One Intensity Sum Red: " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green: " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue: " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Intensity Average Red: " << pImageOneIntensityAverageRed << endl;
	cout << "Image One Intensity Average Green: " << pImageOneIntensityAverageGreen << endl;
	cout << "Image One Intensity Average Blue: " << pImageOneIntensityAverageBlue << endl;

	imageMaskLog << "Image One Intensity Sum Red: " << pImageOneIntensitySumRed << endl;
	imageMaskLog << "Image One Intensity Sum Green: " << pImageOneIntensitySumGreen << endl;
	imageMaskLog << "Image One Intensity Sum Blue: " << pImageOneIntensitySumBlue << endl;
	imageMaskLog << "Image One Intensity Average Red: " << pImageOneIntensityAverageRed << endl;
	imageMaskLog << "Image One Intensity Average Green: " << pImageOneIntensityAverageGreen << endl;
	imageMaskLog << "Image One Intensity Average Blue: " << pImageOneIntensityAverageBlue << endl;


	cout << "Image One Array Size = " << pixelArrayOne.size();

	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;


	for (PixelObject pPixelObject : pixelArrayTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component : " << pPixelObject.RMask << endl;
		cout << "Green Component : " << pPixelObject.GMask << endl;
		cout << "Blue Component : " << pPixelObject.BMask << endl;

		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red Component : " << pPixelObject.RMask << endl;
		imageMaskLog << "Green Component : " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue Component : " << pPixelObject.BMask << endl;

		pImageTwoIntensitySumRed = pImageTwoIntensitySumRed + pPixelObject.RMask;
		pImageTwoIntensitySumGreen = pImageTwoIntensitySumGreen + pPixelObject.GMask;
		pImageTwoIntensitySumBlue = pImageTwoIntensitySumBlue + pPixelObject.BMask;
	}

	pImageTwoIntensityAverageRed = pImageTwoIntensitySumRed / pixelArrayTwo.size();
	pImageTwoIntensityAverageGreen = pImageTwoIntensitySumGreen / pixelArrayTwo.size();
	pImageTwoIntensityAverageBlue = pImageTwoIntensitySumBlue / pixelArrayTwo.size();


	cout << "Image Two Intensity Sum Red: " << pImageTwoIntensitySumRed << endl;
	cout << "Image Two Intensity Sum Green: " << pImageTwoIntensitySumGreen << endl;
	cout << "Image Two Intensity Sum Blue: " << pImageTwoIntensitySumBlue << endl;
	cout << "Image Two Intensity Average Red: " << pImageTwoIntensityAverageRed << endl;
	cout << "Image Two Intensity Average Green: " << pImageTwoIntensityAverageGreen << endl;
	cout << "Image Two Intensity Average Blue: " << pImageTwoIntensityAverageBlue << endl;

	imageMaskLog << "Image Two Intensity Sum Red: " << pImageTwoIntensitySumRed << endl;
	imageMaskLog << "Image Two Intensity Sum Green: " << pImageTwoIntensitySumGreen << endl;
	imageMaskLog << "Image Two Intensity Sum Blue: " << pImageTwoIntensitySumBlue << endl;
	imageMaskLog << "Image Two Intensity Average Red: " << pImageTwoIntensityAverageRed << endl;
	imageMaskLog << "Image Two Intensity Average Green: " << pImageTwoIntensityAverageGreen << endl;
	imageMaskLog << "Image Two Intensity Average Blue: " << pImageTwoIntensityAverageBlue << endl;


	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pInputDataBufferImageTwo = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pOutputBufferForIdenticalPixels = nullptr;
	ID3D11Buffer* pOutputBufferForDifferentPixels = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageTwo = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11UnorderedAccessView* pIdenticalUnorderedView = nullptr;
	ID3D11UnorderedAccessView* pDifferentUnorderedView = nullptr;
	ID3D11Buffer* pOutputReadbackBuffer = nullptr;
	ID3D11Buffer* pIdenticalReadbackBuffer = nullptr;
	ID3D11Buffer* pDifferentReadbackBuffer = nullptr;

    ID3D11Buffer* pReadbackBufferOutput = nullptr;
	
	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	

	hr = InitializeMotionDetectionResourcesRGB(hInstance,
		hWnd,
		pixelArrayOne,
		pixelArrayTwo,
		&ppComputeShaderForImageComparison,
		&pInputDataBufferImageOne,
		&pInputDataBufferImageTwo,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pInputDataSRVImageTwo,
		&pOutputUnorderedView,
		&pOutputReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne, pInputDataSRVImageTwo };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };
    imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunMotionDetectiondOperationRGB(hInstance, hWnd, ppComputeShaderForImageComparison,
		pInputDataSRVImageOne,
		pInputDataSRVImageTwo,
		pOutputUnorderedView,
		2, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pOutputReadbackBuffer, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pOutputReadbackBuffer, 0, D3D11_MAP_READ, 0, &pMammedResource);
	MotionPixelObjectRGB* pOutputDataImages = (MotionPixelObjectRGB*)pMammedResource.pData;



	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		MotionPixelObjectRGB pOutputValue = pOutputDataImages[pIndex];
		pOutputValue.pixelNumber = pIndex;

		
	
		cout << "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputValue.rValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputValue.rValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputValue.gValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputValue.gValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputValue.bValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputValue.bValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputValue.pRedComponentDifference << endl;
		cout << "Green Difference: " << " = " << pOutputValue.pGreenComponentDifference << endl;
		cout << "Blue Difference: " << " = " << pOutputValue.pBlueComponentDifference << endl;
		cout << "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;
		cout << "Motion detected =" << pOutputValue.pOverallMotionDetected << endl;
		

		imageMaskLog<< "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		imageMaskLog<< "X Position: " << " = " << pOutputValue.xPosition << endl;
		imageMaskLog<< "Y Position: " << " = " << pOutputValue.yPosition << endl;
		imageMaskLog<< "Image One Red Component: " << " = " << pOutputValue.rValue0 << endl;
		imageMaskLog<< "Image Two Red Component: " << " = " << pOutputValue.rValue1 << endl;
		imageMaskLog<< "Image One Green Component: " << " = " << pOutputValue.gValue0 << endl;
		imageMaskLog<< "Image Two Green Component: " << " = " << pOutputValue.gValue1 << endl;
		imageMaskLog<< "Image One Blue Component: " << " = " << pOutputValue.bValue0 << endl;
		imageMaskLog<< "Image Two Blue Component: " << " = " << pOutputValue.bValue1 << endl;
		imageMaskLog<< "Red Difference: " << " = " << pOutputValue.pRedComponentDifference << endl;
		imageMaskLog<< "Green Difference: " << " = " << pOutputValue.pGreenComponentDifference << endl;
		imageMaskLog<< "Blue Difference: " << " = " << pOutputValue.pBlueComponentDifference << endl;
		imageMaskLog<< "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		imageMaskLog<< "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;
		imageMaskLog<< "Motion detected =" << pOutputValue.pOverallMotionDetected << endl;

		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputValue.pRedComponentDifference;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputValue.pGreenComponentDifference;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputValue.pBlueComponentDifference;

		pPixelArrayOutputBuffer.push_back(pOutputValue);
	}

	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayIntensityAverageGreen = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayIntensityAverageBlue = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();







	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (MotionPixelObjectRGB pOutputValue : pPixelArrayOutputBuffer)
	{

		cout << "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputValue.rValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputValue.rValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputValue.gValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputValue.gValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputValue.bValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputValue.bValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputValue.pRedComponentDifference << endl;
		cout << "Green Difference: " << " = " << pOutputValue.pGreenComponentDifference << endl;
		cout << "Blue Difference: " << " = " << pOutputValue.pBlueComponentDifference << endl;
		cout << "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;
		cout << "Is Motion Detected =" << pOutputValue.pOverallMotionDetected << endl;


		imageMaskLog<< "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		imageMaskLog<< "X Position: " << " = " << pOutputValue.xPosition << endl;
		imageMaskLog<< "Y Position: " << " = " << pOutputValue.yPosition << endl;
		imageMaskLog<< "Image One Red Component: " << " = " << pOutputValue.rValue0 << endl;
		imageMaskLog<< "Image Two Red Component: " << " = " << pOutputValue.rValue1 << endl;
		imageMaskLog<< "Image One Green Component: " << " = " << pOutputValue.gValue0 << endl;
		imageMaskLog<< "Image Two Green Component: " << " = " << pOutputValue.gValue1 << endl;
		imageMaskLog<< "Image One Blue Component: " << " = " << pOutputValue.bValue0 << endl;
		imageMaskLog<< "Image Two Blue Component: " << " = " << pOutputValue.bValue1 << endl;
		imageMaskLog<< "Red Difference: " << " = " << pOutputValue.pRedComponentDifference << endl;
		imageMaskLog<< "Green Difference: " << " = " << pOutputValue.pGreenComponentDifference << endl;
		imageMaskLog<< "Blue Difference: " << " = " << pOutputValue.pBlueComponentDifference << endl;
		imageMaskLog<< "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		imageMaskLog<< "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;
		imageMaskLog<< "Is Motion Detected =" << pOutputValue.pOverallMotionDetected << endl;

        

	}

	pOutputArraySize = pPixelArrayOutputBuffer.size();

	if (pOutputArraySize > 0)
	{
		pOutputArrayAverage = pOutputArrayIntensitySum / pPixelArrayOutputBuffer.size();
	}
	else
	{
		pOutputArrayAverage = 0;
	}
	cout << "Output Array Intensity Sum Red = " << pOutputArrayIntensitySumRed << endl;
	cout << "Output Array Intensity Sum Green = " << pOutputArrayIntensitySumGreen << endl;
	cout << "Output Array Intensity Sum Blue = " << pOutputArrayIntensitySumBlue << endl;

	cout << "Output Array Intensity Average Red = " << pOutputArrayIntensityAverageRed << endl;
	cout << "Output Array Intensity Average Green = " << pOutputArrayIntensityAverageGreen << endl;
	cout << "Output Array Intensity Average Blue = " << pOutputArrayIntensityAverageBlue<< endl;

	imageMaskLog << "Output Array Intensity Sum Red = " << pOutputArrayIntensitySumRed << endl;
	imageMaskLog << "Output Array Intensity Sum Green = " << pOutputArrayIntensitySumGreen << endl;
	imageMaskLog << "Output Array Intensity Sum Blue = " << pOutputArrayIntensitySumBlue << endl;

	imageMaskLog << "Output Array Intensity Average Red = " << pOutputArrayIntensityAverageRed << endl;
	imageMaskLog << "Output Array Intensity Average Green = " << pOutputArrayIntensityAverageGreen << endl;
	imageMaskLog << "Output Array Intensity Average Blue = " << pOutputArrayIntensityAverageBlue << endl;



	
	


	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppImageOneIntensitySumRed = pImageOneIntensitySumRed;
	*ppImageOneIntensitySumGreen = pImageOneIntensitySumGreen;
	*ppImageOneIntensitySumBlue = pImageOneIntensitySumBlue;
	*ppImageTwoIntensitySumRed = pImageTwoIntensitySumRed;
	*ppImageTwoIntensitySumGreen = pImageTwoIntensitySumGreen;
	*ppImageTwoIntensitySumBlue = pImageTwoIntensitySumBlue;
	*ppImageOneAverageRed = pImageOneIntensityAverageRed;
	*ppImageOneAverageGreen = pImageOneIntensityAverageGreen;
	*ppImageOneAverageBlue = pImageOneIntensityAverageBlue;
	*ppImageTwoAverageRed = pImageTwoIntensityAverageRed;
	*ppImageTwoAverageGreen = pImageTwoIntensityAverageGreen;
	*ppImageTwoAverageBlue = pImageTwoIntensityAverageBlue;
	*ppOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed;
	*ppOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen;
	*ppOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue;
	*ppOutputArrayIntensityAverageRed = pOutputArrayIntensityAverageRed;
	*ppOutputArrayIntensityAverageGreen = pOutputArrayIntensityAverageGreen;
	*ppOutputArrayIntensityAverageBlue = pOutputArrayIntensityAverageBlue;
	

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeMotionDetectionResourcesRGB(HINSTANCE hInstance,
	HWND hWnd, 
    vector<PixelObject> pixelArrayOne, 
    vector<PixelObject> pixelArrayTwo,
    ID3D11ComputeShader** ppComputeShaderObject, 
    ID3D11Buffer** ppInputBufferImageOne,
    ID3D11Buffer** ppInputBufferImageTwo,
    ID3D11Buffer** ppOutputBuffer,
    ID3D11ShaderResourceView** ppSRV1,
    ID3D11ShaderResourceView** ppSRV2,
    ID3D11UnorderedAccessView** ppUAVObjectOutput, 
    ID3D11Buffer** ppReadbackBufferOutput
    )
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
    ID3D11Buffer* pReadbackOutputBuffer = nullptr;
	


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\MotionDetectionAlgorithmRGB.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObject);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObject);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(MotionPixelObjectRGB);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(MotionPixelObjectRGB);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	

	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	


	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(MotionPixelObjectRGB);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(MotionPixelObjectRGB);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferImageOne = pInputBuffer1;
	*ppInputBufferImageTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunMotionDetectiondOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11ShaderResourceView* ppSRV2,
	ID3D11UnorderedAccessView* pUAVObjectOutput,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1, ppSRV2 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUAVObjectOutput};
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RestoreGrayScalePixelFromFilter(
	HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectFilteredGrayScale> pPixelObjectGrayScale,
	vector<PixelObjectGrayScale> *ppOutputPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\RestoreGrayScaleImageFromFilterSetup.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;

	for (OutputPixelObjectFilteredGrayScale pPixelObject : pPixelObjectGrayScale)
	{

		int pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGrayScaleValue;
		bool pIsPixelValid = pPixelObject.pIsPixelValid;


		cout << "Step: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;
		cout << "Is Pixel Valid = " << pIsPixelValid << endl;

		pOutputFileStream << "Step: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;



	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeGrayScaleFilterImageRestorationResources(hInstance,
		hWnd,
		pPixelObjectGrayScale,
		&ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunGrayScaleImageRestoration(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;
		for (int i = 0; i < pPixelObjectGrayScale.size(); ++i)
		{
			if ((p[i].pixelNumber != 777) && (p[i].xPosition != 777) && (p[i].yPosition != 777) && (p[i].pGreyLevel != 777))
			{
				ppOutputDataBuffer.push_back(p[i]);
			}
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right


		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppOutputPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeGrayScaleFilterImageRestorationResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectFilteredGrayScale> pInputFilterGrayscaleVector,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBuffer,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObject, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageGrayScaleImageRestorationResurcesSetup.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSRestoreGrayScalePixelFromFilter.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(OutputPixelObjectFilteredGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectFilteredGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputFilterGrayscaleVector[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputFilterGrayscaleVector.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputFilterGrayscaleVector.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputFilterGrayscaleVector.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppImageRestorationComputeShader = pComputeShaderObject;
	*ppImageRestorationInputBuffer = pInputBuffer1;
	*ppImageRestorationOutputBuffer = pOutputBuffer;
	*ppInputShaderResourceView = pInputSRV1;
	*ppOutputUAVObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulateActivControlModule(HINSTANCE hInstance,
	HWND hWnd,
	float fVar,
	float mVar,
	bool doNeedConstantControl,
	float pMaximumDifference,
	float pLimit,
	bool pDoNeedStability,
	vector<ObjectClassInActiv> ppResourceObjectCollection,
	vector<ObjectClassOutActiv> *pOutputResourceObject)
{
	HRESULT hr = S_OK;

	cout << "This Function Simulates the Active CONTROL Law" << endl;

	cout << "Printing Initial Resource" << endl;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\ActivManagementUnit.txt", fstream::in | fstream::out | fstream::trunc);
	vector<ObjectClassOutActiv>  pOutputResourceObjectCollection = vector<ObjectClassOutActiv>();

	cbConstantBufferAxctivManagement pConstantBufferFinance;
	pConstantBufferFinance.fVar = fVar;
	pConstantBufferFinance.mVar = mVar;
	pConstantBufferFinance.doNeedConstantControl = doNeedConstantControl;
	pConstantBufferFinance.pMaximumDifference = pMaximumDifference;
	pConstantBufferFinance.pLimit = pLimit;
	pConstantBufferFinance.pDoNeedStability = pDoNeedStability;

	for (ObjectClassInActiv pResourceObject : ppResourceObjectCollection)
	{
		cout << "Index: " << pResourceObject.pIndesValue << endl;
		cout << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
		cout << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		cout << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		cout << "Common Potential: " << pResourceObject.pCommonPotentialValAgainstTime << endl;
		cout << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		cout << "Is Cointainment of Growth Needed: " << pResourceObject.pContainableGrowthCondition << endl;
		cout << "Data Varies Strongly: " << pResourceObject.pDataVaryStrongly << endl;
		cout << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		cout << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		cout << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		cout << "Current Time: " << pResourceObject.pTimeValue << endl;
		cout << "Mass Inflow: " << pResourceObject.pMassInflowIn << endl;
		cout << "Mass Outflow: " << pResourceObject.pMassOutflowOut << endl;
		cout << "Input Mass Growth Coefficient" << pResourceObject.pInputKMathGrowth << endl;
		cout << "Previous K:  " << pResourceObject.pPreviousK << endl;
		cout << "K Value " << pResourceObject.pKValue << endl;
	
		imageSegmentationDataFile << "Index: " << pResourceObject.pIndesValue << endl;
		imageSegmentationDataFile << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
		imageSegmentationDataFile << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		imageSegmentationDataFile << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		imageSegmentationDataFile << "Common Potential: " << pResourceObject.pCommonPotentialValAgainstTime << endl;
		imageSegmentationDataFile << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		imageSegmentationDataFile << "Is Cointainment of Growth Needed: " << pResourceObject.pContainableGrowthCondition << endl;
		imageSegmentationDataFile << "Data Varies Strongly: " << pResourceObject.pDataVaryStrongly << endl;
		imageSegmentationDataFile << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		imageSegmentationDataFile << "Average Dynamic Growth: " << pResourceObject.pAverageDynamicGrowthOut << endl;
		imageSegmentationDataFile << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;
		imageSegmentationDataFile << "Current Time: " << pResourceObject.pTimeValue << endl;
		imageSegmentationDataFile << "Mass Inflow: " << pResourceObject.pMassInflowIn << endl;
		imageSegmentationDataFile << "Mass Outflow: " << pResourceObject.pMassOutflowOut << endl;
		imageSegmentationDataFile << "Input Mass Growth Coefficient" << pResourceObject.pInputKMathGrowth << endl;
		imageSegmentationDataFile << "Previous K:  " << pResourceObject.pPreviousK << endl;
		imageSegmentationDataFile << "K Value " << pResourceObject.pKValue << endl;
		
	}

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;

	ID3D11ComputeShader* pFinancialSpaceCS = nullptr;
	ID3D11Buffer* pCurrencyMetalConstantBuffer = nullptr;
	ID3D11Buffer* pMetalInputBuffer = nullptr;
	ID3D11Buffer* pCurrencySpaceOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pCurrencyInputSRV = nullptr;
	ID3D11UnorderedAccessView* pFinancialSpaceOutputUAV = nullptr;
	ID3D11Buffer* pFinancialSpaceReadbackBuffer = nullptr;

	cout << "Initializing Our Resources" << endl;

	hr = InitializeActivControlModule(hInstance,
		hWnd,
		pConstantBufferFinance,
		ppResourceObjectCollection,
		&pFinancialSpaceCS,
		&pCurrencyMetalConstantBuffer,
		&pMetalInputBuffer,
		&pCurrencySpaceOutputBuffer,
		&pCurrencyInputSRV,
		&pFinancialSpaceOutputUAV,
		&pFinancialSpaceReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunActiVControlModule(hInstance, hWnd,
		pFinancialSpaceCS,
		pCurrencyMetalConstantBuffer,
		pCurrencyInputSRV,
		pFinancialSpaceOutputUAV,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pFinancialSpaceReadbackBuffer, pCurrencySpaceOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinancialSpaceReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		ObjectClassOutActiv* p = (ObjectClassOutActiv*)MappedResource.pData;
		for (int i = 0; i < ppResourceObjectCollection.size(); ++i)
		{
			pOutputResourceObjectCollection.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\AxtiManagementCS.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		
		for (ObjectClassOutActiv pResourceObject : pOutputResourceObjectCollection)
		{
			cout << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
			cout << "Time: " << pResourceObject.pTimeValue << endl;
			cout << "X0: " << pResourceObject.pXOne << endl;
			cout << "X1: " << pResourceObject.pXTwo << endl;
			cout << "A0: " << pResourceObject.pAOne << endl;
			cout << "A1: " << pResourceObject.pATwo << endl;
			cout << "Regulatory Function Value: " << pResourceObject.pRegulatoryFunctionValue << endl;
			cout << "Main Equation Result: " << pResourceObject.pMainEquationResult << endl;
			cout << "Minimization Result: " << pResourceObject.pMinimizationResult << endl;

			imageSegmentationDataFile << "Resource Kind: " << pResourceObject.pObjectKindId << endl;
			imageSegmentationDataFile << "Time: " << pResourceObject.pTimeValue << endl;
			imageSegmentationDataFile << "X0: " << pResourceObject.pXOne << endl;
			imageSegmentationDataFile << "X1: " << pResourceObject.pXTwo << endl;
			imageSegmentationDataFile << "A0: " << pResourceObject.pAOne << endl;
			imageSegmentationDataFile << "A1: " << pResourceObject.pATwo << endl;
			imageSegmentationDataFile << "Regulatory Function Value: " << pResourceObject.pRegulatoryFunctionValue << endl;
			imageSegmentationDataFile << "Main Equation Result: " << pResourceObject.pMainEquationResult << endl;
			imageSegmentationDataFile << "Minimization Result: " << pResourceObject.pMinimizationResult << endl;

		}

		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOutputResourceObject = pOutputResourceObjectCollection;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeActivControlModule(HINSTANCE hInstance,
	HWND hWnd,
	cbConstantBufferAxctivManagement pFinancialSpaceCB,
	vector<ObjectClassInActiv> ppResourceObjectCollection,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppFinancialSpaceConstantBuffer,
	ID3D11Buffer** ppFinancialSpaceInputBuffer,
	ID3D11Buffer** ppFinancialSpaceOutputBuffer,
	ID3D11ShaderResourceView** ppShaderResourceViewObject,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ActiveControlSetup.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferCurrency0 = nullptr;
	ID3D11Buffer* pInputBufferCurrency1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVCurrencyO = nullptr;
	ID3D11ShaderResourceView*  pInputSRVCurrency1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ActiveManagementCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbConstantBufferAxctivManagement) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(cbConstantBufferAxctivManagement);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pFinancialSpaceCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Object Class in" << endl;
	imageMaskLog << "Creating the Input Buffer For Object Class in" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppResourceObjectCollection.size() * sizeof(ObjectClassInActiv) / 16 * 17;
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(ObjectClassInActiv) / 16 * 17;
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataMetals;
	pDataMetals.pSysMem = &ppResourceObjectCollection[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pDataMetals, &pInputBufferCurrency0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}







	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppResourceObjectCollection.size() * sizeof(ObjectClassOutActiv);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(ObjectClassOutActiv);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_metals;
	ZeroMemory(&srvbuffer_desc_metals, sizeof(srvbuffer_desc_metals));
	srvbuffer_desc_metals.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_metals.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_metals.Buffer.ElementWidth = ppResourceObjectCollection.size();
	srvbuffer_desc_metals.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency0, &srvbuffer_desc_metals, &pInputSRVCurrencyO);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppResourceObjectCollection.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppResourceObjectCollection.size() * sizeof(ObjectClassOutActiv);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(ObjectClassOutActiv);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppFinancialSpaceConstantBuffer = pConstantBuffer;
	*ppFinancialSpaceInputBuffer = pInputBufferCurrency0;
	*ppFinancialSpaceOutputBuffer = pOutputBuffer;
	*ppShaderResourceViewObject = pInputSRVCurrencyO;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunActiVControlModule(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* ppComputeShaderFinance,
	ID3D11Buffer* ppConstantBufferFinance,
	ID3D11ShaderResourceView* ppShaderResourceView,
	ID3D11UnorderedAccessView* ppUnorderedAcessView,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(ppComputeShaderFinance, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppShaderResourceView };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedAccessView };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &ppConstantBufferFinance);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &ppUnorderedAcessView, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateUPWardFinancialTrendValue(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAverageValue,
	UINT pXValue,
	vector<ResourceObject> ppResourceObjectCollection,
	vector<OutputResourceObject> *pOutputResourceObject)
{
	HRESULT hr = S_OK;

	cout << "This Function Simulates the Upward Financial Trends" << endl;

	cout << "Printing Initial Resource" << endl;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\FinancialSpaceUnit.txt", fstream::in | fstream::out | fstream::trunc);
	vector<OutputResourceObject>  pOutputResourceObjectCollection = vector<OutputResourceObject>();

	FinancialSpaceCB pConstantBufferFinance;
	pConstantBufferFinance.pAverageValue = pAverageValue;
	pConstantBufferFinance.pXValue = pXValue;

	for (ResourceObject pResourceObject : ppResourceObjectCollection)
	{
		cout << "Resource id: " << pResourceObject.pResourceId << endl;
		cout << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		cout << "Common Potential: " << pResourceObject.pCommonPotential << endl;
		cout << "Disposal Coefficient: " << pResourceObject.pDisposalCoefficient << endl;
		cout << "Mass Of Kind Value: " << pResourceObject.pMassOfKindValue << endl;
		cout << "Mass Introductory Value: " << pResourceObject.pMassIntroductoryValue << endl;
		cout << "Previous Potential Value: " << pResourceObject.pPreviousPotentialValue << endl;
		cout << "Medium Growth Level: " << pResourceObject.pMediumGrowthLevel << endl;
		cout << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;

		imageSegmentationDataFile << "Resource id: " << pResourceObject.pResourceId << endl;
		imageSegmentationDataFile << "Growth Coefficient: " << pResourceObject.pGrowthCoefficient << endl;
		imageSegmentationDataFile << "Common Potential: " << pResourceObject.pCommonPotential << endl;
		imageSegmentationDataFile << "Disposal Coefficient: " << pResourceObject.pDisposalCoefficient << endl;
		imageSegmentationDataFile << "Mass Of Kind Value: " << pResourceObject.pMassOfKindValue << endl;
		imageSegmentationDataFile << "Mass Introductory Value: " << pResourceObject.pMassIntroductoryValue << endl;
		imageSegmentationDataFile << "Previous Potential Value: " << pResourceObject.pPreviousPotentialValue << endl;
		imageSegmentationDataFile << "Medium Growth Level: " << pResourceObject.pMediumGrowthLevel << endl;
		imageSegmentationDataFile << "Activity Coefficient: " << pResourceObject.pActivityCoefficient << endl;

	}

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;

	ID3D11ComputeShader* pFinancialSpaceCS = nullptr;
	ID3D11Buffer* pCurrencyMetalConstantBuffer = nullptr;
	ID3D11Buffer* pMetalInputBuffer = nullptr;
	ID3D11Buffer* pCurrencySpaceOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pCurrencyInputSRV = nullptr;
	ID3D11UnorderedAccessView* pFinancialSpaceOutputUAV = nullptr;
	ID3D11Buffer* pFinancialSpaceReadbackBuffer = nullptr;

	cout << "Initializing Our Resources" << endl;

	hr = InitializeUpwardFinancialTrensResources(hInstance,
		hWnd, pConstantBufferFinance,
		ppResourceObjectCollection,
		&pFinancialSpaceCS,
		&pCurrencyMetalConstantBuffer,
		&pMetalInputBuffer,
		&pCurrencySpaceOutputBuffer,
		&pCurrencyInputSRV,
		&pFinancialSpaceOutputUAV,
		&pFinancialSpaceReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunFinancialSpaceUnitSimulation(hInstance, hWnd,
		pFinancialSpaceCS,
		pCurrencyMetalConstantBuffer,
		pCurrencyInputSRV,
		pFinancialSpaceOutputUAV,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pFinancialSpaceReadbackBuffer, pCurrencySpaceOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinancialSpaceReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputResourceObject* p = (OutputResourceObject*)MappedResource.pData;
		for (int i = 0; i < ppResourceObjectCollection.size(); ++i)
		{
			pOutputResourceObjectCollection.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputResourceObject pOutputObject : pOutputResourceObjectCollection)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Activitiy Coefficient: " << pOutputObject.pActivityCoefficient << endl;
			cout << "Resource iD" << pOutputObject.pResourceId << endl;
			cout << "Resource Value" << pOutputObject.pResourceValueParameter << endl;
			cout << "Mass Of Kind Value: " << pOutputObject.pMassOfKindValue << endl;
			cout << "Medium Growth Level: " << pOutputObject.pMediumGrowthLevel << endl;
			cout << "Output Value: " << pOutputObject.pOutputValue << endl;
			cout << "Quality Coefficient" << pOutputObject.pQualityCoefficient << endl;
			cout << "Regulation Parameter" << pOutputObject.pRegulationParameter << endl;
			cout << "Resource Value Parameter " << pOutputObject.pResourceValueParameter << endl;

			imageSegmentationDataFile << "Index = " << iIndex << endl;
			imageSegmentationDataFile << "Activitiy Coefficient: " << pOutputObject.pActivityCoefficient << endl;
			imageSegmentationDataFile << "Resource iD" << pOutputObject.pResourceId << endl;
			imageSegmentationDataFile << "Resource Value" << pOutputObject.pResourceValueParameter << endl;
			imageSegmentationDataFile << "Mass Of Kind Value: " << pOutputObject.pMassOfKindValue << endl;
			imageSegmentationDataFile << "Medium Growth Level: " << pOutputObject.pMediumGrowthLevel << endl;
			imageSegmentationDataFile << "Output Value: " << pOutputObject.pOutputValue << endl;
			imageSegmentationDataFile << "Quality Coefficient" << pOutputObject.pQualityCoefficient << endl;
			imageSegmentationDataFile << "Regulation Parameter" << pOutputObject.pRegulationParameter << endl;
			imageSegmentationDataFile << "Resource Value Parameter " << pOutputObject.pResourceValueParameter << endl;

			iIndex++;
		}

		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOutputResourceObject = pOutputResourceObjectCollection;
	return hr;

}




HRESULT DirectXStandardAlgorithmExecutor::SimulateFinancialSpaceModule(HINSTANCE hInstance,
	HWND hWnd,
	vector<InputSalesUnit> ppResourceObjectCollection,
	vector<OutputSalesUnit> *pOutputResourceObject)
{
	HRESULT hr = S_OK;

	cout << "This Function Simulates the Upward Financial Trends" << endl;

	cout << "Printing Initial Resource" << endl;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\FinancialSpaceUnit.txt", fstream::in | fstream::out | fstream::trunc);
	vector<OutputSalesUnit>  pOutputResourceObjectCollection = vector<OutputSalesUnit>();

	

	for (InputSalesUnit pResourceObject : ppResourceObjectCollection)
	{
		cout << "Resource id: " << pResourceObject.pResourceId << endl;
		cout << "Initial Volume: " << pResourceObject.pInitialVolume << endl;
		cout << "Resource Mass: " << pResourceObject.pResourceMass << endl;
		cout << "Current Time Value: " << pResourceObject.pTimeValue << endl;

		imageSegmentationDataFile << "Resource id: " << pResourceObject.pResourceId << endl;
		imageSegmentationDataFile << "Initial Volume: " << pResourceObject.pInitialVolume << endl;
		imageSegmentationDataFile << "Resource Mass: " << pResourceObject.pResourceMass << endl;
		imageSegmentationDataFile << "Current Time Value: " << pResourceObject.pTimeValue << endl;


	}

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;

	ID3D11ComputeShader* pFinancialSpaceCS = nullptr;
	ID3D11Buffer* pCurrencyMetalConstantBuffer = nullptr;
	ID3D11Buffer* pMetalInputBuffer = nullptr;
	ID3D11Buffer* pCurrencySpaceOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pCurrencyInputSRV = nullptr;
	ID3D11UnorderedAccessView* pFinancialSpaceOutputUAV = nullptr;
	ID3D11Buffer* pFinancialSpaceReadbackBuffer = nullptr;

	cout << "Initializing Our Resources" << endl;

	hr = InitializeFinacialSpaceSystem(hInstance,
		hWnd,
		ppResourceObjectCollection,
		&pFinancialSpaceCS,
		&pMetalInputBuffer,
		&pCurrencySpaceOutputBuffer,
		&pCurrencyInputSRV,
		&pFinancialSpaceOutputUAV,
		&pFinancialSpaceReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunFinancialSpaceSystem(hInstance, hWnd,
		pFinancialSpaceCS,
		pCurrencyInputSRV,
		pFinancialSpaceOutputUAV,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pFinancialSpaceReadbackBuffer, pCurrencySpaceOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinancialSpaceReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputSalesUnit* p = (OutputSalesUnit*)MappedResource.pData;
		for (int i = 0; i < ppResourceObjectCollection.size(); ++i)
		{
			pOutputResourceObjectCollection.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputSalesUnit pOutputObject : pOutputResourceObjectCollection)
		{
			cout << "Resource Id:  " << pOutputObject.pResourceId << endl;
			cout << "Time: " << pOutputObject.pTimeValue << endl;
			cout << "Current Volume: of Sales: " << pOutputObject.pCurrentVolumeOfSales << endl;
			cout << "Unit of Sales: " << pOutputObject.pScaleUnitValue << endl;
			cout << "Moment of Growth: " << pOutputObject.pMomentOfGrowth << endl;
			cout << "Weight of Growth: " << pOutputObject.pWeightGrowthMoment << endl;
			cout << "Volume of Acceleration: " << pOutputObject.pAccelerationVolume << endl;
			cout << "Fluctuation of Resource: " << pOutputObject.pFluctuationOfResource << endl;
			cout << "Sum of Fluctuations " << pOutputObject.pSumOfFluctuations << endl;

			myfile << "Resource Id:  " << pOutputObject.pResourceId << endl;
			myfile << "Time: " << pOutputObject.pTimeValue << endl;
			myfile << "Current Volume: of Sales: " << pOutputObject.pCurrentVolumeOfSales << endl;
			myfile << "Unit of Sales: " << pOutputObject.pScaleUnitValue << endl;
			myfile << "Moment of Growth: " << pOutputObject.pMomentOfGrowth << endl;
			myfile << "Weight of Growth: " << pOutputObject.pWeightGrowthMoment << endl;
			myfile << "Volume of Acceleration: " << pOutputObject.pAccelerationVolume << endl;
			myfile << "Fluctuation of Resource: " << pOutputObject.pFluctuationOfResource << endl;
			myfile << "Sum of Fluctuations " << pOutputObject.pSumOfFluctuations << endl;

			iIndex++;
		}

		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOutputResourceObject = pOutputResourceObjectCollection;
	return hr;

}

HRESULT DirectXStandardAlgorithmExecutor::InitializeFinacialSpaceSystem(HINSTANCE hInstance,
	HWND hWnd,
	vector<InputSalesUnit> ppResourceObjectCollection,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppFinancialSpaceInputBuffer,
	ID3D11Buffer** ppFinancialSpaceOutputBuffer,
	ID3D11ShaderResourceView** ppShaderResourceViewObject,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\CurrencyRelationship.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBufferCurrency0 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVCurrencyO = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSModelOfFinancialSpaceMain.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppResourceObjectCollection.size() * sizeof(InputSalesUnit);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(InputSalesUnit);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataMetals;
	pDataMetals.pSysMem = &ppResourceObjectCollection[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pDataMetals, &pInputBufferCurrency0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}







	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppResourceObjectCollection.size() * sizeof(OutputSalesUnit);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputSalesUnit);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_metals;
	ZeroMemory(&srvbuffer_desc_metals, sizeof(srvbuffer_desc_metals));
	srvbuffer_desc_metals.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_metals.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_metals.Buffer.ElementWidth = ppResourceObjectCollection.size();
	srvbuffer_desc_metals.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency0, &srvbuffer_desc_metals, &pInputSRVCurrencyO);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppResourceObjectCollection.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppResourceObjectCollection.size() * sizeof(OutputSalesUnit);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputSalesUnit);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppFinancialSpaceInputBuffer = pInputBufferCurrency0;
	*ppFinancialSpaceOutputBuffer = pOutputBuffer;
	*ppShaderResourceViewObject = pInputSRVCurrencyO;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunFinancialSpaceSystem(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* ppComputeShaderFinance,
	ID3D11ShaderResourceView* ppShaderResourceView,
	ID3D11UnorderedAccessView* ppUnorderedAcessView,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(ppComputeShaderFinance, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppShaderResourceView };
	ID3D11UnorderedAccessView* ppUAV[] = { ppUnorderedAcessView };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::InitializeUpwardFinancialTrensResources(HINSTANCE hInstance,
	HWND hWnd,
	FinancialSpaceCB pFinancialSpaceCB,
	vector<ResourceObject> ppResourceObjectCollection,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppFinancialSpaceConstantBuffer,
	ID3D11Buffer** ppFinancialSpaceInputBuffer,
	ID3D11Buffer** ppFinancialSpaceOutputBuffer,
	ID3D11ShaderResourceView** ppShaderResourceViewObject,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\CurrencyRelationship.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferCurrency0 = nullptr;
	ID3D11Buffer* pInputBufferCurrency1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVCurrencyO = nullptr;
	ID3D11ShaderResourceView*  pInputSRVCurrency1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\UpwardFinancialTrendCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(FinancialSpaceCB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(FinancialSpaceCB);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pFinancialSpaceCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppResourceObjectCollection.size() * sizeof(ResourceObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(CurrencyObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataMetals;
	pDataMetals.pSysMem = &ppResourceObjectCollection[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pDataMetals, &pInputBufferCurrency0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}







	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppResourceObjectCollection.size() * sizeof(OutputResourceObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputResourceObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_metals;
	ZeroMemory(&srvbuffer_desc_metals, sizeof(srvbuffer_desc_metals));
	srvbuffer_desc_metals.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_metals.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_metals.Buffer.ElementWidth = ppResourceObjectCollection.size();
	srvbuffer_desc_metals.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency0, &srvbuffer_desc_metals, &pInputSRVCurrencyO);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppResourceObjectCollection.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppResourceObjectCollection.size() * sizeof(OutputResourceObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputResourceObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppFinancialSpaceConstantBuffer = pConstantBuffer;
	*ppFinancialSpaceInputBuffer = pInputBufferCurrency0;
	*ppFinancialSpaceOutputBuffer = pOutputBuffer;
	*ppShaderResourceViewObject = pInputSRVCurrencyO;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunFinancialSpaceUnitSimulation(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* ppComputeShaderFinance,
	ID3D11Buffer* ppConstantBufferFinance,
	ID3D11ShaderResourceView* ppShaderResourceView,
	ID3D11UnorderedAccessView* ppUnorderedAcessView,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(ppComputeShaderFinance, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppShaderResourceView };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedAccessView };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &ppConstantBufferFinance);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::SimulateCurrencyCurrencyRelationships(HINSTANCE hInstance,
	HWND hWnd,
	UINT pCurrencyId,
	UINT pMetalId,
	float pAmountOfInvestment,
	DateDataType pCurrentDate,
	vector<CurrencyObject> ppCurrencyObjectCollection0,
	vector<CurrencyObject> ppCurrencyObjectCollection1,
	vector<CurrencyCurrencyPairObject> *pOutputResourceObject)
{

	HRESULT hr = S_OK;
	cout << "This Function Will Simulate The Currency Relationship" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Эта Функция Моделирует Поведение Нисходящего финансового пространстрва", (LPCSTR)"Message", 0);

	vector<CurrencyCurrencyPairObject> pResourceOutputCollection = vector<CurrencyCurrencyPairObject>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\finance\\MetalCurrencyOutput.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	cout << "First we Will Print Out Our Parameter Objects" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Для начала мы выведем и сохраним контрольные значения", (LPCSTR)"Message", 0);

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;


	cout << "Printing Precious Metal Objects" << endl;
	imageSegmentationDataFile << "Printing Precious Metal Objects" << endl;



	for (CurrencyObject pCurrencyObject0 : ppCurrencyObjectCollection0)
	{
		cout << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		cout << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		cout << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		cout << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		cout << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		cout << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		cout << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		cout << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		cout << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		cout << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		cout << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		imageSegmentationDataFile << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;
	}

	cout << "Printing Currency Objects" << endl;
	imageSegmentationDataFile << "Printing Currency Objects" << endl;


	for (CurrencyObject pCurrencyObject1 : ppCurrencyObjectCollection1)
	{
		cout << "Currency id = " << pCurrencyObject1.pCurrencyIdValue << endl;
		cout << "Record Time Second = " << pCurrencyObject1.pSecond << endl;
		cout << "Record Time Minute = " << pCurrencyObject1.pMinute << endl;
		cout << "Record Time Hour = " << pCurrencyObject1.pHour << endl;
		cout << "Record Time Day = " << pCurrencyObject1.pDay << endl;
		cout << "Record Time Month = " << pCurrencyObject1.pMonth << endl;
		cout << "Record Time Year = " << pCurrencyObject1.pYear << endl;
		cout << "Currency Price Open Value = " << pCurrencyObject1.pCurrencyPriceOpenValue << endl;
		cout << "Currency Price High Value = " << pCurrencyObject1.pCurrencyPriceHighValue << endl;
		cout << "Currency Price Low Value = " << pCurrencyObject1.pCurrencyPriceLowValue << endl;
		cout << "Currency Price Close Value = " << pCurrencyObject1.pCurrencyPriceCloseValue << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject1.pCurrencyIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pCurrencyObject1.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pCurrencyObject1.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pCurrencyObject1.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pCurrencyObject1.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pCurrencyObject1.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pCurrencyObject1.pYear << endl;
		imageSegmentationDataFile << "Currency Price Open Value = " << pCurrencyObject1.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High Value = " << pCurrencyObject1.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low Value = " << pCurrencyObject1.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close Value = " << pCurrencyObject1.pCurrencyPriceCloseValue << endl;
	}




	cout << "Creating the Resource Objects" << endl;

	ID3D11ComputeShader* pFinancialSpaceCS = nullptr;
	ID3D11Buffer* pCurrencyMetalConstantBuffer = nullptr;
	ID3D11Buffer* pMetalInputBuffer = nullptr;
	ID3D11Buffer* pCurrencyInputBuffer = nullptr;
	ID3D11Buffer* pCurrencySpaceOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pCurrencyInputSRV = nullptr;
	ID3D11ShaderResourceView* pMetalInputSRV = nullptr;
	ID3D11UnorderedAccessView* pFinancialSpaceOutputUAV = nullptr;
	ID3D11Buffer* pFinancialSpaceReadbackBuffer = nullptr;

	cbCurrencyCurrencyBuffer pFinancialSpaceBufferConst;
	pFinancialSpaceBufferConst.pCurrencyId1 = pCurrencyId;
	pFinancialSpaceBufferConst.pCurrencyId2 = pMetalId;
	pFinancialSpaceBufferConst.pSelectedDateValue = pCurrentDate;
	pFinancialSpaceBufferConst.pAmountOfInvestment = pAmountOfInvestment;

	hr = InitializeCurrencyCurrencyRelationshipResources(hInstance,
		hWnd,
		pFinancialSpaceBufferConst,
		ppCurrencyObjectCollection0,
		ppCurrencyObjectCollection1,
		&pFinancialSpaceCS,
		&pCurrencyMetalConstantBuffer,
		&pMetalInputBuffer,
		&pCurrencyInputBuffer,
		&pCurrencySpaceOutputBuffer,
		&pCurrencyInputSRV,
		&pMetalInputSRV,
		&pFinancialSpaceOutputUAV,
		&pFinancialSpaceReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunCurrencyCurrencyRelationship(hInstance, hWnd,
		pCurrencyMetalConstantBuffer,
		pFinancialSpaceCS,
		pCurrencyInputSRV,
		pMetalInputSRV,
		pFinancialSpaceOutputUAV,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pFinancialSpaceReadbackBuffer, pCurrencySpaceOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinancialSpaceReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		CurrencyCurrencyPairObject* p = (CurrencyCurrencyPairObject*)MappedResource.pData;
		for (int i = 0; i < ppCurrencyObjectCollection0.size(); ++i)
		{
			pResourceOutputCollection.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (CurrencyCurrencyPairObject pOutputObject : pResourceOutputCollection)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Year: " << pOutputObject.pYear << endl;
			cout << "Month: " << pOutputObject.pMonth << endl;
			cout << "Day: " << pOutputObject.pHour << endl;
			cout << "Hour: " << pOutputObject.pMinute << endl;
			cout << "Minute: " << pOutputObject.pSecond << endl;
			cout << "Currency id " << pOutputObject.pCurrencyId0 << endl;
			cout << "Currency id " << pOutputObject.pCurrencyId1 << endl;
			cout << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue0 << endl;
			cout << "Currency Price Open 2: " << pOutputObject.pCurrencyPriceOpenValue1 << endl;
			cout << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue0 << endl;
			cout << "Currency Price High 2: " << pOutputObject.pCurrencyPriceHighValue1 << endl;
			cout << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue0 << endl;
			cout << "Currency Price Low 2: " << pOutputObject.pCurrencyPriceLowValue1 << endl;
			cout << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue0 << endl;
			cout << "Currency Price Close 2: " << pOutputObject.pCurrencyPriceCloseValue1 << endl;
			cout << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
			cout << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
			cout << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
			cout << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;
			cout << "Potential Profit Open: " << pOutputObject.pPotentialProfitOpen << endl;
			cout << "Potential Profit High: " << pOutputObject.pPotentialProfitHigh << endl;
			cout << "Potential Profit Low: " << pOutputObject.pPotentialProfitLow << endl;
			cout << "Potential Profit Close: " << pOutputObject.pPotentialProfitClose << endl;







			myfile << "Index = " << iIndex << endl;
			myfile << "Year: " << pOutputObject.pYear << endl;
			myfile << "Month: " << pOutputObject.pMonth << endl;
			myfile << "Day: " << pOutputObject.pHour << endl;
			myfile << "Hour: " << pOutputObject.pMinute << endl;
			myfile << "Minute: " << pOutputObject.pSecond << endl;
			myfile << "Currency id " << pOutputObject.pCurrencyId0 << endl;
			myfile << "Currency id " << pOutputObject.pCurrencyId1 << endl;
			myfile << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue0 << endl;
			myfile << "Currency Price Open 2: " << pOutputObject.pCurrencyPriceOpenValue1 << endl;
			myfile << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue0 << endl;
			myfile << "Currency Price High 2: " << pOutputObject.pCurrencyPriceHighValue1 << endl;
			myfile << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue0 << endl;
			myfile << "Currency Price Low 2: " << pOutputObject.pCurrencyPriceLowValue1 << endl;
			myfile << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue0 << endl;
			myfile << "Currency Price Close 2: " << pOutputObject.pCurrencyPriceCloseValue1 << endl;
			myfile << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
			myfile << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
			myfile << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
			myfile << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;
			myfile << "Potential Profit Open: " << pOutputObject.pPotentialProfitOpen << endl;
			myfile << "Potential Profit High: " << pOutputObject.pPotentialProfitHigh << endl;
			myfile << "Potential Profit Low: " << pOutputObject.pPotentialProfitLow << endl;
			myfile << "Potential Profit Close: " << pOutputObject.pPotentialProfitClose << endl;




		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOutputResourceObject = pResourceOutputCollection;
	return hr;



}



HRESULT DirectXStandardAlgorithmExecutor::InitializeCurrencyCurrencyRelationshipResources(HINSTANCE hInstance,
	HWND hWnd,
	cbCurrencyCurrencyBuffer pFinancialSpaceBufferConst,
	vector<CurrencyObject> ppCurrencyObjectCollection0,
	vector<CurrencyObject> ppCurrencyObjectCollection1,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppFinancialSpaceConstantBuffer,
	ID3D11Buffer** ppCurrencyBuffer0,
	ID3D11Buffer** ppCurrencyBuffer1,
	ID3D11Buffer** ppFinancialSpaceOutputBuffer,
	ID3D11ShaderResourceView** ppCurrencyShaderResource0,
	ID3D11ShaderResourceView** ppCurrencyShaderResource1,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\CurrencyRelationship.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferCurrency0 = nullptr;
	ID3D11Buffer* pInputBufferCurrency1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVCurrencyO = nullptr;
	ID3D11ShaderResourceView*  pInputSRVCurrency1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CurrencyCurrencyCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCurrencyCurrencyBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(cbCurrencyCurrencyBuffer);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pFinancialSpaceBufferConst;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(CurrencyObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataCurrency0;
	pDataCurrency0.pSysMem = &ppCurrencyObjectCollection0[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pDataCurrency0, &pInputBufferCurrency0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = ppCurrencyObjectCollection1.size() * sizeof(CurrencyObject);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(CurrencyObject);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataCurrency1;
	pDataCurrency1.pSysMem = &ppCurrencyObjectCollection1[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pDataCurrency1, &pInputBufferCurrency1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}






	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyCurrencyPairObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(CurrencyCurrencyPairObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_metals;
	ZeroMemory(&srvbuffer_desc_metals, sizeof(srvbuffer_desc_metals));
	srvbuffer_desc_metals.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_metals.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_metals.Buffer.ElementWidth = ppCurrencyObjectCollection0.size();
	srvbuffer_desc_metals.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency0, &srvbuffer_desc_metals, &pInputSRVCurrencyO);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_currencies;
	ZeroMemory(&srvbuffer_desc_currencies, sizeof(srvbuffer_desc_currencies));
	srvbuffer_desc_currencies.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_currencies.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_currencies.Buffer.ElementWidth = ppCurrencyObjectCollection1.size();
	srvbuffer_desc_currencies.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency1, &srvbuffer_desc_currencies, &pInputSRVCurrency1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppCurrencyObjectCollection0.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyCurrencyPairObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(CurrencyCurrencyPairObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppFinancialSpaceConstantBuffer = pConstantBuffer;
	*ppCurrencyBuffer0 = pInputBufferCurrency0;
	*ppCurrencyBuffer1 = pInputBufferCurrency1;
	*ppFinancialSpaceOutputBuffer = pOutputBuffer;
	*ppCurrencyShaderResource0 = pInputSRVCurrencyO;
	*ppCurrencyShaderResource1 = pInputSRVCurrency1;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunCurrencyCurrencyRelationship(HINSTANCE hInstance,
	HWND hWnd, ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* pConstantBuffers[] = { nullptr };
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, nullptr, nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, pConstantBuffers);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateMetalCurrencyRelationships(HINSTANCE hInstance, HWND hWnd,
	UINT pCurrencyId,
	UINT pMetalId,
	DateDataType pDateDataType,
	UINT pAverageValue, UINT pXValue, vector<MetalObject> pMetalCollectionObject, vector<CurrencyObject> pCurrencyCollection, vector<CurrencyMetalPairObject> *pOutputResourceObject)
{

	HRESULT hr = S_OK;
	cout << "This Function Will Simulate The Currency Relationship" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Эта Функция Моделирует Поведение Нисходящего финансового пространстрва", (LPCSTR)"Message", 0);

	vector<CurrencyMetalPairObject> pResourceOutputCollection = vector<CurrencyMetalPairObject>();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\finance\\MetalCurrencyOutput.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	cout << "First we Will Print Out Our Parameter Objects" << endl;
	MessageBoxA(hWnd, (LPCSTR)"Для начала мы выведем и сохраним контрольные значения", (LPCSTR)"Message", 0);

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageSegmentationDataFile << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageSegmentationDataFile << "For this Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Input Buffer Of Pixels" << endl;
	imageSegmentationDataFile << "1 Output Buffer for Pixel Output" << endl;
	imageSegmentationDataFile << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageSegmentationDataFile << "1 Readback Data Buffer" << endl;


	cout << "Printing Precious Metal Objects" << endl;
	imageSegmentationDataFile << "Printing Precious Metal Objects" << endl;


	for (MetalObject pMetalObject0 : pMetalCollectionObject)
	{
		cout << "Metal id = " << pMetalObject0.pMetalIdValue << endl;
		cout << "Record Time Second = " << pMetalObject0.pSecond << endl;
		cout << "Record Time Minute = " << pMetalObject0.pMinute << endl;
		cout << "Record Time Hour = " << pMetalObject0.pHour << endl;
		cout << "Record Time Day = " << pMetalObject0.pDay << endl;
		cout << "Record Time Month = " << pMetalObject0.pMonth << endl;
		cout << "Record Time Year = " << pMetalObject0.pYear << endl;
		cout << "Metal Price Open Value = " << pMetalObject0.pMetalPriceOpenValue << endl;
		cout << "Metal Price High Value = " << pMetalObject0.pMetalPriceHighValue << endl;
		cout << "Metal Price Low Value = " << pMetalObject0.pMetalPriceLowValue << endl;
		cout << "Metal Price Close Value = " << pMetalObject0.pMetalPriceCloseValue << endl;

		imageSegmentationDataFile << "Metal id = " << pMetalObject0.pMetalIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pMetalObject0.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pMetalObject0.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pMetalObject0.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pMetalObject0.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pMetalObject0.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pMetalObject0.pYear << endl;
		imageSegmentationDataFile << "Metal Price Open Value = " << pMetalObject0.pMetalPriceOpenValue << endl;
		imageSegmentationDataFile << "Metal Price High Value = " << pMetalObject0.pMetalPriceHighValue << endl;
		imageSegmentationDataFile << "Metal Price Low Value = " << pMetalObject0.pMetalPriceLowValue << endl;
		imageSegmentationDataFile << "Metal Price Close Value = " << pMetalObject0.pMetalPriceCloseValue << endl;
	}

	cout << "Printing Currency Objects" << endl;
	imageSegmentationDataFile << "Printing Currency Objects" << endl;

	for (CurrencyObject pCurrencyObject0 : pCurrencyCollection)
	{
		cout << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		cout << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		cout << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		cout << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		cout << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		cout << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		cout << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		cout << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		cout << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		cout << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		cout << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;

		imageSegmentationDataFile << "Currency id = " << pCurrencyObject0.pCurrencyIdValue << endl;
		imageSegmentationDataFile << "Record Time Second = " << pCurrencyObject0.pSecond << endl;
		imageSegmentationDataFile << "Record Time Minute = " << pCurrencyObject0.pMinute << endl;
		imageSegmentationDataFile << "Record Time Hour = " << pCurrencyObject0.pHour << endl;
		imageSegmentationDataFile << "Record Time Day = " << pCurrencyObject0.pDay << endl;
		imageSegmentationDataFile << "Record Time Month = " << pCurrencyObject0.pMonth << endl;
		imageSegmentationDataFile << "Record Time Year = " << pCurrencyObject0.pYear << endl;
		imageSegmentationDataFile << "Currency Price Open Value = " << pCurrencyObject0.pCurrencyPriceOpenValue << endl;
		imageSegmentationDataFile << "Currency Price High Value = " << pCurrencyObject0.pCurrencyPriceHighValue << endl;
		imageSegmentationDataFile << "Currency Price Low Value = " << pCurrencyObject0.pCurrencyPriceLowValue << endl;
		imageSegmentationDataFile << "Currency Price Close Value = " << pCurrencyObject0.pCurrencyPriceCloseValue << endl;
	}






	cout << "Creating the Resource Objects" << endl;

	ID3D11ComputeShader* pFinancialSpaceCS = nullptr;
	ID3D11Buffer* pCurrencyMetalConstantBuffer = nullptr;
	ID3D11Buffer* pMetalInputBuffer = nullptr;
	ID3D11Buffer* pCurrencyInputBuffer = nullptr;
	ID3D11Buffer* pCurrencySpaceOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pCurrencyInputSRV = nullptr;
	ID3D11ShaderResourceView* pMetalInputSRV = nullptr;
	ID3D11UnorderedAccessView* pFinancialSpaceOutputUAV = nullptr;
	ID3D11Buffer* pFinancialSpaceReadbackBuffer = nullptr;

	cbCurrencyMetalBuffer pFinancialSpaceBufferConst;
	pFinancialSpaceBufferConst.pSelectedCurrencyId = pCurrencyId;
	pFinancialSpaceBufferConst.pSelectedMetalId = pMetalId;
	pFinancialSpaceBufferConst.pSelectedDateValue = pDateDataType;

	hr = InitializeMetalCurrencyRelationshipResources(hInstance,
		hWnd,
		pFinancialSpaceBufferConst,
		pCurrencyCollection,
		pMetalCollectionObject,
		&pFinancialSpaceCS,
		&pCurrencyMetalConstantBuffer,
		&pMetalInputBuffer,
		&pCurrencyInputBuffer,
		&pCurrencySpaceOutputBuffer,
		&pCurrencyInputSRV,
		&pMetalInputSRV,
		&pFinancialSpaceOutputUAV,
		&pFinancialSpaceReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunMetalCurrencyRelationship(hInstance, hWnd,
		pCurrencyMetalConstantBuffer,
		pFinancialSpaceCS,
		pCurrencyInputSRV,
		pMetalInputSRV,
		pFinancialSpaceOutputUAV,
		1, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pFinancialSpaceReadbackBuffer, pCurrencySpaceOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinancialSpaceReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		CurrencyMetalPairObject* p = (CurrencyMetalPairObject*)MappedResource.pData;
		for (int i = 0; i < pCurrencyCollection.size(); ++i)
		{
			pResourceOutputCollection.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (CurrencyMetalPairObject pOutputObject : pResourceOutputCollection)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Year: " << pOutputObject.pYear << endl;
			cout << "Month: " << pOutputObject.pMonth << endl;
			cout << "Day: " << pOutputObject.pHour << endl;
			cout << "Hour: " << pOutputObject.pMinute << endl;
			cout << "Minute: " << pOutputObject.pSecond << endl;
			cout << "Currency id " << pOutputObject.pCurrencyId << endl;
			cout << "Currency id " << pOutputObject.pMetalId << endl;
			cout << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue << endl;
			cout << "Metal Price Open: " << pOutputObject.pMetalPriceOpenValue << endl;
			cout << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue << endl;
			cout << "Metal Price High: " << pOutputObject.pMetalPriceHighValue << endl;
			cout << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue << endl;
			cout << "Metal Price Low: " << pOutputObject.pMetalPriceLowValue << endl;
			cout << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue << endl;
			cout << "Metal Price Close " << pOutputObject.pMetalPriceCloseValue << endl;
			cout << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
			cout << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
			cout << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
			cout << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;





			myfile << "Index = " << iIndex << endl;
			myfile << "Year: " << pOutputObject.pYear << endl;
			myfile << "Month: " << pOutputObject.pMonth << endl;
			myfile << "Day: " << pOutputObject.pHour << endl;
			myfile << "Hour: " << pOutputObject.pMinute << endl;
			myfile << "Minute: " << pOutputObject.pSecond << endl;
			myfile << "Currency id " << pOutputObject.pCurrencyId << endl;
			myfile << "Currency id " << pOutputObject.pMetalId << endl;
			myfile << "Currency Price Open 1: " << pOutputObject.pCurrencyPriceOpenValue << endl;
			myfile << "Metal Price Open: " << pOutputObject.pMetalPriceOpenValue << endl;
			myfile << "Currency Price High 1: " << pOutputObject.pCurrencyPriceHighValue << endl;
			myfile << "Metal Price High: " << pOutputObject.pMetalPriceHighValue << endl;
			myfile << "Currency Price Low 1: " << pOutputObject.pCurrencyPriceLowValue << endl;
			myfile << "Metal Price Low: " << pOutputObject.pMetalPriceLowValue << endl;
			myfile << "Currency Price Close 1: " << pOutputObject.pCurrencyPriceCloseValue << endl;
			myfile << "Metal Price Close " << pOutputObject.pMetalPriceCloseValue << endl;
			myfile << "Ratio Open: " << pOutputObject.pRationInPercentageOpen << endl;
			myfile << "Ratio High: " << pOutputObject.pRationInPercentageHigh << endl;
			myfile << "Ratio Low: " << pOutputObject.pRationInPercentageLow << endl;
			myfile << "Ratio Close: " << pOutputObject.pRationInPercentageClose << endl;



		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOutputResourceObject = pResourceOutputCollection;
	return hr;



}



HRESULT DirectXStandardAlgorithmExecutor::InitializeMetalCurrencyRelationshipResources(HINSTANCE hInstance,
	HWND hWnd,
	cbCurrencyMetalBuffer pFinancialSpaceBufferConst,
	vector<CurrencyObject> ppCurrencyObjectCollection0,
	vector<MetalObject> ppCurrencyObjectCollection1,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppFinancialSpaceConstantBuffer,
	ID3D11Buffer** ppCurrencyBuffer0,
	ID3D11Buffer** ppCurrencyBuffer1,
	ID3D11Buffer** ppFinancialSpaceOutputBuffer,
	ID3D11ShaderResourceView** ppCurrencyShaderResource0,
	ID3D11ShaderResourceView** ppCurrencyShaderResource1,
	ID3D11UnorderedAccessView** ppUnorderedAccessViewObject,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\CurrencyRelationship.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferCurrency0 = nullptr;
	ID3D11Buffer* pInputBufferCurrency1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVCurrencyO = nullptr;
	ID3D11ShaderResourceView*  pInputSRVCurrency1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Вычислительное Ядро 2.1\\Вычислительное Ядро 4.0\\Вычислительное Ядро 2019\\Kernel Final\\AlgorithmObjects\\CurrencyMetalPairCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbCurrencyMetalBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(cbCurrencyMetalBuffer);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pFinancialSpaceBufferConst;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(CurrencyObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pDataMetals;
	pDataMetals.pSysMem = &ppCurrencyObjectCollection0[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pDataMetals, &pInputBufferCurrency0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = ppCurrencyObjectCollection1.size() * sizeof(MetalObject);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(MetalObject);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &ppCurrencyObjectCollection1[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData, &pInputBufferCurrency1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}






	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyMetalPairObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(CurrencyMetalPairObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_metals;
	ZeroMemory(&srvbuffer_desc_metals, sizeof(srvbuffer_desc_metals));
	srvbuffer_desc_metals.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_metals.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_metals.Buffer.ElementWidth = ppCurrencyObjectCollection0.size();
	srvbuffer_desc_metals.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency0, &srvbuffer_desc_metals, &pInputSRVCurrencyO);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_currencies;
	ZeroMemory(&srvbuffer_desc_currencies, sizeof(srvbuffer_desc_currencies));
	srvbuffer_desc_currencies.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_currencies.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_currencies.Buffer.ElementWidth = ppCurrencyObjectCollection1.size();
	srvbuffer_desc_currencies.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferCurrency1, &srvbuffer_desc_currencies, &pInputSRVCurrency1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppCurrencyObjectCollection0.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppCurrencyObjectCollection0.size() * sizeof(CurrencyMetalPairObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(CurrencyMetalPairObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppFinancialSpaceConstantBuffer = pConstantBuffer;
	*ppCurrencyBuffer0 = pInputBufferCurrency0;
	*ppCurrencyBuffer1 = pInputBufferCurrency1;
	*ppFinancialSpaceOutputBuffer = pOutputBuffer;
	*ppCurrencyShaderResource0 = pInputSRVCurrencyO;
	*ppCurrencyShaderResource1 = pInputSRVCurrency1;
	*ppUnorderedAccessViewObject = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunMetalCurrencyRelationship(HINSTANCE hInstance,
	HWND hWnd, ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, nullptr, nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateImageProcessingFiniteStateMachineStageTwo(HINSTANCE hInstance, HWND hWnd,
	cbImageProcessingFSMStageTwo pImageInstansityConstants,
	vector<OutputPixelObjectGrayScaleWithState> ppPixelObjectInputArrayOne,
	vector<OutputPixelObjectGrayScaleWithState> ppPixelObjectInputArrayTwo,
	vector<OutputPixelObjectGrayScaleWithStateChange> *ppPixelObjectOutputArray)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectGrayScaleWithStateChange> ppOutputPixelBuffer = vector<OutputPixelObjectGrayScaleWithStateChange>();
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\ImageProcessingSetupFSM.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "This Is the Function that Will Simulate Image Processing FSM" << endl;
	cout << "For This Simulation We will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "2 Input Buffer Object" << endl;
	cout << "1 Output Buffer Object" << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordereded Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	vector<OutputPixelObjectGrayScaleWithState> ppSecondArrayObject = vector<OutputPixelObjectGrayScaleWithState>();


	ID3D11ComputeShader* pComputeShaderFSMStageTwo = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObjectStageTwo = nullptr;
	ID3D11Buffer* pInputBufferCopyObjectStageTwo = nullptr;
	ID3D11Buffer* pOutputBufferObjectStageTwo = nullptr;
	ID3D11ShaderResourceView* pInputSRVObjectStageTwo = nullptr;
	ID3D11ShaderResourceView* pInputSRVObjectStageTwoCopy = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessViewStageTwo = nullptr;
	ID3D11Buffer* pReadBackBufferStageTwo = nullptr;



	cout << "Printing Array Number One" << endl;

	for (OutputPixelObjectGrayScaleWithState pPixelObject : ppPixelObjectInputArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		cout << "Level Of Darkness" << pPixelObject.pLevelOfDarkness << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		imageSegmentationDataFile << "Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
		ppSecondArrayObject.push_back(pPixelObject);
	}

	cout << "Printing Array Number One" << endl;
	for (OutputPixelObjectGrayScaleWithState pPixelObject : ppPixelObjectInputArrayTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		cout << "Level Of Darkness" << pPixelObject.pLevelOfDarkness << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
		imageSegmentationDataFile << "Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
		ppSecondArrayObject.push_back(pPixelObject);
	}
	cout << "Initializing The Resources For State Machine Processing Stage two" << endl;

	hr = InitializeImageProcessingFiniteStateMachineResourcesStageTwo(hInstance,
		hWnd,
		pImageInstansityConstants,
		ppPixelObjectInputArrayOne,
		ppPixelObjectInputArrayTwo,
		&pComputeShaderFSMStageTwo,
		&pConstantBuffer,
		&pInputBufferObjectStageTwo,
		&pInputBufferCopyObjectStageTwo,
		&pOutputBufferObjectStageTwo,
		&pInputSRVObjectStageTwo,
		&pInputSRVObjectStageTwoCopy,
		&pUnorderedAccessViewStageTwo,
		&pReadBackBufferStageTwo);


	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать ресурсы для вычислительного шейдера", (LPCSTR)"Message", 0);
		cout << "Unable to Complete the exit of Resources for finite state machine simulation" << endl;
		return hr;
	}

	cout << "Simulating the State Machine Object" << endl;


	hr = RunImageProcessingFSMStageTwo(hInstance, hWnd,
		pComputeShaderFSMStageTwo,
		pConstantBuffer,
		pInputSRVObjectStageTwo,
		pInputSRVObjectStageTwoCopy,
		pUnorderedAccessViewStageTwo,
		256, 1, 1);


	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBufferStageTwo, pOutputBufferObjectStageTwo);
		hr = m_pD3DCompContext->Map(pReadBackBufferStageTwo, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectGrayScaleWithStateChange* p = (OutputPixelObjectGrayScaleWithStateChange*)MappedResource.pData;
		for (int i = 0; i < ppPixelObjectInputArrayOne.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Grey Level: " << p[i].pGrayScaleValueOutput << endl;
			cout << "Previous Level Of Darkness: " << p[i].pPreviousLevelOfDarkness << endl;
			cout << "Current Level Of Darkness: " << p[i].pLevelOfDarkness << endl;
			cout << "Current State: " << p[i].pCurrentState << endl;
			cout << "Previous State: " << p[i].pPreviousState << endl;
			cout << "Did Pixel State Change Occured" << p[i].pDidStateChange << endl;

			imageSegmentationDataFile << "Pixel Number: " << p[i].pixelNumber;
			imageSegmentationDataFile << "X Position: " << p[i].xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << p[i].yPosition << endl;
			imageSegmentationDataFile << "Grey Level: " << p[i].pGrayScaleValueOutput << endl;
			imageSegmentationDataFile << "Previous Level Of Darkness: " << p[i].pPreviousLevelOfDarkness << endl;
			imageSegmentationDataFile << "Current Level Of Darkness: " << p[i].pLevelOfDarkness << endl;
			imageSegmentationDataFile << "Current State: " << p[i].pCurrentState << endl;
			imageSegmentationDataFile << "Previous State: " << p[i].pPreviousState << endl;
			imageSegmentationDataFile << "Did Pixel State Change Occured" << p[i].pDidStateChange << endl;

			ppOutputPixelBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelObjectGrayScaleWithStateChange pPixelObject : ppOutputPixelBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Grey Level: " << pPixelObject.pGrayScaleValueOutput << endl;
			cout << "Previous Level Of Darkness: " << pPixelObject.pPreviousLevelOfDarkness << endl;
			cout << "Current Level Of Darkness: " << pPixelObject.pLevelOfDarkness << endl;
			cout << "Current State: " << pPixelObject.pCurrentState << endl;
			cout << "Previous State: " << pPixelObject.pPreviousState << endl;
			cout << "Did State Changed: " << pPixelObject.pDidStateChange << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValueOutput << endl;
			imageSegmentationDataFile << "Previous Level Of Darkness: " << pPixelObject.pPreviousLevelOfDarkness << endl;
			imageSegmentationDataFile << "Current Level Of Darkness: " << pPixelObject.pLevelOfDarkness << endl;
			imageSegmentationDataFile << "Current State: " << pPixelObject.pCurrentState << endl;
			imageSegmentationDataFile << "Previous State: " << pPixelObject.pPreviousState << endl;
			imageSegmentationDataFile << "Did State Changed: " << pPixelObject.pDidStateChange << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageSegmentationDataFile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}
	printf("Cleaning up...\n");

	SafeReleaseA(&pComputeShaderFSMStageTwo);
	SafeReleaseA(&pInputBufferObjectStageTwo);
	SafeReleaseA(&pOutputBufferObjectStageTwo);
	SafeReleaseA(&pInputSRVObjectStageTwo);
	SafeReleaseA(&pInputSRVObjectStageTwoCopy);
	SafeReleaseA(&pUnorderedAccessViewStageTwo);
	SafeReleaseA(&pReadBackBufferStageTwo);

	imageSegmentationDataFile.close();
	*ppPixelObjectOutputArray = ppOutputPixelBuffer;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeImageProcessingFiniteStateMachineResourcesStageTwo(HINSTANCE hInstance,
	HWND hWnd,
	cbImageProcessingFSMStageTwo pConstantsArray,
	vector<OutputPixelObjectGrayScaleWithState> pInputArrayForStageOne,
	vector<OutputPixelObjectGrayScaleWithState> pInputArrayForStageTwo,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer0,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppInputSRV0,
	ID3D11ShaderResourceView** ppInputSRV1,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageImageStageTwo.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer0 = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ImageProcessingFiniteStateMachineSimulator.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_constant;
	ZeroMemory(&buffer_desc_constant, sizeof(buffer_desc_constant));
	buffer_desc_constant.ByteWidth = 16 * sizeof(cbImageProcessingFSMStageTwo);
	buffer_desc_constant.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	buffer_desc_constant.StructureByteStride = sizeof(cbImageProcessingFSMStageTwo);
	buffer_desc_constant.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pConstantsArray;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_constant, &pData, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc0;
	ZeroMemory(&buffer_desc0, sizeof(buffer_desc0));
	buffer_desc0.ByteWidth = pInputArrayForStageTwo.size() * sizeof(OutputPixelObjectGrayScaleWithState);
	buffer_desc0.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc0.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc0.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc0.StructureByteStride = sizeof(OutputPixelObjectGrayScaleWithState);
	buffer_desc0.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData0;
	pData0.pSysMem = &pInputArrayForStageOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc0, &pData0, &pInputBuffer0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputArrayForStageTwo.size() * sizeof(OutputPixelObjectGrayScaleWithState);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelObjectGrayScaleWithState);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pInputArrayForStageTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData1, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}





	cout << "Creating the Output Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Output Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputArrayForStageTwo.size() * sizeof(OutputPixelObjectGrayScaleWithStateChange);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectGrayScaleWithStateChange);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputArrayForStageTwo.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer0, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";


	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pInputArrayForStageTwo.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputArrayForStageTwo.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputArrayForStageTwo.size() * sizeof(OutputPixelObjectGrayScaleWithStateChange);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectGrayScaleWithStateChange);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	imageMaskLog.close();


	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer0 = pInputBuffer0;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV0 = pInputSRV1;
	*ppInputSRV1 = pInputSRV2;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::SimulateImageProcessingFiniteStateMachineIntensityPreparatorFunction(HINSTANCE hInstance, HWND hWnd,
	int pIdenticalPixelLabelValue,
	int pDifferentPixelLabelVaule,
	vector<PixelObjectGrayScale> ppPixelObjectInputArrayOne,
	vector<PixelObjectGrayScale> ppPixelObjectInputArrayTwo,
	vector<OutputPixelBufferStateMachineData> *ppPixelObjectOutputArray)
{
	HRESULT hr = S_OK;


	vector<OutputPixelBufferStateMachineData> ppOutputPixelBuffer = vector<OutputPixelBufferStateMachineData>();
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\ImageProcessingSetupFSMGrayScaleSetup.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "This Is the Function that Will Simulate Image Processing FSM" << endl;
	cout << "For This Simulation We will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer Object" << endl;
	cout << "1 Output Buffer Object" << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordereded Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	cout << "Printing the Contents Of Image One" << endl;
	int pIndex = 0;

	for (PixelObjectGrayScale pPixelObject : ppPixelObjectInputArrayOne)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Index = " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "Pixel X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

		pIndex = pIndex + 1;
	}


	cout << "Printing the Contents Of Image Two" << endl;
     pIndex = 0;

	for (PixelObjectGrayScale pPixelObject : ppPixelObjectInputArrayTwo)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

		imageSegmentationDataFile << "Index = " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "Pixel X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;

		pIndex = pIndex + 1;
	}


	ID3D11ComputeShader* pComputeShaderFSM = nullptr;
	ID3D11Buffer* pComputeShaderConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObjectOne = nullptr;
	ID3D11Buffer* pInputBufferObjectTwo = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVObjectOne = nullptr;
	ID3D11ShaderResourceView* pInputSRVObjectTwo = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadBackBuffer = nullptr;

	cout << "Initialize Image Processing Finite State Machine Researches" << endl;
	imageSegmentationDataFile << "Initialize Image Processing Finite State Machine Researches" << endl;


	cout << "Initializing the Resources for Image Processing FSM" << endl;
	imageSegmentationDataFile << "Initalizing the Resources for Image Processing FSM" << endl;

	cout << "Filling the Data Structures for Intensity Function FSM" << endl;
	cbImageProcessingIntensityConstantBuffer pImageIntensityConstants;
	pImageIntensityConstants.pIdenticalImageLabel = 1;
	pImageIntensityConstants.pDifferentImageLabel = 0;


	hr = InitializeImageIntensityFiniteStateMachinePreparatorFunctionResources(hInstance,
		hWnd, pImageIntensityConstants, ppPixelObjectInputArrayOne, ppPixelObjectInputArrayTwo,
		&pComputeShaderFSM, &pComputeShaderConstantBuffer,
		&pInputBufferObjectOne, &pInputBufferObjectTwo,
		&pOutputBufferObject, &pInputSRVObjectOne,
		&pInputSRVObjectTwo,
		&pUnorderedAccessView,
		&pReadBackBuffer);




	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageProcessingFSMPreparator(hInstance,
		hWnd, pComputeShaderConstantBuffer, pComputeShaderFSM,
		pInputSRVObjectOne, pInputSRVObjectTwo, pUnorderedAccessView, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferObject);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelBufferStateMachineData* p = (OutputPixelBufferStateMachineData*)MappedResource.pData;
		for (int i = 0; i < ppPixelObjectInputArrayOne.size(); ++i)
		{
			p[i].pixelNumber = i;
			cout << "Pixel Number: " << p[i].pixelNumber;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Grey Level Image One: " << p[i].pGrayScaleValue0 << endl;
			cout << "Grey Level Image Two = " << p[i].pGrayScaleValue1 << endl;
			cout << "Output Comparison Value = " << p[i].pOutputComparisonValue << endl;
			cout << "Are Images Identical = " << p[i].arePixelsIdenticalVal << endl;
			cout << "Current Image Label = " << p[i].pCurrentState << endl;

			imageSegmentationDataFile << "Pixel Number: " << p[i].pixelNumber;
			imageSegmentationDataFile << "X Position: " << p[i].xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << p[i].yPosition << endl;
			imageSegmentationDataFile << "Grey Level Image One: " << p[i].pGrayScaleValue0 << endl;
			imageSegmentationDataFile << "Grey Level Image Two = " << p[i].pGrayScaleValue1 << endl;
			imageSegmentationDataFile << "Output Comparison Value = " << p[i].pOutputComparisonValue << endl;
			imageSegmentationDataFile << "Are Images Identical = " << p[i].arePixelsIdenticalVal << endl;
			imageSegmentationDataFile << "Current Image Label = " << p[i].pCurrentState << endl;

			ppOutputPixelBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelBufferStateMachineData pPixelObject : ppOutputPixelBuffer)
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
			cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
			cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
			cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
			cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
			imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
			imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
			imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
			imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageSegmentationDataFile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&pComputeShaderFSM);
	SafeReleaseA(&pComputeShaderConstantBuffer);
	SafeReleaseA(&pInputBufferObjectOne);
	SafeReleaseA(&pInputBufferObjectTwo);
	SafeReleaseA(&pOutputBufferObject);
	SafeReleaseA(&pInputSRVObjectOne);
	SafeReleaseA(&pInputSRVObjectTwo);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadBackBuffer);

	imageSegmentationDataFile.close();
	*ppPixelObjectOutputArray = ppOutputPixelBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeImageIntensityFiniteStateMachinePreparatorFunctionResources(HINSTANCE hInstance,
	HWND hWnd,
	cbImageProcessingIntensityConstantBuffer pImageIntensityConstants,
	vector<PixelObjectGrayScale> pImageProcessingInputArrayOne,
	vector<PixelObjectGrayScale> pImageProcessingInputArrayTwo,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppInputBufferObjectOne,
	ID3D11Buffer** ppInputBufferObjectTwo,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppInputSRVOne,
	ID3D11ShaderResourceView** ppInputSRVTwo,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ImageProcessingFiniteStateMachineIntensityFunctionPreparator.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbImageProcessingIntensityConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pImageIntensityConstants;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pImageProcessingInputArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pImageProcessingInputArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image two Object" << endl;



	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pImageProcessingInputArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pImageProcessingInputArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Output Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Output Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pImageProcessingInputArrayTwo.size() * sizeof(OutputPixelBufferStateMachineData);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferStateMachineData);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pImageProcessingInputArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc1, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc2;
	ZeroMemory(&srvbuffer_desc2, sizeof(srvbuffer_desc2));
	srvbuffer_desc2.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc2.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc2.Buffer.ElementWidth = pImageProcessingInputArrayTwo.size();
	srvbuffer_desc2.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc2, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pImageProcessingInputArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pImageProcessingInputArrayOne.size() * sizeof(OutputPixelBufferStateMachineData);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelBufferStateMachineData);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	imageMaskLog.close();

	*ppConstantBufferObject = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferObjectOne = pInputBuffer1;
	*ppInputBufferObjectTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRVOne = pInputSRV1;
	*ppInputSRVTwo = pInputSRV2;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunImageProcessingFSMPreparator(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstanBufferFSM,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pInputSRVFSM0,
	ID3D11ShaderResourceView* pInputSRVFSM1,
	ID3D11UnorderedAccessView* pOutputUAVFSM,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pInputSRVFSM0, pInputSRVFSM1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pOutputUAVFSM };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstanBufferFSM);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::SimulateImageProcessingFiniteStateMachineIntensitySimulator(HINSTANCE hInstance, HWND hWnd,
	cbImageProcessingFSMStageTwo pConstantBufferForSimulation,
	vector<OutputPixelBufferStateMachineData> ppPixelObjectInputArrayOne,
	vector<OutputPixelBufferStateMachineData> ppPixelObjectInputArrayTwo,
	vector<OutputPixelObjectGrayScaleStateChange> *ppPixelObjectOutputArray)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectGrayScaleStateChange> ppOutputPixelBuffer = vector<OutputPixelObjectGrayScaleStateChange>();
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\ImageProcessingSetupFSMGrayScaleSetup.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "This Is the Function that Will Simulate Image Processing FSM" << endl;
	cout << "For This Simulation We will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "2 Input Buffer Objects" << endl;
	cout << "1 Output Buffer Object" << endl;
	cout << "2 Shader Resource Views" << endl;
	cout << "1 Unordereded Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageSegmentationDataFile << "This Is the Function that Will Simulate Image Processing FSM" << endl;
	imageSegmentationDataFile << "For This Simulation We will Use" << endl;
	imageSegmentationDataFile << "1 Compute Shader" << endl;
	imageSegmentationDataFile << "1 Constant Buffer" << endl;
	imageSegmentationDataFile << "2 Input Buffer Objects" << endl;
	imageSegmentationDataFile << "1 Output Buffer Object" << endl;
	imageSegmentationDataFile << "2 Shader Resource View" << endl;
	imageSegmentationDataFile << "1 Unordereded Access View" << endl;
	imageSegmentationDataFile << "1 Readback Buffer" << endl;



	cout << "Printing the Contents Of Image One" << endl;
	int pIndex = 0;

	for (OutputPixelBufferStateMachineData pPixelObject : ppPixelObjectInputArrayOne)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


	}

	cout << "Printing the Contents Of Image Two" << endl;
	for (OutputPixelBufferStateMachineData pPixelObject : ppPixelObjectInputArrayTwo)
	{

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		cout << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		cout << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		cout << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		cout << "Current Image Label = " << pPixelObject.pCurrentState << endl;

		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Grey Level Image One: " << pPixelObject.pGrayScaleValue0 << endl;
		imageSegmentationDataFile << "Grey Level Image Two = " << pPixelObject.pGrayScaleValue1 << endl;
		imageSegmentationDataFile << "Output Comparison Value = " << pPixelObject.pOutputComparisonValue << endl;
		imageSegmentationDataFile << "Are Images Identical = " << pPixelObject.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Current Image Label = " << pPixelObject.pCurrentState << endl;


	}


	ID3D11ComputeShader* pComputeShaderFSM = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObjectOne = nullptr;
	ID3D11Buffer* pInputBufferObjectTwo = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVObjectOne = nullptr;
	ID3D11ShaderResourceView* pInputSRVObjectTwo = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadBackBuffer = nullptr;

	cout << "Initialize Image Processing Finite State Machine Researches" << endl;
	imageSegmentationDataFile << "Initialize Image Processing Finite State Machine Researches" << endl;


	cout << "Initializing the Resources for Image Processing FSM" << endl;
	imageSegmentationDataFile << "Initalizing the Resources for Image Processing FSM" << endl;

	cout << "Filling the Data Structures for Intensity Function FSM" << endl;
	


	hr = InitializeImageProcessingFiniteStateMachineIntensityFunctionSimulationResources(hInstance,
		hWnd,
		pConstantBufferForSimulation,
		ppPixelObjectInputArrayOne,
		ppPixelObjectInputArrayTwo,
		&pComputeShaderFSM,
		&pConstantBuffer,
		&pInputBufferObjectOne,
		&pInputBufferObjectTwo,
		&pOutputBufferObject,
		&pInputSRVObjectOne,
		&pInputSRVObjectTwo,
		&pUnorderedAccessView,
		&pReadBackBuffer);




	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageProcessingFSMSimulator(hInstance,
		hWnd,
		pComputeShaderFSM,
		pConstantBuffer,
		pInputSRVObjectOne,
		pInputSRVObjectTwo,
		pUnorderedAccessView, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferObject);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectGrayScaleStateChange* p = (OutputPixelObjectGrayScaleStateChange*)MappedResource.pData;
		for (int i = 0; i < ppPixelObjectInputArrayOne.size(); ++i)
		{

			cout << "Pixel Number: " << p[i].pixelNumber;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Output Comparison Value One = " << p[i].pOutputComparisonValueOne << endl;
			cout << "Output Comparison Value Two =" << p[i].pOutputComparisonValueTwo << endl;
			cout << "Output Comparison Value Final =" << p[i].pOutputComparisonValueFinal << endl;
			cout << "Current Image State = " << p[i].pCurrentStateTwo << endl;
			cout << "Previous Image State = " << p[i].pCurrentStateOne << endl;
			cout << "Did State Change = " << p[i].pDidStateChange << endl;

			imageSegmentationDataFile << "Pixel Number: " << p[i].pixelNumber;
			imageSegmentationDataFile << "X Position: " << p[i].xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << p[i].yPosition << endl;
			imageSegmentationDataFile << "Output Comparison Value One = " << p[i].pOutputComparisonValueOne << endl;
			imageSegmentationDataFile << "Output Comparison Value Two =" << p[i].pOutputComparisonValueTwo << endl;
			imageSegmentationDataFile << "Output Comparison Value Final =" << p[i].pOutputComparisonValueFinal << endl;
			imageSegmentationDataFile << "Current Image State = " << p[i].pCurrentStateTwo << endl;
			imageSegmentationDataFile << "Previous Image State = " << p[i].pCurrentStateOne << endl;
			imageSegmentationDataFile << "Did State Change = " << p[i].pDidStateChange << endl;


			ppOutputPixelBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelObjectGrayScaleStateChange pPixelObject : ppOutputPixelBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
			cout << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
			cout << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
			cout << "Current Image State = " << pPixelObject.pCurrentStateTwo << endl;
			cout << "Previous Image State = " << pPixelObject.pCurrentStateOne << endl;
			cout << "Did State Change = " << pPixelObject.pDidStateChange << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Output Comparison Value One = " << pPixelObject.pOutputComparisonValueOne << endl;
			imageSegmentationDataFile << "Output Comparison Value Two =" << pPixelObject.pOutputComparisonValueTwo << endl;
			imageSegmentationDataFile << "Output Comparison Value Final =" << pPixelObject.pOutputComparisonValueFinal << endl;
			imageSegmentationDataFile << "Current Image State = " << pPixelObject.pCurrentStateTwo << endl;
			imageSegmentationDataFile << "Previous Image State = " << pPixelObject.pCurrentStateOne << endl;
			imageSegmentationDataFile << "Did State Change = " << pPixelObject.pDidStateChange << endl;



		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageSegmentationDataFile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");
	SafeReleaseA(&pComputeShaderFSM);
	SafeReleaseA(&pInputSRVObjectOne);
	SafeReleaseA(&pInputSRVObjectTwo);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadBackBuffer);

	imageSegmentationDataFile.close();
	*ppPixelObjectOutputArray = ppOutputPixelBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeImageProcessingFiniteStateMachineIntensityFunctionSimulationResources(HINSTANCE hInstance,
	HWND hWnd,
	cbImageProcessingFSMStageTwo pConstantBufferData,
	vector<OutputPixelBufferStateMachineData> pInputArrayForStageOne,
	vector<OutputPixelBufferStateMachineData> pInputArrayForStageTwo,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppInputBuffer0,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppInputSRV0,
	ID3D11ShaderResourceView** ppInputSRV1,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;



	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ImageProcessingFiniteStateMachineIntensitySimulator.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer For Compute Shader" << endl;
	imageMaskLog << "Creating the Constant Buffer For Compute Shader" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbImageProcessingFSMStageTwo) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferData;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputArrayForStageOne.size() * sizeof(OutputPixelBufferStateMachineData);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBufferStateMachineData);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pInputArrayForStageOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData1, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image Two Object" << endl;



	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pInputArrayForStageTwo.size() * sizeof(OutputPixelBufferStateMachineData);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(OutputPixelBufferStateMachineData);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData2;
	pData2.pSysMem = &pInputArrayForStageTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData2, &pInputBuffer2);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Output Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Output Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputArrayForStageOne.size() * sizeof(OutputPixelObjectGrayScaleStateChange);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectGrayScaleStateChange);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pInputArrayForStageOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc1, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc2;
	ZeroMemory(&srvbuffer_desc2, sizeof(srvbuffer_desc2));
	srvbuffer_desc2.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc2.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc2.Buffer.ElementWidth = pInputArrayForStageTwo.size();
	srvbuffer_desc2.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc2, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputArrayForStageOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputArrayForStageOne.size() * sizeof(OutputPixelObjectGrayScaleStateChange);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectGrayScaleStateChange);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	imageMaskLog.close();

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppInputBuffer0 = pInputBuffer1;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV0 = pInputSRV1;
	*ppInputSRV1 = pInputSRV2;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunImageProcessingFSMSimulator(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pInputSRVFSM0, 
	ID3D11ShaderResourceView* pInputSRVFSM1, 
	ID3D11UnorderedAccessView* pOutputUAVFSM, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pInputSRVFSM0, pInputSRVFSM1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pOutputUAVFSM };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pOutputUAVFSM, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::RunImageProcessingFSMStageTwo(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* pInputSRVFSM0,
	ID3D11ShaderResourceView* pInputSRVFSM1,
	ID3D11UnorderedAccessView* pOutputUAVFSM,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	ID3D11ShaderResourceView* ppSRV[] = { pInputSRVFSM0, pInputSRVFSM1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pOutputUAVFSM };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pOutputUAVFSM, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::SimulateImageProcessingFiniteStateMachine(HINSTANCE hInstance, HWND hWnd,
	CBImageIntensityConstants pImageIntensityConstants,
	vector<PixelObject> ppPixelObjectInputArray,
	vector<OutputPixelObjectGrayScaleWithState> *ppPixelObjectOutputArray)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectGrayScaleWithState> ppOutputPixelBuffer = vector<OutputPixelObjectGrayScaleWithState>();
	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\ImageProcessingSetupFSM.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();

	cout << "This Is the Function that Will Simulate Image Processing FSM" << endl;
	cout << "For This Simulation We will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer Object" << endl;
	cout << "1 Output Buffer Object" << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordereded Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	cout << "Printing the Contents Of Image One" << endl;
	int pIndex = 0;

	for (PixelObject pPixelObject : ppPixelObjectInputArray)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;


		imageSegmentationDataFile << "Index = " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "Pixel X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;

		pIndex = pIndex + 1;
	}

	ID3D11ComputeShader* pComputeShaderFSM = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVObject = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadBackBuffer = nullptr;



	cout << "Initialize Image Processing Finite State Machine Researches" << endl;
	imageSegmentationDataFile << "Initialize Image Processing Finite State Machine Researches" << endl;


	cout << "Initializing the Resources for Image Processing FSM" << endl;
	imageSegmentationDataFile << "Initalizing the Resources for Image Processing FSM" << endl;


	hr = InitializeImageProcessingFiniteStateMachineResources(hInstance, hWnd,
		pImageIntensityConstants,
		ppPixelObjectInputArray,
		&pComputeShaderFSM,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pInputSRVObject,
		&pUnorderedAccessView,
		&pReadBackBuffer);





	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageProcessingFSM(hInstance,
		hWnd, pConstantBuffer, pComputeShaderFSM,
		pInputSRVObject, pUnorderedAccessView, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageSegmentationDataFile.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferObject);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectGrayScaleWithState* p = (OutputPixelObjectGrayScaleWithState*)MappedResource.pData;
		for (int i = 0; i < ppPixelObjectInputArray.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Grey Level: " << p[i].pGrayScaleValue << endl;
			cout << "Level of Darkness = " << p[i].pLevelOfDarkness << endl;
			cout << "Current State = " << p[i].pCurrentState << endl;


			imageSegmentationDataFile << "Pixel Number: " << p[i].pixelNumber;
			imageSegmentationDataFile << "X Position: " << p[i].xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << p[i].yPosition << endl;
			imageSegmentationDataFile << "Grey Level: " << p[i].pGrayScaleValue << endl;
			imageSegmentationDataFile << "Level of Darkness = " << p[i].pLevelOfDarkness << endl;
			imageSegmentationDataFile << "Current State = " << p[i].pCurrentState << endl;


			ppOutputPixelBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelObjectGrayScaleWithState pPixelObject : ppOutputPixelBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
			cout << "Level Of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
			cout << "Current State = " << pPixelObject.pCurrentState << endl;

			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "Grey Level: " << pPixelObject.pGrayScaleValue << endl;
			imageSegmentationDataFile << "Level of Darkness = " << pPixelObject.pLevelOfDarkness << endl;
			imageSegmentationDataFile << "Current State = " << pPixelObject.pCurrentState << endl;



		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageSegmentationDataFile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&pComputeShaderFSM);
	SafeReleaseA(&pInputBufferObject);
	SafeReleaseA(&pOutputBufferObject);
	SafeReleaseA(&pInputSRVObject);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadBackBuffer);

	imageSegmentationDataFile.close();
	*ppPixelObjectOutputArray = ppOutputPixelBuffer;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageProcessingFiniteStateMachineResources(HINSTANCE hInstance,
	HWND hWnd,
	CBImageIntensityConstants
	pImageIntensityConstants,
	vector<PixelObject> pImageProcessingInputArray,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppInputBufferObject,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppInputSRV,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);


	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ImageProcessingFiniteStateMachinePreparation.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBImageIntensityConstants) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pImageIntensityConstants;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pImageProcessingInputArray.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pImageProcessingInputArray[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Output Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pImageProcessingInputArray.size() * sizeof(OutputPixelObjectGrayScaleWithState);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectGrayScaleWithState);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pImageProcessingInputArray.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pImageProcessingInputArray.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pImageProcessingInputArray.size() * sizeof(OutputPixelObjectGrayScaleWithState);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectGrayScaleWithState);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	imageMaskLog.close();

	*ppConstantBufferObject = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferObject = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV = pInputSRV1;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunImageProcessingFSM(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstanBufferFSM,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pInputSRVFSM,
	ID3D11UnorderedAccessView* pOutputUAVFSM,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pInputSRVFSM };
	ID3D11UnorderedAccessView* ppUAV[] = { pOutputUAVFSM };
	m_pD3DCompContext->CSSetShaderResources(0, 1, &pInputSRVFSM);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pOutputUAVFSM, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstanBufferFSM);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);

	return hr;
}


















HRESULT DirectXStandardAlgorithmExecutor::SimulateOddEvenNumberFSM(HINSTANCE hInstance, HWND hWnd,
	OddNumberCB pOddNumberCB,
	vector<float> ppEventNumberArray,
	vector<OutputArrayOddEventStruct> *ppOutputNumberArrayVarEven,
	vector<OutputArrayOddEventStruct> *ppOutputNumberArrayVarOdd,
	vector<OutputArrayOddEvenFinalStruct> *ppOutputOddEvenFinalArray)
{

	HRESULT hr = S_OK;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\OddEvenNumberFSM.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();
	
	vector<InputArrayOddEvenStruct> pOddEvenArrayInputVector = vector<InputArrayOddEvenStruct>();
	vector<OutputArrayOddEventStruct> pOutputArrayVectorEven = vector<OutputArrayOddEventStruct>();
	vector<OutputArrayOddEventStruct> pOutputArrayVectorOdd = vector<OutputArrayOddEventStruct>();
	vector<OutputArrayOddEvenFinalStruct> pOutputVectorFinal = vector<OutputArrayOddEvenFinalStruct>();


	cout << "This Function Simulates the Behaviour of Odd-Even Number FSM" << endl;
	imageSegmentationDataFile << "This Function Simulates the Behaviour of Odd-Even Number FSM" << endl;

	cout << "Printing the Initial Output Array" << endl;
	UINT pIndex = 0;
	for (float pOutputNumber : ppEventNumberArray)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Float Value: " << pOutputNumber << endl;
	

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Float Value: " << pOutputNumber << endl;
	

		InputArrayOddEvenStruct pInputArrayVar;
		pInputArrayVar.pItemIndex = pIndex;
		pInputArrayVar.pInputNumberVar = pOutputNumber;
		pOddEvenArrayInputVector.push_back(pInputArrayVar);
		pIndex++;
	}

	ID3D11ComputeShader* pComputeShaderObjectFSM = nullptr;
	ID3D11Buffer* pOddEvenNumberConstantBuffer = nullptr;
	ID3D11Buffer* pOddEvenNumberInputBuffer = nullptr;
	ID3D11Buffer* pOddNumberOutputBuffer = nullptr;
	ID3D11Buffer* pEvenNumberOutputBuffer = nullptr;
	ID3D11Buffer* pFinalOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pOddEvenNumberInputSRV = nullptr;
	ID3D11UnorderedAccessView* pOddNumberOutputUAV = nullptr;
	ID3D11UnorderedAccessView* pEvenNumberOutputUAV = nullptr;
	ID3D11UnorderedAccessView* pFinalNumberOutputUAV = nullptr;
	ID3D11Buffer* pOddNumberReadbackBuffer = nullptr;
	ID3D11Buffer* pEvenNumberReadbackBuffer = nullptr;
	ID3D11Buffer* pFinalNumberReadbackBuffer = nullptr;

	cout << "For This Simulation We Will Use" << endl;
	cout << "1 Constant Buffer Object" << endl;
	cout << "1 Input Buffer" << endl;
	cout << "3 Output Buffers" << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "3 Unordered Unordered Access Views" << endl;
	cout << "3 ReadBack Buffers" << endl;

	imageSegmentationDataFile << "For This Simulation We Will Use" << endl;
	imageSegmentationDataFile << "1 Constant Buffer Object" << endl;
	imageSegmentationDataFile << "1 Input Buffer" << endl;
	imageSegmentationDataFile << "3 Output Buffers" << endl;
	imageSegmentationDataFile << "1 Shader Resource View" << endl;
	imageSegmentationDataFile << "3 Unordered Unordered Access Views" << endl;
	imageSegmentationDataFile << "3 ReadBack Buffers" << endl;


	cout << "Setting Up the Procedure for Initialization of Resources" << endl;
	imageSegmentationDataFile << "Setting Up the Procedure for Initialization of Resources" << endl;


	hr = InitializeOddEventNumberFSM(hInstance, hWnd,
		pOddEvenArrayInputVector, pOddNumberCB,
		&pComputeShaderObjectFSM,
		&pOddEvenNumberConstantBuffer,
		&pOddEvenNumberInputBuffer,
		&pOddNumberOutputBuffer,
		&pEvenNumberOutputBuffer,
		&pFinalOutputBuffer,
		&pOddEvenNumberInputSRV,
		&pOddNumberOutputUAV,
		&pEvenNumberOutputUAV,
		&pFinalNumberOutputUAV,
		&pOddNumberReadbackBuffer,
		&pEvenNumberReadbackBuffer,
		&pFinalNumberReadbackBuffer);

	if (FAILED(hr))
	{
		cout << "Unable to Initialize Odd/Even Number FSM" << endl;
		imageSegmentationDataFile << "Unable to Initialize Odd/Even Number FSM" << endl;
		return hr;
	}

	cout << "Running Our State Machine Simulation" << endl;
	imageSegmentationDataFile << "Running Our State Machine Simulation" << endl;

	hr = RunOddEvenNumberFSM(hInstance, hWnd,
		pOddEvenNumberConstantBuffer,
		pOddEvenNumberInputSRV, pComputeShaderObjectFSM, pEvenNumberOutputUAV,
		pOddNumberOutputUAV,
		pFinalNumberOutputUAV,
		256, 1, 1);

	cout << "Copying Data From Output Buffer to Readback Buffer" << endl;
	imageSegmentationDataFile << "Copying Data From Output Buffer to Readback Buffer" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Odd Number Output Container" << endl;
		D3D11_MAPPED_SUBRESOURCE MappedResourceOdd = { 0 };
		m_pD3DCompContext->CopyResource(pOddNumberReadbackBuffer, pOddNumberOutputBuffer);
		hr = m_pD3DCompContext->Map(pOddNumberReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResourceOdd);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputArrayOddEventStruct* pOdd = (OutputArrayOddEventStruct*)MappedResourceOdd.pData;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		
		for (int i = 0; i < ppEventNumberArray.size(); ++i)
		{
			if (pOdd[i].pInputNumberVar != 0)
			{
				
					cout << "Item Index: " << " " << i << " " << "=" << " " << pOdd[i].pItemIndex << endl;
					imageSegmentationDataFile << "Item Index: " << " " << i << " " << "=" << " " << pOdd[i].pItemIndex << endl;
					
					cout << "Item Float Value: " << " " << i << " " << "=" << " " << pOdd[i].pInputNumberVar << endl;
					imageSegmentationDataFile << "Item Float Value: " << " " << i << " " << "=" << " " << pOdd[i].pInputNumberVar << endl;

					cout << "Kind of Number: " << " " << i << " " << "=" << " " << pOdd[i].kindOfNumber << endl;
					imageSegmentationDataFile << "Kind of Number: " << " " << i << " " << "=" << " " << pOdd[i].kindOfNumber << endl;

					pOutputArrayVectorOdd.push_back(pOdd[i]);
				
				
			}
		}

		cout << "Copying Even Number Output Container" << endl;
		D3D11_MAPPED_SUBRESOURCE MappedResourceEven = { 0 };
		m_pD3DCompContext->CopyResource(pEvenNumberReadbackBuffer, pEvenNumberOutputBuffer);
		hr = m_pD3DCompContext->Map(pEvenNumberReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResourceEven);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputArrayOddEventStruct* pEven = (OutputArrayOddEventStruct*)MappedResourceEven.pData;
		
		for (int i = 0; i < ppEventNumberArray.size(); ++i)
		{
			
			if (pEven[i].pInputNumberVar != 0)
			{
				cout << "Item Index: " << " " << i << " " << "=" << " " << pEven[i].pItemIndex << endl;
				imageSegmentationDataFile << "Item Index: " << " " << i << " " << "=" << " " << pEven[i].pItemIndex << endl;

				cout << "Item Float Value: " << " " << i << " " << "=" << " " << pEven[i].pInputNumberVar << endl;
				imageSegmentationDataFile << "Item Float Value: " << " " << i << " " << "=" << " " << pEven[i].pInputNumberVar << endl;
				
				cout << "Kind of Number: " << " " << i << " " << "=" << " " << pEven[i].kindOfNumber << endl;
				imageSegmentationDataFile << "Kind of Number: " << " " << i << " " << "=" << " " << pEven[i].kindOfNumber << endl;

				pOutputArrayVectorEven.push_back(pEven[i]);


			}
				
		}

		cout << "Copying Final Number Output Container" << endl;
		D3D11_MAPPED_SUBRESOURCE MappedResourceFinal = { 0 };
		m_pD3DCompContext->CopyResource(pFinalNumberReadbackBuffer, pFinalOutputBuffer);
		hr = m_pD3DCompContext->Map(pFinalNumberReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResourceFinal);

	 OutputArrayOddEvenFinalStruct* pOutputFinalStruct = (OutputArrayOddEvenFinalStruct*)MappedResourceFinal.pData;


		int pOddEvenStateCurrent = pOddNumberCB.Undefined;

		int pCurrentState = pOddNumberCB.Undefined;
		int pPreviousState = pOddNumberCB.Undefined;

		for (int pIndex = 0; pIndex < ppEventNumberArray.size(); ++pIndex)
		{


			OutputArrayOddEvenFinalStruct pOutputStructureValue = pOutputFinalStruct[pIndex];
			if (pOutputStructureValue.pInputNumberVar != 0)
			{
				if (pOutputStructureValue.pCurrentState != pPreviousState)
				{
					pOutputStructureValue.didStateChange = true;
				}
				else
				{
					pOutputStructureValue.didStateChange = false;
				}

				cout << "Item Index = " << pOutputStructureValue.pItemIndex << endl;
				cout << "Number Value = " << pOutputStructureValue.pInputNumberVar << endl;
				cout << "Kind of Number Value = " << pOutputStructureValue.kindOfNumber << endl;
				cout << "Current State Value = " << pOutputStructureValue.pCurrentState << endl;
				cout << "Previous State Value = " << pPreviousState << endl;
				cout << "Did State Change = " << pOutputStructureValue.didStateChange << endl;
				pOutputStructureValue.pPreviousState = pPreviousState;

				pOutputVectorFinal.push_back(pOutputStructureValue);
				pPreviousState = pOutputStructureValue.pCurrentState;

			}

		}


		cout << "Printing the Contents of the output vector" << endl;
		




		for (OutputArrayOddEvenFinalStruct pFinalStruct : pOutputVectorFinal)
		{

				cout << "Item Index = " << pFinalStruct.pItemIndex << endl;
				cout << "Input Number = " << pFinalStruct.pInputNumberVar << endl;
				cout << "Kind Of Number = " << pFinalStruct.kindOfNumber << endl;
				cout << "Current State = " << pFinalStruct.pCurrentState << endl;
				cout << "Previous State = " << pFinalStruct.pPreviousState << endl;
				cout << "Did State Change" << pFinalStruct.didStateChange << endl;


				imageSegmentationDataFile << "Item Index = " << pFinalStruct.pItemIndex << endl;
				imageSegmentationDataFile << "Input Number = " << pFinalStruct.pInputNumberVar << endl;
				imageSegmentationDataFile << "Kind Of Number = " << pFinalStruct.kindOfNumber << endl;
				imageSegmentationDataFile << "Current State = " << pFinalStruct.pCurrentState << endl;
				imageSegmentationDataFile << "Previous State = " << pFinalStruct.pPreviousState << endl;
				imageSegmentationDataFile << "Did State Change" << pFinalStruct.didStateChange << endl;


				



			}





		if (bSuccess)
			printf("succeeded\n");

	}

	imageSegmentationDataFile.close();
	printf("Cleaning up...\n");
	SafeReleaseA(&pOddEvenNumberInputSRV);
	SafeReleaseA(&pOddNumberOutputUAV);
	SafeReleaseA(&pEvenNumberOutputUAV);
	SafeReleaseA(&pOddNumberReadbackBuffer);
	SafeReleaseA(&pEvenNumberReadbackBuffer);
	SafeReleaseA(&pOddNumberOutputBuffer);
	SafeReleaseA(&pEvenNumberOutputBuffer);
	SafeReleaseA(&pOddEvenNumberInputBuffer);
	SafeReleaseA(&pOddEvenNumberConstantBuffer);
	SafeReleaseA(&pComputeShaderObjectFSM);
	*ppOutputNumberArrayVarEven = pOutputArrayVectorEven;
	*ppOutputNumberArrayVarOdd = pOutputArrayVectorOdd;
	*ppOutputOddEvenFinalArray = pOutputVectorFinal;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeOddEventNumberFSM(HINSTANCE hInstance,
	HWND hWnd,
	vector<InputArrayOddEvenStruct> ppEventNumberArray,
	OddNumberCB pOddEvenNumberCB,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppInputNumberBufferObject,
	ID3D11Buffer** ppOutputNumberObjectEven,
	ID3D11Buffer** ppOutputNumberObjectOdd,
	ID3D11Buffer** ppOutputNumberObjectFinal,
	ID3D11ShaderResourceView** ppInputNumberSRV,
	ID3D11UnorderedAccessView** ppOutputEvenNumberUAV,
	ID3D11UnorderedAccessView** ppOutputOddNumberUAV,
	ID3D11UnorderedAccessView** ppFinalOutputUAV,
	ID3D11Buffer** ppReadbackEvenNumberBufferObj,
	ID3D11Buffer** ppReadbackOddNumberBufferObj,
	ID3D11Buffer** ppReadbackBufferFinal)
{
	HRESULT hr = S_OK;

	ID3DBlob* pMemoryBuffer = nullptr;
	ID3D11ComputeShader* pExponentialFunctionComputeShader = nullptr;
	ID3D11Buffer* pConstantBufferB = nullptr;
	ID3D11Buffer* pExponentialInputBuffer = nullptr;
	ID3D11Buffer* pExponentialOutputBufferEven = nullptr;
	ID3D11Buffer* pExponentialOutputBufferOdd = nullptr;
	ID3D11Buffer* pExponentialOutputBufferFinal = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionEvenOutputUAV = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionOddOutputUAV = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionFinalOutputUAV = nullptr;
	ID3D11ShaderResourceView* pExponentialInputBufferSRV = nullptr;
	ID3D11Buffer* pExponentialFunctionReadbackBufferOdd = nullptr;
	ID3D11Buffer* pExponentialFunctionReadbackBufferEven = nullptr;
	ID3D11Buffer* pExponentialFunctionReadbackBufferFinal = nullptr;

	vector<BData> pInputStructuresArray = vector<BData>();
	cout << "Copying data to array of Structures" << endl;
	int iIndex = 0;
	UINT pAmountOfSamples = ppEventNumberArray.size();

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\OddEvenNumberFSMResources.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();


	


	cout << "Initializing Direct3D11 Device" << endl;
	imageSegmentationDataFile << "Initializing Direct3D11 Device" << endl;

	hr = InitializeD3D11Device(hWnd, 0);



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}

	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader


	cout << "Compiling the Odd Even Arrat Compute Shader " << endl;
	imageSegmentationDataFile << "Compiling the Odd Even Arrat Compute Shader " << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\OddNumberFilterFSM.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pExponentialFunctionComputeShader);
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		cout << "Compute Shader exit Compilation terminated with error: " << pLastError << endl;
		imageSegmentationDataFile << "Compute Shader exit Compilation terminated with error: " << pLastError << endl;

		return hr;
	}

	//Create the Const Buffer

	cout << "Creaing the Constant Buffer Object" << endl;
	imageSegmentationDataFile << "Creaing the Constant Buffer Object" << endl;



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(OddNumberCB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pConstantBufferData;
	pConstantBufferData.pSysMem = &pOddEvenNumberCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pConstantBufferData, &pConstantBufferB);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось константный буфер ODD/EVENT", (LPCSTR)"Message", 0);
		cout << "ODD/EVEN Constant Buffer Terminated with Error: " << pLastError << endl;
		imageSegmentationDataFile << "ODD / EVEN Constant Buffer Terminated with Error: " << pLastError << endl;

		return hr;
	}

		cout << "Creating the input buffer" << endl;
		imageSegmentationDataFile << "Creating the input buffer" << endl;


		// Create 2 buffers for switching between when performing the transpose
		D3D11_BUFFER_DESC buffer_desc;
		ZeroMemory(&buffer_desc, sizeof(buffer_desc));
		buffer_desc.StructureByteStride = sizeof(InputArrayStruct);
		buffer_desc.ByteWidth = ppEventNumberArray.size() * sizeof(InputArrayStruct);
		buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
		buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
		buffer_desc.Usage = D3D11_USAGE_DEFAULT;

		D3D11_SUBRESOURCE_DATA pData;
		pData.pSysMem = &ppEventNumberArray[0];



		hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pExponentialInputBuffer);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан входной буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Input Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The exit of An input Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			imageSegmentationDataFile << "The exit of An input Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			return hr;
		}


		cout << "Creating the Output Buffer for Even Numbers" << endl;
		imageSegmentationDataFile << "Creating the Output Buffer for Even Numbers" << endl;


		// Create 2 buffers for switching between when performing the transpose
		D3D11_BUFFER_DESC output_buffer_desc_even;
		ZeroMemory(&output_buffer_desc_even, sizeof(output_buffer_desc_even));
		output_buffer_desc_even.StructureByteStride = sizeof(OutputArrayOddEventStruct) / 5 * 6;;
		output_buffer_desc_even.ByteWidth = ppEventNumberArray.size()  * sizeof(OutputArrayOddEventStruct) / 5 * 6;;
		output_buffer_desc_even.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
		output_buffer_desc_even.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
		output_buffer_desc_even.Usage = D3D11_USAGE_DEFAULT;

		hr = m_pD3DCompDevice->CreateBuffer(&output_buffer_desc_even, NULL, &pExponentialOutputBufferEven);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The  Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Выходной Буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The exit of An  Output Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			imageSegmentationDataFile << "The exit of An  Output Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			return hr;
		}

		cout << "Creating the Output Buffer for Odd Numbers" << endl;
		imageSegmentationDataFile << "Creating the Output Buffer for Odd Numbers" << endl;


		// Create 2 buffers for switching between when performing the transpose
		D3D11_BUFFER_DESC output_buffer_desc_odd;
		ZeroMemory(&output_buffer_desc_odd, sizeof(output_buffer_desc_odd));
		output_buffer_desc_odd.StructureByteStride = sizeof(OutputArrayOddEventStruct) / 5 * 6;;
		output_buffer_desc_odd.ByteWidth = ppEventNumberArray.size()  * sizeof(OutputArrayOddEventStruct) / 5 * 6;
		output_buffer_desc_odd.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
		output_buffer_desc_odd.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
		output_buffer_desc_odd.Usage = D3D11_USAGE_DEFAULT;

		hr = m_pD3DCompDevice->CreateBuffer(&output_buffer_desc_odd, NULL, &pExponentialOutputBufferOdd);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The  Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Выходной Буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The exit of An  Output Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			imageSegmentationDataFile << "The exit of An  Output Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			return hr;
		}

		cout << "Creating the Output Buffer for Final State Machine Numbers" << endl;
		imageSegmentationDataFile << "Creating the Output Buffer for Final State Machine Numbers" << endl;


		// Create 2 buffers for switching between when performing the transpose
		D3D11_BUFFER_DESC output_buffer_desc_final;
		ZeroMemory(&output_buffer_desc_final, sizeof(output_buffer_desc_final));
		output_buffer_desc_final.StructureByteStride = sizeof(OutputArrayFinalStructOddEven) / 5 * 6;;
		output_buffer_desc_final.ByteWidth = ppEventNumberArray.size()  * sizeof(OutputArrayFinalStructOddEven) / 5 * 6;
		output_buffer_desc_final.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
		output_buffer_desc_final.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
		output_buffer_desc_final.Usage = D3D11_USAGE_DEFAULT;

		hr = m_pD3DCompDevice->CreateBuffer(&output_buffer_desc_final, NULL, &pExponentialOutputBufferFinal);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The  Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Выходной Буффер для Операции ODD/EVEN", (LPCSTR)"Message", 0);
			cout << "The exit of An  Output Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			imageSegmentationDataFile << "The exit of An  Output Buffer for ODD/EVEN Terminated with error: " << pLastError << endl;
			return hr;
		}


		cout << "Creating the Shader Resource For Input Buffer" << endl;
		imageSegmentationDataFile << "Creating the Shader Resource For Input Buffer" << endl;

		// Create the Shader Resource View for the Buffers
		// This is used for reading the buffer during the transpose
		D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
		ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
		srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
		srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
		srvbuffer_desc.Buffer.ElementWidth = sizeof(InputArrayStruct);
		srvbuffer_desc.Buffer.NumElements = ppEventNumberArray.size();
		srvbuffer_desc.Buffer.ElementOffset = 0;



		hr = m_pD3DCompDevice->CreateShaderResourceView(pExponentialInputBuffer, &srvbuffer_desc, &pExponentialInputBufferSRV);
		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Input Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			imageSegmentationDataFile << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}



		cout << "Creating the Unordered Access view for the Even Number Buffer Buffer" << endl;
		// Create the Unordered Access View for the Buffers
		// This is used for writing the buffer during the sort and transpose
		D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_even;
		ZeroMemory(&uavbuffer_desc_even, sizeof(uavbuffer_desc_even));
		uavbuffer_desc_even.Format = DXGI_FORMAT_UNKNOWN;
		uavbuffer_desc_even.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
		uavbuffer_desc_even.Buffer.FirstElement = 0;
		uavbuffer_desc_even.Buffer.NumElements = ppEventNumberArray.size();
		uavbuffer_desc_even.Buffer.Flags = 0;

		hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBufferEven, &uavbuffer_desc_even, &pExponentialFunctionEvenOutputUAV);

		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВОДА/Вывода  для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс ВВОДА/Вывода для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}


		cout << "Creating the Unordered Access view for the Odd Number Buffer" << endl;
		// Create the Unordered Access View for the Buffers
		// This is used for writing the buffer during the sort and transpose
		D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_odd;
		ZeroMemory(&uavbuffer_desc_odd, sizeof(uavbuffer_desc_odd));
		uavbuffer_desc_odd.Format = DXGI_FORMAT_UNKNOWN;
		uavbuffer_desc_odd.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
		uavbuffer_desc_odd.Buffer.FirstElement = 0;
		uavbuffer_desc_odd.Buffer.NumElements = ppEventNumberArray.size();
		uavbuffer_desc_odd.Buffer.Flags = 0;

		hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBufferOdd, &uavbuffer_desc_odd, &pExponentialFunctionOddOutputUAV);

		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВОДА/Вывода  для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создатьРесурс ВВОДА/Вывода для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}


		cout << "Creating the Unordered Access view for the Final Output Number Buffer" << endl;
		// Create the Unordered Access View for the Buffers
		// This is used for writing the buffer during the sort and transpose
		D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_final;
		ZeroMemory(&uavbuffer_desc_final, sizeof(uavbuffer_desc_final));
		uavbuffer_desc_final.Format = DXGI_FORMAT_UNKNOWN;
		uavbuffer_desc_final.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
		uavbuffer_desc_final.Buffer.FirstElement = 0;
		uavbuffer_desc_final.Buffer.NumElements = ppEventNumberArray.size();
		uavbuffer_desc_final.Buffer.Flags = 0;

		hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBufferFinal, &uavbuffer_desc_final, &pExponentialFunctionFinalOutputUAV);

		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВОДА/Вывода  для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создатьРесурс ВВОДА/Вывода для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}


		cout << "Creating the Readback Buffer for even Operation" << endl;

		// Create the Readback Buffer
		// This is used to read the results back to the CPU
		D3D11_BUFFER_DESC readback_buffer_desc_even;
		ZeroMemory(&readback_buffer_desc_even, sizeof(readback_buffer_desc_even));
		readback_buffer_desc_even.ByteWidth = ppEventNumberArray.size() * sizeof(OutputArrayOddEventStruct) / 5 * 6;
		readback_buffer_desc_even.Usage = D3D11_USAGE_STAGING;
		readback_buffer_desc_even.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
		readback_buffer_desc_even.StructureByteStride = sizeof(OutputArrayOddEventStruct) / 5 * 6;
		hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_even, nullptr, &pExponentialFunctionReadbackBufferEven);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВОДА/Вывода  для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создатьРесурс ВВОДА/Вывода для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}

	

		cout << "Creating the Readback Buffer for Odd Operation" << endl;

		// Create the Readback Buffer
		// This is used to read the results back to the CPU
		D3D11_BUFFER_DESC readback_buffer_desc_odd;
		ZeroMemory(&readback_buffer_desc_odd, sizeof(readback_buffer_desc_odd));
		readback_buffer_desc_odd.ByteWidth = ppEventNumberArray.size() * sizeof(OutputArrayOddEventStruct) / 5 * 6;
		readback_buffer_desc_odd.Usage = D3D11_USAGE_STAGING;
		readback_buffer_desc_odd.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
		readback_buffer_desc_odd.StructureByteStride = sizeof(OutputArrayOddEventStruct) / 5 * 6;
		hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_odd, nullptr, &pExponentialFunctionReadbackBufferOdd);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВОДА/Вывода  для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создатьРесурс ВВОДА/Вывода для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}

		cout << "Creating the Readback Buffer for Final Summary Operation" << endl;

		// Create the Readback Buffer
		// This is used to read the results back to the CPU
		D3D11_BUFFER_DESC readback_buffer_desc_final;
		ZeroMemory(&readback_buffer_desc_final, sizeof(readback_buffer_desc_final));
		readback_buffer_desc_final.ByteWidth = ppEventNumberArray.size() * sizeof(OutputArrayFinalStructOddEven) / 5 * 6;
		readback_buffer_desc_final.Usage = D3D11_USAGE_STAGING;
		readback_buffer_desc_final.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
		readback_buffer_desc_final.StructureByteStride = sizeof(OutputArrayFinalStructOddEven) / 5 * 6;
		hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_final, nullptr, &pExponentialFunctionReadbackBufferFinal);


		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВОДА/Вывода  для операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
			imageSegmentationDataFile << "The Output Buffer for the ODD/EVEN function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создатьРесурс ВВОДА/Вывода для  операции ODD/EVENT", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the ODD/EVEN function has not been successfully created: " << pLastError << endl;
			return hr;
		}


	ID3D11ShaderResourceView* pShaderResourceViews[] = { pExponentialInputBufferSRV };

	*ppConstantBufferObject = pConstantBufferB;
	*ppComputeShaderObject = pExponentialFunctionComputeShader;
	*ppInputNumberBufferObject = pExponentialInputBuffer;
	*ppOutputNumberObjectOdd = pExponentialOutputBufferOdd;
	*ppOutputNumberObjectEven = pExponentialOutputBufferEven;
	*ppOutputNumberObjectFinal = pExponentialOutputBufferFinal;
	*ppInputNumberSRV = pExponentialInputBufferSRV;
	*ppOutputEvenNumberUAV = pExponentialFunctionEvenOutputUAV;
	*ppOutputOddNumberUAV = pExponentialFunctionOddOutputUAV;
	*ppFinalOutputUAV = pExponentialFunctionFinalOutputUAV;
	*ppReadbackEvenNumberBufferObj = pExponentialFunctionReadbackBufferEven;
	*ppReadbackOddNumberBufferObj = pExponentialFunctionReadbackBufferOdd;
	*ppReadbackBufferFinal = pExponentialFunctionReadbackBufferFinal;
	return hr;

}



HRESULT DirectXStandardAlgorithmExecutor::RunOddEvenNumberFSM(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBufferCB,
	ID3D11ShaderResourceView* ppShaderResourceViewOne,
	ID3D11ComputeShader* ppComputeShaderObject,
	ID3D11UnorderedAccessView* ppUnordererdAccessViewEven,
	ID3D11UnorderedAccessView* ppUnordererdAccessViewOdd,
	ID3D11UnorderedAccessView* ppUnorderedAccessViewFinal,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;


	ID3D11UnorderedAccessView* ppUnordererdAccessViews[] = { ppUnordererdAccessViewEven, ppUnordererdAccessViewOdd, ppUnorderedAccessViewFinal};
	m_pD3DCompContext->CSSetShader(ppComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUnordererdAccessViews, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, &ppShaderResourceViewOne);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufferCB);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, nullptr, nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::ComputePixelImageDerivativeFunctionForYValues(HINSTANCE hInsance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pGrayScalePixelList,
	float pImageWidth,
	float pImageHeight,
	vector<CImageDerivativeClass> *ppImageDerivativeObjectListForYValues)
{
	HRESULT hr = S_OK;
	UINT pIndexIncrement = 0;
	fstream imageIntensityFunctionX;
	imageIntensityFunctionX.open("C:\\\pixels\\ComputeImageInstensityFunctionForX.txt", fstream::in | fstream::out | fstream::trunc);
	imageIntensityFunctionX.clear();
	cout << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values"
		<< endl;
	imageIntensityFunctionX << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values" << endl;
	float pixelOneIntensity = 0;
	float pixelTwoIntensity = 0;
	float pGradientId = 0;
	float pGradientValue = 0;
	float pGradientXPosition = 0;
	float pGradientYPosition = 0;
	float pXPositionPlus = 0;
	cout << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
	imageIntensityFunctionX << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
	vector<CImageDerivativeClass> pImageDerivativeClassList = vector<CImageDerivativeClass>();
	vector<float> pXPositionValues = vector<float>();
	for (PixelObjectGrayScale pPixelObjectGrayScale : pGrayScalePixelList)
	{
		float pXPosition = pPixelObjectGrayScale.xPosition;
		pXPositionValues.push_back(pXPosition);
	}

	std::cout << "Printing the array data" << endl;
	for (PixelObjectGrayScale pPixelObject : pGrayScalePixelList)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		imageIntensityFunctionX << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageIntensityFunctionX << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Y Position: " << pPixelObject.yPosition << endl;
		imageIntensityFunctionX << "Grey Level: " << pPixelObject.pGreyLevel << endl;
	}
	for each (PixelObjectGrayScale pFirstPixel in pGrayScalePixelList)
	{
		cout << "Getting Next X Position Pixels" << endl;
		int pXPosition = pFirstPixel.xPosition;
		int pYPosition = pFirstPixel.yPosition;
		float pLastX = pImageWidth - 1;
		float pLastY = pImageHeight - 1;




		PixelObjectGrayScale pSecondPixel = GetNextGreaterPixelByXPosition(pGrayScalePixelList, pFirstPixel);
		if (pSecondPixel.xPosition == pXPosition + 1 && pSecondPixel.yPosition == pYPosition)
		{
			cout << "Extracting First Pixel For Subtraction" << endl;
			float xPosition = pFirstPixel.xPosition;
			cout << "First Pixel X Position: " << xPosition << endl;
			cout << "First Pixel Y Position:" << pFirstPixel.yPosition << endl;
			cout << "First Pixel Intensity:" << pFirstPixel.pGreyLevel << endl;
			cout << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
			cout << "Second Pixel Pixel Y Position" << pSecondPixel.yPosition << endl;
			cout << "Second Pixel Pixel Intensity" << pSecondPixel.pGreyLevel << endl;
			imageIntensityFunctionX << "Extracting First Pixel For Subtraction" << endl;
			imageIntensityFunctionX << "First Pixel X Position: " << xPosition << endl;
			imageIntensityFunctionX << "First Pixel Y Position:" << pFirstPixel.yPosition << endl;
			imageIntensityFunctionX << "First Pixel Intensity:" << pFirstPixel.pGreyLevel << endl;
			imageIntensityFunctionX << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
			imageIntensityFunctionX << "Second Pixel Pixel Y Position" << pSecondPixel.yPosition << endl;
			imageIntensityFunctionX << "Second Pixel Pixel Intensity" << pSecondPixel.pGreyLevel << endl;
			cout << "Processing Pixel Number: " << pFirstPixel.pixelNumber << endl;
			pixelOneIntensity = pFirstPixel.pGreyLevel;
			pixelTwoIntensity = pSecondPixel.pGreyLevel;
			cout << "Found Neighbouring Pixel" << endl;
			cout << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
			cout << "Greater Neighbour Y" << pSecondPixel.yPosition << endl;
			cout << "Smaller Neighbour X: " << pFirstPixel.xPosition << endl;
			cout << "Smaller Neighbour Y" << pFirstPixel.yPosition << endl;
			cout << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
			cout << "Intentsity of the Second Pixel: " << pixelTwoIntensity << endl;
			pGradientId = pFirstPixel.pixelNumber;
			pGradientXPosition = pSecondPixel.xPosition;
			pGradientYPosition = pSecondPixel.yPosition;

			pGradientValue = abs(pixelTwoIntensity - pixelOneIntensity);
			cout << "Index Value = " << pGradientId << endl;
			cout << "X Position = " << pGradientXPosition << endl;
			cout << "Y Position = " << pGradientYPosition << endl;
			cout << "Gradient Value = " << pGradientValue << endl;
			imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
			imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
			imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
			imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
			CImageDerivativeClass pImageDerivativeClass = CImageDerivativeClass(pGradientId,
				pGradientXPosition, pGradientYPosition, pGradientValue);
			pImageDerivativeClassList.push_back(pImageDerivativeClass);



		}
		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}
		else if (pXPosition == pLastX)
		{
			pYPosition = pYPosition + 1;
			pXPosition = 0;
		}



	}
	cout << "Listing the Derivative Function Values for the Current Image" << endl;
	for (CImageDerivativeClass pImageDerivativesClass : pImageDerivativeClassList)
	{
		cout << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativesClass.xPosition << endl;
		cout << "Y Position = " << pImageDerivativesClass.yPosition << endl;
		cout << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
		imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
		imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
		imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
		imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
	}
	imageIntensityFunctionX.close();
	*ppImageDerivativeObjectListForYValues = pImageDerivativeClassList;
	return hr;
}

CImageDerivativeClass DirectXStandardAlgorithmExecutor::GetNextImageDerivativeByXPosition(vector<CImageDerivativeClass> pImageDerivativeList, CImageDerivativeClass pImageDerivative)
{
	CImageDerivativeClass pImageDerivativeObject = CImageDerivativeClass(0.0f, 0.0f, 0.0f, 0.0f);
	for each (CImageDerivativeClass pSelectedObject in pImageDerivativeList)
	{
		float pDifference = pSelectedObject.xPosition - pImageDerivative.pDerivativeValue;
		if ((pSelectedObject.yPosition == pImageDerivative.yPosition) && (pDifference == 1))
		{
			pImageDerivativeObject.pDerivativeIndex = pSelectedObject.pDerivativeIndex;
			pImageDerivativeObject.xPosition = pSelectedObject.xPosition;
			pImageDerivativeObject.yPosition = pSelectedObject.yPosition;
			pImageDerivativeObject.pDerivativeValue = pSelectedObject.pDerivativeValue;
		}
	}
	return pImageDerivativeObject;
}


CImageDerivativeClass DirectXStandardAlgorithmExecutor::GetNextImageDerivativeByYPosition(vector<CImageDerivativeClass> pImageDerivativeList, CImageDerivativeClass pImageDerivative)
{
	CImageDerivativeClass pImageDerivativeObject = CImageDerivativeClass(0.0f, 0.0f, 0.0f, 0.0f);
	for each (CImageDerivativeClass pSelectedObject in pImageDerivativeList)
	{
		float pDifference = pSelectedObject.yPosition - pImageDerivative.yPosition;
		if ((pSelectedObject.xPosition == pImageDerivative.xPosition) && (pDifference == 1))
		{
			pImageDerivativeObject.pDerivativeIndex = pSelectedObject.pDerivativeIndex;
			pImageDerivativeObject.xPosition = pSelectedObject.xPosition;
			pImageDerivativeObject.yPosition = pSelectedObject.yPosition;
			pImageDerivativeObject.pDerivativeValue = pSelectedObject.pDerivativeValue;
		}
	}
	return pImageDerivativeObject;
}




CImageDerivativeClass DirectXStandardAlgorithmExecutor::GetImageDerivativeObjectByXAndYPosition(vector
	<CImageDerivativeClass> ppImageDerivativeList, float pXPosition, float pYPosition)
{
	CImageDerivativeClass pImageDerivativeObject = CImageDerivativeClass(0.0f, 0.0f, 0.0f, 0.0f);
	for (CImageDerivativeClass pSelectedObject : ppImageDerivativeList)
	{
		if ((pSelectedObject.xPosition == pXPosition) && (pSelectedObject.yPosition == pYPosition))
		{
			pImageDerivativeObject.pDerivativeIndex = pSelectedObject.pDerivativeIndex;
			pImageDerivativeObject.xPosition = pSelectedObject.xPosition;
			pImageDerivativeObject.yPosition = pSelectedObject.yPosition;
			pImageDerivativeObject.pDerivativeValue = pSelectedObject.pDerivativeValue;
		}
	}
	return pImageDerivativeObject;
}



PixelObjectGrayScale DirectXStandardAlgorithmExecutor::GetImagePixelObjectByXAndYPosition(vector
	<PixelObjectGrayScale> ppImageDerivativeList, float pXPosition, float pYPosition)
{
	
	PixelObjectGrayScale pSelectedObjectItem = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);
	pSelectedObjectItem.pixelNumber = 0;
	pSelectedObjectItem.xPosition = 0.0f;
	pSelectedObjectItem.yPosition = 0.0f;
	pSelectedObjectItem.pGreyLevel = 0.0f;


	PixelObjectGrayScale pImageDerivativeObject = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);
	pImageDerivativeObject.pixelNumber = 0;
	pImageDerivativeObject.xPosition = 0.0f;
	pImageDerivativeObject.yPosition = 0.0f;
	pImageDerivativeObject.pGreyLevel = 0.0f;

	for (PixelObjectGrayScale pSelectedObject : ppImageDerivativeList)
	{
		if ((pSelectedObject.xPosition == pXPosition) && (pSelectedObject.yPosition == pYPosition))
		{
			PixelObjectGrayScale pImageDerivativeObject = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);
			pImageDerivativeObject.pixelNumber= pSelectedObject.pixelNumber;
			pImageDerivativeObject.xPosition = pSelectedObject.xPosition;
			pImageDerivativeObject.yPosition = pSelectedObject.yPosition;
			pImageDerivativeObject.pGreyLevel = pSelectedObject.pGreyLevel;
		}
	}
	return pImageDerivativeObject;
}



HRESULT DirectXStandardAlgorithmExecutor::ComputePixelImageDerivativeFunctionForXValues(HINSTANCE hInsance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pGrayScalePixelList,
	float pImageWidth,
	float pImageHeight,
	vector<CImageDerivativeClass> *ppImageDerivativeObjectListForX)
{
	HRESULT hr = S_OK;
	UINT pIndexIncrement = 0;
	fstream imageIntensityFunctionX;
	imageIntensityFunctionX.open("C:\\\pixels\\ComputeImageInstensityFunctionForX.txt", fstream::in | fstream:: out | fstream::trunc);
	imageIntensityFunctionX.clear(); 
		cout << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values"
		<< endl;
	imageIntensityFunctionX << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values" << endl;
		float pixelOneIntensity = 0;
	float pixelTwoIntensity = 0;
	float pGradientId = 0;
	float pGradientValue = 0;
	float pGradientXPosition = 0;
	float pGradientYPosition = 0;
	float pXPositionPlus = 0;
	cout << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
	imageIntensityFunctionX << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
		vector<CImageDerivativeClass> pImageDerivativeClassList = vector<CImageDerivativeClass>();
	vector<float> pXPositionValues = vector<float>();
	for (PixelObjectGrayScale pPixelObjectGrayScale : pGrayScalePixelList)
	{
		float pXPosition = pPixelObjectGrayScale.xPosition;
		pXPositionValues.push_back(pXPosition);
	}

	std::cout << "Printing the array data" << endl;
	for (PixelObjectGrayScale pPixelObject : pGrayScalePixelList)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		imageIntensityFunctionX << "Pixel Number: " << pPixelObject.pixelNumber;
		imageIntensityFunctionX << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Y Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Grey Level: " << pPixelObject.pGreyLevel << endl;
	}
	for each (PixelObjectGrayScale pFirstPixel in pGrayScalePixelList)
	{
		cout << "Getting Next X Position Pixels" << endl;
		int pXPosition = pFirstPixel.xPosition;
		int pYPosition = pFirstPixel.yPosition;
		float pLastX = pImageWidth - 1;
		float pLastY = pImageHeight - 1;

		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}



		
		PixelObjectGrayScale pSecondPixel = GetNextGreaterPixelByYPosition(pGrayScalePixelList, pFirstPixel);
		if (pSecondPixel.yPosition == pYPosition + 1 && pSecondPixel.xPosition == pXPosition)
		{
			cout << "Extracting First Pixel For Subtraction" << endl;
			float xPosition = pFirstPixel.xPosition;
			cout << "First Pixel X Position: " << xPosition << endl;
			cout << "First Pixel Y Position:" << pFirstPixel.yPosition << endl;
			cout << "First Pixel Intensity:" << pFirstPixel.pGreyLevel << endl;
			cout << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
			cout << "Second Pixel Pixel Y Position" << pSecondPixel.yPosition << endl;
			cout << "Second Pixel Pixel Intensity" << pSecondPixel.pGreyLevel << endl;
			imageIntensityFunctionX << "Extracting First Pixel For Subtraction" << endl;
			imageIntensityFunctionX << "First Pixel X Position: " << xPosition << endl;
			imageIntensityFunctionX << "First Pixel Y Position:" << pFirstPixel.yPosition << endl;
			imageIntensityFunctionX << "First Pixel Intensity:" << pFirstPixel.pGreyLevel << endl;
			imageIntensityFunctionX << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
			imageIntensityFunctionX << "Second Pixel Pixel Y Position" << pSecondPixel.yPosition << endl;
			imageIntensityFunctionX << "Second Pixel Pixel Intensity" << pSecondPixel.pGreyLevel << endl;
			cout << "Processing Pixel Number: " << pFirstPixel.pixelNumber << endl;
			pixelOneIntensity = pFirstPixel.pGreyLevel;
			pixelTwoIntensity = pSecondPixel.pGreyLevel;
			cout << "Found Neighbouring Pixel" << endl;
			cout << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
			cout << "Greater Neighbour Y" << pSecondPixel.yPosition << endl;
			cout << "Smaller Neighbour X: " << pFirstPixel.xPosition << endl;
			cout << "Smaller Neighbour Y" << pFirstPixel.yPosition << endl;
			cout << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
			cout << "Intentsity of the Second Pixel: " << pixelTwoIntensity << endl;
			pGradientId = pFirstPixel.pixelNumber;
			pGradientXPosition = pSecondPixel.xPosition;
			pGradientYPosition = pSecondPixel.yPosition;

			pGradientValue = abs(pixelTwoIntensity - pixelOneIntensity);
			cout << "Index Value = " << pGradientId << endl;
			cout << "X Position = " << pGradientXPosition << endl;
			cout << "Y Position = " << pGradientYPosition << endl;
			cout << "Gradient Value = " << pGradientValue << endl;
			imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
			imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
			imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
			imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
			CImageDerivativeClass pImageDerivativeClass = CImageDerivativeClass(pGradientId,
				pGradientXPosition, pGradientYPosition, pGradientValue);
			pImageDerivativeClassList.push_back(pImageDerivativeClass);



		}
		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}
		else if (pYPosition == pLastY)
		{
			pXPosition = pXPosition + 1;
			pYPosition = 0;
		}
	
	

		}
		cout << "Listing the Derivative Function Values for the Current Image" << endl;
		for (CImageDerivativeClass pImageDerivativesClass : pImageDerivativeClassList)
		{
			cout << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
			cout << "X Position = " << pImageDerivativesClass.xPosition << endl;
			cout << "Y Position = " << pImageDerivativesClass.yPosition << endl;
			cout << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
			imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
			imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
			imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
			imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
		}
		imageIntensityFunctionX.close();
		*ppImageDerivativeObjectListForX = pImageDerivativeClassList;
		return hr;
	}
	


PixelObjectGrayScale DirectXStandardAlgorithmExecutor::GetNextGreaterPixelByXPosition(vector
	<PixelObjectGrayScale> pPixelGrayScaleList, PixelObjectGrayScale pixelToCompare)
{
	vector<PixelObjectGrayScale> pArrayToSearh = pPixelGrayScaleList;
	PixelObjectGrayScale pSelectedObjectItem = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);
	pSelectedObjectItem.pixelNumber = 0;
	pSelectedObjectItem.xPosition = 0.0f;
	pSelectedObjectItem.yPosition = 0.0f;
	pSelectedObjectItem.pGreyLevel = 0.0f;

	for each (PixelObjectGrayScale pSelectedObject in pArrayToSearh)
	{
		float pXDifference = pSelectedObject.xPosition - pixelToCompare.xPosition;
		if (pXDifference == 1 && (pSelectedObject.yPosition == pixelToCompare.yPosition))
		{
			pSelectedObjectItem = pSelectedObject;
			break;
		}
	}
	return pSelectedObjectItem;
}



PixelObjectGrayScale DirectXStandardAlgorithmExecutor::GetNextGreaterPixelByYPosition(vector<PixelObjectGrayScale> pPixelGrayScaleList, float pXPosition, float pYPosition)
{
	
	PixelObjectGrayScale pSelectedObjectItem = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);


	vector<PixelObjectGrayScale> pArrayToSearh = pPixelGrayScaleList;
	for each (PixelObjectGrayScale pSelectedObject in pArrayToSearh)
	{
		float pYDifference = pSelectedObject.yPosition - pYPosition;
		if (pYDifference == 1 && (pSelectedObject.xPosition == pXPosition))
		{
			pSelectedObjectItem = pSelectedObject;
			break;
		}

	}
	return pSelectedObjectItem;
}

PixelObjectGrayScale DirectXStandardAlgorithmExecutor::GetNextGreaterPixelByXPosition(vector<PixelObjectGrayScale> pPixelGrayScaleList, float pXPosition, float pYPosition)
{
	PixelObjectGrayScale pSelectedObjectItem = PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);


	vector<PixelObjectGrayScale> pArrayToSearh = pPixelGrayScaleList;
	for each (PixelObjectGrayScale pSelectedObject in pArrayToSearh)
	{
		float pXDifference = pSelectedObject.xPosition - pXPosition;
		if (pXDifference == 1 && (pSelectedObject.yPosition == pYPosition))
		{
			pSelectedObjectItem = pSelectedObject;
			break;
		}

	}
	return pSelectedObjectItem;
}


PixelObjectGrayScale DirectXStandardAlgorithmExecutor::GetNextGreaterPixelByYPosition(vector
	<PixelObjectGrayScale> pPixelGrayScaleList, PixelObjectGrayScale pixelToCompare)
{
	PixelObjectGrayScale pSelectedObjectItem =  PixelObjectGrayScale(0, 0.0f, 0.0f, 0.0f);
	

	vector<PixelObjectGrayScale> pArrayToSearh = pPixelGrayScaleList;
	for each (PixelObjectGrayScale pSelectedObject in pArrayToSearh)
	{
		float pYDifference = pSelectedObject.yPosition - pixelToCompare.yPosition;
		if (pYDifference == 1 && (pSelectedObject.xPosition == pixelToCompare.xPosition))
		{
			pSelectedObjectItem = pSelectedObject;
			break;
		}
		
	}
	return pSelectedObjectItem;
}

vector<PixelObjectGrayScale> DirectXStandardAlgorithmExecutor::GetPixelObjectsGrayScaleByYPosition(vector<PixelObjectGrayScale> *pPixelGrayScaleList, float pYPosition)
{
	vector<PixelObjectGrayScale> pPixelObjectGrayscaleValues = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pArrayToSearh = *pPixelGrayScaleList;
	for (PixelObjectGrayScale pSelectedObject : pArrayToSearh)
	{
		if (pSelectedObject.xPosition == pYPosition)
		{
			pPixelObjectGrayscaleValues.push_back(pSelectedObject);
		}
	}

	return pPixelObjectGrayscaleValues;
}













GaussianOutputVar DirectXStandardAlgorithmExecutor::GetNextGaussianValueByXPosition(vector<GaussianOutputVar> pGaussianOutputVector, GaussianOutputVar pGaussianOutputVarToCompare, float pDelta)
{
	GaussianOutputVar pSelectedObjectItem;
	vector<GaussianOutputVar> pArrayToSearh = pGaussianOutputVector;
	for (GaussianOutputVar pSelectedObject : pArrayToSearh)
	{
		float pXDifference = pSelectedObject.xPosition - pGaussianOutputVarToCompare.xPosition;
		if (pXDifference == pDelta && (pSelectedObject.xPosition == pGaussianOutputVarToCompare.xPosition))
		{
			pSelectedObjectItem = pSelectedObject;
		}
	}

	return pSelectedObjectItem;
}

GaussianOutputVar DirectXStandardAlgorithmExecutor::GetNextGaussianValueByYPosition(vector<GaussianOutputVar> pGaussianOutputVector, GaussianOutputVar pGaussianOutputVarToCompare, float pDelta)
{
	GaussianOutputVar pSelectedObjectItem;
	vector<GaussianOutputVar> pArrayToSearh = pGaussianOutputVector;
	for (GaussianOutputVar pSelectedObject : pArrayToSearh)
	{
		float pYDifference = pSelectedObject.xPosition - pGaussianOutputVarToCompare.xPosition;
		if (pYDifference == pDelta && (pSelectedObject.xPosition == pGaussianOutputVarToCompare.xPosition))
		{
			pSelectedObjectItem = pSelectedObject;
		}
	}

	return pSelectedObjectItem;
}




HRESULT DirectXStandardAlgorithmExecutor::ComputeImageDerivativeFunctionForwardForYValuesGaussian(HINSTANCE hInsance,
	HWND hWnd,
	vector<GaussianOutputVar> pGrayScalePixelList,
	float pImageWidth,
	float pImageHeight,
	float pDeltaVar,
	vector<CImageDerivativeClass> *ppImageDerivativeObjectListForX)
{
	HRESULT hr = S_OK;
	UINT pIndexIncrement = 0;
	fstream imageIntensityFunctionX;
	imageIntensityFunctionX.open("C:\\\pixels\\ComputeImageInstensityFunctionForX.txt", fstream::in | fstream::out | fstream::trunc);
	imageIntensityFunctionX.clear();
	cout << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values"
		<< endl;
	imageIntensityFunctionX << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values" << endl;
	float pixelOneIntensity = 0;
	float pixelTwoIntensity = 0;
	float pGradientId = 0;
	float pGradientValue = 0;
	float pGradientXPosition = 0;
	float pGradientYPosition = 0;
	float pXPositionPlus = 0;
	cout << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
	imageIntensityFunctionX << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
	vector<CImageDerivativeClass> pImageDerivativeClassList = vector<CImageDerivativeClass>();
	vector<float> pXPositionValues = vector<float>();
	for (GaussianOutputVar pPixelObjectGrayScale : pGrayScalePixelList)
	{
		float pXPosition = pPixelObjectGrayScale.xPosition;
		pXPositionValues.push_back(pXPosition);
	}
	std::sort(pGrayScalePixelList.begin(), pGrayScalePixelList.end(), &SmallerGaussianXPosition);
	std::cout << "Printing the array data" << endl;
	for (GaussianOutputVar pPixelObject : pGrayScalePixelList)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGaussianValueF << endl;
		imageIntensityFunctionX << "Pixel Number: " << pPixelObject.pixelNumber;
		imageIntensityFunctionX << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Y Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Grey Level: " << pPixelObject.pGaussianValueF << endl;
	}
	for each (GaussianOutputVar pFirstPixel in pGrayScalePixelList)
	{
		cout << "Getting Next X Position Pixels" << endl;
		int pXPosition = pFirstPixel.xPosition;
		int pYPosition = pFirstPixel.xPosition;
		float pLastX = pImageWidth - 1;
		float pLastY = pImageHeight - 1;
		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}
		int pNextYPosition = pYPosition + 1;
		GaussianOutputVar pSecondPixel = GetNextGaussianValueByXPosition(pGrayScalePixelList, pFirstPixel, pDeltaVar);
		cout << "Extracting First Pixel For Subtraction" << endl;
		cout << "First Pixel X Position: " << pFirstPixel.xPosition << endl;
		cout << "First Pixel Y Position:" << pFirstPixel.xPosition << endl;
		cout << "First Pixel Intensity:" << pFirstPixel.pGaussianValueF << endl;
		cout << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
		cout << "Second Pixel Pixel Y Position" << pSecondPixel.xPosition << endl;
		cout << "Second Pixel Pixel Intensity" << pSecondPixel.pGaussianValueF << endl;
		imageIntensityFunctionX << "Extracting First Pixel For Subtraction" << endl;
		imageIntensityFunctionX << "First Pixel X Position: " << pFirstPixel.xPosition << endl;
		imageIntensityFunctionX << "First Pixel Y Position:" << pFirstPixel.xPosition << endl;
		imageIntensityFunctionX << "First Pixel Intensity:" << pFirstPixel.pGaussianValueF << endl;
		imageIntensityFunctionX << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
		imageIntensityFunctionX << "Second Pixel Pixel Y Position" << pSecondPixel.xPosition << endl;
		imageIntensityFunctionX << "Second Pixel Pixel Intensity" << pSecondPixel.pGaussianValueF << endl;
		cout << "Processing Pixel Number: " << pFirstPixel.pixelNumber << endl;
		pixelOneIntensity = pFirstPixel.pGaussianValueF;
		pixelTwoIntensity = pSecondPixel.pGaussianValueF;
		cout << "Found Neighbouring Pixel" << endl;
		cout << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
		cout << "Greater Neighbour Y" << pSecondPixel.xPosition << endl;
		cout << "Smaller Neighbour X: " << pFirstPixel.xPosition << endl;
		cout << "Smaller Neighbour Y" << pFirstPixel.xPosition << endl;
		cout << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
		cout << "Intentsity of the Second Pixel: " << pixelTwoIntensity << endl;
		pGradientId = pIndexIncrement;
		pGradientXPosition = pSecondPixel.xPosition;
		pGradientYPosition = pSecondPixel.xPosition;
		pGradientValue = abs((pixelTwoIntensity - pixelOneIntensity) / pDeltaVar);
		cout << "Index Value = " << pGradientId << endl;
		cout << "X Position = " << pGradientXPosition << endl;
		cout << "Y Position = " << pGradientYPosition << endl;
		cout << "Gradient Value = " << pGradientValue << endl;
		imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
		imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
		imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
		imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
		CImageDerivativeClass pImageDerivativeClass = CImageDerivativeClass(pGradientId,
			pGradientXPosition, pGradientYPosition, pGradientValue);
		pImageDerivativeClassList.push_back(pImageDerivativeClass);
		pGradientId = pGradientId + 1;
	}
	cout << "Listing the Derivative Function Values for the Current Image" << endl;
	for (CImageDerivativeClass pImageDerivativesClass : pImageDerivativeClassList)
	{
		cout << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativesClass.xPosition << endl;
		cout << "Y Position = " << pImageDerivativesClass.yPosition << endl;
		cout << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
		imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
		imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
		imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
		imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
	}
	imageIntensityFunctionX.close();
	*ppImageDerivativeObjectListForX = pImageDerivativeClassList;
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ComputeImageDerivativeFunctionForwardForXValuesGaussian(HINSTANCE hInsance,
	HWND hWnd,
	vector<GaussianOutputVar> pGrayScalePixelList,
	float pImageWidth,
	float pImageHeight,
	float pDeltaVar,
	vector<CImageDerivativeClass> *ppImageDerivativeObjectListForX)
{
	HRESULT hr = S_OK;
	UINT pIndexIncrement = 0;
	fstream imageIntensityFunctionX;
	imageIntensityFunctionX.open("C:\\\pixels\\ComputeImageInstensityFunctionForX.txt", fstream::in | fstream:: out | fstream::trunc);
	imageIntensityFunctionX.clear();
	cout << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values"
		<< endl;
	imageIntensityFunctionX << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image For X Values" << endl;
		float pixelOneIntensity = 0;
	float pixelTwoIntensity = 0;
	float pGradientId = 0;
	float pGradientValue = 0;
	float pGradientXPosition = 0;
	float pGradientYPosition = 0;
	float pXPositionPlus = 0;
	cout << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
	imageIntensityFunctionX << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives For X" << endl;
		vector<CImageDerivativeClass> pImageDerivativeClassList = vector<CImageDerivativeClass>();
	vector<float> pXPositionValues = vector<float>();
	for (GaussianOutputVar pPixelObjectGrayScale : pGrayScalePixelList)
	{
		float pXPosition = pPixelObjectGrayScale.xPosition;
		pXPositionValues.push_back(pXPosition);
	}
	std::sort(pGrayScalePixelList.begin(), pGrayScalePixelList.end(), &SmallerGaussianXPosition);
	std::cout << "Printing the array data" << endl;
	for (GaussianOutputVar pPixelObject : pGrayScalePixelList)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGaussianValueF << endl;
		imageIntensityFunctionX << "Pixel Number: " << pPixelObject.pixelNumber;
		imageIntensityFunctionX << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Y Position: " << pPixelObject.yPosition << endl;
		imageIntensityFunctionX << "Grey Level: " << pPixelObject.pGaussianValueF << endl;
	}
	for each (GaussianOutputVar pFirstPixel in pGrayScalePixelList)
	{
		cout << "Getting Next X Position Pixels" << endl;
		int pXPosition = pFirstPixel.xPosition;
		int pYPosition = pFirstPixel.yPosition;
		float pLastX = pImageWidth - 1;
		float pLastY = pImageHeight - 1;
		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}
		else if (pYPosition == pLastY)
		{
					pXPosition = pXPosition + 1;
					pYPosition = 0;
		}
	
		

		int pNextXPosition = pXPosition + 1;
		GaussianOutputVar pSecondPixel = GetNextGaussianValueByXPosition(pGrayScalePixelList, pFirstPixel, pDeltaVar);
		cout << "Extracting First Pixel For Subtraction" << endl;
		cout << "First Pixel X Position: " << pFirstPixel.xPosition << endl;
		cout << "First Pixel Y Position:" << pFirstPixel.xPosition << endl;
		cout << "First Pixel Intensity:" << pFirstPixel.pGaussianValueF << endl;
		cout << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
		cout << "Second Pixel Pixel Y Position" << pSecondPixel.xPosition << endl;
		cout << "Second Pixel Pixel Intensity" << pSecondPixel.pGaussianValueF << endl;
		imageIntensityFunctionX << "Extracting First Pixel For Subtraction" << endl;
		imageIntensityFunctionX << "First Pixel X Position: " << pFirstPixel.xPosition << endl;
		imageIntensityFunctionX << "First Pixel Y Position:" << pFirstPixel.xPosition << endl;
		imageIntensityFunctionX << "First Pixel Intensity:" << pFirstPixel.pGaussianValueF << endl;
		imageIntensityFunctionX << "Second Pixel Pixel X Position" << pSecondPixel.xPosition << endl;
		imageIntensityFunctionX << "Second Pixel Pixel Y Position" << pSecondPixel.xPosition << endl;
		imageIntensityFunctionX << "Second Pixel Pixel Intensity" << pSecondPixel.pGaussianValueF << endl;
		cout << "Processing Pixel Number: " << pFirstPixel.pixelNumber << endl;
		pixelOneIntensity = pFirstPixel.pGaussianValueF;
		pixelTwoIntensity = pSecondPixel.pGaussianValueF;
		cout << "Found Neighbouring Pixel" << endl;
		cout << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
		cout << "Greater Neighbour Y" << pSecondPixel.xPosition << endl;
		cout << "Smaller Neighbour X: " << pFirstPixel.xPosition << endl;
		cout << "Smaller Neighbour Y" << pFirstPixel.xPosition << endl;
		cout << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
		cout << "Intentsity of the Second Pixel: " << pixelTwoIntensity << endl;
		pGradientId = pIndexIncrement;
		pGradientXPosition = pSecondPixel.xPosition;
		pGradientYPosition = pSecondPixel.xPosition;
		pGradientValue = abs((pixelTwoIntensity - pixelOneIntensity) / pDeltaVar);
		cout << "Index Value = " << pGradientId << endl;
		cout << "X Position = " << pGradientXPosition << endl;
		cout << "Y Position = " << pGradientYPosition << endl;
		cout << "Gradient Value = " << pGradientValue << endl;
		imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
		imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
		imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
		imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
		CImageDerivativeClass pImageDerivativeClass = CImageDerivativeClass(pGradientId,
			pGradientXPosition, pGradientYPosition, pGradientValue);
		pImageDerivativeClassList.push_back(pImageDerivativeClass);
		pGradientId = pGradientId + 1;
	}
	cout << "Listing the Derivative Function Values for the Current Image" << endl;
	for (CImageDerivativeClass pImageDerivativesClass : pImageDerivativeClassList)
	{
		cout << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativesClass.xPosition << endl;
		cout << "Y Position = " << pImageDerivativesClass.yPosition << endl;
		cout << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
		imageIntensityFunctionX << "Index Value = " << pGradientId << endl;
		imageIntensityFunctionX << "X Position = " << pGradientXPosition << endl;
		imageIntensityFunctionX << "Y Position = " << pGradientYPosition << endl;
		imageIntensityFunctionX << "Gradient Value = " << pGradientValue << endl;
	}
	imageIntensityFunctionX.close();
	*ppImageDerivativeObjectListForX = pImageDerivativeClassList;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateImageConvolutionOperationStructuredX(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	UINT pKernelWidth,
	UINT pKernelHeight,
	UINT pOutputImageWidth,
	UINT pOutputImageHeight,
	vector<PixelObjectGrayScale> pCoreImageObject,
	float pFilterArray[3],
	vector<PixelObjectGrayScale> *ppPixelOutputValues)
{
	HRESULT hr = S_OK;
	fstream imageIntensityFunctionX;
	imageIntensityFunctionX.open("C:\\\pixels\\ImageKernelConvolutionOperationSetupInfo.txt", fstream::in | fstream::out | fstream::trunc);
	vector<PixelObjectGrayScale> pImageDerivativeVector = vector<PixelObjectGrayScale>();

	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader For Convolution Operation" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageIntensityFunctionX << "Preparing the Instruments For the Simulation" << endl;
	imageIntensityFunctionX << "They Include: " << endl;
	imageIntensityFunctionX << "1 Compute Shader For Convolution Operation" << endl;
	imageIntensityFunctionX << "1 Constant Buffer" << endl;
	imageIntensityFunctionX << "1 Input Buffer " << endl;
	imageIntensityFunctionX << "1 Output Buffer " << endl;
	imageIntensityFunctionX << "1 Shader Resource View" << endl;
	imageIntensityFunctionX << "1 Unordered Access View" << endl;
	imageIntensityFunctionX << "1 Readback Buffer" << endl;

	cout << "Printing the Initial Data For The Simulation" << endl;
	imageIntensityFunctionX << "Printing the Initial Data For The Simulation" << endl;

	for (PixelObjectGrayScale pImageDerivativeObject : pCoreImageObject)
	{
		cout << "Pixel Index: " << pImageDerivativeObject.pixelNumber << endl;
		cout << "X Position: " << pImageDerivativeObject.xPosition << endl;
		cout << "Y Position: " << pImageDerivativeObject.yPosition << endl;
		cout << "Intensity Value: " << pImageDerivativeObject.pGreyLevel << endl;

		imageIntensityFunctionX << "PixelIndex: " << pImageDerivativeObject.pixelNumber << endl;
		imageIntensityFunctionX << "X Position: " << pImageDerivativeObject.xPosition << endl;
		imageIntensityFunctionX << "Y Position: " << pImageDerivativeObject.xPosition << endl;
		imageIntensityFunctionX << "Intensity Value: " << pImageDerivativeObject.pGreyLevel << endl;
	}

	cout << "Printing The Data For the Convolution" << endl;
	UINT pIndexValue = 0;
	



	ID3D11ComputeShader* ppConvolutionComputeShaderObject = nullptr;
	ID3D11Buffer* ppFilterConstantBuffer = nullptr;
	ID3D11Buffer* pFilterImageDataBuffer = nullptr;
	ID3D11Buffer* ppFilterInputBuffer = nullptr;
	ID3D11Buffer* ppOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViewInput = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViewKernel = nullptr;

	ID3D11UnorderedAccessView* ppUnorderedAccessViewOutput = nullptr;
	ID3D11Buffer* ppReadbackDataBuffer = nullptr;

	cout << "Our First Step Is To Initialize Our resources for Kernel Convolution" << endl;
	imageIntensityFunctionX << "Our First Step Is To Initialize Our resources for Kernel Convolution" << endl;

	CbConvolultionBuffer pKernelConvolutionConstantBuffer;
	pKernelConvolutionConstantBuffer.pImageHeight = pImageHeight;
	pKernelConvolutionConstantBuffer.pImageWidth = pImageWidth;
	pKernelConvolutionConstantBuffer.pFilterHeight = 3;
	pKernelConvolutionConstantBuffer.pFilterWidth = 3;
	pKernelConvolutionConstantBuffer.pOutputHeight = pOutputImageHeight;
	pKernelConvolutionConstantBuffer.pOutputWidth = pOutputImageWidth;
	pKernelConvolutionConstantBuffer.pFilterArrayVal[0] = pFilterArray[0];
	pKernelConvolutionConstantBuffer.pFilterArrayVal[1] = pFilterArray[1];
	pKernelConvolutionConstantBuffer.pFilterArrayVal[2] = pFilterArray[2];


	vector<ImageKernelItem> pImageKernelItems = vector<ImageKernelItem>();

	



	hr = InitializeImageConvolutionResourcesStructuredX(hInstance,
		hWnd, pKernelConvolutionConstantBuffer,
		&ppConvolutionComputeShaderObject,
		pCoreImageObject,
		&ppFilterConstantBuffer,
		&pFilterImageDataBuffer,
		&ppOutputDataBuffer,
		&ppShaderResourceViewInput,
		&ppUnorderedAccessViewOutput,
		&ppReadbackDataBuffer);

	



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		imageIntensityFunctionX << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		return hr;
	}

	cout << "Launching Our Computing Simulation Operation" << endl;
	imageIntensityFunctionX << "Launching Our Computing Simulation Operation" << endl;


	hr = RunConvolutionOperationsStructured(hInstance, hWnd, ppFilterConstantBuffer,
		ppConvolutionComputeShaderObject,
		ppShaderResourceViewInput,
		ppUnorderedAccessViewOutput, 2, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		imageIntensityFunctionX << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		return hr;
	}

	cout << "Copying the Output From the Output Buffer To The Readback Buffer " << endl;
	D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };

	cout << "Exporting the Data For Read/Write CPU Access" << endl;

	m_pD3DCompContext->CopyResource(ppReadbackDataBuffer, ppOutputDataBuffer);
	hr = m_pD3DCompContext->Map(ppReadbackDataBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);
	

	// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
	// This is also a common trick to debug CS programs.



	// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
	// This is also a common trick to debug CS programs.
	PixelObjectGrayScale* ppOutputComputationsData = (PixelObjectGrayScale*)MappedResource.pData;
	for (int i = 0; i <pCoreImageObject.size(); ++i)
	{
		pImageDerivativeVector.push_back(ppOutputComputationsData[i]);
	}





	std::time_t t = std::time(0);   // get time now
	std::tm* now = std::localtime(&t);
	std::cout << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;

	// Verify that if Compute Shader has done right
	printf("Verifying against CPU result...");
	bool bSuccess = true;
	int iIndex = 0;
	for (PixelObjectGrayScale pPixelObject : pImageDerivativeVector)
	{
		cout << "Gradient Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Output Value: " << pPixelObject.pGreyLevel << endl;


		imageIntensityFunctionX << "Gradient Number: " << pPixelObject.pixelNumber << endl;
		imageIntensityFunctionX << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionX << "Y Position: " << pPixelObject.yPosition << endl;
		imageIntensityFunctionX << "Output Value: " << pPixelObject.pGreyLevel << endl;

	}
	if (bSuccess)
		printf("succeeded\n");
	t = std::time(0);   // get time now
	now = std::localtime(&t);
	std::cout << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;
	imageIntensityFunctionX << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;



	

	printf("Cleaning up...\n");

	SafeReleaseA(&ppConvolutionComputeShaderObject);
	SafeReleaseA(&ppFilterConstantBuffer);
	SafeReleaseA(&ppFilterInputBuffer);
	SafeReleaseA(&ppOutputDataBuffer);
	SafeReleaseA(&ppUnorderedAccessViewOutput);
	SafeReleaseA(&ppReadbackDataBuffer);

	imageIntensityFunctionX.close();
	*ppPixelOutputValues = pImageDerivativeVector;







	return hr;


}


HRESULT DirectXStandardAlgorithmExecutor::SimulateImageConvolutionOperationStructuredY(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	UINT pKernelWidth,
	UINT pKernelHeight,
	UINT pOutputImageWidth,
	UINT pOutputImageHeight,
	vector<PixelObjectGrayScale> pCoreImageObject,
	float pFilterArray[3],
	vector<PixelObjectGrayScale> *ppPixelOutputValues)
{
	HRESULT hr = S_OK;
	fstream imageIntensityFunctionY;
	imageIntensityFunctionY.open("C:\\\pixels\\ImageKernelConvolutionOperationSetupInfo.txt", fstream::in | fstream::out | fstream::trunc);
	vector<PixelObjectGrayScale> pImageDerivativeVector = vector<PixelObjectGrayScale>();

	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader For Convolution Operation" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageIntensityFunctionY << "Preparing the Instruments For the Simulation" << endl;
	imageIntensityFunctionY << "They Include: " << endl;
	imageIntensityFunctionY << "1 Compute Shader For Convolution Operation" << endl;
	imageIntensityFunctionY << "1 Constant Buffer" << endl;
	imageIntensityFunctionY << "1 Input Buffer " << endl;
	imageIntensityFunctionY << "1 Output Buffer " << endl;
	imageIntensityFunctionY << "1 Shader Resource View" << endl;
	imageIntensityFunctionY << "1 Unordered Access View" << endl;
	imageIntensityFunctionY << "1 Readback Buffer" << endl;

	cout << "Printing the Initial Data For The Simulation" << endl;
	imageIntensityFunctionY << "Printing the Initial Data For The Simulation" << endl;

	for (PixelObjectGrayScale pImageDerivativeObject : pCoreImageObject)
	{
		cout << "Pixel Index: " << pImageDerivativeObject.pixelNumber << endl;
		cout << "X Position: " << pImageDerivativeObject.xPosition << endl;
		cout << "Y Position: " << pImageDerivativeObject.yPosition << endl;
		cout << "Intensity Value: " << pImageDerivativeObject.pGreyLevel << endl;

		imageIntensityFunctionY << "PixelIndex: " << pImageDerivativeObject.pixelNumber << endl;
		imageIntensityFunctionY << "X Position: " << pImageDerivativeObject.xPosition << endl;
		imageIntensityFunctionY << "Y Position: " << pImageDerivativeObject.xPosition << endl;
		imageIntensityFunctionY << "Intensity Value: " << pImageDerivativeObject.pGreyLevel << endl;
	}

	cout << "Printing The Data For the Convolution" << endl;
	UINT pIndexValue = 0;




	ID3D11ComputeShader* ppConvolutionComputeShaderObject = nullptr;
	ID3D11Buffer* ppFilterConstantBuffer = nullptr;
	ID3D11Buffer* pFilterImageDataBuffer = nullptr;
	ID3D11Buffer* ppOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViewInput = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViewKernel = nullptr;

	ID3D11UnorderedAccessView* ppUnorderedAccessViewOutput = nullptr;
	ID3D11Buffer* ppReadbackDataBuffer = nullptr;

	cout << "Our First Step Is To Initialize Our resources for Kernel Convolution" << endl;
	imageIntensityFunctionY << "Our First Step Is To Initialize Our resources for Kernel Convolution" << endl;

	CbConvolultionBuffer pKernelConvolutionConstantBuffer;
	pKernelConvolutionConstantBuffer.pImageHeight = pImageHeight;
	pKernelConvolutionConstantBuffer.pImageWidth = pImageWidth;
	pKernelConvolutionConstantBuffer.pFilterHeight = 3;
	pKernelConvolutionConstantBuffer.pFilterWidth = 3;
	pKernelConvolutionConstantBuffer.pOutputHeight = pOutputImageHeight;
	pKernelConvolutionConstantBuffer.pOutputWidth = pOutputImageWidth;



	vector<ImageKernelItem> pImageKernelItems = vector<ImageKernelItem>();





	hr = InitializeImageConvolutionResourcesStructuredY(hInstance,
		hWnd, pKernelConvolutionConstantBuffer,
		&ppConvolutionComputeShaderObject,
		pCoreImageObject,
		&ppFilterConstantBuffer,
		&pFilterImageDataBuffer,
		&ppOutputDataBuffer,
		&ppShaderResourceViewInput,
		&ppUnorderedAccessViewOutput,
		&ppReadbackDataBuffer);





	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		imageIntensityFunctionY << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		return hr;
	}

	cout << "Launching Our Computing Simulation Operation" << endl;
	imageIntensityFunctionY << "Launching Our Computing Simulation Operation" << endl;


	hr = RunConvolutionOperationsStructured(hInstance, hWnd, ppFilterConstantBuffer,
		ppConvolutionComputeShaderObject,
		ppShaderResourceViewInput,
		ppUnorderedAccessViewOutput, 2, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		imageIntensityFunctionY << "Unable to Initialize the Resources for Image Convolution Operation" << endl;
		return hr;
	}

	cout << "Copying the Output From the Output Buffer To The Readback Buffer " << endl;
	D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };

	cout << "Exporting the Data For Read/Write CPU Access" << endl;

	m_pD3DCompContext->CopyResource(ppReadbackDataBuffer, ppOutputDataBuffer);
	hr = m_pD3DCompContext->Map(ppReadbackDataBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


	// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
	// This is also a common trick to debug CS programs.



	// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
	// This is also a common trick to debug CS programs.
	PixelObjectGrayScale* ppOutputComputationsData = (PixelObjectGrayScale*)MappedResource.pData;
	for (int i = 0; i < pCoreImageObject.size(); ++i)
	{
		pImageDerivativeVector.push_back(ppOutputComputationsData[i]);
	}





	std::time_t t = std::time(0);   // get time now
	std::tm* now = std::localtime(&t);
	std::cout << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;

	// Verify that if Compute Shader has done right
	printf("Verifying against CPU result...");
	bool bSuccess = true;
	int iIndex = 0;
	for (PixelObjectGrayScale pPixelObject : pImageDerivativeVector)
	{
		cout << "Gradient Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Output Value: " << pPixelObject.pGreyLevel << endl;


		imageIntensityFunctionY << "Gradient Number: " << pPixelObject.pixelNumber << endl;
		imageIntensityFunctionY << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionY << "Y Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionY << "Output Value: " << pPixelObject.pGreyLevel << endl;

	}
	if (bSuccess)
		printf("succeeded\n");
	t = std::time(0);   // get time now
	now = std::localtime(&t);
	std::cout << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;
	imageIntensityFunctionY << (now->tm_year + 1900) << '-'
		<< (now->tm_mon + 1) << '-'
		<< now->tm_mday
		<< now->tm_hour
		<< now->tm_min
		<< now->tm_sec
		<< endl;





	printf("Cleaning up...\n");

	SafeReleaseA(&ppConvolutionComputeShaderObject);
	SafeReleaseA(&ppFilterConstantBuffer);
	SafeReleaseA(&pFilterImageDataBuffer);
	SafeReleaseA(&ppOutputDataBuffer);
	SafeReleaseA(&ppUnorderedAccessViewOutput);
	SafeReleaseA(&ppReadbackDataBuffer);

	imageIntensityFunctionY.close();
	*ppPixelOutputValues = pImageDerivativeVector;







	return hr;


}





HRESULT DirectXStandardAlgorithmExecutor::ComputeSecondOrderDerivativeFoxXValues(HINSTANCE hInsance,
	HWND hWnd,
	vector<CImageDerivativeClass> pGrayScalePixelList,
	float pImageWidth,
	float pImageHeight,
	vector<CImageDerivativeClass> *ppImageDerivativeObjectListForYValues)
{
	
	HRESULT hr = S_OK;
	UINT pIndexIncrement = 0;
	fstream imageIntensityFunctionY;
	imageIntensityFunctionY.open("C:\\\pixels\\SeconOrderDerivativeY.txt", fstream::in | fstream::out | fstream::trunc);
	imageIntensityFunctionY.clear();
	cout << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image" << endl;
	imageIntensityFunctionY << "This Method Will Perform the Discrete Differentiation of A Grayscale BinaryImage" << endl;
	float pixelOneIntensity = 0;
	float pixelTwoIntensity = 0;
	float pGradientId = 0;
	float pGradientValue = 0;
	float pGradientXPosition = 0;
	float pGradientYPosition = 0;
	float pYPositionPlus = 0;
	cout << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives" << endl;
	imageIntensityFunctionY << "This Function Will Loop Through The Pixel Array Object And Compute	Derivatives" << endl;

	std::sort(pGrayScalePixelList.begin(), pGrayScalePixelList.end(), &SmallerGradientYPosition);
	for (CImageDerivativeClass pPixelObject : pGrayScalePixelList)
	{
		cout << "Derivative Number: " << pPixelObject.pDerivativeIndex << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Value: " << pPixelObject.pDerivativeValue << endl;
		imageIntensityFunctionY << "Derivative Number: " << pPixelObject.pDerivativeIndex << endl;
		imageIntensityFunctionY << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionY << "Y Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionY << "Value: " << pPixelObject.pDerivativeValue << endl;
	}
	vector<CImageDerivativeClass> pImageDerivativeClassList = vector<CImageDerivativeClass>();
	for each (CImageDerivativeClass pPixelObject in pGrayScalePixelList)
	{
		int pXPosition = pPixelObject.xPosition;
		int pYPosition = pPixelObject.xPosition;
		float pLastX = pImageWidth - 1;
		float pLastY = pImageHeight - 1;
		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}
		if (pYPosition == pLastY)
		{
			pLastY = pLastY + 1;
			pXPosition = 0;
		}
		else
		{
			int pNextXPosition = pXPosition + 1;
			CImageDerivativeClass pSecondPixel = GetNextImageDerivativeByYPosition(pGrayScalePixelList, pPixelObject);

			if (pSecondPixel.xPosition == pNextXPosition && pSecondPixel.yPosition == pPixelObject.xPosition)
			{
				cout << "Extracting First Derivative For Subtraction" << endl;
				cout << "First  Derivative X Position: " << pPixelObject.xPosition;
				cout << "First  Derivative Y Position:" << pPixelObject.xPosition;
				cout << "First  Derivative Intensity:" << pPixelObject.pDerivativeValue;
				cout << "Extracting Second  Derivative For Subtraction" << endl;
				cout << "Second  Derivative X Position" << pSecondPixel.xPosition << endl;
				cout << "Second  Derivative Y Position" << pSecondPixel.yPosition << endl;
				cout << "Second  Derivative Intensity" << pSecondPixel.pDerivativeValue << endl;

				imageIntensityFunctionY << "Extracting First Derivative For Subtraction" << endl;
				imageIntensityFunctionY << "First Derivative X Position: " << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "First Derivative Y Position:" << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "First Derivative Intensity:" << pPixelObject.pDerivativeValue << endl;
				imageIntensityFunctionY << "Extracting Second Derivative For Subtraction" << endl;
				imageIntensityFunctionY << "Second Pixel Derivative X Position" << pSecondPixel.xPosition << endl;
				imageIntensityFunctionY << "Second Pixel Derivative Y Position" << pSecondPixel.yPosition << endl;
				imageIntensityFunctionY << "Second Pixel Derivative Intensity" << pSecondPixel.pDerivativeValue << endl;

				cout << "Processing Pixel Number: " << pPixelObject.pDerivativeIndex << endl;
				imageIntensityFunctionY << "Processing Pixel Number: " << pPixelObject.pDerivativeIndex << endl;
				pixelOneIntensity = pPixelObject.pDerivativeValue;
				pixelTwoIntensity = pSecondPixel.pDerivativeValue;
				cout << "Found Neighbouring Pixel" << endl;
				cout << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
				cout << "Greater Neighbour Y" << pSecondPixel.yPosition << endl;
				cout << "Smaller Neighbour X: " << pPixelObject.xPosition << endl;
				cout << "Smaller Neighbour Y" << pPixelObject.pDerivativeIndex << endl;
				cout << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
				cout << "Intensity of the Second Pixel: " << pixelTwoIntensity << endl;

				imageIntensityFunctionY << "Found Neighbouring Pixel" << endl;
				imageIntensityFunctionY << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
				imageIntensityFunctionY << "Greater Neighbour Y" << pSecondPixel.yPosition << endl;
				imageIntensityFunctionY << "Smaller Neighbour X: " << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "Smaller Neighbour Y: " << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
				imageIntensityFunctionY << "Intensity of the Second Pixel: " << pixelTwoIntensity << endl;

				pGradientXPosition = pSecondPixel.xPosition;
				pGradientYPosition = pSecondPixel.yPosition;
				pGradientValue = abs(pixelTwoIntensity - pixelOneIntensity);
				cout << "Index Value = " << pGradientId << endl;
				cout << "X Position = " << pGradientXPosition << endl;
				cout << "Y Position = " << pGradientYPosition << endl;
				cout << "Gradient Value = " << pGradientValue << endl;
				imageIntensityFunctionY << "Index Value = " << pGradientId << endl;
				imageIntensityFunctionY << "X Position = " << pGradientXPosition << endl;
				imageIntensityFunctionY << "Y Position = " << pGradientYPosition << endl;
				imageIntensityFunctionY << "Gradient Value = " << pGradientValue << endl;
				CImageDerivativeClass pImageDerivativeClass = CImageDerivativeClass(pGradientId,
					pXPosition, pYPosition, pGradientValue);
				pImageDerivativeClassList.push_back(pImageDerivativeClass);
				pGradientId = pGradientId + 1;
			}
		}
		cout << "Listing the Derivative Function Values for the Current Image" << endl;
		for (CImageDerivativeClass pImageDerivativesClass : pImageDerivativeClassList)
		{
			cout << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
			cout << "X Position = " << pImageDerivativesClass.xPosition << endl;
			cout << "Y Position = " << pImageDerivativesClass.yPosition << endl;
			cout << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
			imageIntensityFunctionY << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
			imageIntensityFunctionY << "X Position = " << pImageDerivativesClass.xPosition << endl;
			imageIntensityFunctionY << "Y Position = " << pImageDerivativesClass.yPosition << endl;
			imageIntensityFunctionY << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
		}
	}
	imageIntensityFunctionY.close();
	*ppImageDerivativeObjectListForYValues = pImageDerivativeClassList;
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ComputeSecondOrderDerivativeFoxYValues(HINSTANCE hInsance,
	HWND hWnd,
	vector<CImageDerivativeClass> pGrayScalePixelList,
	float pImageWidth,
	float pImageHeight,
	vector<CImageDerivativeClass> *ppImageDerivativeObjectListForYValues)
{
	HRESULT hr = S_OK;
	UINT pIndexIncrement = 0;
	fstream imageIntensityFunctionY;
	imageIntensityFunctionY.open("C:\\\pixels\\SeconOrderDerivativeY.txt", fstream::in | fstream::out | fstream::trunc);
	imageIntensityFunctionY.clear();
	cout << "This Method Will Perform the Discrete Differentiation of A Grayscale Binary Image" << endl;
	imageIntensityFunctionY << "This Method Will Perform the Discrete Differentiation of A Grayscale BinaryImage" << endl;
	float pixelOneIntensity = 0;
	float pixelTwoIntensity = 0;
	float pGradientId = 0;
	float pGradientValue = 0;
	float pGradientXPosition = 0;
	float pGradientYPosition = 0;
	float pYPositionPlus = 0;
	cout << "This Function Will Loop Through The Pixel Array Object And Compute Derivatives" << endl;
	imageIntensityFunctionY << "This Function Will Loop Through The Pixel Array Object And Compute	Derivatives" << endl;

	std::sort(pGrayScalePixelList.begin(), pGrayScalePixelList.end(), &SmallerGradientYPosition);
	for (CImageDerivativeClass pPixelObject : pGrayScalePixelList)
	{
		cout << "Derivative Number: " << pPixelObject.pDerivativeIndex << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.xPosition << endl;
		cout << "Value: " << pPixelObject.pDerivativeValue << endl;
		imageIntensityFunctionY << "Derivative Number: " << pPixelObject.pDerivativeIndex << endl;
		imageIntensityFunctionY << "X Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionY << "Y Position: " << pPixelObject.xPosition << endl;
		imageIntensityFunctionY << "Value: " << pPixelObject.pDerivativeValue << endl;
	}
	vector<CImageDerivativeClass> pImageDerivativeClassList = vector<CImageDerivativeClass>();
	for each (CImageDerivativeClass pPixelObject in pGrayScalePixelList)
	{
		int pXPosition = pPixelObject.xPosition;
		int pYPosition = pPixelObject.xPosition;
		float pLastX = pImageWidth - 1;
		float pLastY = pImageHeight - 1;

		if ((pXPosition == pLastX) && (pYPosition == pLastY))
		{
			break;
		}
	
		
		else 
		{

			if (pYPosition == pLastY)
			{
				pYPosition = 0;
				pXPosition = pXPosition + 1;
			}
			int pNextYPosition = pYPosition + 1;
			CImageDerivativeClass pSecondPixel = GetNextImageDerivativeByYPosition(pGrayScalePixelList, pPixelObject);

			if (pSecondPixel.yPosition == pNextYPosition && pSecondPixel.xPosition == pXPosition)
			{
				cout << "Extracting First Derivative For Subtraction" << endl;
				cout << "First  Derivative X Position: " << pPixelObject.xPosition;
				cout << "First  Derivative Y Position:" << pPixelObject.xPosition;
				cout << "First  Derivative Intensity:" << pPixelObject.pDerivativeValue;
				cout << "Extracting Second  Derivative For Subtraction" << endl;
				cout << "Second  Derivative X Position" << pSecondPixel.xPosition << endl;
				cout << "Second  Derivative Y Position" << pSecondPixel.yPosition << endl;
				cout << "Second  Derivative Intensity" << pSecondPixel.pDerivativeValue << endl;

				imageIntensityFunctionY << "Extracting First Derivative For Subtraction" << endl;
				imageIntensityFunctionY << "First Derivative X Position: " << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "First Derivative Y Position:" << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "First Derivative Intensity:" << pPixelObject.pDerivativeValue << endl;
				imageIntensityFunctionY << "Extracting Second Derivative For Subtraction" << endl;
				imageIntensityFunctionY << "Second Pixel Derivative X Position" << pSecondPixel.xPosition << endl;
				imageIntensityFunctionY << "Second Pixel Derivative Y Position" << pSecondPixel.yPosition << endl;
				imageIntensityFunctionY << "Second Pixel Derivative Intensity" << pSecondPixel.pDerivativeValue << endl;

				cout << "Processing Pixel Number: " << pPixelObject.pDerivativeIndex << endl;
				imageIntensityFunctionY << "Processing Pixel Number: " << pPixelObject.pDerivativeIndex << endl;
				pixelOneIntensity = pPixelObject.pDerivativeValue;
				pixelTwoIntensity = pSecondPixel.pDerivativeValue;
				cout << "Found Neighbouring Pixel" << endl;
				cout << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
				cout << "Greater Neighbour Y" << pSecondPixel.yPosition << endl;
				cout << "Smaller Neighbour X: " << pPixelObject.xPosition << endl;
				cout << "Smaller Neighbour Y" << pPixelObject.pDerivativeIndex << endl;
				cout << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
				cout << "Intensity of the Second Pixel: " << pixelTwoIntensity << endl;

				imageIntensityFunctionY << "Found Neighbouring Pixel" << endl;
				imageIntensityFunctionY << "Greater Neighbour X: " << pSecondPixel.xPosition << endl;
				imageIntensityFunctionY << "Greater Neighbour Y" << pSecondPixel.yPosition << endl;
				imageIntensityFunctionY << "Smaller Neighbour X: " << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "Smaller Neighbour Y: " << pPixelObject.xPosition << endl;
				imageIntensityFunctionY << "Intensity of the First Pixel: " << pixelOneIntensity << endl;
				imageIntensityFunctionY << "Intensity of the Second Pixel: " << pixelTwoIntensity << endl;
				
				pGradientXPosition = pSecondPixel.xPosition;
				pGradientYPosition = pSecondPixel.yPosition;
				pGradientValue = abs(pixelTwoIntensity - pixelOneIntensity);
				cout << "Index Value = " << pGradientId << endl;
				cout << "X Position = " << pGradientXPosition << endl;
				cout << "Y Position = " << pGradientYPosition << endl;
				cout << "Gradient Value = " << pGradientValue << endl;
				imageIntensityFunctionY << "Index Value = " << pGradientId << endl;
				imageIntensityFunctionY << "X Position = " << pGradientXPosition << endl;
				imageIntensityFunctionY << "Y Position = " << pGradientYPosition << endl;
				imageIntensityFunctionY << "Gradient Value = " << pGradientValue << endl;
				CImageDerivativeClass pImageDerivativeClass = CImageDerivativeClass(pGradientId,
					pGradientXPosition, pGradientYPosition, pGradientValue);
				pImageDerivativeClassList.push_back(pImageDerivativeClass);
				pGradientId = pGradientId + 1;
			}
		}
		cout << "Listing the Derivative Function Values for the Current Image" << endl;
		for (CImageDerivativeClass pImageDerivativesClass : pImageDerivativeClassList)
		{
			cout << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
			cout << "X Position = " << pImageDerivativesClass.xPosition << endl;
			cout << "Y Position = " << pImageDerivativesClass.yPosition << endl;
			cout << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
			imageIntensityFunctionY << "Index Value = " << pImageDerivativesClass.pDerivativeIndex << endl;
			imageIntensityFunctionY << "X Position = " << pImageDerivativesClass.xPosition << endl;
			imageIntensityFunctionY << "Y Position = " << pImageDerivativesClass.yPosition << endl;
			imageIntensityFunctionY << "Gradient Value = " << pImageDerivativesClass.pDerivativeValue << endl;
		}
	}
	imageIntensityFunctionY.close();
	*ppImageDerivativeObjectListForYValues = pImageDerivativeClassList;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ComputeImageFunctionDerivativesFinalGPU(HINSTANCE hInstance,
	HWND hWnd,
	vector<CImageDerivativeClass> ppImageDerivativeObjectListForX,
	vector<CImageDerivativeClass> ppImageDerivativeObjectListForY,
	vector<CImageFullDerivativeClassStruct> *pFullDerivativesClass)
{
	HRESULT hr = S_OK;
	fstream imageIntensityFunctionY;
	imageIntensityFunctionY.open("C:\\\pixels\\ComputeImageInstensityGradientsGPU.txt", fstream::in | fstream::out | fstream::trunc);
	imageIntensityFunctionY.clear();

	vector<CImageDerivativeClassStruct> ppGradientXStructureVector = vector<CImageDerivativeClassStruct>();
	vector<CImageDerivativeClassStruct> ppGradientYStructureVector = vector<CImageDerivativeClassStruct>();
	vector<CImageFullDerivativeClassStruct> ppOutputGradientFunctionVector = vector<CImageFullDerivativeClassStruct>();


	cout << "This function will be used to compute common gradient function for selected image" << endl;
	imageIntensityFunctionY << "This function will be used to compute common gradient function for selected image" << endl;

	cout << "This Function Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "2 Input Buffers" << endl;
	cout << "2 Shader Resource Views" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageIntensityFunctionY << "This Function Will Use" << endl;
	imageIntensityFunctionY << "1 Compute Shader" << endl;
	imageIntensityFunctionY << "2 Input Buffers" << endl;
	imageIntensityFunctionY << "2 Shader Resource Views" << endl;
	imageIntensityFunctionY << "1 Unordered Access View" << endl;
	imageIntensityFunctionY << "1 Readback Buffer" << endl;


	ID3D11ComputeShader* ppComputeShaderGradients = nullptr;
	ID3D11Buffer* ppInputBufferObjectGradientsX = nullptr;
	ID3D11Buffer* ppInputBufferObjectGradientsY = nullptr;
	ID3D11Buffer* ppOutputBufferObjectGradients = nullptr;
	ID3D11ShaderResourceView* ppInputBufferSRV1 = nullptr;
	ID3D11ShaderResourceView* ppInputBufferSRV2 = nullptr;
	ID3D11UnorderedAccessView* ppOutputBufferUAV = nullptr;
	ID3D11Buffer* ppReadbackObjectBuffer = nullptr;



	cout << "First We will Print the Data for Our Gradient function Compute " << endl;
	imageIntensityFunctionY << "First We will Print the Data for Our Gradient function Compute " << endl;

	for (CImageDerivativeClass pImageDerivativeXObject : ppImageDerivativeObjectListForX)
	{
		CImageDerivativeClass pImageFunctionDerivativeObjectX = pImageDerivativeXObject;
		float pXPosition0 = pImageFunctionDerivativeObjectX.xPosition;
		float pYPosition0 = pImageFunctionDerivativeObjectX.yPosition;

		CImageDerivativeClass pImageFunctionDerivativeObjectY = GetImageDerivativeObjectByXAndYPosition(ppImageDerivativeObjectListForY, pXPosition0, pYPosition0);

		int pIdValue = pImageFunctionDerivativeObjectX.pDerivativeIndex;
		int pIdValueY = pImageFunctionDerivativeObjectY.pDerivativeIndex;
	
		


		float pXPosition1 = pImageFunctionDerivativeObjectY.xPosition;
		float pYPosition1 = pImageFunctionDerivativeObjectY.yPosition;
		float pGradientXValue = pImageFunctionDerivativeObjectX.pDerivativeValue;
		float pGradientYValue = pImageFunctionDerivativeObjectY.pDerivativeValue;

		cout << "Gradient G(X) X Position = " << pXPosition0 << endl;
		cout << "Gradient G(X) Y Position = " << pYPosition0 << endl;
		cout << "Gradient G(X) Value = " << pImageFunctionDerivativeObjectX.pDerivativeValue << endl;


		cout << "Gradient G(Y) X Position = " << pXPosition1 << endl;
		cout << "Gradient G(Y) Y Position = " << pXPosition1 << endl;
		cout << "Gradient G(Y) Value = " << pImageFunctionDerivativeObjectY.pDerivativeValue << endl;


		imageIntensityFunctionY << "Gradient G(X) X Position = " << pXPosition0 << endl;
		imageIntensityFunctionY << "Gradient G(X) Y Position = " << pYPosition0 << endl;
		imageIntensityFunctionY << "Gradient G(X) Value = " << pImageFunctionDerivativeObjectX.pDerivativeValue << endl;
		imageIntensityFunctionY << "Gradient G(Y) X Position = " << pXPosition1 << endl;
		imageIntensityFunctionY << "Gradient G(Y) Y Position = " << pYPosition1 << endl;
		imageIntensityFunctionY << "Gradient G(Y) Value = " << pImageFunctionDerivativeObjectY.pDerivativeValue << endl;

		CImageDerivativeClassStruct pXPositionStruct = CImageDerivativeClassStruct(pIdValue,
			pXPosition0, pYPosition0, pGradientXValue);

		CImageDerivativeClassStruct pYPositionStruct = CImageDerivativeClassStruct(pIdValue,
			pXPosition1, pYPosition1, pGradientYValue);

		ppGradientXStructureVector.push_back(pXPositionStruct);
		ppGradientYStructureVector.push_back(pYPositionStruct);
	}

	cout << "Initializing our Resource Objects" << endl;
	imageIntensityFunctionY << "Initializing our Resource Objects" << endl;

	hr = InitializeComputeFinalDerivativesResources(hInstance,
		hWnd,
		ppGradientXStructureVector,
		ppGradientYStructureVector,
		&ppComputeShaderGradients,
		&ppInputBufferObjectGradientsX,
		&ppInputBufferObjectGradientsY,
		&ppOutputBufferObjectGradients,
		&ppInputBufferSRV1,
		&ppInputBufferSRV2,
		&ppOutputBufferUAV,
		&ppReadbackObjectBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Derivatives Resources Error:" << pLastError << endl;
		imageIntensityFunctionY << "Unable to Initialize Image Derivatives Resources Error:" << pLastError << endl;
		return hr;
	}

	cout << "Ruunning Our Simulated Function" << endl;
	imageIntensityFunctionY << "Ruunning Our Simulated Function" << endl;

	ID3D11ShaderResourceView* ppShaderResourceViews[] = { ppInputBufferSRV1, ppInputBufferSRV2 };

	hr == RunComputeOfDerivativeValues(hInstance, hWnd, ppComputeShaderGradients,
		ppInputBufferSRV1, ppInputBufferSRV2, ppOutputBufferUAV, 2, 1, 256, 1, 1);

	cout << "Copying the Results from GPU to CPU" << endl;
	imageIntensityFunctionY << "Copying the Results from GPU to CPU" << endl;

	m_pD3DCompContext->CopyResource(ppReadbackObjectBuffer, ppOutputBufferObjectGradients);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The ResourceS For the Simulation Error: " << pLastError << endl;
		imageIntensityFunctionY << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageIntensityFunctionY.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;
	imageIntensityFunctionY << "Compute Simulation has been Completed" << endl;
	imageIntensityFunctionY <<  "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;


	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		hr = m_pD3DCompContext->Map(ppReadbackObjectBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		CImageFullDerivativeClassStruct* p = (CImageFullDerivativeClassStruct*)MappedResource.pData;
		for (int i = 0; i < ppGradientXStructureVector.size(); ++i)
		{
			ppOutputGradientFunctionVector.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (CImageFullDerivativeClassStruct pPixelObject : ppOutputGradientFunctionVector)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Derivative Number: " << pPixelObject.pDerivativeIndex << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Gradient X Value: " << pPixelObject.pDerivativeValueX << endl;
			cout << "Gradient Y Value: " << pPixelObject.pDerivativeValueY << endl;
			cout << "Magnitude: " << pPixelObject.pMagnitude << endl;
			cout << "Direction: " << pPixelObject.pDirection << endl;


			imageIntensityFunctionY << "Index = " << iIndex << endl;
			imageIntensityFunctionY << "Derivative Number: " << pPixelObject.pDerivativeIndex << endl;
			imageIntensityFunctionY << "X Position: " << pPixelObject.xPosition << endl;
			imageIntensityFunctionY << "Y Position: " << pPixelObject.xPosition << endl;
			imageIntensityFunctionY << "Gradient X Value: " << pPixelObject.pDerivativeValueX << endl;
			imageIntensityFunctionY << "Gradient Y Value: " << pPixelObject.pDerivativeValueY << endl;
			imageIntensityFunctionY << "Magnitude: " << pPixelObject.pMagnitude << endl;
			imageIntensityFunctionY << "Direction: " << pPixelObject.pDirection << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageIntensityFunctionY << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderGradients);
	SafeReleaseA(&ppInputBufferObjectGradientsX);
	SafeReleaseA(&ppInputBufferObjectGradientsY);
	SafeReleaseA(&ppOutputBufferObjectGradients);
	SafeReleaseA(&ppInputBufferSRV1);
	SafeReleaseA(&ppInputBufferSRV2);
	SafeReleaseA(&ppOutputBufferUAV);
	SafeReleaseA(&ppReadbackObjectBuffer);

	imageIntensityFunctionY.close();
	*pFullDerivativesClass = ppOutputGradientFunctionVector;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeComputeFinalDerivativesResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<CImageDerivativeClassStruct> ppImageDerivativeObjectListForX,
	vector<CImageDerivativeClassStruct> ppImageDerivativeObjectListForY,
	ID3D11ComputeShader** ppComputeDerivaticesCSShader,
	ID3D11Buffer** ppBufferForArrayOne,
	ID3D11Buffer** ppBufferForArrayTwo,
	ID3D11Buffer** ppComputeImageDerivativeOutput,
	ID3D11ShaderResourceView** ppShaderResourceView0,
	ID3D11ShaderResourceView** ppShaderResourceView1,
	ID3D11UnorderedAccessView** ppOutputDerivativesUAV,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageGradientsPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeCommonDerivativesFunction.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image X Derivatives" << endl;
	imageMaskLog << "Creating the Input Buffer For Image X Derivatives" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppImageDerivativeObjectListForX.size() * sizeof(CImageDerivativeClassStruct);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(CImageDerivativeClassStruct);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &ppImageDerivativeObjectListForX[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image y Derivatives" << endl;
	imageMaskLog << "Creating the Input Buffer For Image y Derivatives" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = ppImageDerivativeObjectListForY.size() * sizeof(CImageDerivativeClassStruct);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(CImageDerivativeClassStruct);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &ppImageDerivativeObjectListForY[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc2));
	buffer_desc_output.ByteWidth = ppImageDerivativeObjectListForX.size() * sizeof(CImageFullDerivativeClassStruct);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(CImageFullDerivativeClassStruct);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = ppImageDerivativeObjectListForX.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = ppImageDerivativeObjectListForY.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppImageDerivativeObjectListForX.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppImageDerivativeObjectListForX.size() * sizeof(CImageFullDerivativeClassStruct);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeDerivaticesCSShader = pComputeShaderObject;
	*ppBufferForArrayOne = pInputBuffer1;
	*ppBufferForArrayTwo = pInputBuffer2;
	*ppComputeImageDerivativeOutput = pOutputBuffer;
	*ppShaderResourceView0 = pInputSRV1;
	*ppShaderResourceView1 = pInputSRV2;
	*ppOutputDerivativesUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunComputeOfDerivativeValues(HINSTANCE hInstance,
	HWND hWnd, ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::ComputeImageFunctionDerivativesFinal(HINSTANCE hInstance,
	HWND hWnd, vector<CImageDerivativeClass> ppImageDerivativeObjectListForX,
	vector<CImageDerivativeClass> ppImageDerivativeObjectListForY,
	vector<CImageFullDerivativesClass> *pFullDerivativesClass)
{
	HRESULT hr = S_OK;
	cout << "This Function Will Compute The Common Image Function Derivative for X and Y" << endl;

	vector<CImageFullDerivativesClass> pFullDervativesObjectCollection = vector<CImageFullDerivativesClass>();
	fstream imageIntensityFunctionY;
	imageIntensityFunctionY.open("C:\\\pixels\\ComputeImageInstensityGradients.txt", fstream::in | fstream::out | fstream::trunc);
	imageIntensityFunctionY.clear();

	cout << "Before We Compute The Derivatives we Must Sort Our Gradient Arrays" << endl;





	cout << "Printing  Out the Derivatives List For X Gradient" << endl;
	imageIntensityFunctionY << "Printing  Out the Derivatives List For X Gradient" << endl;

	for (CImageDerivativeClass pImageDerivativeXObject : ppImageDerivativeObjectListForX)
	{
		cout << "Index Value = " << pImageDerivativeXObject.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeXObject.xPosition << endl;
		cout << "Y Position = " << pImageDerivativeXObject.yPosition << endl;
		cout << "Gradient Value = " << pImageDerivativeXObject.pDerivativeValue << endl;

		imageIntensityFunctionY << "Index Value = " << pImageDerivativeXObject.pDerivativeIndex << endl;
		imageIntensityFunctionY << "X Position = " << pImageDerivativeXObject.xPosition << endl;
		imageIntensityFunctionY << "Y Position = " << pImageDerivativeXObject.yPosition << endl;
		imageIntensityFunctionY << "Gradient Value = " << pImageDerivativeXObject.pDerivativeValue << endl;
	}

	cout << "Printing  Out the Derivatives List For Y Gradient" << endl;
	imageIntensityFunctionY << "Printing  Out the Derivatives List For Y Gradient" << endl;

	for (CImageDerivativeClass pImageDerivativeYObject : ppImageDerivativeObjectListForY)
	{
		cout << "Index Value = " << pImageDerivativeYObject.pDerivativeIndex << endl;
		cout << "X Position = " << pImageDerivativeYObject.xPosition << endl;
		cout << "Y Position = " << pImageDerivativeYObject.yPosition << endl;
		cout << "Gradient Value = " << pImageDerivativeYObject.pDerivativeValue << endl;

		imageIntensityFunctionY << "Index Value = " << pImageDerivativeYObject.pDerivativeIndex << endl;
		imageIntensityFunctionY << "X Position = " << pImageDerivativeYObject.xPosition << endl;
		imageIntensityFunctionY << "Y Position = " << pImageDerivativeYObject.yPosition << endl;
		imageIntensityFunctionY << "Gradient Value = " << pImageDerivativeYObject.pDerivativeValue << endl;
	}


	for (CImageDerivativeClass pImageDerivativeXObject : ppImageDerivativeObjectListForX)
	{

		CImageDerivativeClass pImageFunctionDerivativeObjectX = pImageDerivativeXObject;
		int pIdValue = pImageFunctionDerivativeObjectX.pDerivativeIndex;
		float pXPosition0 = pImageFunctionDerivativeObjectX.xPosition;
		float pYPosition0 = pImageFunctionDerivativeObjectX.yPosition;

		CImageDerivativeClass pImageFunctionDerivativeObjectY = GetImageDerivativeObjectByXAndYPosition(ppImageDerivativeObjectListForY, pXPosition0, pYPosition0);



		float pXPosition1 = pImageFunctionDerivativeObjectY.xPosition;
		float pYPosition1 = pImageFunctionDerivativeObjectY.yPosition;
		float pGradientXValue = pImageFunctionDerivativeObjectX.pDerivativeValue;
		float pGradientYValue = pImageFunctionDerivativeObjectY.pDerivativeValue;

		cout << "Gradient G(X) X Position = " << pXPosition0 << endl;
		cout << "Gradient G(X) Y Position = " << pYPosition0 << endl;
		cout << "Gradient G(X) Value = " << pImageFunctionDerivativeObjectX.pDerivativeValue << endl;


		cout << "Gradient G(Y) X Position = " << pXPosition1 << endl;
		cout << "Gradient G(Y) Y Position = " << pXPosition1 << endl;
		cout << "Gradient G(Y) Value = " << pImageFunctionDerivativeObjectY.pDerivativeValue << endl;


		imageIntensityFunctionY << "Gradient G(X) X Position = " << pXPosition0 << endl;
		imageIntensityFunctionY << "Gradient G(X) Y Position = " << pYPosition0 << endl;
		imageIntensityFunctionY << "Gradient G(X) Value = " << pImageFunctionDerivativeObjectX.pDerivativeValue << endl;
		imageIntensityFunctionY << "Gradient G(Y) X Position = " << pXPosition1 << endl;
		imageIntensityFunctionY << "Gradient G(Y) Y Position = " << pYPosition1 << endl;
		imageIntensityFunctionY << "Gradient G(Y) Value = " << pImageFunctionDerivativeObjectY.pDerivativeValue << endl;


		float pMagitudeValue = sqrt(pow(pImageFunctionDerivativeObjectX.pDerivativeValue, 2) + pow(pImageFunctionDerivativeObjectY.pDerivativeValue, 2));
		float pDirectionValue = atan(pImageFunctionDerivativeObjectY.pDerivativeValue / pImageFunctionDerivativeObjectX.pDerivativeValue);

		cout << "Computing New Common Gradient Item" << endl;
		cout << "Id Value: " << pIdValue << endl;
		cout << "X Position: " << pXPosition0 << endl;
		cout << "Y Position: " << pXPosition0 << endl;




		cout << "Magnitude Value: " << pMagitudeValue << endl;
		cout << "Direction Angle: " << pDirectionValue << endl;

		imageIntensityFunctionY << "Computing New Common Gradient Item" << endl;
		imageIntensityFunctionY << "Id Value: " << pIdValue << endl;
		imageIntensityFunctionY << "X Position: " << pXPosition0 << endl;
		imageIntensityFunctionY << "Y Position: " << pXPosition0 << endl;

		imageIntensityFunctionY << "Magnitude Value: " << pMagitudeValue << endl;
		imageIntensityFunctionY << "Direction Angle: " << pDirectionValue << endl;


		CImageFullDerivativesClass pImageDerivativeObject = CImageFullDerivativesClass(pIdValue,
			pXPosition0, pYPosition0, pMagitudeValue, pDirectionValue);
		pFullDervativesObjectCollection.push_back(pImageDerivativeObject);


	}









	*pFullDerivativesClass = pFullDervativesObjectCollection;
	return hr;
}



			
			
	

	





HRESULT DirectXStandardAlgorithmExecutor::SubtractImageData(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObject> pPixelArrayOne,
	vector<PixelObject> pPixelArrayTwo,
	UINT pXPosition, UINT pYPosition,
	int pImageWidth, int pImageHeight, vector<PixelObject> *ppPixelDataOutput)
{
	HRESULT hr = S_OK;
	fstream pImageStreamData("C:\\\pixels\\ImageSubtractionArray.txt");


	cout << "This Function Will Simulate the Image Comparison Algorithm" << endl;
	cout << "This Function Will Simulate the Image Comparison Algorithm" << endl;
	cout << "First we have to load And Clip Our Images" << endl;

	pImageStreamData << "This Function Will Simulate the Image Comparison Algorithm" << endl;
	pImageStreamData << "This Function Will Simulate the Image Comparison Algorithm" << endl;
	pImageStreamData << "First we have to load And Clip Our Images" << endl;


	
	vector<PixelObject> pImageSubtractionResult = vector<PixelObject>();

	cout << "Clipping Image One" << endl;
	pImageStreamData << "Clipping Image One" << endl;


	

	cout << "Printing The Pixel Buffer for Clip One" << endl;
	pImageStreamData << "Printing The Pixel Buffer for Clip One" << endl;


	int pIndex = 0;
	for (PixelObject pPixelObject : pPixelArrayOne)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;

		pImageStreamData << "Index: " << pIndex << endl;
		pImageStreamData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pImageStreamData << "X Position: " << pPixelObject.xPosition << endl;
		pImageStreamData << "Y Position: " << pPixelObject.yPosition << endl;
		pImageStreamData << "Red Component: " << pPixelObject.RMask << endl;
		pImageStreamData << "Green Component: " << pPixelObject.GMask << endl;
		pImageStreamData << "Blue Component: " << pPixelObject.BMask << endl;

	}
	pImageStreamData << "End Clip One" << endl;


	cout << "Printing the Pixel Buffer for Clip Two" << endl;
	pImageStreamData << "Printing The Pixel Buffer for Clip Two" << endl;

	pIndex = 0;
	for (PixelObject pPixelObject : pPixelArrayTwo)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;

		pImageStreamData << "Index: " << pIndex << endl;
		pImageStreamData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pImageStreamData << "X Position: " << pPixelObject.xPosition << endl;
		pImageStreamData << "Y Position: " << pPixelObject.yPosition << endl;
		pImageStreamData << "Red Component: " << pPixelObject.RMask << endl;
		pImageStreamData << "Green Component: " << pPixelObject.GMask << endl;
		pImageStreamData << "Blue Component: " << pPixelObject.BMask << endl;
	}


	hr = SimulaeImageSubtractionOnGPU(hInstance, hWnd, pPixelArrayOne, pPixelArrayTwo,
			&pImageSubtractionResult);

		cout << "Printing the Output Results Buffer" << endl;
		pImageStreamData << "Printing the Output Results Buffer" << endl;
		pIndex = 0;
		pIndex = 0;

		for (PixelObject pPixelObject : pImageSubtractionResult)
		{
			cout << "Index: " << pIndex << endl;
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;

			pImageStreamData << "Index: " << pIndex << endl;
			pImageStreamData << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pImageStreamData << "X Position: " << pPixelObject.xPosition << endl;
			pImageStreamData << "Y Position: " << pPixelObject.yPosition << endl;
			pImageStreamData << "Red Component: " << pPixelObject.RMask << endl;
			pImageStreamData << "Green Component: " << pPixelObject.GMask << endl;
			pImageStreamData << "Blue Component: " << pPixelObject.BMask << endl;
			pIndex = pIndex + 1;

		}
	
		cout << "Simulation Completed Successfully" << endl;



		*ppPixelDataOutput = pImageSubtractionResult;

		return hr;


	

}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConvolutionResourcesStructuredX(HINSTANCE hInstance,
	HWND hWnd,
	CbConvolultionBuffer pConvolutionBufferObject,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pInputDataArray,
	ID3D11Buffer** ppInputDataBuffer,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppOutputDataBuffer,
	ID3D11ShaderResourceView** ppInputDataSRV,
	ID3D11UnorderedAccessView** ppOutputDataUAV,
	ID3D11Buffer** ppReadbackDataBuffer)

	

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageConvolutionFilePreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pImageConvolutionConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferForImageFile = nullptr;
	ID3D11Buffer* pInputKernelDataBuffer = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVImage = nullptr;
	ID3D11ShaderResourceView* pInputKernelSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSImageConvolutionFunctionX.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);




	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer for Convolution Function" << endl;


	// Create the Const Buffer
	cout << "Creating the Constant Buffer For the Convolution Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;

	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CbConvolultionBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pConstantBufferData;
	pConstantBufferData.pSysMem = &pConvolutionBufferObject;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pConstantBufferData, &pImageConvolutionConstantBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Constant Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Constant BufferAlgorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;
	UINT pStrideVal = sizeof(PixelObjectGrayScale);

	D3D11_BUFFER_DESC buffer_desc_image_one;
	ZeroMemory(&buffer_desc_image_one, sizeof(buffer_desc_image_one));
	buffer_desc_image_one.ByteWidth = pInputDataArray.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_image_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_image_one.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_image_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_image_one.StructureByteStride = pStrideVal;
	buffer_desc_image_one.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataArray[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_image_one, &pData, &pInputBufferForImageFile);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	




	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for image kernel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Output Buffer Object" << endl;


	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataArray.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = pStrideVal;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_image;
	ZeroMemory(&srvbuffer_desc_image, sizeof(srvbuffer_desc_image));
	srvbuffer_desc_image.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_image.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_image.Buffer.ElementWidth = pInputDataArray.size();
	srvbuffer_desc_image.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferForImageFile, &srvbuffer_desc_image, &pInputSRVImage);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}







	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataArray.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataArray.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pImageConvolutionConstantBuffer;
	*ppInputDataBuffer = pInputBufferForImageFile;
	*ppOutputDataBuffer = pOutputBuffer;
	*ppInputDataSRV = pInputSRVImage;
	*ppOutputDataUAV = pOutputUAV;
	*ppReadbackDataBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConvolutionResourcesStructuredY(HINSTANCE hInstance,
	HWND hWnd,
	CbConvolultionBuffer pConvolutionBufferObject,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pInputDataArray,
	ID3D11Buffer** ppInputDataBuffer,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppOutputDataBuffer,
	ID3D11ShaderResourceView** ppInputDataSRV,
	ID3D11UnorderedAccessView** ppOutputDataUAV,
	ID3D11Buffer** ppReadbackDataBuffer)



{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageConvolutionFilePreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pImageConvolutionConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferForImageFile = nullptr;
	ID3D11Buffer* pInputKernelDataBuffer = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVImage = nullptr;
	ID3D11ShaderResourceView* pInputKernelSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSImageConvolutionFunctionX.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);




	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer for Convolution Function" << endl;


	// Create the Const Buffer
	cout << "Creating the Constant Buffer For the Convolution Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;

	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CbConvolultionBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pConstantBufferData;
	pConstantBufferData.pSysMem = &pConvolutionBufferObject;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pConstantBufferData, &pImageConvolutionConstantBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Constant Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Constant BufferAlgorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;
	UINT pStrideVal = sizeof(PixelObjectGrayScale);

	D3D11_BUFFER_DESC buffer_desc_image_one;
	ZeroMemory(&buffer_desc_image_one, sizeof(buffer_desc_image_one));
	buffer_desc_image_one.ByteWidth = pInputDataArray.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_image_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_image_one.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_image_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_image_one.StructureByteStride = pStrideVal;
	buffer_desc_image_one.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataArray[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_image_one, &pData, &pInputBufferForImageFile);





	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}






	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for image kernel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Output Buffer Object" << endl;


	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataArray.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = pStrideVal;
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_image;
	ZeroMemory(&srvbuffer_desc_image, sizeof(srvbuffer_desc_image));
	srvbuffer_desc_image.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_image.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_image.Buffer.ElementWidth = pInputDataArray.size();
	srvbuffer_desc_image.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBufferForImageFile, &srvbuffer_desc_image, &pInputSRVImage);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}







	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataArray.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataArray.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pImageConvolutionConstantBuffer;
	*ppInputDataBuffer = pInputBufferForImageFile;
	*ppOutputDataBuffer = pOutputBuffer;
	*ppInputDataSRV = pInputSRVImage;
	*ppOutputDataUAV = pOutputUAV;
	*ppReadbackDataBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateImageConvolutionOperation(HINSTANCE hInstance,
	HWND hWnd, 
	UINT pImageWidth,
	UINT pImageHeight, 
	vector<PixelObjectGrayScale> pCoreImageObject,
	vector<ImageKernelItem> pImageKernel, vector<PixelObjectGrayScale> *ppPixelOutputValues)
{

	HRESULT hr = S_OK;
	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\ImageConvolutionTests.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();


	cout << "This Function Allows To Simulate The Convolution of a Digital Image" << endl;
	cout << "As An Input Data this Function will take 1 Pixel Array and one Kernel Value" << endl;
	cout << "First we have to Initialize Our Resources" << endl;


	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "2 Input Buffers " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "2 Shader Resource Views" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	pOutputFileStream << "This Function Allows To Simulate The Convolution of a Digital Image" << endl;
	pOutputFileStream << "As An Input Data this Function will take 1 Pixel Array and one Kernel Value" << endl;
	pOutputFileStream << "First we have to Initialize Our Resources" << endl;


	pOutputFileStream << "Preparing the Instruments For the Simulation" << endl;
	pOutputFileStream << "They Include: " << endl;
	pOutputFileStream << "1 Compute Shader " << endl;
	pOutputFileStream << "1 Constant Buffer" << endl;
	pOutputFileStream << "2 Input Buffers " << endl;
	pOutputFileStream << "1 Output Buffer " << endl;
	pOutputFileStream << "2 Shader Resource Views" << endl;
	pOutputFileStream << "1 Unordered Access View" << endl;
	pOutputFileStream << "1 Readback Buffer" << endl;

	cout << "Now We have to initiailize Our Resources" << endl;


	pOutputFileStream << "Now We have to initiailize Our Resources" << endl;

	ID3D11ComputeShader* pImageFilterComputeShaderCS = nullptr;

	ID3D11Buffer* pInputBufferOneForImageFilterFunction = nullptr;
	ID3D11Buffer* pKernelInputDatBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pOutputBufferForImageFilterFunction = nullptr;
	ID3D11ShaderResourceView* pImageFilterFunctionSRV0 = nullptr;
	ID3D11ShaderResourceView* pImageFilterFunctionSRV1 = nullptr;
	ID3D11UnorderedAccessView* pImageFilterFunctionUAV0 = nullptr;
	ID3D11Buffer* pImageFilterFunctionReadBackBuffer = nullptr;

	cout << "Initializing the Resources For Image Convolution" << endl;
	UINT pNumberOfThread = pImageHeight * pImageWidth;

	CbConvolultionBuffer pConvolutionBuffer;
	pConvolutionBuffer.pImageHeight = pImageHeight;
	pConvolutionBuffer.pImageWidth = pImageWidth;
	pConvolutionBuffer.pFilterHeight = 3;
	pConvolutionBuffer.pFilterWidth = 3;
	pConvolutionBuffer.pOutputHeight = pImageHeight,
	pConvolutionBuffer.pOutputWidth = pImageWidth;

	

	if (FAILED(hr))
	{
		cout << "Unable to Initialize the Resources for Image Convolution" << endl;
	}

	ID3D11ShaderResourceView* ppShaderResourceVies[] = { pImageFilterFunctionSRV0, pImageFilterFunctionSRV1 };

	cout << "Running The Image Convolution Using Predefined Procedure" << endl;

	m_pD3DCompContext->UpdateSubresource(pInputBufferOneForImageFilterFunction, 0, nullptr, &pCoreImageObject[0], 0, 0);

	
	hr = RunConvolutionOperationsStructured(hInstance, hWnd, 
		pConstantBuffer,
		pImageFilterComputeShaderCS,
		pImageFilterFunctionSRV0,
		pImageFilterFunctionUAV0, 2, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Execute The Convolutiion Compute Shader" << endl;
	}
	cout << "Copying the Resources From the Output Buffer" << endl;
	
	m_pD3DCompContext->CopyResource(pImageFilterFunctionReadBackBuffer, pOutputBufferForImageFilterFunction);


	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The ResourceS For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		hr = m_pD3DCompContext->Map(pImageFilterFunctionReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;
		for (int i = 0; i < pCoreImageObject.size(); ++i)
		{
			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;

			pOutputFileStream << "Index = " << iIndex << endl;
			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Grey Level: " << pPixelObject.pGreyLevel << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&pImageFilterComputeShaderCS);
	SafeReleaseA(&pInputBufferOneForImageFilterFunction);
	SafeReleaseA(&pKernelInputDatBuffer);
	SafeReleaseA(&pOutputBufferForImageFilterFunction);
	SafeReleaseA(&pImageFilterFunctionSRV0);
	SafeReleaseA(&pImageFilterFunctionSRV1);
	SafeReleaseA(&pImageFilterFunctionUAV0);
	SafeReleaseA(&pImageFilterFunctionReadBackBuffer);

	pOutputFileStream.close();
	*ppPixelOutputValues = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunConvolutionOperationsStructured(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* ppContstantBufffers,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView1};
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &ppContstantBufffers);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
		hr = E_FAIL;
		return hr;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulaeImageSubtractionOnGPU(HINSTANCE hInstance,
	HWND hWnd, 
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	vector<PixelObject> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	cout << "This Function Allows To Simulate The Subtraction of Digital Image" << endl;
	cout << "As An Input Data this Function will take 2 Sets Of Pixel Array" << endl;
	cout << "First we have to Initialize Our Resources" << endl;


	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "2 Input Buffers " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	cout << "Now We have to initalize Our Resources" << endl;
	vector<PixelObject> pOutputPixelObjectArray = vector<PixelObject>();

	ID3D11ComputeShader* pImageMaskComputeShaderCS = nullptr;
	ID3D11Buffer* pInputBufferOneForImageSubtractionFunction = nullptr;
	ID3D11Buffer* pInputBufferTwoForImageSubtractionFunction = nullptr;
	ID3D11Buffer* pOutputBufferForImageSubtractionFunction = nullptr;
	ID3D11ShaderResourceView* pImageSubtractionFunctionSRV0 = nullptr;
	ID3D11ShaderResourceView* pImageSubtractionFunctionSRV1 = nullptr;
	ID3D11UnorderedAccessView* pImageSubtractionFunctionUAV0 = nullptr;
	ID3D11Buffer* pImageSubtractionFunctionReadBackBuffer = nullptr;


	ID3D11UnorderedAccessView* ppUnorderedAccessViews = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViews = nullptr;

	cout << "Printing the Contents Of Image One" << endl;
	int pIndex = 0;
	for (PixelObject pPixelObject : pixelArrayOne)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Red Component: " << pPixelObject.RMask << endl;
		cout << "Pixel Green Component: " << pPixelObject.GMask << endl;
		cout << "Pixel Blue Component: " << pPixelObject.BMask << endl;
		pIndex = pIndex + 1;
	}

	cout << "Printing the Contents of Image Two" << endl;
    pIndex = 0;
	for (PixelObject pPixelObject : pixelArrayTwo)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Red Component: " << pPixelObject.RMask << endl;
		cout << "Pixel Green Component: " << pPixelObject.GMask << endl;
		cout << "Pixel Blue Component: " << pPixelObject.BMask << endl;
		pIndex = pIndex + 1;
	}



	cout << "Creating the Resource Objects" << endl;

	hr = InitializeImageSubtractionFunctionResources(hInstance,
		hWnd, pixelArrayOne.size(), &pImageMaskComputeShaderCS,
		pixelArrayOne, pixelArrayTwo,
		&pInputBufferOneForImageSubtractionFunction,
		&pInputBufferTwoForImageSubtractionFunction,
		&pOutputBufferForImageSubtractionFunction,
		&pImageSubtractionFunctionSRV0,
		&pImageSubtractionFunctionSRV1,
		&pImageSubtractionFunctionUAV0,
		&pImageSubtractionFunctionReadBackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	hr = RunImageSubtractionFunctionShaderAlgorithm(hInstance, hWnd,
		pImageMaskComputeShaderCS,
		pImageSubtractionFunctionSRV0,
		pImageSubtractionFunctionSRV1,
		pImageSubtractionFunctionUAV0,
		2, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pImageSubtractionFunctionReadBackBuffer, pOutputBufferForImageSubtractionFunction);
		hr = m_pD3DCompContext->Map(pImageSubtractionFunctionReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObject* p = (PixelObject*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			pOutputPixelObjectArray.push_back(p[i]);
		}



		fstream myfile;
		myfile.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
		myfile.clear();


		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObject pPixelObject : pOutputPixelObjectArray)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component" << pPixelObject.GMask << endl;
			cout << "Blue Component" << pPixelObject.BMask << endl;

			myfile << "Index = " << iIndex << endl;
			myfile << "Pixel Number: " << pPixelObject.pixelNumber;
			myfile << "X Position: " << pPixelObject.xPosition << endl;
			myfile << "Y Position: " << pPixelObject.xPosition << endl;
			myfile << "Red Component: " << pPixelObject.RMask << endl;
			myfile << "Green Component" << pPixelObject.GMask << endl;
			myfile << "Blue Component" << pPixelObject.BMask << endl;
				 
		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");




	*pOuputResultArray = pOutputPixelObjectArray;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulaeImageSubtractionGrayScaleOnGPU(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	vector<PixelObjectGrayScale> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\\pixels\\ImageGrayScalePreOutput.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile.clear();
	vector<OutputPixelBuffer> ppImageDataOutputVector = vector<OutputPixelBuffer>();


	cout << "This Function Allows To Simulate The Subtraction of Digital Image" << endl;
	cout << "As An Input Data this Function will take 2 Sets Of Pixel Array" << endl;
	cout << "First we have to Initialize Our Resources" << endl;


	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "2 Input Buffers " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	cout << "Now We have to initalize Our Resources" << endl;


	imageSegmentationDataFile << "This Function Allows To Simulate The Subtraction of Digital Image" << endl;
	imageSegmentationDataFile << "As An Input Data this Function will take 2 Sets Of Pixel Array" << endl;
	imageSegmentationDataFile << "First we have to Initialize Our Resources" << endl;


	imageSegmentationDataFile << "Preparing the Instruments For the Simulation" << endl;
	imageSegmentationDataFile << "They Include: " << endl;
	imageSegmentationDataFile << "1 Compute Shader " << endl;
	imageSegmentationDataFile << "2 Input Buffers " << endl;
	imageSegmentationDataFile << "1 Output Buffer " << endl;
	imageSegmentationDataFile << "1 Shader Resource View" << endl;
	imageSegmentationDataFile << "1 Unordered Access View" << endl;
	imageSegmentationDataFile << "1 Readback Buffer" << endl;

	imageSegmentationDataFile << "Now We have to initalize Our Resources" << endl;
	vector<PixelObjectGrayScale> pOutputPixelObjectArray = vector<PixelObjectGrayScale>();

	ID3D11ComputeShader* pImageMaskComputeShaderCS = nullptr;
	ID3D11Buffer* pInputBufferOneForImageSubtractionFunction = nullptr;
	ID3D11Buffer* pInputBufferTwoForImageSubtractionFunction = nullptr;
	ID3D11Buffer* pOutputBufferForImageSubtractionFunction = nullptr;
	ID3D11ShaderResourceView* pImageSubtractionFunctionSRV0 = nullptr;
	ID3D11ShaderResourceView* pImageSubtractionFunctionSRV1 = nullptr;
	ID3D11UnorderedAccessView* pImageSubtractionFunctionUAV0 = nullptr;
	ID3D11Buffer* pImageSubtractionFunctionReadBackBuffer = nullptr;


	ID3D11UnorderedAccessView* ppUnorderedAccessViews = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViews = nullptr;

	cout << "Printing the Contents Of Image One" << endl;
	int pIndex = 0;
	for (PixelObjectGrayScale pPixelObject : pixelArrayOne)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Index = " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "Pixel X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;


		pIndex = pIndex + 1;
	}

	cout << "Printing the Contents of Image Two" << endl;
	pIndex = 0;
	for (PixelObjectGrayScale pPixelObject : pixelArrayTwo)
	{
		cout << "Index = " << pIndex << endl;
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "Pixel X Position: " << pPixelObject.xPosition << endl;
		cout << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		cout << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;


		imageSegmentationDataFile << "Index = " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "Pixel X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Pixel Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "GrayScale Value: " << pPixelObject.pGreyLevel << endl;


		pIndex = pIndex + 1;
	}



	cout << "Creating the Resource Objects" << endl;
	imageSegmentationDataFile << "Creating the Resource Objects" << endl;


	hr = InitializeImageGrayScaleSubtractionResources(hInstance,
		hWnd, pixelArrayOne.size(), &pImageMaskComputeShaderCS,
		pixelArrayOne, pixelArrayTwo,
		&pInputBufferOneForImageSubtractionFunction,
		&pInputBufferTwoForImageSubtractionFunction,
		&pOutputBufferForImageSubtractionFunction,
		&pImageSubtractionFunctionSRV0,
		&pImageSubtractionFunctionSRV1,
		&pImageSubtractionFunctionUAV0,
		&pImageSubtractionFunctionReadBackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize Image Subtraction Input Resources" << endl;
		return hr;
	}

	cout << "Uploading the Data To the Input Buffers" << endl;


	cout << "Running Image Mask Compute Shader Algorithm" << endl;
	imageSegmentationDataFile << "Running Image Mask Compute Shader Algorithm" << endl;

	hr = RunImageSubtractionFunctionShaderAlgorithm(hInstance, hWnd,
		pImageMaskComputeShaderCS,
		pImageSubtractionFunctionSRV0,
		pImageSubtractionFunctionSRV1,
		pImageSubtractionFunctionUAV0,
		2, 1, 256, 1, 1);

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pImageSubtractionFunctionReadBackBuffer, pOutputBufferForImageSubtractionFunction);
		hr = m_pD3DCompContext->Map(pImageSubtractionFunctionReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;
		int iIndex = 0;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{ 
			p[i].pixelNumber = pIndex;
			pOutputPixelObjectArray.push_back(p[i]);
			iIndex++;
		}



	
		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageSegmentationDataFile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
	    iIndex = 0;
		for (PixelObjectGrayScale pPixelObject : pOutputPixelObjectArray)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "GrayScale: " << pPixelObject.pGreyLevel << endl;

			imageSegmentationDataFile << "Index = " << iIndex << endl;
			imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
			imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
			imageSegmentationDataFile << "GrayScale: " << pPixelObject.pGreyLevel << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageSegmentationDataFile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		imageSegmentationDataFile.close();

	}

	printf("Cleaning up...\n");




	*pOuputResultArray = pOutputPixelObjectArray;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalInAThreadPool(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	int *pAmountOfIdenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBuffer> *ppOutputPixelData,
	vector<PixelObjectGrayScale> *ppIdenticalPixelBuffer,
	vector<PixelObjectGrayScale> *ppDifferentPixelBuffer,
	float *ppOutputArrayIntensitySum,
	float *ppOutputArrayAverage,
	float *ppIdenticalPixelsIntensitySum,
	float *ppIdenticalPixelsAverage,
	float *ppDifferentPixelsIntensitySum,
	float *ppDifferentPixelsAverage,
	BOOL *pAreIdenticalOutput)

{
	HRESULT hr = S_OK;
	TP_CALLBACK_ENVIRON pCallbackEnv;

	ThreadPoolTaskItemComparisonGrayScale pComparisonTask = ThreadPoolTaskItemComparisonGrayScale(this,
		pixelArrayOne,
		pixelArrayTwo);
	



	pImageOneForComparisonGlobalGrayScale = vector<PixelObjectGrayScale>();
	pImageTwoForComparisonGlobalGrayScale = vector<PixelObjectGrayScale>();
	pImageOneForComparisonGlobalGrayScale.clear();
	pImageTwoForComparisonGlobalGrayScale.clear();

	for (PixelObjectGrayScale pixelObject : pixelArrayOne)
	{
		pImageOneForComparisonGlobalGrayScale.push_back(pixelObject);
	}

	for (PixelObjectGrayScale pixelObject : pixelArrayTwo)
	{
		pImageTwoForComparisonGlobalGrayScale.push_back(pixelObject);
	}



	DWORD pThreadId = 0;

	SRWLOCK pLockObject;
	unsigned int tasksPerThread = 1;
	unsigned int totalTasksComleted;
	PTP_WORK pWorkerThreadItem;
	
	
	cout << "Initializing threadpool environment" << endl;
	InitializeThreadpoolEnvironment(&pCallbackEnv);
	SRWLOCK pLockObjectVar;
	THREADARG pThreadArguments;
	pThreadArguments.pThreadNumber = 0;
	pThreadArguments.tasksToComplete = 1;
	pThreadArguments.tasksCompleted = 0;
	pThreadArguments.pLockObject = pLockObjectVar;
	
	

	
	pWorkerThreadItem = CreateThreadpoolWork(ComparisonFunctionThreadPool, (VOID*)&pComparisonTask,
		&pCallbackEnv);
	cout << "Submitting Threadpool Work" << endl;
	SubmitThreadpoolWork(pWorkerThreadItem);


	cout << "Waiting for Callback Items" << endl;
	WaitForThreadpoolWorkCallbacks(pWorkerThreadItem, FALSE);

	CloseThreadpoolWork(pWorkerThreadItem);

	fstream imageMaskLog;
	imageMaskLog.open("C:\\pixels\\ImageComparisonFunctionInternal.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	int pIndex = 0;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArraySize = 0.0f;
	float pIdenticalArraySize = 0.0f;
	float pDifferentArraySize = 0.0f;
	float pIdenticalPixelArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;


	for (OutputPixelBuffer ppOutputPixelValue : pOutputPixelBufferOutputArrayGlobal)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of identical pixel = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixel = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;
	}

	pOutputArraySize = pOutputPixelBufferOutputArrayGlobal.size();

	if (pOutputArraySize > 0)
	{
		pOutputArrayAverage = pOutputArrayIntensitySum / pOutputPixelBufferOutputArrayGlobal.size();
	}
	else
	{
		pOutputArrayAverage = 0;
	}
	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << pOutputArraySize << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;

	imageMaskLog << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageMaskLog << "Output Array Size = " << pOutputArraySize << endl;
	imageMaskLog << "Output Array Average = " << pOutputArrayAverage << endl;


	pIdenticalArraySize = pImageComparisonIdenticalGlobal.size();
	cout << "Printing Out the Identical Pixels" << endl;
	imageMaskLog << "Printing Out the Identical Pixels" << endl;
	for (PixelObjectGrayScale pPixelObject : pImageComparisonIdenticalGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIdenticalPixelArraySum = pIdenticalPixelArraySum + pPixelObject.pGreyLevel;
	}

	if (pImageComparisonIdenticalGlobal.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelArraySum / pImageComparisonIdenticalGlobal.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}
	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArraySum << endl;
	cout << "Identical Pixel Array Size = " << pImageComparisonIdenticalGlobal.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	imageMaskLog << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArraySum << endl;
	imageMaskLog << "Identical Pixel Array Size = " << pImageComparisonIdenticalGlobal.size() << endl;
	imageMaskLog << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	cout << "Printing Out the Different Pixels" << endl;
	imageMaskLog << "Printing Out the Different Pixels" << endl;

	pDifferentArraySize = pImageComparisonDifferentGlobal.size();
	for (PixelObjectGrayScale pPixelObject : pImageComparisonDifferentGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pDifferentArraySum = pDifferentArraySum + pPixelObject.pGreyLevel;
	}

	if (pImageComparisonDifferentGlobal.size() > 0)
	{
		pDifferentArrayAverage = pDifferentArraySum / pImageComparisonDifferentGlobal.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}

	int pIdenticalPixelSize = pImageComparisonIdenticalGlobal.size();
	int pDifferentPixelSize = pImageComparisonDifferentGlobal.size();

	*pAmountOfIdenticalPixels = pIdenticalPixelSize;
	*pAmountODifferentPixels = pDifferentPixelSize;
	*ppOutputPixelData = pOutputPixelBufferOutputArrayGlobal;
	*ppIdenticalPixelBuffer = pImageComparisonIdenticalGlobal;
	*ppDifferentPixelBuffer = pImageComparisonDifferentGlobal;
	*ppOutputArrayIntensitySum = pOutputArrayIntensitySum;
	*ppOutputArrayAverage = pOutputArrayAverage;
	*ppIdenticalPixelsIntensitySum = pIdenticalPixelArraySum;
	*ppIdenticalPixelsAverage = pIdenticalPixelArrayAverage;
	*ppDifferentPixelsIntensitySum = pDifferentArraySum;
	*ppDifferentPixelsAverage = pDifferentPixelArrayAverage;

	return hr;


}


HRESULT DirectXStandardAlgorithmExecutor::InitializeRGBInvalidPixelImageRestorationResourcesFromClassifier(HINSTANCE hInstance,
	HWND hWnd,
	vector<OutputPixelObjectClassified> pInputFilterGrayscaleVector,
	CBBinaryClassifierConstantBuffer pConstantData,
	ID3D11ComputeShader** ppImageRestorationComputeShader,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppImageRestorationInputBuffer,
	ID3D11Buffer** ppImageRestorationOutputBufferClassOne,
	ID3D11ShaderResourceView** ppInputShaderResourceView,
	ID3D11UnorderedAccessView** ppOutputUAVObjectOne, ID3D11Buffer** ppReadbackBufferOne)
{
	HRESULT hr = S_OK;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalInAThread(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	int *pAmountOfIdenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBuffer> *ppOutputPixelData,
	vector<PixelObjectGrayScale> *ppIdenticalPixelBuffer,
	vector<PixelObjectGrayScale> *ppDifferentPixelBuffer,
	float *ppOutputArrayIntensitySum,
	float *ppOutputArrayAverage,
	float *ppIdenticalPixelsIntensitySum,
	float *ppIdenticalPixelsAverage,
	float *ppDifferentPixelsIntensitySum,
	float *ppDifferentPixelsAverage,
	BOOL *pAreIdenticalOutput)

{

		HRESULT hr = S_OK;
	DWORD pThreadId = 0;

	pImageOneForComparisonGlobalGrayScale = vector<PixelObjectGrayScale>();
	pImageTwoForComparisonGlobalGrayScale = vector<PixelObjectGrayScale>();

	for (PixelObjectGrayScale pixelObject : pixelArrayOne)
	{
		pImageOneForComparisonGlobalGrayScale.push_back(pixelObject);
	}

	for (PixelObjectGrayScale pixelObject : pixelArrayTwo)
	{
		pImageTwoForComparisonGlobalGrayScale.push_back(pixelObject);
	}



	pImageComparisonMutexObject = CreateMutex(NULL, FALSE, L"ImageComparisonMutex");


	pImageComparisonThreadHandleValue = CreateThread(NULL,
		0,
		ComparisonFunctionThread,
		this,
		0,
		&pThreadId);

	WaitForSingleObject(pImageComparisonThreadHandleValue, INFINITE);
	CloseHandle(pImageComparisonMutexObject);

	fstream imageMaskLog;
	imageMaskLog.open("C:\\pixels\\ImageComparisonFunctionInternal.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	int pIndex = 0;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArraySize = 0.0f;
	float pIdenticalArraySize = 0.0f;
	float pDifferentArraySize = 0.0f;
	float pIdenticalPixelArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;


	for (OutputPixelBuffer ppOutputPixelValue : pOutputPixelBufferOutputArrayGlobal)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of identical pixel = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixel = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;
	}

	pOutputArraySize = pOutputPixelBufferOutputArrayGlobal.size();

	if (pOutputArraySize > 0)
	{
		pOutputArrayAverage = pOutputArrayIntensitySum / pOutputPixelBufferOutputArrayGlobal.size();
	}
	else
	{
		pOutputArrayAverage = 0;
	}
	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << pOutputArraySize << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;

	imageMaskLog << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageMaskLog << "Output Array Size = " << pOutputArraySize << endl;
	imageMaskLog << "Output Array Average = " << pOutputArrayAverage << endl;


	pIdenticalArraySize = pImageComparisonIdenticalGlobal.size();
	cout << "Printing Out the Identical Pixels" << endl;
	imageMaskLog << "Printing Out the Identical Pixels" << endl;
	for (PixelObjectGrayScale pPixelObject : pImageComparisonIdenticalGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIdenticalPixelArraySum = pIdenticalPixelArraySum + pPixelObject.pGreyLevel;
	}

	if (pImageComparisonIdenticalGlobal.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelArraySum / pImageComparisonIdenticalGlobal.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}
	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArraySum << endl;
	cout << "Identical Pixel Array Size = " << pImageComparisonIdenticalGlobal.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	imageMaskLog << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArraySum << endl;
	imageMaskLog << "Identical Pixel Array Size = " << pImageComparisonIdenticalGlobal.size() << endl;
	imageMaskLog << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	cout << "Printing Out the Different Pixels" << endl;
	imageMaskLog << "Printing Out the Different Pixels" << endl;

	pDifferentArraySize = pImageComparisonDifferentGlobal.size();
	for (PixelObjectGrayScale pPixelObject : pImageComparisonDifferentGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pDifferentArraySum = pDifferentArraySum + pPixelObject.pGreyLevel;
	}

	if (pImageComparisonDifferentGlobal.size() > 0)
	{
		pDifferentArrayAverage = pDifferentArraySum / pImageComparisonDifferentGlobal.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}

	int pIdenticalPixelSize = pImageComparisonIdenticalGlobal.size();
	int pDifferentPixelSize = pImageComparisonDifferentGlobal.size();

	*pAmountOfIdenticalPixels = pIdenticalPixelSize;
	*pAmountODifferentPixels = pDifferentPixelSize;
	*ppOutputPixelData = pOutputPixelBufferOutputArrayGlobal;
	*ppIdenticalPixelBuffer = pImageComparisonIdenticalGlobal;
	*ppDifferentPixelBuffer = pImageComparisonDifferentGlobal;
	*ppOutputArrayIntensitySum = pOutputArrayIntensitySum;
	*ppOutputArrayAverage = pOutputArrayAverage;
	*ppIdenticalPixelsIntensitySum = pIdenticalPixelArraySum;
	*ppIdenticalPixelsAverage = pIdenticalPixelArrayAverage;
	*ppDifferentPixelsIntensitySum = pDifferentArraySum;
	*ppDifferentPixelsAverage = pDifferentPixelArrayAverage;

	return hr;


}



HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalInAThreadWithRestoration(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	int *pAmountOfIdenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBuffer> *ppOutputPixelData,
	vector<PixelObjectGrayScale> *ppIdenticalPixelBuffer,
	vector<PixelObjectGrayScale> *ppDifferentPixelBuffer,
	float *ppOutputArrayIntensitySum,
	float *ppOutputArrayAverage,
	float *ppIdenticalPixelsIntensitySum,
	float *ppIdenticalPixelsAverage,
	float *ppDifferentPixelsIntensitySum,
	float *ppDifferentPixelsAverage,
	BOOL *pAreIdenticalOutput)

{

	HRESULT hr = S_OK;
	DWORD pThreadId = 0;

	pImageOneForComparisonGlobalGrayScale = vector<PixelObjectGrayScale>();
	pImageTwoForComparisonGlobalGrayScale = vector<PixelObjectGrayScale>();

	for (PixelObjectGrayScale pixelObject : pixelArrayOne)
	{
		pImageOneForComparisonGlobalGrayScale.push_back(pixelObject);
	}

	for (PixelObjectGrayScale pixelObject : pixelArrayTwo)
	{
		pImageTwoForComparisonGlobalGrayScale.push_back(pixelObject);
	}



	pImageComparisonMutexObject = CreateMutex(NULL, FALSE, L"ImageComparisonMutex");


	pImageComparisonThreadHandleValue = CreateThread(NULL,
		0,
		ComparisonFunctionThreadGPU,
		this,
		0,
		&pThreadId);

	WaitForSingleObject(pImageComparisonThreadHandleValue, INFINITE);
	CloseHandle(pImageComparisonMutexObject);

	fstream imageMaskLog;
	imageMaskLog.open("C:\\pixels\\ImageComparisonFunctionInternal.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);

	int pIndex = 0;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArraySize = 0.0f;
	float pIdenticalArraySize = 0.0f;
	float pDifferentArraySize = 0.0f;
	float pIdenticalPixelArraySum = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArraySum = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;


	for (OutputPixelBuffer ppOutputPixelValue : pOutputPixelBufferOutputArrayGlobal)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of identical pixel = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixel = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;
	}

	pOutputArraySize = pOutputPixelBufferOutputArrayGlobal.size();

	if (pOutputArraySize > 0)
	{
		pOutputArrayAverage = pOutputArrayIntensitySum / pOutputPixelBufferOutputArrayGlobal.size();
	}
	else
	{
		pOutputArrayAverage = 0;
	}
	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << pOutputArraySize << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;

	imageMaskLog << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageMaskLog << "Output Array Size = " << pOutputArraySize << endl;
	imageMaskLog << "Output Array Average = " << pOutputArrayAverage << endl;


	pIdenticalArraySize = pImageComparisonIdenticalGlobal.size();
	cout << "Printing Out the Identical Pixels" << endl;
	imageMaskLog << "Printing Out the Identical Pixels" << endl;
	for (PixelObjectGrayScale pPixelObject : pImageComparisonIdenticalGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIdenticalPixelArraySum = pIdenticalPixelArraySum + pPixelObject.pGreyLevel;
	}

	if (pImageComparisonIdenticalGlobal.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelArraySum / pImageComparisonIdenticalGlobal.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}
	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArraySum << endl;
	cout << "Identical Pixel Array Size = " << pImageComparisonIdenticalGlobal.size() << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	imageMaskLog << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArraySum << endl;
	imageMaskLog << "Identical Pixel Array Size = " << pImageComparisonIdenticalGlobal.size() << endl;
	imageMaskLog << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	cout << "Printing Out the Different Pixels" << endl;
	imageMaskLog << "Printing Out the Different Pixels" << endl;

	pDifferentArraySize = pImageComparisonDifferentGlobal.size();
	for (PixelObjectGrayScale pPixelObject : pImageComparisonDifferentGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pDifferentArraySum = pDifferentArraySum + pPixelObject.pGreyLevel;
	}

	if (pImageComparisonDifferentGlobal.size() > 0)
	{
		pDifferentArrayAverage = pDifferentArraySum / pImageComparisonDifferentGlobal.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}

	int pIdenticalPixelSize = pImageComparisonIdenticalGlobal.size();
	int pDifferentPixelSize = pImageComparisonDifferentGlobal.size();

	*pAmountOfIdenticalPixels = pIdenticalPixelSize;
	*pAmountODifferentPixels = pDifferentPixelSize;
	*ppOutputPixelData = pOutputPixelBufferOutputArrayGlobal;
	*ppIdenticalPixelBuffer = pImageComparisonIdenticalGlobal;
	*ppDifferentPixelBuffer = pImageComparisonDifferentGlobal;
	*ppOutputArrayIntensitySum = pOutputArrayIntensitySum;
	*ppOutputArrayAverage = pOutputArrayAverage;
	*ppIdenticalPixelsIntensitySum = pIdenticalPixelArraySum;
	*ppIdenticalPixelsAverage = pIdenticalPixelArrayAverage;
	*ppDifferentPixelsIntensitySum = pDifferentArraySum;
	*ppDifferentPixelsAverage = pDifferentPixelArrayAverage;

	return hr;


}


HRESULT DirectXStandardAlgorithmExecutor::ApplyVectorOfSectorizationRulesToPixelVector(HINSTANCE hInstance, HWND hWnd, vector<PixelObject> pInputObjectVector, vector<SectorizationRuleY> pRulesToSectorizeForY,
	vector<SectorizationRuleX> pRulesToSectorizeForX,
	vector<SectorizationOutputX> *pSectorizationOutputXVector,
	vector<SectorizationOutputY> *pSectorizationOutputYVector)
{
	HRESULT hr = S_OK;
	vector<SectorizationOutputY> pSectorizationVectorForY = vector<SectorizationOutputY>();
	vector<SectorizationOutputX> pSectorizationVectorForX = vector<SectorizationOutputX>();

	for (SectorizationRuleY pSectorizationRule : pRulesToSectorizeForY)
	{
		SectorObjectY pOutputObject = SectorObjectY(pSectorizationRule.pRuleId, pSectorizationRule.pYConstant,
			pSectorizationRule.pXThresold, 1, 2,
			pSectorizationRule.pSelectedColorRed, pSectorizationRule.pSelectedColorGreen,
			pSectorizationRule.pSelectedColorBlue);


		SectoringRuleY pSectoringRuleObject = SectoringRuleY(pSectorizationRule.pYConstant,
			pSectorizationRule.pXThresold, 1, 2, -1);


		hr = SectorizePixelArrayAgainstYPositionUsingARule(hInstance,
			hWnd, pInputObjectVector, 
			pSectorizationRule.pSelectedColorRed, pSectorizationRule.pSelectedColorGreen,
			pSectorizationRule.pSelectedColorBlue,
			pSectoringRuleObject,
			&pOutputObject);
		SectorizationOutputY pOutputVar = SectorizationOutputY(pOutputObject.pSectorNumber,
			pOutputObject.pYConstant,
			pOutputObject.pXBreackPoint,
			pOutputObject.pSectoringArrayA,
			pOutputObject.pSectoringArrayB,
			pOutputObject.pAverageX0,
			pOutputObject.pAverageX1);
		pSectorizationVectorForY.push_back(pOutputVar);
	}


	for (SectorizationRuleX pSectorizationRule : pRulesToSectorizeForX)
	{
		SectorObjectX pOutputObject = SectorObjectX(pSectorizationRule.pRuleId, pSectorizationRule.pXConstant,
			pSectorizationRule.pYThresold, 1, 2,
			pSectorizationRule.pSelectedColorRed, pSectorizationRule.pSelectedColorGreen,
			pSectorizationRule.pSelectedColorBlue);

		SectoringRuleX pSectoringRuleObject = SectoringRuleX(pSectorizationRule.pXConstant,
			pSectorizationRule.pYThresold, 1, 2, -1);

		hr = SectorizePixelArrayAgainstXPositionUsingARule(hInstance,
			hWnd, pInputObjectVector, 
			pSectorizationRule.pSelectedColorRed, pSectorizationRule.pSelectedColorGreen,
			pSectorizationRule.pSelectedColorBlue,
			pSectoringRuleObject,
			&pOutputObject);
		SectorizationOutputX pOutputVar = SectorizationOutputX(pOutputObject.pSectorNumber,
			pOutputObject.pXConstant,
			pOutputObject.pYBreackPoint,
			pOutputObject.pSectoringArrayA,
			pOutputObject.pSectoringArrayB,
			pOutputObject.pAverageY0,
			pOutputObject.pAverageY1);
		pSectorizationVectorForX.push_back(pOutputVar);
	}

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SectorizePixelArrayAgainstXPositionUsingARule(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pPixelObjectArray,
	float pSelectedColorRed,
	float pSelectedColorGreen,
	float pSelectedColorBlue,
	SectoringRuleX pSectoringRule, SectorObjectX* pOutputSectorObject)
{
	HRESULT hr = S_OK;
	int pSectorPairId = 0;
	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\SectorizingOperationX.txt");

	cout << "Sectorizing our Pixel Array" << endl;
	float pXConstantVar = 0.0f;
	float pYBreakPoint = 0.0f;
	int pSectorNumberOne = 0;
	int pSectorNumberTwo = 0;
	int pInvalidPixelObject = 0;

	pXConstantVar = pSectoringRule.pXConstant;
	pYBreakPoint = pSectoringRule.pYBreackPoint;
	pSectorNumberOne = pSectoringRule.pSectorOne;
	pSectorNumberTwo = pSectoringRule.pSectorTwo;
	pInvalidPixelObject = pSectoringRule.pInvalidPixelLabel;

	vector<FilterPixelLabel> pOutputPixelObjectSectored = vector<FilterPixelLabel>();
	vector<PixelObject> pSectorAObjectArray = vector<PixelObject>();
	vector<PixelObject> pSectorBObjectArray = vector<PixelObject>();


	hr = FilterPixelsForXPositionConstantAndYBreakpoint(hInstance,
		hWnd,
		pXConstantVar,
		pYBreakPoint,
		pSectorNumberOne,
		pSectorNumberTwo,
		pInvalidPixelObject,
		pPixelObjectArray,
		&pOutputPixelObjectSectored);

	if (SUCCEEDED(hr))
	{
		hr = RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd, pSectorNumberOne,
			pOutputPixelObjectSectored,
			&pSectorAObjectArray);
		hr = RestoreRGBPixelFromSectoringOperationForXPosition(hInstance,
			hWnd, pSectorNumberTwo,
			pOutputPixelObjectSectored,
			&pSectorBObjectArray);
	}



	SectorObjectX pSectorObjectVar = SectorObjectX(
		pSectorPairId,
		pSectoringRule.pXConstant,
		pSectoringRule.pYBreackPoint,
		pSectoringRule.pSectorOne,
		pSectoringRule.pSectorTwo,
		pSelectedColorRed,
		pSelectedColorGreen,
		pSelectedColorBlue);
	pSectorObjectVar.pSectoringArrayA = pSectorAObjectArray;
	pSectorObjectVar.pSectoringArrayB = pSectorBObjectArray;

	*pOutputSectorObject = pSectorObjectVar;
	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::SectorizePixelArrayAgainstYPositionUsingARule(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pPixelObjectArray,
	float pSelectedColorRed,
	float pSelectedColorGreen,
	float pSelectedColorBlue,
	SectoringRuleY pSectoringRule, SectorObjectY* pOutputSectorObject)
{
	HRESULT hr = S_OK;
	int pSectorPairId = 0;
	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\SectorizingOperationX.txt");

	cout << "Sectorizing our Pixel Array" << endl;
	float pYConstantVar = 0.0f;
	float pXBreakPoint = 0.0f;
	int pSectorNumberOne = 0;
	int pSectorNumberTwo = 0;
	int pInvalidPixelObject = 0;

	pYConstantVar = pSectoringRule.pYConstant;
	pXBreakPoint = pSectoringRule.pXBreackPoint;
	pSectorNumberOne = pSectoringRule.pSectorOne;
	pSectorNumberTwo = pSectoringRule.pSectorTwo;
	pInvalidPixelObject = pSectoringRule.pInvalidPixelLabel;

	vector<FilterPixelLabel> pOutputPixelObjectSectored = vector<FilterPixelLabel>();
	vector<PixelObject> pSectorAObjectArray = vector<PixelObject>();
	vector<PixelObject> pSectorBObjectArray = vector<PixelObject>();


	hr = FilterPixelsForYPositionConstantAndXBreakpoint(hInstance,
		hWnd,
		pYConstantVar,
		pXBreakPoint,
		pSectorNumberOne,
		pSectorNumberTwo,
		pInvalidPixelObject,
		pPixelObjectArray,
		&pOutputPixelObjectSectored);

	if (SUCCEEDED(hr))
	{
		hr = RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd, pSectorNumberOne,
			pOutputPixelObjectSectored,
			&pSectorAObjectArray);
		hr = RestoreRGBPixelFromSectoringOperationForYPosition(hInstance,
			hWnd, pSectorNumberTwo,
			pOutputPixelObjectSectored,
			&pSectorBObjectArray);
	}

	SectorObjectY pSectorObjectVar = SectorObjectY(
		pSectorPairId,
		pSectoringRule.pYConstant,
		pSectoringRule.pXBreackPoint,
		pSectoringRule.pSectorOne,
		pSectoringRule.pSectorTwo,
		pSelectedColorRed,
		pSelectedColorGreen,
		pSelectedColorBlue);

	pSectorObjectVar.pSectoringArrayA = pSectorAObjectArray;
	pSectorObjectVar.pSectoringArrayB = pSectorBObjectArray;

	*pOutputSectorObject = pSectorObjectVar;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriersThreaded(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	float pColorOneRed,
	float pColorOneGreen,
	float pColorOneBlue,
	float pColorTwoRed,
	float pColorTwoGreen,
	float pColorTwoBlue,
	int pClassOneValue,
	int pClassTwoValue,
	int pClassThreeValue,
	float pThresoldValueData,
	vector<PixelObject> pInputPixelObjectVector,
	vector<OutputPixelObjectDescriptor> *pOutputPixelObjectVector,
	vector<PixelObject> *pClassOnePixelObjectVector,
	vector<PixelObject> *pClassTwoPixelObjectVector
	)
{
	HRESULT hr = S_OK;


	float pImageOneIntensitySumRed = 0.0f;
	

	pPixelObjectOneDetectorGlobal = vector<PixelObject>();
	pOutputPixelObjectVectorGlobal = vector<OutputPixelObjectDescriptor>();
	pClassOnePixelObjectVectorGlobal = vector<PixelObject>();
	pClassTwoPixelObjectVectorGlobal = vector<PixelObject>();
	pColorOneRedGlobal = 0.0f;
	pColorOneGreenGlobal = 0.0f;
	pColorOneBlueGlobal = 0.0f;

	pPixelObjectOneDetectorGlobal = vector<PixelObject>();
	pOutputPixelObjectVectorGlobal = vector<OutputPixelObjectDescriptor>();
	pClassOnePixelObjectVectorGlobal = vector<PixelObject>();
	pClassTwoPixelObjectVectorGlobal = vector<PixelObject>();

	for (PixelObject pixelObject : pInputPixelObjectVector)
	{
		pPixelObjectOneDetectorGlobal.push_back(pixelObject);

	}

	pColorOneRedGlobal = pColorOneRed;
	pColorOneGreenGlobal = pColorOneGreen;
	pColorOneBlueGlobal = pColorOneBlue;
	pColorTwoRedGlobal = pColorTwoRed;
	pColorTwoGreenGlobal = pColorTwoGreen;
	pColorTwoBlueGlobal = pColorTwoBlue;
	pClassOneGlobalVar = pClassOneValue;
	pClassTwoGlobalVar = pClassTwoValue;
	pClassThreeGlobalVar = pClassThreeValue;
	pThresoldValueData = pThresoldValueData;



	DWORD pThreadId = 0;

	pImageComparisonMutexObject = CreateMutex(NULL, FALSE, L"ImageComparisonMutex");


	pImageComparisonThreadHandleValue = CreateThread(NULL,
		0,
		DescriptorThreadedFunctionOutput,
		this,
		0,
		&pThreadId);

	WaitForSingleObject(pImageComparisonThreadHandleValue, INFINITE);
	CloseHandle(pImageComparisonMutexObject);




	*pOutputPixelObjectVector = pOutputPixelObjectVectorGlobal;
	*pClassOnePixelObjectVector = pClassOnePixelObjectVectorGlobal;
	*pClassTwoPixelObjectVector = pClassTwoPixelObjectVectorGlobal;
	return hr;


}



HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalRGBThreaded(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBufferRGB> *ppOutputPixelDataRGB,
	vector<PixelObject> *ppIdenticalPixelBufferRGB,
	vector<PixelObject> *ppDifferentPixelBufferRGB,
	float *ppImageOneIntensitySumRed,
	float *ppImageOneIntensitySumGreen,
	float *ppImageOneIntensitySumBlue,
	float *ppImageTwoIntensitySumRed,
	float *ppImageTwoIntensitySumGreen,
	float *ppImageTwoIntensitySumBlue,
	float *ppImageOutputIntensitySumRed,
	float *ppImageOutputIntensitySumGreen,
	float *ppImageOutputIntensitySumBlue,
	float *ppImageIdenticalIntensitySumRed,
	float *ppImageIdenticalIntensitySumGreen,
	float *ppImageIdenticaltIntensitySumBlue,
	float *ppImageDifferentIntensitySumRed,
	float *ppImageDifferentIntensitySumGreen,
	float *ppImageDifferenttIntensitySumBlue,
	float *ppImageOneIntensityAverageRed,
	float *ppImageOneIntensityAverageGreen,
	float *ppImageOneIntensityAverageBlue,
	float *ppImageTwoIntensityAverageRed,
	float *ppImageTwoIntensityAverageGreen,
	float *ppImageTwoIntensityAverageBlue,
	float *ppImageOutputIntensityAverageRed,
	float *ppImageOutputIntensityAverageGreen,
	float *ppImageOutputIntensityAverageBlue,
	float *ppImageIdenticalIntensityAverageRed,
	float *ppImageIdenticalIntensityAverageGreen,
	float *ppImageIdenticalIntensityAverageBlue,
	float *ppImageDifferentIntensityAverageRed,
	float *ppImageDifferentIntensityAverageGreen,
	float *ppImageDifferenttIntensityAverageBlue,
	BOOL *pAreIdenticalOutput)
{
	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;

	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;


	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;

	float pImageOneIntensityAverageRed = 0.0f;
	float pImageOneIntensityAverageGreen = 0.0f;
	float pImageOneIntensityAverageBlue = 0.0f;

	float pImageTwoIntensityAverageRed = 0.0f;
	float pImageTwoIntensityAverageGreen = 0.0f;
	float pImageTwoIntensityAverageBlue = 0.0f;


	float pOutputArrayIntensityAverageRed = 0.0f;
	float pOutputArrayIntensityAverageGreen = 0.0f;
	float pOutputArrayIntensityAverageBlue = 0.0f;

	float pIdenticalArrayIntensityAverageRed = 0.0f;
	float pIdenticalArrayIntensityAverageGreen = 0.0f;
	float pIdenticalArrayIntensityAverageBlue = 0.0f;


	float pDifferentArrayIntensityAverageRed = 0.0f;
	float pDifferentArrayIntensityAverageGreen = 0.0f;
	float pDifferentArrayIntensityAverageBlue = 0.0f;



	pImageOneForComparisonGlobalRGB = vector<PixelObject>();
	pImageTwoForComparisonGlobalRGB = vector<PixelObject>();

	for (PixelObject pixelObject : pixelArrayOne)
	{
		pImageOneForComparisonGlobalRGB.push_back(pixelObject);
		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumRed + pixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumRed + pixelObject.BMask;

	}

	pImageOneIntensityAverageRed = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneIntensityAverageGreen = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneIntensityAverageBlue = pImageOneIntensitySumBlue / pixelArrayOne.size();



	for (PixelObject pixelObject : pixelArrayTwo)
	{
		pImageTwoForComparisonGlobalRGB.push_back(pixelObject);
		pImageTwoIntensitySumRed = pImageTwoIntensitySumRed + pixelObject.RMask;
		pImageTwoIntensitySumGreen = pImageTwoIntensitySumRed + pixelObject.GMask;
		pImageTwoIntensitySumBlue = pImageTwoIntensitySumRed + pixelObject.BMask;

	}

	pImageTwoIntensityAverageRed = pImageTwoIntensitySumRed / pixelArrayOne.size();
	pImageTwoIntensityAverageGreen = pImageTwoIntensitySumGreen / pixelArrayOne.size();
	pImageTwoIntensityAverageBlue = pImageTwoIntensitySumBlue / pixelArrayOne.size();




	HRESULT hr = S_OK;
	DWORD pThreadId = 0;

	pImageComparisonMutexObject = CreateMutex(NULL, FALSE, L"ImageComparisonMutex");


	pImageComparisonThreadHandleValue = CreateThread(NULL,
		0,
		ComparisonFunctionThreadRGB,
		this,
		0,
		&pThreadId);

	WaitForSingleObject(pImageComparisonThreadHandleValue, INFINITE);
	CloseHandle(pImageComparisonMutexObject);

	fstream imageMaskLog;
	imageMaskLog.open("C:\\pixels\\ImageComparisonFunctionInternal.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);


	for (OutputPixelBufferRGB pOutputPixelValue : pOutputPixelBufferOutputArrayGlobalRGB)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;

	}

	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pOutputPixelBufferOutputArrayGlobalRGB.size();
	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pOutputPixelBufferOutputArrayGlobalRGB.size();
	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pOutputPixelBufferOutputArrayGlobalRGB.size();


	cout << "Printing Identical Pixel Array Buffer" << endl;
	imageMaskLog << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pImageComparisonIdenticalGlobalRGB)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;

	}

	pIdenticalArrayIntensityAverageRed = pIdenticalArrayIntensitySumRed / pImageComparisonIdenticalGlobalRGB.size();
	pIdenticalArrayIntensityAverageGreen = pIdenticalArrayIntensitySumGreen / pImageComparisonIdenticalGlobalRGB.size();
	pIdenticalArrayIntensityAverageBlue = pIdenticalArrayIntensitySumBlue / pImageComparisonIdenticalGlobalRGB.size();



	for (PixelObject pPixelObject : pImageComparisonDifferentGlobalRGB)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;
		
		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;

	}

	pDifferentArrayIntensityAverageRed = pDifferentArrayIntensitySumRed / pImageComparisonDifferentGlobalRGB.size();
	pDifferentArrayIntensityAverageGreen = pDifferentArrayIntensitySumGreen / pImageComparisonDifferentGlobalRGB.size();
	pDifferentArrayIntensityAverageBlue = pDifferentArrayIntensitySumBlue / pImageComparisonDifferentGlobalRGB.size();

	int pIdenticalPixelAmount = pImageComparisonIdenticalGlobalRGB.size();
	int pDifferentPixelAmount = pImageComparisonDifferentGlobalRGB.size();


	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountOfidenticalPixels = pDifferentPixelAmount;
	*ppOutputPixelDataRGB = pOutputPixelBufferOutputArrayGlobalRGB;
	*ppIdenticalPixelBufferRGB = pImageComparisonIdenticalGlobalRGB;
	*ppDifferentPixelBufferRGB = pImageComparisonDifferentGlobalRGB;
	*ppImageOneIntensitySumRed = pImageOneIntensitySumRed;
	*ppImageOneIntensitySumGreen = pImageOneIntensitySumGreen;
	*ppImageOneIntensitySumBlue = pImageOneIntensitySumBlue;
	*ppImageTwoIntensitySumRed = pImageTwoIntensitySumRed;
	*ppImageTwoIntensitySumGreen = pImageTwoIntensitySumGreen;
	*ppImageTwoIntensitySumBlue = pImageTwoIntensitySumBlue;
	*ppImageOutputIntensitySumRed = pOutputArrayIntensitySumRed;
	*ppImageOutputIntensitySumGreen = pOutputArrayIntensitySumGreen;
	*ppImageOutputIntensitySumBlue = pOutputArrayIntensitySumBlue;
	*ppImageOneIntensityAverageRed = pImageOneIntensityAverageRed;
	*ppImageOneIntensityAverageGreen = pImageOneIntensityAverageGreen;
	*ppImageOneIntensityAverageBlue = pImageOneIntensityAverageBlue;
	*ppImageTwoIntensityAverageRed = pImageTwoIntensityAverageRed;
	*ppImageTwoIntensityAverageGreen = pImageTwoIntensityAverageGreen;
	*ppImageTwoIntensityAverageBlue = pImageTwoIntensityAverageBlue;
	*ppImageOutputIntensityAverageRed = pOutputArrayIntensityAverageRed;
	*ppImageOutputIntensityAverageGreen = pOutputArrayIntensityAverageGreen;
	*ppImageOutputIntensityAverageBlue = pOutputArrayIntensityAverageBlue;
	*ppImageIdenticalIntensityAverageRed = pIdenticalArrayIntensityAverageRed;
	*ppImageIdenticalIntensityAverageGreen = pIdenticalArrayIntensityAverageGreen;
	*ppImageIdenticalIntensityAverageBlue = pIdenticalArrayIntensityAverageBlue;
	*ppImageDifferentIntensityAverageRed = pDifferentArrayIntensityAverageRed;
	*ppImageDifferentIntensityAverageGreen = pDifferentArrayIntensityAverageGreen;
	*ppImageDifferenttIntensityAverageBlue = pDifferentArrayIntensityAverageBlue;




	return hr;


}












HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalRGBThreadedUsingSemaphores(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBufferRGB> *ppOutputPixelDataRGB,
	vector<PixelObject> *ppIdenticalPixelBufferRGB,
	vector<PixelObject> *ppDifferentPixelBufferRGB,
	float *ppImageOneIntensitySumRed,
	float *ppImageOneIntensitySumGreen,
	float *ppImageOneIntensitySumBlue,
	float *ppImageTwoIntensitySumRed,
	float *ppImageTwoIntensitySumGreen,
	float *ppImageTwoIntensitySumBlue,
	float *ppImageOutputIntensitySumRed,
	float *ppImageOutputIntensitySumGreen,
	float *ppImageOutputIntensitySumBlue,
	float *ppImageIdenticalIntensitySumRed,
	float *ppImageIdenticalIntensitySumGreen,
	float *ppImageIdenticaltIntensitySumBlue,
	float *ppImageDifferentIntensitySumRed,
	float *ppImageDifferentIntensitySumGreen,
	float *ppImageDifferenttIntensitySumBlue,
	float *ppImageOneIntensityAverageRed,
	float *ppImageOneIntensityAverageGreen,
	float *ppImageOneIntensityAverageBlue,
	float *ppImageTwoIntensityAverageRed,
	float *ppImageTwoIntensityAverageGreen,
	float *ppImageTwoIntensityAverageBlue,
	float *ppImageOutputIntensityAverageRed,
	float *ppImageOutputIntensityAverageGreen,
	float *ppImageOutputIntensityAverageBlue,
	float *ppImageIdenticalIntensityAverageRed,
	float *ppImageIdenticalIntensityAverageGreen,
	float *ppImageIdenticalIntensityAverageBlue,
	float *ppImageDifferentIntensityAverageRed,
	float *ppImageDifferentIntensityAverageGreen,
	float *ppImageDifferenttIntensityAverageBlue,
	BOOL *pAreIdenticalOutput,
	SYSTEMTIME* pCreationTimeVar,
	SYSTEMTIME* pExitTimeVar,
	SYSTEMTIME* pKernelTimeVar,
	SYSTEMTIME* pUserTimeVar)
{
	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;

	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;


	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;

	float pImageOneIntensityAverageRed = 0.0f;
	float pImageOneIntensityAverageGreen = 0.0f;
	float pImageOneIntensityAverageBlue = 0.0f;

	float pImageTwoIntensityAverageRed = 0.0f;
	float pImageTwoIntensityAverageGreen = 0.0f;
	float pImageTwoIntensityAverageBlue = 0.0f;


	float pOutputArrayIntensityAverageRed = 0.0f;
	float pOutputArrayIntensityAverageGreen = 0.0f;
	float pOutputArrayIntensityAverageBlue = 0.0f;

	float pIdenticalArrayIntensityAverageRed = 0.0f;
	float pIdenticalArrayIntensityAverageGreen = 0.0f;
	float pIdenticalArrayIntensityAverageBlue = 0.0f;


	float pDifferentArrayIntensityAverageRed = 0.0f;
	float pDifferentArrayIntensityAverageGreen = 0.0f;
	float pDifferentArrayIntensityAverageBlue = 0.0f;



	pImageOneForComparisonGlobalRGB = vector<PixelObject>();
	pImageTwoForComparisonGlobalRGB = vector<PixelObject>();

	for (PixelObject pixelObject : pixelArrayOne)
	{
		pImageOneForComparisonGlobalRGB.push_back(pixelObject);
		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumRed + pixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumRed + pixelObject.BMask;

	}

	pImageOneIntensityAverageRed = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneIntensityAverageGreen = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneIntensityAverageBlue = pImageOneIntensitySumBlue / pixelArrayOne.size();



	for (PixelObject pixelObject : pixelArrayTwo)
	{
		pImageTwoForComparisonGlobalRGB.push_back(pixelObject);
		pImageTwoIntensitySumRed = pImageTwoIntensitySumRed + pixelObject.RMask;
		pImageTwoIntensitySumGreen = pImageTwoIntensitySumRed + pixelObject.GMask;
		pImageTwoIntensitySumBlue = pImageTwoIntensitySumRed + pixelObject.BMask;

	}

	pImageTwoIntensityAverageRed = pImageTwoIntensitySumRed / pixelArrayOne.size();
	pImageTwoIntensityAverageGreen = pImageTwoIntensitySumGreen / pixelArrayOne.size();
	pImageTwoIntensityAverageBlue = pImageTwoIntensitySumBlue / pixelArrayOne.size();




	HRESULT hr = S_OK;
	DWORD pThreadId = 0;

	pImageComparionSemaphoreObject = CreateSemaphore(NULL, 2, 2, L"ImageComparisonSemaphores");


	pImageComparisonThreadHandleValue = CreateThread(NULL,
		0,
		ComparisonFunctionThreadRGBSemaphores,
		this,
		0,
		&pThreadId);

	WaitForSingleObject(pImageComparisonThreadHandleValue, INFINITE);
	FILETIME creationTime;
	FILETIME exitTime;
	FILETIME kernelTime;
	FILETIME userTime;
	FILETIME creationTimeLocal;
	FILETIME exitTimeLocal;
	FILETIME kernelTimeLocal;
	FILETIME userTimeLocal;
	SYSTEMTIME creationTimeSystem;
	SYSTEMTIME creationTimeLocalSystem;
	SYSTEMTIME exitTimeSystem;
	SYSTEMTIME exitTimeLocalSystem;
	SYSTEMTIME kernelTimeSystem;
	SYSTEMTIME kernelTimeLocalSystem;
	SYSTEMTIME userTimeSystem;
	SYSTEMTIME userTimeLocalSystem;



	GetThreadTimes(pImageComparisonThreadHandleValue,
		&creationTime,
		&exitTime,
		&kernelTime,
		&userTime);

	FileTimeToLocalFileTime(&creationTime, &creationTimeLocal);
	FileTimeToLocalFileTime(&exitTime, &exitTimeLocal);
	FileTimeToLocalFileTime(&kernelTime, &kernelTimeLocal);
	FileTimeToLocalFileTime(&userTime, &userTimeLocal);


	TIME_ZONE_INFORMATION pTimeZoneVar;
	GetTimeZoneInformation(&pTimeZoneVar);



	FileTimeToSystemTime(&creationTime, &creationTimeSystem);
	SystemTimeToTzSpecificLocalTime(&pTimeZoneVar, &creationTimeSystem, &creationTimeLocalSystem);

	FileTimeToSystemTime(&exitTime, &exitTimeSystem);
	SystemTimeToTzSpecificLocalTime(&pTimeZoneVar, &exitTimeSystem, &exitTimeLocalSystem);

	FileTimeToSystemTime(&kernelTime, &kernelTimeSystem);
	SystemTimeToTzSpecificLocalTime(&pTimeZoneVar, &kernelTimeSystem, &kernelTimeLocalSystem);

	FileTimeToSystemTime(&userTime, &userTimeSystem);
	SystemTimeToTzSpecificLocalTime(&pTimeZoneVar, &userTimeSystem, &userTimeLocalSystem);



	


	CloseHandle(pImageComparionSemaphoreObject);

	fstream imageMaskLog;
	imageMaskLog.open("C:\\pixels\\ImageComparisonFunctionInternalSemaphores.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);


	for (OutputPixelBufferRGB pOutputPixelValue : pOutputPixelBufferOutputArrayGlobalRGB)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;

	}

	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pOutputPixelBufferOutputArrayGlobalRGB.size();
	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pOutputPixelBufferOutputArrayGlobalRGB.size();
	pOutputArrayIntensityAverageRed = pOutputArrayIntensitySumRed / pOutputPixelBufferOutputArrayGlobalRGB.size();


	cout << "Printing Identical Pixel Array Buffer" << endl;
	imageMaskLog << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pImageComparisonIdenticalGlobalRGB)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;

	}

	pIdenticalArrayIntensityAverageRed = pIdenticalArrayIntensitySumRed / pImageComparisonIdenticalGlobalRGB.size();
	pIdenticalArrayIntensityAverageGreen = pIdenticalArrayIntensitySumGreen / pImageComparisonIdenticalGlobalRGB.size();
	pIdenticalArrayIntensityAverageBlue = pIdenticalArrayIntensitySumBlue / pImageComparisonIdenticalGlobalRGB.size();



	for (PixelObject pPixelObject : pImageComparisonDifferentGlobalRGB)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;

	}

	cout << "Start of procedure: " << creationTimeLocalSystem.wHour << ":" << creationTimeLocalSystem.wMinute << ":" << creationTimeLocalSystem.wSecond << endl;
	cout << "End of procedure: " << exitTimeLocalSystem.wHour << ":" << exitTimeLocalSystem.wMinute << ":" << exitTimeLocalSystem.wSecond << endl;
	cout << "Kernel time of procedure: " << kernelTimeLocalSystem.wHour << ":" << kernelTimeLocalSystem.wMinute << ":" << kernelTimeLocalSystem.wSecond << endl;
	cout << "User of procedure: " << userTimeLocalSystem.wHour << ":" << userTimeLocalSystem.wMinute << ":" << userTimeLocalSystem.wSecond << endl;

	imageMaskLog << "Start of procedure: " << creationTimeLocalSystem.wHour << ":" << creationTimeLocalSystem.wMinute << ":" << creationTimeLocalSystem.wSecond << endl;
	imageMaskLog << "End of procedure: " << exitTimeLocalSystem.wHour << ":" << exitTimeLocalSystem.wMinute << ":" << exitTimeLocalSystem.wSecond << endl;
	imageMaskLog << "Kernel time of procedure: " << kernelTimeLocalSystem.wHour << ":" << kernelTimeLocalSystem.wMinute << ":" << kernelTimeLocalSystem.wSecond << endl;
	imageMaskLog << "User time of procedure: " << userTimeLocalSystem.wHour << ":" << userTimeLocalSystem.wMinute << ":" << userTimeLocalSystem.wSecond << endl;
	imageMaskLog.close();



	pDifferentArrayIntensityAverageRed = pDifferentArrayIntensitySumRed / pImageComparisonDifferentGlobalRGB.size();
	pDifferentArrayIntensityAverageGreen = pDifferentArrayIntensitySumGreen / pImageComparisonDifferentGlobalRGB.size();
	pDifferentArrayIntensityAverageBlue = pDifferentArrayIntensitySumBlue / pImageComparisonDifferentGlobalRGB.size();

	int pIdenticalPixelAmount = pImageComparisonIdenticalGlobalRGB.size();
	int pDifferentPixelAmount = pImageComparisonDifferentGlobalRGB.size();


	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountOfidenticalPixels = pDifferentPixelAmount;
	*ppOutputPixelDataRGB = pOutputPixelBufferOutputArrayGlobalRGB;
	*ppIdenticalPixelBufferRGB = pImageComparisonIdenticalGlobalRGB;
	*ppDifferentPixelBufferRGB = pImageComparisonDifferentGlobalRGB;
	*ppImageOneIntensitySumRed = pImageOneIntensitySumRed;
	*ppImageOneIntensitySumGreen = pImageOneIntensitySumGreen;
	*ppImageOneIntensitySumBlue = pImageOneIntensitySumBlue;
	*ppImageTwoIntensitySumRed = pImageTwoIntensitySumRed;
	*ppImageTwoIntensitySumGreen = pImageTwoIntensitySumGreen;
	*ppImageTwoIntensitySumBlue = pImageTwoIntensitySumBlue;
	*ppImageOutputIntensitySumRed = pOutputArrayIntensitySumRed;
	*ppImageOutputIntensitySumGreen = pOutputArrayIntensitySumGreen;
	*ppImageOutputIntensitySumBlue = pOutputArrayIntensitySumBlue;
	*ppImageOneIntensityAverageRed = pImageOneIntensityAverageRed;
	*ppImageOneIntensityAverageGreen = pImageOneIntensityAverageGreen;
	*ppImageOneIntensityAverageBlue = pImageOneIntensityAverageBlue;
	*ppImageTwoIntensityAverageRed = pImageTwoIntensityAverageRed;
	*ppImageTwoIntensityAverageGreen = pImageTwoIntensityAverageGreen;
	*ppImageTwoIntensityAverageBlue = pImageTwoIntensityAverageBlue;
	*ppImageOutputIntensityAverageRed = pOutputArrayIntensityAverageRed;
	*ppImageOutputIntensityAverageGreen = pOutputArrayIntensityAverageGreen;
	*ppImageOutputIntensityAverageBlue = pOutputArrayIntensityAverageBlue;
	*ppImageIdenticalIntensityAverageRed = pIdenticalArrayIntensityAverageRed;
	*ppImageIdenticalIntensityAverageGreen = pIdenticalArrayIntensityAverageGreen;
	*ppImageIdenticalIntensityAverageBlue = pIdenticalArrayIntensityAverageBlue;
	*ppImageDifferentIntensityAverageRed = pDifferentArrayIntensityAverageRed;
	*ppImageDifferentIntensityAverageGreen = pDifferentArrayIntensityAverageGreen;
	*ppImageDifferenttIntensityAverageBlue = pDifferentArrayIntensityAverageBlue;
	*pCreationTimeVar = creationTimeLocalSystem;
	*pExitTimeVar = exitTimeLocalSystem;
	*pKernelTimeVar = kernelTimeLocalSystem;
	*pUserTimeVar = userTimeLocalSystem;



	return hr;


}





HRESULT DirectXStandardAlgorithmExecutor::InitializeImageGrayScaleSubtractionResources(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppInputBuffer2,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\\Cleaner Simulation\\Kernel Final\\AlgorithmObjects\\ImageMaskSubtractionGrayScale.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc2));
	buffer_desc_output.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayTwo.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppInputBuffer2 = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunGrayScaleImageSubtractionFunctionShaderAlgorithm(HINSTANCE hInstance, 
										HWND hWnd, 
										ID3D11ComputeShader* pComputeShaderObject,
										ID3D11ShaderResourceView* pShaderResourceView0,
										ID3D11ShaderResourceView* pShaderResourceView1, 
										ID3D11UnorderedAccessView* pUnorderedUAV, 
										UINT pNumberOfSRV, UINT pNumberOfUAV, 
										UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCoordinatesCriteriaYCBCR(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	vector<YCBRPixelDataBuffer> ppPixelArrayInput,
	vector<OutputPixelObjectFilteredYCBCR> *ppPixelObjectGrayScale)
{
		HRESULT hr = S_OK;

		fstream pOutputFileStream;
		pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

		pOutputFileStream.clear();
		vector<OutputPixelObjectFilteredYCBCR> ppOutputDataBuffer = vector<OutputPixelObjectFilteredYCBCR>();

		cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
		cout << "For this Simulation We Will Use" << endl;
		cout << "1 Compute Shader" << endl;
		cout << "1 Input Buffer Of Pixels" << endl;
		cout << "1 Output Buffer for Pixel Output" << endl;
		cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
		cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
		cout << "1 Readback Data Buffer" << endl;

		pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
		pOutputFileStream << "For this Simulation We Will Use" << endl;
		pOutputFileStream << "1 Compute Shader" << endl;
		pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
		pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
		pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
		pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
		pOutputFileStream << "1 Readback Data Buffer" << endl;




		cout << "We Will Start By Printing Out our Pixel Data" << endl;
		int pIndex = 0;
		for (YCBRPixelDataBuffer pOutputData : ppPixelArrayInput)
		{
			cout << "Pixel №: " << pOutputData.pixelNumber << endl;
			cout << "X Position: " << pOutputData.xPosition << endl;
			cout << "Y Position: " << pOutputData.yPosition << endl;
			cout << "Y Component" << pOutputData.pYValue << endl;
			cout << "Cb Component" << pOutputData.pCbValue << endl;
			cout << "Cr Component" << pOutputData.pCrValue << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
			pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
			pOutputFileStream << "Red Component" << pOutputData.pYValue << endl;
			pOutputFileStream << "Green Component" << pOutputData.pCbValue << endl;
			pOutputFileStream << "Blue Mask" << pOutputData.pCrValue << endl;

			pIndex = pIndex + 1;
		}

		cout << "Reserving Data And Preparing Resources" << endl;

		ID3D11ComputeShader* ppComputeShaderObject = nullptr;
		ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
		ID3D11Buffer* ppInputDataBuffer = nullptr;
		ID3D11Buffer* pOutputDataBuffer = nullptr;
		ID3D11ShaderResourceView* pShaderResourceView = nullptr;
		ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
		ID3D11Buffer* pReadbackOutputBuffer = nullptr;

		hr = InitializeImageThresholdingCoordinatesOperationYCBCR(hInstance,
			hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY, &ppComputeShaderObject,
			ppPixelArrayInput,
			&ppBinaryImageConstantBuffer,
			&ppInputDataBuffer, &pOutputDataBuffer,
			&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
			pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
			pOutputFileStream.close();
			return hr;
		}

		cout << "Simulating the Prepared Image Conversion" << endl;

		hr = RunImageThresholdingOperationYCBCR(hInstance,
			hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
			pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
			pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
			pOutputFileStream.close();
		}

		cout << "Compute Simulation has been Completed" << endl;
		cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

		cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

		printf("done\n");

		// Read back the result from GPU, verify its correctness against result computed by CPU
		{
			cout << "Copying Data From GPU To CPU" << endl;

			D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
			m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
			hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

			// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
			// This is also a common trick to debug CS programs.



			// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
			// This is also a common trick to debug CS programs.
			OutputPixelObjectFilteredYCBCR* p = (OutputPixelObjectFilteredYCBCR*)MappedResource.pData;

			if (p == nullptr)
			{
				cout << "Filter Returned No Output" << endl;
				pOutputFileStream << "Filter Returned No Output" << endl;
				return hr;
			}

			for (int i = 0; i < ppPixelArrayInput.size(); ++i)
			{

				ppOutputDataBuffer.push_back(p[i]);

			}





			std::time_t t = std::time(0);   // get time now
			std::tm* now = std::localtime(&t);
			std::cout << (now->tm_year + 1900) << '-'
				<< (now->tm_mon + 1) << '-'
				<< now->tm_mday
				<< now->tm_hour
				<< now->tm_min
				<< now->tm_sec
				<< endl;


			for (OutputPixelObjectFilteredYCBCR pPixelObject : ppOutputDataBuffer)
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Y Value: " << pPixelObject.pYValue << endl;
				cout << "Cb Value: " << pPixelObject.pCbValue << endl;
				cout << "Cr Value: " << pPixelObject.pCrValue << endl;
				cout << "Used In Computations: " << pPixelObject.pIsPixelValid << endl;

				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Y Value: " << pPixelObject.pYValue << endl;
				pOutputFileStream << "Cb Value: " << pPixelObject.pCbValue << endl;
				pOutputFileStream << "Cr Value: " << pPixelObject.pCrValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pIsPixelValid << endl;


			}

			t = std::time(0);   // get time now
			now = std::localtime(&t);
			std::cout << (now->tm_year + 1900) << '-'
				<< (now->tm_mon + 1) << '-'
				<< now->tm_mday
				<< now->tm_hour
				<< now->tm_min
				<< now->tm_sec
				<< endl;
			pOutputFileStream << (now->tm_year + 1900) << '-'
				<< (now->tm_mon + 1) << '-'
				<< now->tm_mday
				<< now->tm_hour
				<< now->tm_min
				<< now->tm_sec
				<< endl;



		}

		printf("Cleaning up...\n");

		SafeReleaseA(&ppComputeShaderObject);
		SafeReleaseA(&ppInputDataBuffer);
		SafeReleaseA(&pOutputDataBuffer);
		SafeReleaseA(&pShaderResourceView);
		SafeReleaseA(&pUnorderedAccessView);
		SafeReleaseA(&pReadbackOutputBuffer);

		pOutputFileStream.close();
		*ppPixelObjectGrayScale = ppOutputDataBuffer;


		return hr;
	


}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingCoordinatesOperationYCBCR(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<YCBRPixelDataBuffer> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThresholdImageConstantBufferCoordinatesrGrayScale pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pMinimumX = pMinimumX;
	pBinaryImageConstantBuffer.pMinimumY = pMinimumY;
	pBinaryImageConstantBuffer.pMaximumX = pMaximumX;
	pBinaryImageConstantBuffer.pMaximumY = pMaximumY;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelsByCoordinatesCondiitionYCBCR.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThresholdImageConstantBufferCoordinatesrGrayScale) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(YCBRPixelDataBuffer);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(YCBRPixelDataBuffer);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFilteredYCBCR);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFilteredYCBCR);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFilteredYCBCR);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFilteredYCBCR);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunImageThresholdingOperationYCBCR(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCoordinatesCriteria(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	vector<PixelObjectGrayScale> ppPixelArrayInput, vector<OutputPixelObjectFilteredGrayScale> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixelsGrayScale.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFilteredGrayScale> ppOutputDataBuffer = vector<OutputPixelObjectFilteredGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObjectGrayScale pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "GrayScale Value: " << pOutputData.pGreyLevel << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "GrayScale Value: " << pOutputData.pGreyLevel << endl;


		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingCoordinatesOperation(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY, &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, 
		ppBinaryImageConstantBuffer,
		ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFilteredGrayScale* p = (OutputPixelObjectFilteredGrayScale*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;

		auto ItA = begin(ppPixelArrayInput);
		auto ItB = begin(ppOutputDataBuffer);

		while (ItA < end(ppPixelArrayInput) && ItB < end(ppOutputDataBuffer))
		{
			cout << "Processing Item At Index: " << pIndex << endl;
			ItB->pixelNumber = ItA->pixelNumber;
			ItB->xPosition = ItA->xPosition;
			ItB->yPosition = ItA->yPosition;
			++ItA;
			++ItB;
			pIndex = pIndex + 1;
		}


		for (OutputPixelObjectFilteredGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Filtered Value: " << pPixelObject.pGrayScaleValue << endl;
			cout << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Filtered Value: " << pPixelObject.pGrayScaleValue << endl;
			pOutputFileStream << "Is Pixel Valid: " << pPixelObject.pIsPixelValid << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunImageThresholdingOperation(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingCoordinatesOperation(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThresholdImageConstantBufferCoordinatesrGrayScale pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pMinimumX = pMinimumX;
	pBinaryImageConstantBuffer.pMinimumY = pMinimumY;
	pBinaryImageConstantBuffer.pMaximumX = pMaximumX;
	pBinaryImageConstantBuffer.pMaximumY = pMaximumY;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelsByCoordinatesCondition.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThresholdImageConstantBufferCoordinatesrGrayScale) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFilteredGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFilteredGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFilteredGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFilteredGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializePixelValidationProcedureColors(HINSTANCE hInstance,
	HWND hWnd,
	float pSamplRed,
	float pSampleGreen,
	float pSampleBlue,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	cbPixelValidationBuffer pPixelValidationConstantBuffer;
	pPixelValidationConstantBuffer.pRedComponentConst = pSamplRed;
	pPixelValidationConstantBuffer.pGreenComponentConst = pSampleGreen;
	pPixelValidationConstantBuffer.pBlueComponentConst = pSampleBlue;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ValidatePixelByTotalColorCorrespondense.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbPixelValidationBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pPixelValidationConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
	
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;

	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingCoordinatesOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThresholdImageConstantBufferCoordinatesRGB pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pMinimumX = pMinimumX;
	pBinaryImageConstantBuffer.pMinimumY = pMinimumY;
	pBinaryImageConstantBuffer.pMaximumX = pMaximumX;
	pBinaryImageConstantBuffer.pMaximumY = pMaximumY;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelsByCoordinatesConditionRGB.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThresholdImageConstantBufferCoordinatesRGB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCriteriaGrayScale(HINSTANCE hInstance,
	HWND hWnd, float pMinimumX, float pMinimumY, float pMaximumX, float pMaximumY, float pThresholdIntensityValueBottom, float pThresholdIntensityValueTop, vector<PixelObjectGrayScale> ppPixelArrayInput, vector<OutputPixelObjectFilteredGrayScale> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\FilterImageByCoordinatesAndPixels.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFilteredGrayScale> ppOutputDataBuffer = vector<OutputPixelObjectFilteredGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObjectGrayScale pPixelObject : ppPixelArrayInput)
	{

		float pPixelNumber = pPixelObject.pixelNumber;
		float pXValue = pPixelObject.xPosition;
		float pYValue = pPixelObject.yPosition;
		float pPixeoObjectGrayScale = pPixelObject.pGreyLevel;

		cout << "Step: " << pPixelObject.pixelNumber << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperation(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY,
		pThresholdIntensityValueBottom, pThresholdIntensityValueTop, &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd,  ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFilteredGrayScale* p = (OutputPixelObjectFilteredGrayScale*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;

		auto ItA = begin(ppPixelArrayInput);
		auto ItB = begin(ppOutputDataBuffer);


		for (OutputPixelObjectFilteredGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Filtered Value: " << pPixelObject.pGrayScaleValue << endl;
			cout << "Is Pixel Used: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Filtered Value: " << pPixelObject.pGrayScaleValue << endl;
			pOutputFileStream << "Is Pixel Used: " << pPixelObject.pIsPixelValid << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCriteriaRGB(HINSTANCE hInstance, HWND hWnd,
	float pMinimumX, float pMinimumY, float pMaximumX, float pMaximumY,
	float pThresholdIntensityValueBottomR,
	float pThresholdIntensityValueTopR,
	float pThresholdIntensityValueBottomG,
	float pThresholdIntensityValueTopG,
	float pThresholdIntensityValueBottomB,
	float pThresholdIntensityValueTopB,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
    
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
		{

			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pIndex = pIndex + 1;
		}
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperationRGB(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY,
        pThresholdIntensityValueBottomR,
        pThresholdIntensityValueTopR,
        pThresholdIntensityValueBottomG,
        pThresholdIntensityValueTopG,
        pThresholdIntensityValueBottomB,
        pThresholdIntensityValueTopB,
        &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd,  ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			
		

				ppOutputDataBuffer.push_back(p[i]);
					
			
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
	


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			
			if ((pPixelObject.rValue != 255.0f) && (pPixelObject.gValue != 255.0f) && (pPixelObject.bValue != 255.0f))
			{
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
			}


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondence(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRed,
	float pSampleGreen,
	float pSampleBlue,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializePixelValidationProcedureColors(hInstance,
		hWnd, pSampleRed, pSampleGreen, pSampleBlue, ppPixelArrayInput,  &ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelValidationProcedure(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;

			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCriteriaRGBWithColors(HINSTANCE hInstance, HWND hWnd,
	float pMinimumX, float pMinimumY, float pMaximumX, float pMaximumY,
	float pThresholdIntensityValueBottomR,
	float pThresholdIntensityValueTopR,
	float pThresholdIntensityValueBottomG,
	float pThresholdIntensityValueTopG,
	float pThresholdIntensityValueBottomB,
	float pThresholdIntensityValueTopB,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
    
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		
			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			pIndex = pIndex + 1;
		
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingOperationRGB(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY,
        pThresholdIntensityValueBottomR,
        pThresholdIntensityValueTopR,
        pThresholdIntensityValueBottomG,
        pThresholdIntensityValueTopG,
        pThresholdIntensityValueBottomB,
        pThresholdIntensityValueTopB,
        &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd,  ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;
			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			
		

				ppOutputDataBuffer.push_back(p[i]);
					
			
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
	


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			
			
				cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				cout << "X Position: " << pPixelObject.xPosition << endl;
				cout << "Y Position: " << pPixelObject.yPosition << endl;
				cout << "Red Component: " << pPixelObject.rValue << endl;
				cout << "Green Component: " << pPixelObject.gValue << endl;
				cout << "Blue Component: " << pPixelObject.bValue << endl;
				cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


				pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
				pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
				pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
				pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
				pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
				pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
				pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;
		


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::InitializePixelValidationProcedure(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	float pSampleRed,
	float pSampleGreen,
	float pSampleBlue,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	cbPixelValidationBuffer pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pRedComponentConst = pSampleRed;
	pBinaryImageConstantBuffer.pGreenComponentConst = pSampleGreen;
	pBinaryImageConstantBuffer.pBlueComponentConst = pSampleBlue;


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ValidatePixelByTotalCorrespondense.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbPixelValidationBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelValidationProcedure(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulateInterestPointDetector(HINSTANCE hInstance,
	HWND hWnd,
	int pPixelNumberFactor,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectInterestPoint> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectInterestPoint> ppOutputDataBuffer = vector<OutputPixelObjectInterestPoint>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeInterestPointDetectorRGB(hInstance,
		hWnd, pPixelNumberFactor, &ppComputeShaderObject, ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunInterestingPointDetector(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectInterestPoint* p = (OutputPixelObjectInterestPoint*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;

			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectInterestPoint pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Remainder Var: " << pPixelObject.pRemainderVar << endl;
			cout << "Used In Computations: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pIsPixelValid << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeInterestPointDetectorRGB(HINSTANCE hInstance,
	HWND hWnd,
	int pPixelNumberFactor, 
	ID3D11ComputeShader** ppComputeShaderObject, 
	vector<PixelObject> pixelArrayOne, 
	ID3D11Buffer** ppConstantBuffer, 
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer, 
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1, 
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	
	CSConstantBufferPixelNumberStruct pConstantBufferStr;
	pConstantBufferStr.pPixelNumberFactor = pPixelNumberFactor;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSInterestPointDetectorShader.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CSConstantBufferPixelNumberStruct) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferStr;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectInterestPoint);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectInterestPoint);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectInterestPoint);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectInterestPoint);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulateInterestPointDetectorCoordinates(HINSTANCE hInstance,
	HWND hWnd,
	float pXPositionDivisor,
	float pYPositionDivisor,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectInterestPointCoordinates> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectInterestPointCoordinates> ppOutputDataBuffer = vector<OutputPixelObjectInterestPointCoordinates>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeInterestPointDetectorCoordinates(hInstance,
		hWnd, pXPositionDivisor, pYPositionDivisor, &ppComputeShaderObject, ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunInterestingPointDetector(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectInterestPointCoordinates* p = (OutputPixelObjectInterestPointCoordinates*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;

			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectInterestPointCoordinates pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pIsPixelValid << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pIsPixelValid << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeInterestPointDetectorCoordinates(HINSTANCE hInstance,
	HWND hWnd,
	float pXPositionFactor,
	float pYPositionFactor,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	CBThreshHoldVarCoordinatesVar pConstantBufferStr;
	pConstantBufferStr.pXPositionDivisor = pXPositionFactor;
	pConstantBufferStr.pYPositionDivisor = pYPositionFactor;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSInterestPointDetectorShaderCoordinates.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CSConstantBufferPixelNumberStruct) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferStr;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectInterestPoint);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectInterestPoint);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectInterestPoint);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectInterestPoint);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunInterestingPointDetector(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::ThresoldPixelValuesByCoordinatesCriteriaRGB(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingCoordinatesOperationRGB(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY, &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;

			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			
				ppOutputDataBuffer.push_back(p[i]);
			
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ComputeWindowFunctionForRGBImage(HINSTANCE hInstance,
	HWND hWnd,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectFiltered> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\FilterImageByCoordinatesAndPixelsRGB.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectFiltered> ppOutputDataBuffer = vector<OutputPixelObjectFiltered>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageThresholdingCoordinatesOperationRGB(hInstance,
		hWnd, ppPixelArrayInput.size(), pMinimumX, pMinimumY, pMaximumX, pMaximumY, &ppComputeShaderObject,
		ppPixelArrayInput,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageThresholdingOperation(hInstance,
		hWnd, ppBinaryImageConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectFiltered* p = (OutputPixelObjectFiltered*)MappedResource.pData;

		if (p == nullptr)
		{
			cout << "Filter Returned No Output" << endl;
			pOutputFileStream << "Filter Returned No Output" << endl;

			return hr;
		}

		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{

			ppOutputDataBuffer.push_back(p[i]);

		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;


		for (OutputPixelObjectFiltered pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Used In Computations: " << pPixelObject.pUsedInComputations << endl;


		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}











HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingOperation(HINSTANCE hInstance,
    HWND hWnd,
	UINT ppAmountOfSamples,
	float pMinimumX,
	float pMinimumY,
	float pMaximumX,
	float pMaximumY,
	float pThresholdIntensityValueBottom,
	float pThresholdIntensityValueTop,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThresholdImageConstantBufferGrayScale pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pThreshHoldValueLower = pThresholdIntensityValueBottom;
	pBinaryImageConstantBuffer.pThresHoldValueUpper = pThresholdIntensityValueTop;
	pBinaryImageConstantBuffer.pMinimumX = pMinimumX;
	pBinaryImageConstantBuffer.pMinimumY = pMinimumY;
	pBinaryImageConstantBuffer.pMaximumX = pMaximumX;
	pBinaryImageConstantBuffer.pMaximumY = pMaximumY;
    

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelsByRangeConditionGrayScaleProcedured.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThresholdImageConstantBufferGrayScale) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFilteredGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFilteredGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFilteredGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFilteredGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ApplyBinaryClassifierForImagePixels(HINSTANCE hInstance,
	HWND hWnd,
	float pThresholdIntensityValueR,
	float pThresholdIntensityValueG,
	float pThresholdIntensityValueB,
	int pValidPixelClassifier,
	int pInvalidPixelClassifier,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectClassified> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\PixelDataToBlackAndWithe.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectClassified> ppOutputDataBuffer = vector<OutputPixelObjectClassified>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;

	CBBinaryClassifierConstantBuffer pConstantData;
	pConstantData.pThresholdIntensityValueR = pThresholdIntensityValueR;
	pConstantData.pThresholdIntensityValueB = pThresholdIntensityValueB;
	pConstantData.pThresholdIntensityValueG = pThresholdIntensityValueG;
	pConstantData.pValidPixelConstant = 1;
	pConstantData.pInvalidPixelConstant = 0;

	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelArrayInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;



	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppBinaryImageConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageBinaryClassifierResources(hInstance,
		hWnd, pConstantData,
		ppPixelArrayInput,
		&ppComputeShaderObject,
		&ppBinaryImageConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageBinaryClassifier(hInstance,
		hWnd,
		ppBinaryImageConstantBuffer,
		ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resource For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectClassified* p = (OutputPixelObjectClassified*)MappedResource.pData;
		for (int i = 0; i < ppPixelArrayInput.size(); ++i)
		{
			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		for (OutputPixelObjectClassified pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component: " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			cout << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			cout << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			cout << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component: " << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component: " << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component: " << pPixelObject.bValue << endl;
			pOutputFileStream << "Class of Pixel Red: " << pPixelObject.pClassOfPixelRed << endl;
			pOutputFileStream << "Class of Pixel Green: " << pPixelObject.pClassOfPixelGreen << endl;
			pOutputFileStream << "Class of Pixel Blue: " << pPixelObject.pClassOfPixelBlue << endl;
			pOutputFileStream << "Class of Pixel Output: " << pPixelObject.pClassOfPixelOutput << endl;



		}

		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppBinaryImageConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*ppPixelObjectGrayScale = ppOutputDataBuffer;


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeImageBinaryClassifierResources(HINSTANCE hInstance,
	HWND hWnd,
	CBBinaryClassifierConstantBuffer pConstantBufferObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\BinaryPixelClassifierCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBBinaryClassifierConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstantBufferObject;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectClassified);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectClassified);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectClassified);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectClassified);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunImageBinaryClassifier(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataFromSinglePixelToLinkedListModel(HINSTANCE hInstance,
	HWND hWnd, 
	float pImageWidth, 
	float pImageHeight,
	float pIndexDelta, 
	vector<PixelObject> pixelArrayOne, vector<PixelObjectLinkedListElement> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToLinkedList.txt");

	pOutputFileStream.clear();
	vector<PixelObjectLinkedListElement> ppOutputDataBuffer = vector<PixelObjectLinkedListElement>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;
	

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}





	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBufferOne = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageConversionFromRGBModelToLinkedListModel(hInstance,
		hWnd, pixelArrayOne.size(),
		pixelArrayOne,
		pImageWidth,
		pImageHeight,
		pIndexDelta,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBufferOne,
		&pOutputDataBuffer,
		&pShaderResourceViewOne,
		&pUnorderedAccessView,
		&pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelToLinkedListModel(hInstance,
		hWnd, 
		pConstantBuffer,
		ppComputeShaderObject,
		pShaderResourceViewOne,
		pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectLinkedListElement* p = (PixelObjectLinkedListElement*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			cout << "Pixel Number One: " << p[i].pixelNumber << endl;
			cout << "X Position One: " << p[i].xPosition << endl;
			cout << "Y Position One: " << p[i].yPosition << endl;
			cout << "Red Component One: " << p[i].rValue << endl;
			cout << "Green Component One: " << p[i].gValue << endl;
			cout << "Blue Value: " << p[i].bValue << endl;
			cout << "Is Pixel First: " << p[i].isFirst << endl;
			cout << "Is Pixel Last: " << p[i].isLast << endl;
			cout << "Next Pixel: " << p[i].pNextPixelNumber << endl;
			

			pOutputFileStream << "Pixel Number One: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position One: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position One: " << p[i].yPosition << endl;
			pOutputFileStream << "Red Component One: " << p[i].rValue << endl;
			pOutputFileStream << "Green Component One: " << p[i].gValue << endl;
			pOutputFileStream << "Blue Value: " << p[i].bValue << endl;
			pOutputFileStream << "Is Pixel First: " << p[i].isFirst << endl;
			pOutputFileStream << "Is Pixel Last: " << p[i].isLast << endl;
			pOutputFileStream << "Next Pixel: " << p[i].pNextPixelNumber << endl;
		

			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectLinkedListElement pPixelObjectClass : ppOutputDataBuffer)
		{
			cout << "Pixel Number One: " << pPixelObjectClass.pixelNumber << endl;
			cout << "X Position One: " << pPixelObjectClass.xPosition << endl;
			cout << "Y Position One: " << pPixelObjectClass.yPosition << endl;
			cout << "Red Component One: " << pPixelObjectClass.rValue << endl;
			cout << "Green Component One: " << pPixelObjectClass.gValue << endl;
			cout << "Blue Value: " << pPixelObjectClass.bValue << endl;
			cout << "Is Pixel First: " << pPixelObjectClass.isFirst << endl;
			cout << "Is Pixel Last: " << pPixelObjectClass.isLast << endl;
			cout << "Next Pixel: " << pPixelObjectClass.pNextPixelNumber << endl;


			pOutputFileStream << "Pixel Number One: " << pPixelObjectClass.pixelNumber << endl;
			pOutputFileStream << "X Position One: " << pPixelObjectClass.xPosition << endl;
			pOutputFileStream << "Y Position One: " << pPixelObjectClass.yPosition << endl;
			pOutputFileStream << "Red Component One: " << pPixelObjectClass.rValue << endl;
			pOutputFileStream << "Green Component One: " << pPixelObjectClass.gValue << endl;
			pOutputFileStream << "Blue Value: " << pPixelObjectClass.bValue << endl;
			pOutputFileStream << "Is Pixel First: " << pPixelObjectClass.isFirst << endl;
			pOutputFileStream << "Is Pixel Last: " << pPixelObjectClass.isLast << endl;
			pOutputFileStream << "Next Pixel: " << pPixelObjectClass.pNextPixelNumber << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBufferOne);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceViewOne);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConversionFromRGBModelToLinkedListModel(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	vector<PixelObject> pixelArrayOne,
	float pImageWidth,
	float pImageHeight,
	float pIndexDelta,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	cbImageLinkedListModel pLinkedListModel;
	pLinkedListModel.pImageHeight = pImageHeight;
	pLinkedListModel.pImageWidth = pImageWidth;
	pLinkedListModel.pIndexDelta = pIndexDelta;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling thCompute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSConvertImageToPixelLinkedListModel.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}



	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbImageLinkedListModel) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pLinkedListModel;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creatingthe Input Buffer For Image One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectLinkedListElement);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectLinkedListElement);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectLinkedListElement);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectLinkedListElement);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelToLinkedListModel(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV};
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr};
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataFromRGBModelToTemperatureModel(HINSTANCE hInstance, HWND hWnd,
	float pHighestTemperature,
	float pHighestColorValue,
	float pVolatileRegionMark,
	float pStillRegionMark,
	vector<PixelObject> pixelArrayOne,
	vector<OutputPixelObjectTemperature> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<OutputPixelObjectTemperature> ppOutputDataBuffer = vector<OutputPixelObjectTemperature>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppConstantBuffer = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageConversionFromRGBModelToTemperatureModel(hInstance,
		hWnd, pixelArrayOne.size(), pixelArrayOne, pHighestColorValue,
		pHighestTemperature,
		pStillRegionMark,
		pVolatileRegionMark,
		&ppComputeShaderObject,
		&pConstantBuffer,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunPixelToTemperatureModelConversion(hInstance,
		hWnd,  pConstantBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputPixelObjectTemperature* p = (OutputPixelObjectTemperature*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Red Component" << p[i].rValue << endl;
			cout << "Green Component" << p[i].gValue << endl;
			cout << "Blue Component" << p[i].bValue << endl;
			cout << "Red Value Temperature: " << p[i].pTemperatureRed << endl;
			cout << "Green Value Temperature: " << p[i].pTemperatureGreen << endl;
			cout << "Blue Value Temperature: " << p[i].pTemperatureBlue << endl;
			cout << "Overall Temperature: " << p[i].pOverallTemperature << endl;
			cout << "Region Label" << p[i].pRegionMarkerValue <<  endl;
			
			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Red Component" << p[i].rValue << endl;
			pOutputFileStream << "Green Component" << p[i].gValue << endl;
			pOutputFileStream << "Blue Component" << p[i].bValue << endl;
			pOutputFileStream << "Red Value Temperature: " << p[i].pTemperatureRed << endl;
			pOutputFileStream << "Green Value Temperature: " << p[i].pTemperatureGreen << endl;
			pOutputFileStream << "Blue Value Temperature: " << p[i].pTemperatureBlue << endl;
			pOutputFileStream << "Overall Temperature: " << p[i].pOverallTemperature << endl;
			pOutputFileStream << "Region Label" << p[i].pRegionMarkerValue << endl;

			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputPixelObjectTemperature pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component" << pPixelObject.rValue << endl;
			cout << "Green Component" << pPixelObject.gValue << endl;
			cout << "Blue Component" << pPixelObject.bValue << endl;
			cout << "Red Value Temperature: " << pPixelObject.pTemperatureRed << endl;
			cout << "Green Value Temperature: " << pPixelObject.pTemperatureGreen << endl;
			cout << "Blue Value Temperature: " << pPixelObject.pTemperatureBlue << endl;
			cout << "Overall Temperature: " << pPixelObject.pOverallTemperature << endl;
			cout << "Region Label" << pPixelObject.pRegionMarkerValue << endl;

			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Red Component" << pPixelObject.rValue << endl;
			pOutputFileStream << "Green Component" << pPixelObject.gValue << endl;
			pOutputFileStream << "Blue Component" << pPixelObject.bValue << endl;
			pOutputFileStream << "Red Value Temperature: " << pPixelObject.pTemperatureRed << endl;
			pOutputFileStream << "Green Value Temperature: " << pPixelObject.pTemperatureGreen << endl;
			pOutputFileStream << "Blue Value Temperature: " << pPixelObject.pTemperatureBlue << endl;
			pOutputFileStream << "Overall Temperature: " << pPixelObject.pOverallTemperature << endl;
			pOutputFileStream << "Region Label" << pPixelObject.pRegionMarkerValue << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&pConstantBuffer);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageConversionFromRGBModelToTemperatureModel(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	vector<PixelObject> pixelArrayOne,
	float pColorMaximumVar,
	float pTemperatureMaximumVar,
	float pStillRegionMarker,
	float pVolatileRegionMarker,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBTemperatureModelBuffer pTemperatureModelConstantBuffer;
	pTemperatureModelConstantBuffer.pColorMaximumVar = 255;
	pTemperatureModelConstantBuffer.pTemperatureMaximumVar = 100;
	pTemperatureModelConstantBuffer.pStillRegionMarker = 0;
	pTemperatureModelConstantBuffer.pVolatileRegionMarker = 1;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling thCompute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSConvertRGBModelImageToTemperatureModel.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBTemperatureModelBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pTemperatureModelConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectTemperature);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectTemperature);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectTemperature);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectTemperature);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelToTemperatureModelConversion(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11Buffer* ppConstantBuffer[] = { nullptr };

	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffer);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataToGrayScaleUsingInts(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectInt> pixelArrayOne,
	vector<PixelObjectGrayScaleInt> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\PixelToGrayScaleTempInt.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScaleInt> ppOutputDataBuffer = vector<PixelObjectGrayScaleInt>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObjectInt pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageGrayScaleConversionResourcesUsingInts(hInstance,
		hWnd, pixelArrayOne.size(), pixelArrayOne, &ppComputeShaderObject,
		&ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageToGrayScaleConvertionInts(hInstance,
		hWnd, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScaleInt* p = (PixelObjectGrayScaleInt*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			
			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].xPosition << endl;
			cout << "Y Position: " << p[i].yPosition << endl;
			cout << "Grey Level: " << p[i].pGreyLevel << endl;

			pOutputFileStream << "Pixel Number: " << p[i].pixelNumber << endl;
			pOutputFileStream << "X Position: " << p[i].xPosition << endl;
			pOutputFileStream << "Y Position: " << p[i].yPosition << endl;
			pOutputFileStream << "Grey Level: " << p[i].pGreyLevel << endl;


			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectGrayScaleInt pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
			pOutputFileStream << "Grey Level: " << pPixelObject.pGreyLevel << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataToGrayScaleInAMutex(HINSTANCE hInstance, HWND hWnd, vector<PixelObject> pPixelObjectInput, vector<PixelObjectGrayScale> *ppOutputPixelObjectGrayScaleArray)
{
	HRESULT hr = S_OK;

	cout << "Creating the Compute Direct3D11 Device" << endl;
	cout << "Preparing the input Data" << endl;
	cout << "First Let Us Copy our Simulation Parameters to GlobalMemory" << endl;
	DWORD dwThreadId = 0;
	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\PixelToGrayScaleTemp.txt");
	pPixelObjectGlobal = vector<PixelObject>();
	pPixelObjectGlobal.clear();

	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pPixelObjectInput)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component" << pOutputData.RMask << endl;
		cout << "Green Component" << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pOutputData.xPosition << endl;
		pOutputFileStream << "Y Position: " << pOutputData.yPosition << endl;
		pOutputFileStream << "Red Component" << pOutputData.RMask << endl;
		pOutputFileStream << "Green Component" << pOutputData.GMask << endl;
		pOutputFileStream << "Blue Mask" << pOutputData.BMask << endl;

		pPixelObjectGlobal.push_back(pOutputData);
		pIndex = pIndex + 1;
	}

	cout << "Creating Mutex Object" << endl;
	pGrayScaleMutex = CreateMutex(
		NULL,              // default security attributes
		FALSE,
		L"GrayScaleMutex");// initially not owned


	cout << "Starting Quadratic Function Thread" << endl;
	pGrayScaleMutexThread = CreateThread(NULL,
		0,
		ConvertImageDataToGrayscale,
		this,
		0,
		&dwThreadId);

	WaitForSingleObject(pGrayScaleMutexThread, INFINITE);

	cout << "Closing Mutex Objects" << endl;
	CloseHandle(pGrayScaleMutex);

	for (PixelObjectGrayScale pPixelObject : pPixelObjectGlobalGrayScaleGlobal)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
		pOutputFileStream << "Y Position: " << pPixelObject.yPosition << endl;
		pOutputFileStream << "Grey Level: " << pPixelObject.pGreyLevel << endl;

	}


	*ppOutputPixelObjectGrayScaleArray = pPixelObjectGlobalGrayScaleGlobal;
	return hr;

}



HRESULT DirectXStandardAlgorithmExecutor::InitializeImageGrayScaleConversionResourcesUsingInts(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	vector<PixelObjectInt> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSConvertRGBImageToGrayscaleInt.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectInt);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectInt);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScaleInt);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectGrayScaleInt);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScaleInt);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScaleInt);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;


}






HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataToGrayScaleLuminosity(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObjectGrayScale> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\PixelToGrayScaleTemp.txt");

	pOutputFileStream.clear();
	vector<PixelObjectGrayScale> ppOutputDataBuffer = vector<PixelObjectGrayScale>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageGrayScaleConversionResourcesLuminosity(hInstance,
		hWnd, pixelArrayOne.size(), &ppComputeShaderObject,
		pixelArrayOne, &ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageToGrayScaleConvertion(hInstance,
		hWnd, pixelArrayOne, ppInputDataBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectGrayScale* p = (PixelObjectGrayScale*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectGrayScale pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Grey Level: " << pPixelObject.pGreyLevel << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingOperationRGBAgainstPixelNumber(HINSTANCE hInstance,
	HWND hWnd,
	int pPixelNumberStart,
	int pPixelNumberEnd,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppConstantBuffer, 
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer, 
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();


	cbPixelNumberConstantBuffer pConstabtBufferData;
	pConstabtBufferData.pMinimumPixelNumber = pPixelNumberStart;
	pConstabtBufferData.pMaximumPixelNumber = pPixelNumberEnd;



	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelByRangeConditionRGBProcedured.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbPixelNumberConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pConstabtBufferData;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeImageThresholdingOperationRGB(HINSTANCE hInstance, 
	HWND hWnd, UINT ppAmountOfSamples,
	float pMinimumX, float pMinimumY, 
	float pMaximumX, float pMaximumY, 
	float pThresholdIntensityValueBottomR, 
	float pThresholdIntensityValueTopR,
	float pThresholdIntensityValueBottomG, 
	float pThresholdIntensityValueTopG,
	float pThresholdIntensityValueBottomB,
	float pThresholdIntensityValueTopB, ID3D11ComputeShader** ppComputeShaderObject, vector<PixelObject> pixelArrayOne, ID3D11Buffer** ppConstantBuffer, ID3D11Buffer** ppInputBuffer1, ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1, ID3D11UnorderedAccessView** ppUAVObject1, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToBinaryConvertionPreOutput.txt");
	imageMaskLog.clear();

	CBThresholdImageConstantBufferRGB pBinaryImageConstantBuffer;
	pBinaryImageConstantBuffer.pMinRedValue = pThresholdIntensityValueBottomR;
	pBinaryImageConstantBuffer.pMaxRedValue = pThresholdIntensityValueTopR;
	pBinaryImageConstantBuffer.pMinGreenValue = pThresholdIntensityValueBottomG;
	pBinaryImageConstantBuffer.pMaxGreenValue = pThresholdIntensityValueTopG;
	pBinaryImageConstantBuffer.pMinBlueValue = pThresholdIntensityValueBottomB,
	pBinaryImageConstantBuffer.pMaxBlueValue = pThresholdIntensityValueTopB;
	pBinaryImageConstantBuffer.pMinimumX = pMinimumX;
	pBinaryImageConstantBuffer.pMinimumY = pMinimumY;
	pBinaryImageConstantBuffer.pMaximumX = pMaximumX;
	pBinaryImageConstantBuffer.pMaximumY = pMaximumY;
    

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSFilterOutPixelByRangeConditionRGBProcedured.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;




	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThresholdImageConstantBufferRGB) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pBinaryImageConstantBuffer;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectFiltered);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
//		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
	//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelObjectFiltered);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputPixelObjectFiltered);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
	//	MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::ConvertImageDataToHSI(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pixelArrayOne,
    vector<PixelObjectHSI> *pOuputResultArray)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\PixelToHSITemp.txt");

	pOutputFileStream.clear();
	vector<PixelObjectHSI> ppOutputDataBuffer = vector<PixelObjectHSI>();

	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer Of Pixels" << endl;
	pOutputFileStream << "1 Output Buffer for Pixel Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : pixelArrayOne)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

		pOutputFileStream << "Pixel №: " << pOutputData.pixelNumber <<
			"X Position: " << pOutputData.xPosition <<
			"Y Position: " << pOutputData.yPosition <<
			"Red Component" << pOutputData.RMask <<
			"Green Component" << pOutputData.GMask <<
			"Blue Mask" << pOutputData.BMask << endl;

            pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;
	
    ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* ppInputDataBuffer = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;

	hr = InitializeImageHSIConversionResources(hInstance,
		hWnd, pixelArrayOne.size(), &ppComputeShaderObject,
		pixelArrayOne, &ppInputDataBuffer, &pOutputDataBuffer,
		&pShaderResourceView, &pUnorderedAccessView, &pReadbackOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
		return hr;
    }

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImageToHSIConversion(hInstance,
		hWnd, pixelArrayOne, ppInputDataBuffer, ppComputeShaderObject,
		pShaderResourceView, pUnorderedAccessView, 1, 1, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		pOutputFileStream.close();
	}
    
	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBuffer, pOutputDataBuffer);
		hr = m_pD3DCompContext->Map(pReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectHSI* p = (PixelObjectHSI*)MappedResource.pData;
		for (int i = 0; i < pixelArrayOne.size(); ++i)
		{
			ppOutputDataBuffer.push_back(p[i]);
		}



		

		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
	
		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectHSI pPixelObject : ppOutputDataBuffer)
		{
			cout << "Index = " << iIndex << endl;
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.pXValue << endl;
			cout << "Y Postion: " << pPixelObject.pYValue << endl;
			cout << "HUE Value: " << pPixelObject.pHueValue << endl;
			cout << "Saturation Value: " << pPixelObject.pSaturationValue << endl;
			cout << "Intensity Value: " << pPixelObject.pIntensityValue << endl;

			pOutputFileStream << "Index = " << iIndex << endl;
			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber;
			pOutputFileStream << "X Position: " << pPixelObject.pXValue << endl;
			pOutputFileStream << "Y Postion: " << pPixelObject.pYValue << endl;
			pOutputFileStream << "HUE Value: " << pPixelObject.pHueValue << endl;
			pOutputFileStream << "Saturation Value" << pPixelObject.pSaturationValue << endl;
			pOutputFileStream << "Intensity Value:" << pPixelObject.pSaturationValue << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		

	}

	printf("Cleaning up...\n");




	SafeReleaseA(&ppComputeShaderObject);
	SafeReleaseA(&ppInputDataBuffer);
	SafeReleaseA(&pOutputDataBuffer);
	SafeReleaseA(&pShaderResourceView);
	SafeReleaseA(&pUnorderedAccessView);
	SafeReleaseA(&pReadbackOutputBuffer);

	pOutputFileStream.close();
	*pOuputResultArray = ppOutputDataBuffer;


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ClassifyImagePixelsByCriteriaSet(HINSTANCE hInstance,
	HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	vector<PixelObject> ppPixelObjectInputArray,
	vector<PixelObjectWithALabel>
	*ppPixelArrayWithCriteria)
{

	HRESULT hr = S_OK;

	ID3D11ComputeShader* pComputeShaderObjectClassification = nullptr;
	ID3D11Buffer* pImageProcessingConstantBufferClassificiation = nullptr;
	ID3D11Buffer* pInputDataBufferClassification = nullptr;
	ID3D11Buffer* pOutputDataBufferClassification = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewClassification = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessViewClassification = nullptr;
	ID3D11Buffer* pReadbackOutputBufferClassification = nullptr;


	cout << "This Function Simulates Classification of Image Pixels" << endl;
	vector<PixelObjectWithALabel> ppOutputDataBuffer = vector<PixelObjectWithALabel>();

	fstream imageMaskLog("С:\\pixels\\ImageClassificationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;
	
	cout << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer Of Pixels" << endl;
	cout << "1 Output Buffer for Pixel Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	cout << "1 Readback Data Buffer" << endl;

	imageMaskLog << "This Function Coverts Pixel Data To Hue, Saturation, Intensity Function" << endl;
	imageMaskLog << "For this Simulation We Will Use" << endl;
	imageMaskLog << "1 Compute Shader" << endl;
	imageMaskLog << "1 Input Buffer Of Pixels" << endl;
	imageMaskLog << "1 Output Buffer for Pixel Output" << endl;
	imageMaskLog << "1 Shader Resource View For Input Buffer of Pixels" << endl;
	imageMaskLog << "1 Unordered Access View for Output Buffer of Pixels" << endl;
	imageMaskLog << "1 Readback Data Buffer" << endl;




	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;
	for (PixelObject pOutputData : ppPixelObjectInputArray)
	{
		cout << "Pixel №: " << pOutputData.pixelNumber << endl;
		cout << "X Position: " << pOutputData.xPosition << endl;
		cout << "Y Position: " << pOutputData.yPosition << endl;
		cout << "Red Component: " << pOutputData.RMask << endl;
		cout << "Green Component: " << pOutputData.GMask << endl;
		cout << "Blue Mask" << pOutputData.BMask <<  endl;

		imageMaskLog << "Pixel №: " << pOutputData.pixelNumber << endl;
		imageMaskLog << "X Position: " << pOutputData.xPosition << endl;			
		imageMaskLog << "Y Position: " << pOutputData.yPosition << endl;
		imageMaskLog << "Red Component: " << pOutputData.RMask << endl;
		imageMaskLog << "Green Component: " << pOutputData.GMask << endl;
		imageMaskLog << "Blue Mask" << pOutputData.BMask << endl;

		pIndex = pIndex + 1;
	}

	cout << "Reserving Data And Preparing Resources" << endl;

	cout << "Filling Out Image Classification Constant Buffer" << endl;


	cbImageLabelConstants pImageLabelConstants;
	pImageLabelConstants.pBlackCluster = 20;
	pImageLabelConstants.pRedCluster = 40;
	pImageLabelConstants.pGreenCluster = 60;
	pImageLabelConstants.pBlueCluster = 80;
	pImageLabelConstants.pWhiteCluster = 100;


	hr = InitializeImagaPixelClassificationResources(hInstance,
		hWnd, pImageWidth, pImageHeight, ppPixelObjectInputArray,
		pImageLabelConstants,
		&pComputeShaderObjectClassification,
		&pImageProcessingConstantBufferClassificiation,
		&pInputDataBufferClassification,
		&pOutputDataBufferClassification,
		&pShaderResourceViewClassification,
		&pUnorderedAccessViewClassification,
		&pReadbackOutputBufferClassification);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Simulating the Prepared Image Conversion" << endl;

	hr = RunImagePixelClassifierCS(hInstance,
		hWnd, pComputeShaderObjectClassification,
		pImageProcessingConstantBufferClassificiation,
		pShaderResourceViewClassification,
		pUnorderedAccessViewClassification,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize The Resourcer For the Simulation Error: " << pLastError << endl;
		imageMaskLog.close();
	}

	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackOutputBufferClassification, pOutputDataBufferClassification);
		hr = m_pD3DCompContext->Map(pReadbackOutputBufferClassification, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		PixelObjectWithALabel* p = (PixelObjectWithALabel*)MappedResource.pData;
		for (int i = 0; i < ppPixelObjectInputArray.size(); ++i)
		{

			cout << "Pixel Number: " << p[i].pixelNumber << endl;
			cout << "X Position: " << p[i].pXPosition << endl;
			cout << "Y Position: " << p[i].pYPosition<< endl;
			cout << "Red Component: " << p[i].rValue << endl;
			cout << "Green Component " << p[i].gValue << endl;
			cout << "Blue Component: " << p[i].bValue << endl;
			cout << "Pixel Label: " << p[i].pClusterLabel << endl;

			imageMaskLog << "Pixel Number: " << p[i].pixelNumber << endl;
			imageMaskLog << "X Position: " << p[i].pXPosition << endl;
			imageMaskLog << "Y Position: " << p[i].pYPosition << endl;
			imageMaskLog << "Red Component: " << p[i].rValue << endl;
			imageMaskLog << "Green Component " << p[i].gValue << endl;
			imageMaskLog << "Blue Component: " << p[i].bValue << endl;
			imageMaskLog << "Pixel Label: " << p[i].pClusterLabel << endl;

		



			ppOutputDataBuffer.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (PixelObjectWithALabel pPixelObject : ppOutputDataBuffer)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.pXPosition << endl;
			cout << "Y Position: " << pPixelObject.pYPosition << endl;
			cout << "Red Component: " << pPixelObject.rValue << endl;
			cout << "Green Component " << pPixelObject.gValue << endl;
			cout << "Blue Component: " << pPixelObject.bValue << endl;
			cout << "Pixel Label: " << pPixelObject.pClusterLabel << endl;

			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			imageMaskLog << "X Position: " << pPixelObject.pXPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.pYPosition << endl;
			imageMaskLog << "Red Component: " << pPixelObject.rValue << endl;
			imageMaskLog << "Green Component " << pPixelObject.gValue << endl;
			imageMaskLog << "Blue Component: " << pPixelObject.bValue << endl;
			imageMaskLog << "Pixel Label: " << pPixelObject.pClusterLabel << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		imageMaskLog << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	printf("Cleaning up...\n");

	SafeReleaseA(&pComputeShaderObjectClassification);
	SafeReleaseA(&pInputDataBufferClassification);
	SafeReleaseA(&pOutputDataBufferClassification);
	SafeReleaseA(&pShaderResourceViewClassification);
	SafeReleaseA(&pUnorderedAccessViewClassification);
	SafeReleaseA(&pReadbackOutputBufferClassification);

	imageMaskLog.close();
	*ppPixelArrayWithCriteria = ppOutputDataBuffer;


	return hr;


}

HRESULT DirectXStandardAlgorithmExecutor::InitializeImagaPixelClassificationResources(HINSTANCE hInstance,
	HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	vector<PixelObject> ppPixelObjectInputArray,
	cbImageLabelConstants pImageIntensityConstants,
	ID3D11ComputeShader** ppComputeShaderImageClassification,
	ID3D11Buffer** ppImageProcessingConstantBuffer,
	ID3D11Buffer** ppImageProcessingInputBuffer,
	ID3D11Buffer** ppImageProcessingOutputBuffer,
	ID3D11ShaderResourceView** ppInputImageProcessingSRV,
	ID3D11UnorderedAccessView** ppOutputUnorderedUAV,
	ID3D11Buffer** ppReadbackBufferImageClassifier)
{
	HRESULT hr = S_OK;
	cout << "Initializing Direct3D11 Device" << endl;
	hr = InitializeD3D11Device(hWnd, 0);


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	fstream imageMaskLogSetup("С:\\pixels\\ImageClassificationPreOutputSetup.txt");
	imageMaskLogSetup.clear();


	cout << "Compiling the Compute SHader By Threshold" << endl;
	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ImagePixelClassifierCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLogSetup << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLogSetup << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLogSetup.close();
		return hr;
	}
	cout << "Creating the Constant Buffer For Image One Object" << endl;
	imageMaskLogSetup << "Creating the Constant Buffer For Image One Object" << endl;

	

	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBImageIntensityConstants) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pImageIntensityConstants;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
		

	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLogSetup << "Creating the Input Buffer For Image One Object" << endl;




	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = ppPixelObjectInputArray.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &ppPixelObjectInputArray[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLogSetup << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLogSetup.close();
		return hr;
	}


	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = ppPixelObjectInputArray.size() * sizeof(PixelObjectWithALabel);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectWithALabel);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLogSetup << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLogSetup.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLogSetup << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementOffset = 0;
	srvbuffer_desc.Buffer.NumElements = ppPixelObjectInputArray.size();


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLogSetup << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLogSetup.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLogSetup << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = ppPixelObjectInputArray.size();
	

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLogSetup << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLogSetup << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLogSetup.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLogSetup << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = ppPixelObjectInputArray.size() * sizeof(PixelObjectWithALabel);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectWithALabel);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLogSetup << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLogSetup.close();
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLogSetup.close();
		return hr;
	}

	*ppImageProcessingConstantBuffer = pConstantBuffer;
	*ppComputeShaderImageClassification = pComputeShaderObject;
	*ppImageProcessingInputBuffer = pInputBuffer1;
	*ppImageProcessingOutputBuffer = pOutputBuffer;
	*ppInputImageProcessingSRV = pInputSRV1;
	*ppOutputUnorderedUAV = pOutputUAV;
	*ppReadbackBufferImageClassifier = pReadbackBuffer;

	return hr;


}



HRESULT DirectXStandardAlgorithmExecutor::RunImagePixelClassifierCS(HINSTANCE hInstance,
	HWND hWnd, ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* ppConstantBuffer,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11UnorderedAccessView* ppUAVObjectOutput,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1 };
	ID3D11UnorderedAccessView* ppUAV[] = { ppUAVObjectOutput };
	m_pD3DCompContext->CSSetShaderResources(0, 1, &ppSRV1);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &ppUAVObjectOutput, nullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &ppConstantBuffer);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SearchForBordersWithinImages(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> pImageOneToTest,
	vector<PixelObjectGrayScale> pImageTwoToTest,
	vector<BorderOutputStructure> *ppBorderObjectCollections)
{
	HRESULT hr = S_OK;
	vector<BorderOutputStructure> pBorderOutputStructure = vector<BorderOutputStructure>();

	fstream imageMaskLog("С:\\pixels\\ObjectMovementDetectionTest.txt");
	imageMaskLog.clear();

	cout << "This Function will simulate border detection simulation within image" << endl;
	cout << "For this Function We will use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "2 Input Buffers" << endl;
	cout << "2 Shader Resource Views" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "This Function will simulate border detection simulation within image" << endl;
	imageMaskLog << "For this Function We will use" << endl;
	imageMaskLog << "1 Compute Shader" << endl;
	imageMaskLog << "2 Input Buffers" << endl;
	imageMaskLog << "2 Shader Resource Views" << endl;
	imageMaskLog << "1 Unordered Access View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;


	float pImageOneIntensitySum = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoAverage = 0.0f;





	for (PixelObjectGrayScale pPixelObject : pImageOneToTest)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber << endl;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pImageOneIntensitySum = pImageOneIntensitySum + pPixelObject.pGreyLevel;

	}
	pImageOneAverage = pImageOneIntensitySum / pImageOneToTest.size();

	cout << "Image One Intensity Sum = " << pImageOneIntensitySum << endl;
	cout << "Image One Array Size = " << pImageOneToTest.size();
	cout << "Image One Average Intensity = " << pImageOneAverage << endl;

	imageMaskLog << "Image One Intensity Sum = " << pImageOneIntensitySum << endl;
	imageMaskLog << "Image One Array Size = " << pImageOneToTest.size();
	imageMaskLog << "Image One Average Intensity = " << pImageOneAverage << endl;

	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;


	for (PixelObjectGrayScale pPixelObject : pImageTwoToTest)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pImageTwoIntensitySum = pImageTwoIntensitySum + pPixelObject.pGreyLevel;
	}

	pImageTwoAverage = pImageTwoIntensitySum / pImageOneToTest.size();
	cout << "Image Two Intensity Sum = " << pImageTwoIntensitySum << endl;
	cout << "Image Two Array Size = " << pImageOneToTest.size();
	cout << "Image Two Average Intensity = " << pImageTwoAverage << endl;

	imageMaskLog << "Image Two Intensity Sum = " << pImageTwoIntensitySum << endl;
	imageMaskLog << "Image Two Array Size = " << pImageTwoToTest.size();
	imageMaskLog << "Image Two Average Intensity = " << pImageTwoAverage << endl;


	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pInputDataBufferImageTwo = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewOne = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewTwo = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadBackBuffer = nullptr;

	cout << "Initializing Object Resources" << endl;
	imageMaskLog << "Initializing Object Resources" << endl;

	hr = InitializeBorderSearchFunctionResources(hInstance,
		hWnd,
		&ppComputeShaderForImageComparison,
		pImageOneToTest,
		pImageTwoToTest,
		&pInputDataBufferImageOne,
		&pInputDataBufferImageTwo,
		&pOutputDataBuffer,
		&pShaderResourceViewOne,
		&pShaderResourceViewTwo,
		&pUnorderedAccessView,
		&pReadBackBuffer);



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pShaderResourceViewOne, pShaderResourceViewTwo };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pUnorderedAccessView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunBorderSearchFunction(hInstance, hWnd,
        ppComputeShaderForImageComparison,
		pShaderResourceViewOne,
		pShaderResourceViewTwo,
		pUnorderedAccessView,
		2, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &pMammedResource);
	BorderOutputStructure* pOutputDataImages = (BorderOutputStructure*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pImageOneToTest.size(); ++pIndex)
	{
		BorderOutputStructure pOutputValue = pOutputDataImages[pIndex];
		pOutputValue.pixelNumber = pIndex;

		
		pBorderOutputStructure.push_back(pOutputValue);
	}

	


	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (BorderOutputStructure ppOutputPixelValue : pBorderOutputStructure)
	{
		cout << "Pixel Number " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position One" << " = " << ppOutputPixelValue.xPosition0 << endl;
		cout << "Y Position One " << " = " << ppOutputPixelValue.yPosition0 << endl;
		cout << "X Position Two" << " = " << ppOutputPixelValue.xPosition0 << endl;
		cout << "Y Position Two " << " = " << ppOutputPixelValue.yPosition0 << endl;
		cout << "GrayScale Value0 " << " = " << ppOutputPixelValue.pGrayScaleValue0 << endl;
		cout << "GrayScale Value1 " << " = " << ppOutputPixelValue.pGrayScaleValue1 << endl;
		cout << "Output GrayScale Value " << " = " << ppOutputPixelValue.pOutputPixelValue << endl;
		cout << "Is Pixel Border " << ppOutputPixelValue.pIsBorderValue << endl;


		imageMaskLog << "Pixel Number " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position One" << " = " << ppOutputPixelValue.xPosition0 << endl;
		imageMaskLog << "Y Position One " << " = " << ppOutputPixelValue.yPosition0 << endl;
		imageMaskLog << "X Position Two" << " = " << ppOutputPixelValue.xPosition0 << endl;
		imageMaskLog << "Y Position Two " << " = " << ppOutputPixelValue.yPosition0 << endl;
		imageMaskLog << "GrayScale Value0 " << " = " << ppOutputPixelValue.pGrayScaleValue0 << endl;
		imageMaskLog << "GrayScale Value1 " << " = " << ppOutputPixelValue.pGrayScaleValue1 << endl;
		imageMaskLog << "Output GrayScale Value " << " = " << ppOutputPixelValue.pOutputPixelValue << endl;
		imageMaskLog << "Is Pixel Border " << ppOutputPixelValue.pIsBorderValue << endl;



		pIndex++;
	}

	
	imageMaskLog.close();
	*ppBorderObjectCollections = pBorderOutputStructure;

    return hr;



}


HRESULT DirectXStandardAlgorithmExecutor::InitializeBorderSearchFunctionResources(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	ID3D11Buffer** ppInputBuffer1,
    ID3D11Buffer** ppInputBuffer2,
	ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\СSBorderCatcherObject.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayTwo.size() * sizeof(BorderOutputStructure);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(BorderOutputStructure);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	


	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(BorderOutputStructure);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(BorderOutputStructure);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppInputBuffer2 = pInputBuffer2;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObject1 = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunBorderSearchFunction(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = {pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pUnorderedUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelBundleUsingADescriptor(HINSTANCE hInstance,
	HWND hWnd, UINT pImageWidth,
	UINT pImageHeight,
	float pRedValueLimit,
	float pGreenValueLimit,
	float pBlueValueLimit,
	vector<PixelBundle> pPixelBundleVector,
	vector<OutputPixelBundleWithValidations> *ppOutputPixelBundleWithValidationss)
{
	HRESULT hr = S_OK;

	vector<OutputPixelBundleWithValidations> pOutputPixelDataBuffer = vector<OutputPixelBundleWithValidations>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	cbColorThreshold pColorCB;
	pColorCB.pRedPixelValue = pRedValueLimit;
	pColorCB.pGreenPixelValue = pGreenValueLimit;
	pColorCB.pBluePixelValue = pBlueValueLimit;

	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;



	for (PixelBundle pPixelBundleObject : pPixelBundleVector)
	{
		 




		cout << "Bundle id:" << pPixelBundleObject.pBundleId << endl;
		cout << "Pixel One Details: " << endl;
		cout << "X Position: " << pPixelBundleObject.xPosition << endl;
		cout << "Y Position: " << pPixelBundleObject.yPosition << endl;
		cout << "Red Component Image One: " << pPixelBundleObject.pRedValue0 << endl;
		cout << "Green Component Image One: " << pPixelBundleObject.pGreenValue0 << endl;
		cout << "Blue Component Image One" << pPixelBundleObject.pBlueValue0 << endl;
		cout << "Red Component Image Two: " << pPixelBundleObject.pRedValue1 << endl;
		cout << "Green Component Image Two: " << pPixelBundleObject.pGreenValue1 << endl;
		cout << "Blue Component Image Two" << pPixelBundleObject.pBlueValue1 << endl;
		cout << "Red Component Image Output: " << pPixelBundleObject.pRedValue2 << endl;
		cout << "Green Component Image Output: " << pPixelBundleObject.pGreenValue2 << endl;
		cout << "Blue Component Image Output" << pPixelBundleObject.pBlueValue2 << endl;


		imageMaskLog << "Bundle id:" << pPixelBundleObject.pBundleId << endl;
		imageMaskLog << "Pixel One Details: " << endl;
		imageMaskLog << "X Position: " << pPixelBundleObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelBundleObject.yPosition << endl;
		imageMaskLog << "Red Component Image One: " << pPixelBundleObject.pRedValue0 << endl;
		imageMaskLog << "Green Component Image One: " << pPixelBundleObject.pGreenValue0 << endl;
		imageMaskLog << "Blue Component Image One" << pPixelBundleObject.pBlueValue0 << endl;
		imageMaskLog << "Red Component Image Two: " << pPixelBundleObject.pRedValue1 << endl;
		imageMaskLog << "Green Component Image Two: " << pPixelBundleObject.pGreenValue1 << endl;
		imageMaskLog << "Blue Component Image Two" << pPixelBundleObject.pBlueValue1 << endl;
		imageMaskLog << "Red Component Image Output: " << pPixelBundleObject.pRedValue2 << endl;
		imageMaskLog << "Green Component Image Output: " << pPixelBundleObject.pGreenValue2 << endl;
		imageMaskLog << "Blue Component Image Output" << pPixelBundleObject.pBlueValue2 << endl;



	
	}

	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelBundleValidationProcedure(hInstance,
		hWnd,
		pColorCB,
		pPixelBundleVector,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError  << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBundleWithValidations* pOutputDataImages = (OutputPixelBundleWithValidations*)pMammedResource.pData;
	
	int pIndex = 0;
    
	for (pIndex = 0; pIndex < pPixelBundleVector.size(); ++pIndex)
	{

		OutputPixelBundleWithValidations pValidationItem = pOutputDataImages[pIndex];
		cout << "Output Bundle id: " << pValidationItem.pBundleId << endl;
		cout << "Printing Pixel One Data" << endl;
		cout << "X Position: " << pValidationItem.xPosition << endl;
		cout << "Y Position: " << pValidationItem.yPosition << endl;
		cout << "Red Component : " << pValidationItem.pRedValue0 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		cout << "Red Component: " << pValidationItem.pRedValue1 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue1 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue1 << endl;
		cout << "Red Component: " << pValidationItem.pRedValueOutput << endl;
		cout << "Green Component: " << pValidationItem.pGreenValueOutput << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValueOutput << endl;
		cout << "Red Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		cout << "Green Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		cout << "Blue Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		cout << "Overall Marker Value: " << pValidationItem.pOutputBundleLogic << endl;

		imageMaskLog << "Output Bundle id: " << pValidationItem.pBundleId << endl;
		imageMaskLog << "Printing Pixel One Data" << endl;
		imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
		imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue1 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue1 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue1 << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValueOutput << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValueOutput << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValueOutput << endl;
		imageMaskLog << "Red Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		imageMaskLog << "Green Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		imageMaskLog << "Blue Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		imageMaskLog << "Overall Marker Value: " << pValidationItem.pOutputBundleLogic << endl;

		pOutputPixelDataBuffer.push_back(pValidationItem);
	} 
	

	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelBundleWithValidations pValidationItem : pOutputPixelDataBuffer)
	{
		cout << "Output Bundle id: " << pValidationItem.pBundleId << endl;
		cout << "Printing Pixel One Data" << endl;
		cout << "X Position: " << pValidationItem.xPosition << endl;
		cout << "Y Position: " << pValidationItem.yPosition << endl;
		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		cout << "Red Component: " << pValidationItem.pRedValue1 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue1 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue1 << endl;
		cout << "Red Component: " << pValidationItem.pRedValueOutput << endl;
		cout << "Green Component: " << pValidationItem.pGreenValueOutput << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValueOutput << endl;
		cout << "Red Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		cout << "Green Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		cout << "Blue Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		cout << "Overall Marker Value: " << pValidationItem.pOutputBundleLogic << endl;

		imageMaskLog << "Output Bundle id: " << pValidationItem.pBundleId << endl;
		imageMaskLog << "Printing Pixel One Data" << endl;
		imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
		imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue1 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue1 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue1 << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValueOutput << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValueOutput << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValueOutput << endl;
		imageMaskLog << "Red Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		imageMaskLog << "Green Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		imageMaskLog << "Blue Marker Value: " << pValidationItem.pPixelOutputRedMarker << endl;
		imageMaskLog << "Overall Marker Value: " << pValidationItem.pOutputBundleLogic << endl;

	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppOutputPixelBundleWithValidationss = pOutputPixelDataBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptor(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRedOne,
	float pSampleGreenOne, float pSampleBlueOne,
	float pSampleRedTwo, float pSampleGreenTwo,
	float pSampleBlueTwo,
	int pClassOneLabel, int pClassTwoLabel,
	int pClassThreeLabel,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectDescriptor> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptor> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptor>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptor  pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pBackGroundClassValue = pClassThreeLabel;
	
	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColors(hInstance,
		hWnd,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;
	
	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptor* pOutputDataImages = (OutputPixelObjectDescriptor*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{

		OutputPixelObjectDescriptor pValidationItem = pOutputDataImages[pIndex];
		cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
		cout << "X Position: " << pValidationItem.xPosition << endl;
		cout << "Y Position: " << pValidationItem.yPosition << endl;
		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;


		imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
		imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
		imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;

		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptor pValidationItem: pOutputPixelDataBuffer)
	{
		cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
		cout << "Printing Pixel One Data" << endl;
		cout << "X Position: " << pValidationItem.xPosition << endl;
		cout << "Y Position: " << pValidationItem.yPosition << endl;
		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


		imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
		imageMaskLog << "Printing Pixel One Data" << endl;
		imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
		imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		imageMaskLog << "Class Of Pixel: " << pValidationItem.pClassMarkerValue << endl;
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializePixelsValidationUsingADescrptorColors(HINSTANCE hInstance,
	HWND hWnd,
	CBThreshHoldVarColorDescriptor pColorThresoldStructure,
	vector<PixelObject> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	for (PixelObject pOutputData : pPixelBundleArrayStructure)
	{
		if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
		{

			cout << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			imageMaskLog << "Pixel №: " << pOutputData.pixelNumber <<
				"X Position: " << pOutputData.xPosition <<
				"Y Position: " << pOutputData.yPosition <<
				"Red Component" << pOutputData.RMask <<
				"Green Component" << pOutputData.GMask <<
				"Blue Mask" << pOutputData.BMask << endl;

			
		}
	}


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;




	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDualRGBFilterShaderAlgorithm.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarColorDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelObject);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelObject);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorWithThresoldConstant(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRedOne,
	float pSampleGreenOne, float pSampleBlueOne,
	float pSampleRedTwo, float pSampleGreenTwo,
	float pSampleBlueTwo,
	float pThresold,
	int pClassOneLabel, int pClassTwoLabel,
	int pClassThreeLabel,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectDescriptor> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptor> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptor>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptorWithDelta pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pThresoldValue = pThresold;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pBackGroundValue = pClassThreeLabel;


	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColorsWithThresold(hInstance,
		hWnd,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptor* pOutputDataImages = (OutputPixelObjectDescriptor*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{

		OutputPixelObjectDescriptor pValidationItem = pOutputDataImages[pIndex];
		cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
		cout << "X Position: " << pValidationItem.xPosition << endl;
		cout << "Y Position: " << pValidationItem.yPosition << endl;
		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;


		imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
		imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
		imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;

		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptor pValidationItem : pOutputPixelDataBuffer)
	{
		cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
		cout << "Printing Pixel One Data" << endl;
		cout << "X Position: " << pValidationItem.xPosition << endl;
		cout << "Y Position: " << pValidationItem.yPosition << endl;
		cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
		cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


		imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
		imageMaskLog << "Printing Pixel One Data" << endl;
		imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
		imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
		imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
		imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
		imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
		imageMaskLog << "Class Of Pixel: " << pValidationItem.pClassMarkerValue << endl;
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializePixelsValidationUsingADescrptorColorsWithBarriers(HINSTANCE hInstance,
	HWND hWnd,
	CBThreshHoldVarColorDescriptorBarriers pColorThresoldStructure,
	vector<PixelObject> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	for (PixelObject pOutputData : pPixelBundleArrayStructure)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
			{

				cout << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;

				imageMaskLog << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;


			}
		}
	}


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;




	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSApplyColorDescriptorWithBarriers.hlsl", "CS_Main",
		"cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarColorDescriptorBarriers) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelObject);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelObject);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::InitializePixelsValidationUsingADescrptorColorsWithBarriersParametrizedThreads(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfThreads,
	CBThreshHoldVarColorDescriptorBarriers pColorThresoldStructure,
	vector<PixelObject> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	int number = pAmountOfThreads;
	stringstream strs;
	strs << number;
	string temp_str = strs.str();
	char* char_type = (char*)temp_str.c_str();

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	for (PixelObject pOutputData : pPixelBundleArrayStructure)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
			{

				cout << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;

				imageMaskLog << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;


			}
		}
	}


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;




	hr = CompileD3DShaderFromFileWhithThreadMacro(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSApplyColorDescriptorWithBarriersParametrizedThreads.hlsl", "CS_Main", char_type, "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarColorDescriptorBarriers) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelObject);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelObject);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriersClosedMode(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRedOne,
	float pSampleGreenOne,
	float pSampleBlueOne,
	float pSampleRedTwo,
	float pSampleGreenTwo,
	float pSampleBlueTwo,
	int pClassOneLabel,
	int pClassTwoLabel,
	int pClassThreeLabel,
	float pThresoldValue,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectDescriptor> *ppPixelObjectGrayScale,
	vector<PixelObject> *pClassOnePixelArray,
	vector<PixelObject> *pClassTwoPixelArray )
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptor> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptor>();
	vector<PixelObject> pClassOnePixelBuffer = vector<PixelObject>();
	vector<PixelObject> pClassTwoPixelBuffer = vector<PixelObject>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptorBarriers  pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pBackGroundValue = pClassThreeLabel;
	pColorCB.pDeltaValue = pThresoldValue;


	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColorsWithBarriers(hInstance,
		hWnd,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptor* pOutputDataImages = (OutputPixelObjectDescriptor*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{


		OutputPixelObjectDescriptor pValidationItem = pOutputDataImages[pIndex];

		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;
			}
		}


		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptor pValidationItem : pOutputPixelDataBuffer)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "Printing Pixel One Data" << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "Printing Pixel One Data" << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Class Of Pixel: " << pValidationItem.pClassMarkerValue << endl;
			}
		}
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;

	hr = RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
		hWnd, pClassOneLabel, pOutputPixelDataBuffer,
		&pClassOnePixelBuffer);

	if (SUCCEEDED(hr))
	{
		hr = RestoreRGBPixelFromDescriptorForAGivenClass(hInstance,
			hWnd, pClassTwoLabel, pOutputPixelDataBuffer,
			&pClassTwoPixelBuffer);

	}
		


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;
	*pClassOnePixelArray = pClassOnePixelBuffer;
	*pClassTwoPixelArray = pClassTwoPixelBuffer;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriersWithNumberOfThreads(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRedOne, 
	float pSampleGreenOne,
	float pSampleBlueOne,
	float pSampleRedTwo, 
	float pSampleGreenTwo,
	float pSampleBlueTwo,
	int pClassOneLabel,
	int pClassTwoLabel, 
	int pClassThreeLabel, 
	float pThresoldValue, 
	UINT pNumberOfThreads, 
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectDescriptor> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptor> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptor>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptorBarriers  pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pBackGroundValue = pClassThreeLabel;
	pColorCB.pDeltaValue = pThresoldValue;


	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColorsWithBarriersParametrizedThreads(hInstance,
		hWnd,
		pNumberOfThreads,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, pNumberOfThreads, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptor* pOutputDataImages = (OutputPixelObjectDescriptor*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{


		OutputPixelObjectDescriptor pValidationItem = pOutputDataImages[pIndex];

		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;
			}
		}


		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptor pValidationItem : pOutputPixelDataBuffer)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "Printing Pixel One Data" << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "Printing Pixel One Data" << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Class Of Pixel: " << pValidationItem.pClassMarkerValue << endl;
			}
		}
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;

	return hr;
}













HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorWithDefinedBarriers(HINSTANCE hInstance,
	HWND hWnd,
	float pSampleRedOne,
	float pSampleGreenOne,
	float pSampleBlueOne,
	float pSampleRedTwo,
	float pSampleGreenTwo,
	float pSampleBlueTwo,
	int pClassOneLabel,
	int pClassTwoLabel,
	int pClassThreeLabel,
	float pThresoldValue,
	vector<PixelObject> ppPixelArrayInput,
	vector<OutputPixelObjectDescriptor> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptor> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptor>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptorBarriers  pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pBackGroundValue = pClassThreeLabel;
	pColorCB.pDeltaValue = pThresoldValue;
	

	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColorsWithBarriers(hInstance,
		hWnd,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptor* pOutputDataImages = (OutputPixelObjectDescriptor*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{

	
		OutputPixelObjectDescriptor pValidationItem = pOutputDataImages[pIndex];
		
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
			cout << "Y Position: " << pValidationItem.yPosition << endl;
			cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
			cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
			cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
			cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;
	

			imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
			imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
			imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
			imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
			imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
			imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
			imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;
			}
		}
	
		
		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptor pValidationItem : pOutputPixelDataBuffer)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "Printing Pixel One Data" << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "Printing Pixel One Data" << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Class Of Pixel: " << pValidationItem.pClassMarkerValue << endl;
			}
		}
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;

	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::InitializePixelsValidationUsingADescrptorColorsWithDelta(HINSTANCE hInstance,
	HWND hWnd,
	CBThreshHoldVarColorDescriptorWithDelta pColorThresoldStructure,
	vector<PixelObject> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	for (PixelObject pOutputData : pPixelBundleArrayStructure)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
			{

				cout << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;

				imageMaskLog << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;


			}
		}
	}


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;




	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSImageDescriptorForTwoColorsWithThresold.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarColorDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelObject);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelObject);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ValidatePixelByColorCorrespondenceUsingColorDescriptorExact(HINSTANCE hInstance, HWND hWnd, float pSampleRedOne, float pSampleGreenOne, float pSampleBlueOne, float pSampleRedTwo, float pSampleGreenTwo, float pSampleBlueTwo, int pClassOneLabel, int pClassTwoLabel, int pClassThreeLabel, vector<PixelObject> ppPixelArrayInput, vector<OutputPixelObjectDescriptor> *ppPixelObjectGrayScale)
{
	HRESULT hr = S_OK;

	vector<OutputPixelObjectDescriptor> pOutputPixelDataBuffer = vector<OutputPixelObjectDescriptor>();


	fstream imageMaskLog("С:\\pixels\\ImageBundleexitPreOutput.txt");
	imageMaskLog.clear();

	cout << "This Function will be used to validate pixel bundles" << endl;
	imageMaskLog << "This Function will be used to validate pixel bundles" << endl;

	cout << "This Function Will be Using the Following Instruments" << endl;
	imageMaskLog << "This Function Will be Using the Following Instruments" << endl;


	CBThreshHoldVarColorDescriptor  pColorCB;
	pColorCB.pRedValueOne = pSampleRedOne;
	pColorCB.pGreenValueOne = pSampleGreenOne;
	pColorCB.pBlueValueOne = pSampleBlueOne;
	pColorCB.pRedValueTwo = pSampleRedTwo;
	pColorCB.pGreenValueTwo = pSampleGreenTwo;
	pColorCB.pBlueValueTwo = pSampleBlueTwo;
	pColorCB.pClassOneValue = pClassOneLabel;
	pColorCB.pClassTwoValue = pClassTwoLabel;
	pColorCB.pBackGroundClassValue = pClassThreeLabel;
	


	cout << "1 Compute Shader File" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Shader Resource" << endl;
	cout << "1 Unordered Acess View" << endl;
	cout << "1 Readback Buffer" << endl;

	imageMaskLog << "1 Compute Shader File" << endl;
	imageMaskLog << "1 Constant Buffer" << endl;
	imageMaskLog << "1 Input Buffer " << endl;
	imageMaskLog << "1 Shader Resource" << endl;
	imageMaskLog << "1 Unordered Acess View" << endl;
	imageMaskLog << "1 Readback Buffer" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceOne = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferObject = nullptr;





	cout << "Initializing Resources for the Simulations" << endl;
	imageMaskLog << "Initializing Resources for the Simulations" << endl;


	hr = InitializePixelsValidationUsingADescrptorColorsExact(hInstance,
		hWnd,
		pColorCB,
		ppPixelArrayInput,
		&pComputeShaderObject,
		&pConstantBuffer,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceOne,
		&pUnorderedAccessView,
		&pReadbackBufferObject);

	if (FAILED(hr))
	{
		int pGetLastError = GetLastError();
		cout << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		imageMaskLog << "Unable to Create the Resources for the Simulations Error: " << pGetLastError << endl;
		return hr;

	}

	cout << "Running Our Compute Shader Object" << endl;
	hr = RunPixelBundleValidations(hInstance,
		hWnd, pComputeShaderObject,
		pConstantBuffer, pShaderResourceOne,
		pUnorderedAccessView, 1,
		1, 256, 1, 1);


	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferObject, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferObject, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelObjectDescriptor* pOutputDataImages = (OutputPixelObjectDescriptor*)pMammedResource.pData;

	int pIndex = 0;

	for (pIndex = 0; pIndex < ppPixelArrayInput.size(); ++pIndex)
	{


		OutputPixelObjectDescriptor pValidationItem = pOutputDataImages[pIndex];

		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Pixel id: " << pValidationItem.pixelNumber << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Pixel id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Pixel Marker: " << pValidationItem.pClassMarkerValue << endl;
			}
		}


		pOutputPixelDataBuffer.push_back(pValidationItem);
	}


	cout << "Printing Output Pixel Data Buffer" << endl;
	imageMaskLog << "Printing Output Pixel Data Buffer" << endl;

	for (OutputPixelObjectDescriptor pValidationItem : pOutputPixelDataBuffer)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pValidationItem.pRedValue0 != 255.0f) && (pValidationItem.pGreenValue0 != 255.0f) && (pValidationItem.pBlueValue0 != 255.0f))
			{
				cout << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				cout << "Printing Pixel One Data" << endl;
				cout << "X Position: " << pValidationItem.xPosition << endl;
				cout << "Y Position: " << pValidationItem.yPosition << endl;
				cout << "Red Component: " << pValidationItem.pRedValue0 << endl;
				cout << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				cout << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				cout << "Descriptor Marker: " << pValidationItem.pClassMarkerValue << endl;


				imageMaskLog << "Output Bundle id: " << pValidationItem.pixelNumber << endl;
				imageMaskLog << "Printing Pixel One Data" << endl;
				imageMaskLog << "X Position: " << pValidationItem.xPosition << endl;
				imageMaskLog << "Y Position: " << pValidationItem.yPosition << endl;
				imageMaskLog << "Red Component: " << pValidationItem.pRedValue0 << endl;
				imageMaskLog << "Green Component: " << pValidationItem.pGreenValue0 << endl;
				imageMaskLog << "Blue Component: " << pValidationItem.pBlueValue0 << endl;
				imageMaskLog << "Class Of Pixel: " << pValidationItem.pClassMarkerValue << endl;
			}
		}
	}

	cout << "Copying Output Vector to External vector" << endl;
	imageMaskLog << "Copying Output Vector to External vector" << endl;


	*ppPixelObjectGrayScale = pOutputPixelDataBuffer;

	return hr;
}









HRESULT DirectXStandardAlgorithmExecutor::InitializePixelsValidationUsingADescrptorColorsExact(HINSTANCE hInstance,
	HWND hWnd,
	CBThreshHoldVarColorDescriptor pColorThresoldStructure,
	vector<PixelObject> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	for (PixelObject pOutputData : pPixelBundleArrayStructure)
	{
		if (DESCRIPTOR_CANCEL_OUTPUT == FALSE)
		{
			if ((pOutputData.RMask != 255.0f) && (pOutputData.GMask != 255.0f) && (pOutputData.BMask != 255.0f))
			{

				cout << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;

				imageMaskLog << "Pixel №: " << pOutputData.pixelNumber <<
					"X Position: " << pOutputData.xPosition <<
					"Y Position: " << pOutputData.yPosition <<
					"Red Component" << pOutputData.RMask <<
					"Green Component" << pOutputData.GMask <<
					"Blue Mask" << pOutputData.BMask << endl;


			}
		}
	}


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;




	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSApplyColorDescriptorExact.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBThreshHoldVarColorDescriptor) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelObject);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelObject);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelObjectDescriptor);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelObjectDescriptor);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}








HRESULT DirectXStandardAlgorithmExecutor::InitializePixelBundleValidationProcedure(HINSTANCE hInstance,
	HWND hWnd,
	cbColorThreshold pColorThresoldStructure,
	vector<PixelBundle> pPixelBundleArrayStructure,
	ID3D11ComputeShader** ppComputeShaderObjectVector,
	ID3D11Buffer** ppConstantBufferObject,
	ID3D11Buffer** ppPixelBundleInputBuffer,
	ID3D11Buffer** ppPixelBundleOutputBuffer,
	ID3D11ShaderResourceView** ppShaderSRV,
	ID3D11UnorderedAccessView** ppUnorderedUAV,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer*  pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ValidatePixelBundleAgainstColorThreshold.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(cbColorThreshold) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresource;
	pSubresource.pSysMem = &pColorThresoldStructure;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresource, &pConstantBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		}
		cout << "The Binarization Constant Buffer Has Been Created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать  константный буффер для бинаризатора", (LPCSTR)"Message", 0);
		cout << "The exit of The Binarization Constant Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_input;
	ZeroMemory(&buffer_desc_input, sizeof(buffer_desc_input));
	buffer_desc_input.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(PixelBundle);
	buffer_desc_input.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_input.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_input.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_input.StructureByteStride = sizeof(PixelBundle);
	buffer_desc_input.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pPixelBundleArrayStructure[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_input, &pData1, &pInputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelBundleWithValidations);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBundleWithValidations);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pPixelBundleArrayStructure.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pPixelBundleArrayStructure.size();
	

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pPixelBundleArrayStructure.size() * sizeof(OutputPixelBundleWithValidations);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBundleWithValidations);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderObjectVector = pComputeShaderObject;
	*ppConstantBufferObject = pConstantBuffer;
	*ppPixelBundleInputBuffer = pInputBuffer;
	*ppPixelBundleOutputBuffer = pOutputPixelBuffer;
	*ppShaderSRV = pInputSRV1;
	*ppUnorderedUAV = pPixelOutputUAV;
	*ppReadbackBuffer = pReadbackOutputBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunPixelBundleValidations(HINSTANCE hInstance,
	HWND hWnd, 
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBufferObject,
	ID3D11ShaderResourceView* pShaderSRV,
	ID3D11UnorderedAccessView* pUnorderedUAV, 
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderSRV} ;
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV, };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufferObject);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr};
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppConstantBuffers[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppConstantBuffers);
	return hr;
}







DWORD WINAPI CompareImagesThreadFunctionRGB(LPVOID lParam)
{
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HRESULT hr = S_OK;
	HWND hWnd = (HWND)lParam;

	fstream imageSegmentationDataFile;
	imageSegmentationDataFile.open("C:\\pixels\\ImageComparisonOperationThreaded.txt", std::fstream::in | std::fstream::out | std::fstream::trunc);
	imageSegmentationDataFile << "New Record" << endl;

	DWORD pResult = 0;



	pOutputPixelBufferOutputArrayGlobalRGB = vector<OutputPixelBufferRGB>();
	pImageComparisonIdenticalGlobalRGB = vector<PixelObject>();
	pImageComparisonDifferentGlobalRGB = vector<PixelObject>();

	DirectXStandardAlgorithmExecutor* pStandardAlgorithmObject = (DirectXStandardAlgorithmExecutor*)lParam;


	if (pImageOneForComparisonGlobal.size() == 0 || pImageTwoForComparisonGlobal.size() == 0)
	{
		cout << "Data Processing Containers are empty" << endl;
		pResult = -1;
		return pResult;
	}


	cout << "Simulating the Image Subtraction Operation" << endl;

	cout << "Printing Array One" << endl;

	UINT pIndex = 0;
	for (PixelObject pixelObject : pImageOneForComparisonGlobal)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}


	cout << "Printing Array One" << endl;

	pIndex = 0;
	for (PixelObject pixelObject : pImageTwoForComparisonGlobal)
	{
		cout << "Index: " << pIndex << endl;
		cout << "Pixel Number: " << pixelObject.pixelNumber << endl;
		cout << "X Position: " << pixelObject.xPosition << endl;
		cout << "Y Position: " << pixelObject.yPosition << endl;
		cout << "Red Value: " << pixelObject.RMask << endl;
		cout << "Green Value: " << pixelObject.GMask << endl;
		cout << "Blue Value: " << pixelObject.BMask << endl;

		imageSegmentationDataFile << "Index: " << pIndex << endl;
		imageSegmentationDataFile << "Pixel Number: " << pixelObject.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << pixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Value: " << pixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Value: " << pixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Value: " << pixelObject.BMask << endl;



	}

	










	int pAmountOfIdenticalPixels = 0;
	int pAmountOfDifferentPixels = 0;
	vector<OutputPixelBufferRGB> ppVerificationOutputArray = vector<OutputPixelBufferRGB>();
	vector<PixelObject> ppIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> ppDifferentPixelOutputArray = vector<PixelObject>();

	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;





	BOOL pAreImagesIdentical = FALSE;

	hr = pStandardAlgorithmObject->CheckIfImagesAreIdenticalRGB(hInstance, hWnd, 0, 0, pImageOneForComparisonGlobalRGB,
		pImageTwoForComparisonGlobalRGB, &pAmountOfIdenticalPixels, &pAmountOfDifferentPixels, &ppVerificationOutputArray,
		&ppIdenticalPixelOutputArray, &ppDifferentPixelOutputArray,
		&pImageOneIntensitySumRedGlobal, &pImageOneIntensitySumGreenGlobal, &pImageOneIntensitySumBlueGlobal,
		&pImageTwoIntensitySumRedGlobal, &pImageTwoIntensitySumGreenGlobal, &pImageTwoIntensitySumBlueGlobal,
		&pOutputArrayIntensitySumRedGlobal, &pOutputArrayIntensitySumGreenGlobal, &pOutputArrayIntensitySumBlueGlobal,
		&pIdenticalArrayIntensitySumRedGlobal, &pIdenticalArrayIntensitySumGreenGlobal, &pIdenticalArrayIntensitySumBlueGlobal,
		&pDifferentArrayIntensitySumRedGlobal, &pDifferentArrayIntensitySumGreenGlobal, &pDifferentArrayIntensitySumBlueGlobal,
		&pImageOneRedAverageGlobal, &pImageOneGreenAverageGlobal, &pImageOneBlueAverageGlobal,
		&pImageTwoRedAverageGlobal, &pImageTwoGreenAverageGlobal, &pImageTwoBlueAverageGlobal,
		&pOutputArrayRedAverageGlobal, &pOutputArrayGreenAverageGlobal, &pOutputArrayBlueAverageGlobal,
		&pIdenticalArrayRedAverageGlobal, &pIdenticalArrayGreenAverageGlobal, &pIdenticalArrayBlueAverageGlobal,
		&pDifferentArrayRedAverageGlobal, &pDifferentArrayGreenAverageGlobal, &pDifferentArrayBlueAverageGlobal,
		&pAreImagesIdentical);



	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << " " << endl;
	imageSegmentationDataFile << "New Operation Begin" << endl;

	cout << "Printing the Output Buffer Of Comparison Operation" << endl;
	imageSegmentationDataFile << "Printing the Output Buffer Of Comparison Operation" << endl;

	int pIntensitySummation = 0;
	pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	for (OutputPixelBufferRGB pOutputPixelValue : ppVerificationOutputArray)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




		imageSegmentationDataFile << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageSegmentationDataFile << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageSegmentationDataFile << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageSegmentationDataFile << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageSegmentationDataFile << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageSegmentationDataFile << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageSegmentationDataFile << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageSegmentationDataFile << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageSegmentationDataFile << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageSegmentationDataFile << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageSegmentationDataFile << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageSegmentationDataFile << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		imageSegmentationDataFile << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
		imageSegmentationDataFile << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;

		pIndex++;
	}

	cout << "Printing the output of Identical Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Identical Pixel Vector" << endl;

	for (PixelObject pPixelObject : ppIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}


	cout << "Printing the output of Different Pixel Vector" << endl;
	imageSegmentationDataFile << "Printing the output of Different Pixel Vector" << endl;



	for (PixelObject pPixelObject : ppDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageSegmentationDataFile << "Pixel Number: " << pPixelObject.pixelNumber;
		imageSegmentationDataFile << "X Position: " << pPixelObject.xPosition << endl;
		imageSegmentationDataFile << "Y Position: " << pPixelObject.yPosition << endl;
		imageSegmentationDataFile << "Red Component: " << pPixelObject.RMask << endl;
		imageSegmentationDataFile << "Green Component: " << pPixelObject.GMask << endl;
		imageSegmentationDataFile << "Blue Component: " << pPixelObject.BMask << endl;




	}

	// Copying vector by copy function 
	std::copy(ppVerificationOutputArray.begin(), ppVerificationOutputArray.end(), back_inserter(pOutputPixelBufferOutputArrayGlobalRGB));
	std:copy(ppIdenticalPixelOutputArray.begin(), ppIdenticalPixelOutputArray.end(), back_inserter(pImageComparisonIdenticalGlobalRGB));
	std::copy(ppDifferentPixelOutputArray.begin(), ppDifferentPixelOutputArray.end(), back_inserter(pImageComparisonDifferentGlobalRGB));







	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalRGB(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBufferRGB> *ppOutputPixelData,
	vector<PixelObject> *ppIdenticalPixelBuffer,
	vector<PixelObject> *ppDifferentPixelBuffer,
	float *ppImageOneIntensitySumRed,
	float *ppImageOneIntensitySumGreen,
	float *ppImageOneIntensitySumBlue,
	float *ppImageTwoIntensitySumRed,
	float *ppImageTwoIntensitySumGreen,
	float *ppImageTwoIntensitySumBlue,
	float *ppImageOutputIntensitySumRed,
	float *ppImageOutputIntensitySumGreen,
	float *ppImageOutputIntensitySumBlue,
	float *ppImageIdenticalIntensitySumRed,
	float *ppImageIdenticalIntensitySumGreen,
	float *ppImageIdenticaltIntensitySumBlue,
	float *ppImageDifferentIntensitySumRed,
	float *ppImageDifferentIntensitySumGreen,
	float *ppImageDifferenttIntensitySumBlue,
	float *ppImageOneIntensityAverageRed,
	float *ppImageOneIntensityAverageGreen,
	float *ppImageOneIntensityAverageBlue,
	float *ppImageTwoIntensityAverageRed,
	float *ppImageTwoIntensityAverageGreen,
	float *ppImageTwoIntensityAverageBlue,
	float *ppImageOutputIntensityAverageRed,
	float *ppImageOutputIntensityAverageGreen,
	float *ppImageOutputIntensityAverageBlue,
	float *ppImageIdenticalIntensityAverageRed,
	float *ppImageIdenticalIntensityAverageGreen,
	float *ppImageIdenticalIntensityAverageBlue,
	float *ppImageDifferentIntensityAverageRed,
	float *ppImageDifferentIntensityAverageGreen,
	float *ppImageDifferenttIntensityAverageBlue,
	BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferRGB> pPixelArrayOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneRedAverage = 0.0f;
	float pImageOneGreenAverage = 0.0f;
	float pImageOneBlueAverage = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoRedAverage = 0.0f;
	float pImageTwoGreenAverage = 0.0f;
	float pImageTwoBlueAverage = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayArraySize = 0.0f;
	float pOutputArrayRedAverage = 0.0f;
	float pOutputArrayGreenAverage = 0.0f;
	float pOutputArrayBlueAverage = 0.0f;



	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;
	float pIdenticalArrayArraySize = 0.0f;
	float pIdenticalArrayRedAverage = 0.0f;
	float pIdenticalArrayGreenAverage = 0.0f;
	float pIdenticalArrayBlueAverage = 0.0f;

	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;
	float pDifferentArrayArraySize = 0.0f;
	float pDifferentArrayRedAverage = 0.0f;
	float pDifferentArrayGreenAverage = 0.0f;
	float pDifferentArrayBlueAverage = 0.0f;




	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;

		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;



	}
	
	pImageOneRedAverage = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneGreenAverage = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneBlueAverage = pImageOneIntensitySumBlue / pixelArrayOne.size();



	cout << "Image One Intensity Sum Red = " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green = " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue = " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Average Intensity Red = " << pImageOneRedAverage << endl;
	cout << "Image One Average Intensity Green = " << pImageOneGreenAverage << endl;
	cout << "Image One Average Intensity Blue = " << pImageOneBlueAverage << endl;




	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;

	for (PixelObject pPixelObject : pixelArrayTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pImageTwoIntensitySumRed = pImageTwoIntensitySumRed + pPixelObject.RMask;
		pImageTwoIntensitySumGreen = pImageTwoIntensitySumGreen + pPixelObject.GMask;
		pImageTwoIntensitySumBlue = pImageTwoIntensitySumBlue + pPixelObject.BMask;



	}

	pImageTwoRedAverage = pImageTwoIntensitySumRed / pixelArrayTwo.size();
	pImageTwoGreenAverage = pImageTwoIntensitySumGreen / pixelArrayTwo.size();
	pImageTwoBlueAverage = pImageTwoIntensitySumBlue / pixelArrayTwo.size();



	cout << "Image Two Intensity Sum Red = " << pImageTwoIntensitySumRed << endl;
	cout << "Image Two Intensity Sum Green = " << pImageTwoIntensitySumGreen << endl;
	cout << "Image Two Intensity Sum Blue = " << pImageTwoIntensitySumBlue << endl;
	cout << "Image Two Average Intensity Red = " << pImageTwoRedAverage << endl;
	cout << "Image Two Average Intensity Green = " << pImageTwoGreenAverage << endl;
	cout << "Image Two Average Intensity Blue = " << pImageTwoBlueAverage << endl;


	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pInputDataBufferImageTwo = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageTwo = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	hr = InitializeIdentityVerificationResourcesRGB(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pixelArrayOne,
		pixelArrayTwo,
		&ppComputeShaderForImageComparison,
		&pInputDataBufferImageOne,
		&pInputDataBufferImageTwo,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pInputDataSRVImageTwo,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne, pInputDataSRVImageTwo };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView};


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperationRGB(hInstance, hWnd, ppComputeShaderForImageComparison,
		pInputDataSRVImageOne,
		pInputDataSRVImageTwo,
		pOutputUnorderedView,
		2, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferRGB* pOutputDataImages = (OutputPixelBufferRGB*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferRGB pOutputPixelValue = pOutputDataImages[pIndex];
		pOutputPixelValue.pixelNumber = pIndex;

		if (pOutputPixelValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputPixelValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputPixelValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputPixelValue.pAmountOfDifferentPixels = pDifferentPixelAmount;

		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);

		

	}


	hr = RestoreZeroRGBPixelsFromImageCompationInitialPixels(hInstance, hWnd, pPixelArrayOutputBuffer,
		&pIdenticalPixelOutputArray);
	hr = RestoreNonZeroRGBPixelsFromImageCompationInitialPixels(hInstance, hWnd, pPixelArrayOutputBuffer,
		&pDifferentPixelOutputArray);



	pOutputArrayRedAverage = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayGreenAverage = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayBlueAverage = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{

		
	

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;


	

	}


	pIdenticalArrayRedAverage = pIdenticalArrayIntensitySumRed / pIdenticalPixelOutputArray.size();
	pIdenticalArrayGreenAverage = pIdenticalArrayIntensitySumGreen / pIdenticalPixelOutputArray.size();
	pIdenticalArrayBlueAverage = pIdenticalArrayIntensitySumBlue / pIdenticalPixelOutputArray.size();



	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pDifferentArrayRedAverage = pDifferentArrayIntensitySumRed / pDifferentPixelOutputArray.size();
	pDifferentArrayGreenAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();
	pDifferentArrayBlueAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();




	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferRGB pOutputPixelValue : pPixelArrayOutputBuffer)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pIndex++;
	}

	cout << "Printing Identical Pixel Array Buffer" << endl;
	imageMaskLog << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green  Component: " << pPixelObject.GMask << endl;
		cout << "Blue  Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;

	}

	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountOfidenticalPixels = pDifferentPixelAmount;
	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppIdenticalPixelBuffer = pIdenticalPixelOutputArray;
	*ppDifferentPixelBuffer = pDifferentPixelOutputArray;
	*ppImageOneIntensitySumRed = pImageOneIntensitySumRed;
	*ppImageOneIntensitySumGreen = pImageOneIntensitySumGreen;
	*ppImageOneIntensitySumBlue = pImageOneIntensitySumBlue;
	*ppImageTwoIntensitySumRed = pImageTwoIntensitySumRed;
	*ppImageTwoIntensitySumGreen = pImageTwoIntensitySumGreen;
	*ppImageTwoIntensitySumBlue = pImageTwoIntensitySumBlue;
	*ppImageOutputIntensitySumRed = pOutputArrayIntensitySumRed;
	*ppImageOutputIntensitySumGreen = pOutputArrayIntensitySumGreen;
	*ppImageOutputIntensitySumBlue = pOutputArrayIntensitySumBlue;
	*ppImageOneIntensityAverageRed = pImageOneRedAverage;
	*ppImageOneIntensityAverageGreen = pImageOneGreenAverage;
	*ppImageOneIntensityAverageBlue = pImageOneBlueAverage;
	*ppImageTwoIntensityAverageRed = pImageTwoRedAverage;
	*ppImageTwoIntensityAverageGreen = pImageTwoGreenAverage;
	*ppImageTwoIntensityAverageBlue = pImageTwoBlueAverage;
	*ppImageOutputIntensityAverageRed = pOutputArrayRedAverage;
	*ppImageOutputIntensityAverageGreen = pOutputArrayGreenAverage;
	*ppImageOutputIntensityAverageBlue = pOutputArrayBlueAverage;
	*ppImageIdenticalIntensityAverageRed = pIdenticalArrayRedAverage;
	*ppImageIdenticalIntensityAverageGreen = pIdenticalArrayGreenAverage;
	*ppImageIdenticalIntensityAverageBlue = pIdenticalArrayBlueAverage;
	*ppImageDifferentIntensityAverageRed = pDifferentArrayRedAverage;
	*ppImageDifferentIntensityAverageGreen = pDifferentArrayGreenAverage;
	*ppImageDifferenttIntensityAverageBlue = pDifferentArrayBlueAverage;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResourcesRGB(HINSTANCE hInstance,
	HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBufferImageOne,
	ID3D11Buffer** ppInputBufferImageTwo,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObjectOutput,
	ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11Buffer* pOutputIdenticalPixelBuffer = nullptr;
	ID3D11Buffer* pOutputDifferentPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CheckIfTwoImageAreIdenticalRGBProcedured.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObject);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObject);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayTwo.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	


	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferImageOne = pInputBuffer1;
	*ppInputBufferImageTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunImageIdentityVerificationOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11ShaderResourceView* ppSRV2,
	ID3D11UnorderedAccessView* pUAVObjectOutput,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1, ppSRV2 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUAVObjectOutput };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::MultiplyImagePixelValuesByAColor(HINSTANCE hInstance,
	HWND hWnd, UINT pImageWidth, UINT pImageHeight, vector<PixelObject> pixelArrayOne, float pSampleRed, float pSampleGreen, float pSampleBlue,
	int *pAmountOfidenticalPixels, int *pAmountODifferentPixels, vector<OutputPixelBufferRGB> *ppOutputPixelData, 
	vector<PixelObject> *ppIdenticalPixelBuffer, vector<PixelObject> *ppDifferentPixelBuffer, float *ppImageOneIntensitySumRed, float *ppImageOneIntensitySumGreen, float *ppImageOneIntensitySumBlue, float *ppImageOutputIntensitySumRed, float *ppImageOutputIntensitySumGreen, float *ppImageOutputputIntensitySumBlue, float *ppImageIdenticalIntensitySumRed, float *ppImageIdenticalIntensitySumGreen, float *ppImageIdenticaltIntensitySumBlue, float *ppImageDifferentIntensitySumRed, float *ppImageDifferentIntensitySumGreen, float *ppImageDifferenttIntensitySumBlue, float *ppImageOneIntensityAverageRed, float *ppImageOneIntensityAverageGreen, float *ppImageOneIntensityAverageBlue, float *ppImageOutputIntensityAverageRed, float *ppImageOutputIntensityAverageGreen, float *ppImageOutputputIntensityAverageBlue, float *ppImageIdenticalIntensityAverageRed, float *ppImageIdenticalIntensityAverageGreen, float *ppImageIdenticaltIntensityAverageBlue, float *ppImageDifferentIntensityAverageRed, float *ppImageDifferentIntensityAverageGreen, float *ppImageDifferenttIntensityAverageBlue, BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferRGB> pPixelArrayOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneRedAverage = 0.0f;
	float pImageOneGreenAverage = 0.0f;
	float pImageOneBlueAverage = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoRedAverage = 0.0f;
	float pImageTwoGreenAverage = 0.0f;
	float pImageTwoBlueAverage = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayArraySize = 0.0f;
	float pOutputArrayRedAverage = 0.0f;
	float pOutputArrayGreenAverage = 0.0f;
	float pOutputArrayBlueAverage = 0.0f;



	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;
	float pIdenticalArrayArraySize = 0.0f;
	float pIdenticalArrayRedAverage = 0.0f;
	float pIdenticalArrayGreenAverage = 0.0f;
	float pIdenticalArrayBlueAverage = 0.0f;

	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;
	float pDifferentArrayArraySize = 0.0f;
	float pDifferentArrayRedAverage = 0.0f;
	float pDifferentArrayGreenAverage = 0.0f;
	float pDifferentArrayBlueAverage = 0.0f;




	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;

		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;



	}

	pImageOneRedAverage = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneGreenAverage = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneBlueAverage = pImageOneIntensitySumBlue / pixelArrayOne.size();



	cout << "Image One Intensity Sum Red = " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green = " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue = " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Average Intensity Red = " << pImageOneRedAverage << endl;
	cout << "Image One Average Intensity Green = " << pImageOneGreenAverage << endl;
	cout << "Image One Average Intensity Blue = " << pImageOneBlueAverage << endl;




	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;





	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	CBColorSubtraction pSubtractionVar;

	pSubtractionVar.pRedValue = pSampleRed;
	pSubtractionVar.pGreenValue = pSampleGreen;
	pSubtractionVar.pBlueValue = pSampleBlue;

	hr = InitializeIdentityVerificationResourcesRGBAgainstAColorMultiplication(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pSampleRed,
		pSampleGreen,
		pSampleBlue,
		pixelArrayOne,
		&ppComputeShaderForImageComparison,
		&pConstantBufferObject,
		&pInputDataBufferImageOne,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}


	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperationRGBAgainstAColor(hInstance, hWnd, ppComputeShaderForImageComparison,
		pConstantBufferObject,
		pInputDataSRVImageOne,
		pOutputUnorderedView,
		1, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferRGB* pOutputDataImages = (OutputPixelBufferRGB*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferRGB pOutputPixelValue = pOutputDataImages[pIndex];
		pOutputPixelValue.pixelNumber = pIndex;

		if (pOutputPixelValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputPixelValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputPixelValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputPixelValue.pAmountOfDifferentPixels = pDifferentPixelAmount;

		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);



		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;

		
	}

	pOutputArrayRedAverage = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayGreenAverage = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayBlueAverage = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pIdenticalArrayRedAverage = pIdenticalArrayIntensitySumRed / pIdenticalPixelOutputArray.size();
	pIdenticalArrayGreenAverage = pIdenticalArrayIntensitySumGreen / pIdenticalPixelOutputArray.size();
	pIdenticalArrayBlueAverage = pIdenticalArrayIntensitySumBlue / pIdenticalPixelOutputArray.size();



	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pDifferentArrayRedAverage = pDifferentArrayIntensitySumRed / pDifferentPixelOutputArray.size();
	pDifferentArrayGreenAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();
	pDifferentArrayBlueAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();




	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferRGB pOutputPixelValue : pPixelArrayOutputBuffer)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Green: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Blue: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pIndex++;
	}



	*ppOutputPixelData = pPixelArrayOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::DivideImagePixelValuesByAColor(HINSTANCE hInstance,
	HWND hWnd, UINT pImageWidth, UINT pImageHeight, vector<PixelObject> pixelArrayOne, float pSampleRed, float pSampleGreen, float pSampleBlue,
	int *pAmountOfidenticalPixels, int *pAmountODifferentPixels, vector<OutputPixelBufferRGB> *ppOutputPixelData,
	vector<PixelObject> *ppIdenticalPixelBuffer, vector<PixelObject> *ppDifferentPixelBuffer, float *ppImageOneIntensitySumRed, float *ppImageOneIntensitySumGreen, float *ppImageOneIntensitySumBlue, float *ppImageOutputIntensitySumRed, float *ppImageOutputIntensitySumGreen, float *ppImageOutputputIntensitySumBlue, float *ppImageIdenticalIntensitySumRed, float *ppImageIdenticalIntensitySumGreen, float *ppImageIdenticaltIntensitySumBlue, float *ppImageDifferentIntensitySumRed, float *ppImageDifferentIntensitySumGreen, float *ppImageDifferenttIntensitySumBlue, float *ppImageOneIntensityAverageRed, float *ppImageOneIntensityAverageGreen, float *ppImageOneIntensityAverageBlue, float *ppImageOutputIntensityAverageRed, float *ppImageOutputIntensityAverageGreen, float *ppImageOutputputIntensityAverageBlue, float *ppImageIdenticalIntensityAverageRed, float *ppImageIdenticalIntensityAverageGreen, float *ppImageIdenticaltIntensityAverageBlue, float *ppImageDifferentIntensityAverageRed,
	float *ppImageDifferentIntensityAverageGreen, float *ppImageDifferenttIntensityAverageBlue, BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferRGB> pPixelArrayOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneRedAverage = 0.0f;
	float pImageOneGreenAverage = 0.0f;
	float pImageOneBlueAverage = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoRedAverage = 0.0f;
	float pImageTwoGreenAverage = 0.0f;
	float pImageTwoBlueAverage = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayArraySize = 0.0f;
	float pOutputArrayRedAverage = 0.0f;
	float pOutputArrayGreenAverage = 0.0f;
	float pOutputArrayBlueAverage = 0.0f;



	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;
	float pIdenticalArrayArraySize = 0.0f;
	float pIdenticalArrayRedAverage = 0.0f;
	float pIdenticalArrayGreenAverage = 0.0f;
	float pIdenticalArrayBlueAverage = 0.0f;

	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;
	float pDifferentArrayArraySize = 0.0f;
	float pDifferentArrayRedAverage = 0.0f;
	float pDifferentArrayGreenAverage = 0.0f;
	float pDifferentArrayBlueAverage = 0.0f;




	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red Component: " << pPixelObject.RMask << endl;
		cout << "Green Component: " << pPixelObject.GMask << endl;
		cout << "Blue Component: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;

		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;



	}

	pImageOneRedAverage = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneGreenAverage = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneBlueAverage = pImageOneIntensitySumBlue / pixelArrayOne.size();



	cout << "Image One Intensity Sum Red = " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green = " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue = " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Average Intensity Red = " << pImageOneRedAverage << endl;
	cout << "Image One Average Intensity Green = " << pImageOneGreenAverage << endl;
	cout << "Image One Average Intensity Blue = " << pImageOneBlueAverage << endl;




	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;





	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	CBColorSubtraction pSubtractionVar;

	pSubtractionVar.pRedValue = pSampleRed;
	pSubtractionVar.pGreenValue = pSampleGreen;
	pSubtractionVar.pBlueValue = pSampleBlue;

	hr = InitializeIdentityVerificationResourcesRGBAgainstAColorDivision(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pSampleRed,
		pSampleGreen,
		pSampleBlue,
		pixelArrayOne,
		&ppComputeShaderForImageComparison,
		&pConstantBufferObject,
		&pInputDataBufferImageOne,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}


	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperationRGBAgainstAColor(hInstance, hWnd, ppComputeShaderForImageComparison,
		pConstantBufferObject,
		pInputDataSRVImageOne,
		pOutputUnorderedView,
		1, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferRGB* pOutputDataImages = (OutputPixelBufferRGB*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferRGB pOutputPixelValue = pOutputDataImages[pIndex];
		pOutputPixelValue.pixelNumber = pIndex;

		if (pOutputPixelValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputPixelValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputPixelValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputPixelValue.pAmountOfDifferentPixels = pDifferentPixelAmount;

		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);



		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;


	}

	pOutputArrayRedAverage = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayGreenAverage = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayBlueAverage = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pIdenticalArrayRedAverage = pIdenticalArrayIntensitySumRed / pIdenticalPixelOutputArray.size();
	pIdenticalArrayGreenAverage = pIdenticalArrayIntensitySumGreen / pIdenticalPixelOutputArray.size();
	pIdenticalArrayBlueAverage = pIdenticalArrayIntensitySumBlue / pIdenticalPixelOutputArray.size();



	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{




		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pDifferentArrayRedAverage = pDifferentArrayIntensitySumRed / pDifferentPixelOutputArray.size();
	pDifferentArrayGreenAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();
	pDifferentArrayBlueAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();




	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferRGB pOutputPixelValue : pPixelArrayOutputBuffer)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Green: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Blue: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pIndex++;
	}



	*ppOutputPixelData = pPixelArrayOutputBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResourcesRGBAgainstAColorDivision(HINSTANCE hInstance, HWND hWnd,
	float pImageWidth, float pImageHeight,
	float pSampleRed, float pSampleGreen, float pSampleBlue,
	vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBufferOne,
	ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObjectOutput, ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	CBColorSubtraction pColorCB;
	pColorCB.pRedValue = pSampleRed;
	pColorCB.pGreenValue = pSampleGreen;
	pColorCB.pBlueValue = pSampleBlue;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSDivideImagePixelIntensityByNumber.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBColorSubtraction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pColorCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pData1, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBufferOne = pInputBuffer1;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResourcesRGBAgainstAColor(HINSTANCE hInstance, HWND hWnd, 
	float pImageWidth, float pImageHeight, 
	float pSampleRed, float pSampleGreen, float pSampleBlue,
	vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject, 
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBufferOne,
	ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObjectOutput, ID3D11Buffer** ppReadbackBufferOutput )
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	CBColorSubtraction pColorCB;
	pColorCB.pRedValue = pSampleRed;
	pColorCB.pGreenValue = pSampleGreen;
	pColorCB.pBlueValue = pSampleBlue;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSubtactColorFromImagePixelValues.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBColorSubtraction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pColorCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pData1, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	

	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	
	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBufferOne = pInputBuffer1;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::AddColorToImagePixelsFromRGBImage(HINSTANCE hInstance, HWND hWnd,
	UINT pImageWidth, UINT pImageHeight, vector<PixelObject> pixelArrayOne,
	float pSampleRed, float pSampleGreen, float pSampleBlue, vector<OutputPixelBufferRGB> *ppOutputPixelData)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferRGB> pPixelArrayOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneRedAverage = 0.0f;
	float pImageOneGreenAverage = 0.0f;
	float pImageOneBlueAverage = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoRedAverage = 0.0f;
	float pImageTwoGreenAverage = 0.0f;
	float pImageTwoBlueAverage = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayArraySize = 0.0f;
	float pOutputArrayRedAverage = 0.0f;
	float pOutputArrayGreenAverage = 0.0f;
	float pOutputArrayBlueAverage = 0.0f;



	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;
	float pIdenticalArrayArraySize = 0.0f;
	float pIdenticalArrayRedAverage = 0.0f;
	float pIdenticalArrayGreenAverage = 0.0f;
	float pIdenticalArrayBlueAverage = 0.0f;

	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;
	float pDifferentArrayArraySize = 0.0f;
	float pDifferentArrayRedAverage = 0.0f;
	float pDifferentArrayGreenAverage = 0.0f;
	float pDifferentArrayBlueAverage = 0.0f;




	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;

			pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
			pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
			pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;
		}


	}

	pImageOneRedAverage = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneGreenAverage = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneBlueAverage = pImageOneIntensitySumBlue / pixelArrayOne.size();



	cout << "Image One Intensity Sum Red = " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green = " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue = " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Average Intensity Red = " << pImageOneRedAverage << endl;
	cout << "Image One Average Intensity Green = " << pImageOneGreenAverage << endl;
	cout << "Image One Average Intensity Blue = " << pImageOneBlueAverage << endl;




	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;





	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	CBColorSubtraction pSubtractionVar;

	pSubtractionVar.pRedValue = pSampleRed;
	pSubtractionVar.pGreenValue = pSampleGreen;
	pSubtractionVar.pBlueValue = pSampleBlue;

	hr = InitializeIdentityVerificationResourcesRGBAgainstAColorAddition(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pSampleRed,
		pSampleGreen,
		pSampleBlue,
		pixelArrayOne,
		&ppComputeShaderForImageComparison,
		&pConstantBufferObject,
		&pInputDataBufferImageOne,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}


	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperationRGBAgainstAColor(hInstance, hWnd, ppComputeShaderForImageComparison,
		pConstantBufferObject,
		pInputDataSRVImageOne,
		pOutputUnorderedView,
		1, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferRGB* pOutputDataImages = (OutputPixelBufferRGB*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferRGB pOutputPixelValue = pOutputDataImages[pIndex];
		pOutputPixelValue.pixelNumber = pIndex;

		if (pOutputPixelValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputPixelValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputPixelValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputPixelValue.pAmountOfDifferentPixels = pDifferentPixelAmount;


		if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

			imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		}
		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);



		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;


	}

	pOutputArrayRedAverage = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayGreenAverage = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayBlueAverage = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{


		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{

			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		
		}

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;


	}


	pIdenticalArrayRedAverage = pIdenticalArrayIntensitySumRed / pIdenticalPixelOutputArray.size();
	pIdenticalArrayGreenAverage = pIdenticalArrayIntensitySumGreen / pIdenticalPixelOutputArray.size();
	pIdenticalArrayBlueAverage = pIdenticalArrayIntensitySumBlue / pIdenticalPixelOutputArray.size();



	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{

		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{


			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

			pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
			pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
			pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;

		}


	}


	pDifferentArrayRedAverage = pDifferentArrayIntensitySumRed / pDifferentPixelOutputArray.size();
	pDifferentArrayGreenAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();
	pDifferentArrayBlueAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();




	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferRGB pOutputPixelValue : pPixelArrayOutputBuffer)
	{
		if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
		{
			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Green: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Blue: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

			imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			imageMaskLog << "Red Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			imageMaskLog << "Green Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			imageMaskLog << "Blue Sum: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
		}
		pIndex++;
	}



	*ppOutputPixelData = pPixelArrayOutputBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResourcesRGBAgainstAColorAddition(HINSTANCE hInstance, HWND hWnd,
	float pImageWidth, float pImageHeight,
	float pSampleRed, float pSampleGreen, float pSampleBlue,
	vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBufferOne,
	ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObjectOutput, ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	CBColorSubtraction pColorCB;
	pColorCB.pRedValue = pSampleRed;
	pColorCB.pGreenValue = pSampleGreen;
	pColorCB.pBlueValue = pSampleBlue;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\СSAddIntensityToImagePixelValues.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBColorSubtraction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pColorCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pData1, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBufferOne = pInputBuffer1;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SubtractColorFromRGBImage(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObject> pixelArrayOne,
	float pSampleRed,
	float pSampleGreen,
	float pSampleBlue,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBufferRGB> *ppOutputPixelData,
	vector<PixelObject> *ppIdenticalPixelBuffer,
	vector<PixelObject> *ppDifferentPixelBuffer,
	float *ppImageOneIntensitySumRed,
	float *ppImageOneIntensitySumGreen,
	float *ppImageOneIntensitySumBlue,
	float *ppImageOutputIntensitySumRed,
	float *ppImageOutputIntensitySumGreen,
	float *ppImageOutputputIntensitySumBlue,
	float *ppImageIdenticalIntensitySumRed,
	float *ppImageIdenticalIntensitySumGreen,
	float *ppImageIdenticaltIntensitySumBlue,
	float *ppImageDifferentIntensitySumRed,
	float *ppImageDifferentIntensitySumGreen,
	float *ppImageDifferenttIntensitySumBlue,
	float *ppImageOneIntensityAverageRed,
	float *ppImageOneIntensityAverageGreen,
	float *ppImageOneIntensityAverageBlue,
	float *ppImageOutputIntensityAverageRed,
	float *ppImageOutputIntensityAverageGreen,
	float *ppImageOutputputIntensityAverageBlue,
	float *ppImageIdenticalIntensityAverageRed,
	float *ppImageIdenticalIntensityAverageGreen,
	float *ppImageIdenticaltIntensityAverageBlue,
	float *ppImageDifferentIntensityAverageRed,
	float *ppImageDifferentIntensityAverageGreen,
	float *ppImageDifferenttIntensityAverageBlue,
	BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferRGB> pPixelArrayOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneRedAverage = 0.0f;
	float pImageOneGreenAverage = 0.0f;
	float pImageOneBlueAverage = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoRedAverage = 0.0f;
	float pImageTwoGreenAverage = 0.0f;
	float pImageTwoBlueAverage = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayArraySize = 0.0f;
	float pOutputArrayRedAverage = 0.0f;
	float pOutputArrayGreenAverage = 0.0f;
	float pOutputArrayBlueAverage = 0.0f;



	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;
	float pIdenticalArrayArraySize = 0.0f;
	float pIdenticalArrayRedAverage = 0.0f;
	float pIdenticalArrayGreenAverage = 0.0f;
	float pIdenticalArrayBlueAverage = 0.0f;

	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;
	float pDifferentArrayArraySize = 0.0f;
	float pDifferentArrayRedAverage = 0.0f;
	float pDifferentArrayGreenAverage = 0.0f;
	float pDifferentArrayBlueAverage = 0.0f;




	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;

		}
	
		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;



	}

	pImageOneRedAverage = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneGreenAverage = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneBlueAverage = pImageOneIntensitySumBlue / pixelArrayOne.size();



	cout << "Image One Intensity Sum Red = " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green = " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue = " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Average Intensity Red = " << pImageOneRedAverage << endl;
	cout << "Image One Average Intensity Green = " << pImageOneGreenAverage << endl;
	cout << "Image One Average Intensity Blue = " << pImageOneBlueAverage << endl;




	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;





	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	CBColorSubtraction pSubtractionVar;

	pSubtractionVar.pRedValue = pSampleRed;
	pSubtractionVar.pGreenValue = pSampleGreen;
	pSubtractionVar.pBlueValue = pSampleBlue;

	hr = InitializeIdentityVerificationResourcesRGBAgainstAColor(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pSampleRed,
		pSampleGreen,
		pSampleBlue,
		pixelArrayOne,
		&ppComputeShaderForImageComparison,
		&pConstantBufferObject,
		&pInputDataBufferImageOne,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}


	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperationRGBAgainstAColor(hInstance, hWnd, ppComputeShaderForImageComparison,
		pConstantBufferObject,
		pInputDataSRVImageOne,
		pOutputUnorderedView,
		1, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferRGB* pOutputDataImages = (OutputPixelBufferRGB*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferRGB pOutputPixelValue = pOutputDataImages[pIndex];
		pOutputPixelValue.pixelNumber = pIndex;

		if (pOutputPixelValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputPixelValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputPixelValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputPixelValue.pAmountOfDifferentPixels = pDifferentPixelAmount;

	
		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);



		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;

		if ((pOutputPixelValue.pOutputComparisonValueRed == 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen == 0.0f) && (pOutputPixelValue.pOutputComparisonValueRed == 0.0f))
		{ 
			PixelObject identicalPixel = PixelObject(pOutputPixelValue.pixelNumber,
				pOutputPixelValue.xPosition,
				pOutputPixelValue.yPosition,
				pOutputPixelValue.pRedValue0,
				pOutputPixelValue.pGreenValue0,
				pOutputPixelValue.pBlueValue0);
			pIdenticalPixelOutputArray.push_back(identicalPixel);

		}
		else if (((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueRed != 0.0f)))
		{
			PixelObject differentPixel = PixelObject(pOutputPixelValue.pixelNumber,
				pOutputPixelValue.xPosition,
				pOutputPixelValue.yPosition,
				pOutputPixelValue.pRedValue0,
				pOutputPixelValue.pGreenValue0,
				pOutputPixelValue.pBlueValue0);
			pDifferentPixelOutputArray.push_back(differentPixel);

		}




	}

	pOutputArrayRedAverage = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayGreenAverage = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayBlueAverage = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{

	
		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;

		}


	


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pIdenticalArrayRedAverage = pIdenticalArrayIntensitySumRed / pIdenticalPixelOutputArray.size();
	pIdenticalArrayGreenAverage = pIdenticalArrayIntensitySumGreen / pIdenticalPixelOutputArray.size();
	pIdenticalArrayBlueAverage = pIdenticalArrayIntensitySumBlue / pIdenticalPixelOutputArray.size();



	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{



		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;

		}

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;




	}



	pDifferentArrayRedAverage = pDifferentArrayIntensitySumRed / pDifferentPixelOutputArray.size();
	pDifferentArrayGreenAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();
	pDifferentArrayBlueAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();




	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	float pColorSum = 0.0f;

	for (OutputPixelBufferRGB pOutputPixelValue : pPixelArrayOutputBuffer)
	{
	
		if ((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue != 0.0f))
		{

			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			imageMaskLog << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			imageMaskLog << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
		}
	}
	cout << "Printing Identical Pixel Array Buffer" << endl;
	imageMaskLog << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{
		float pColorSum = pPixelObject.RMask + pPixelObject.GMask + pPixelObject.BMask;
		if (pColorSum != 765)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green  Component: " << pPixelObject.GMask << endl;
			cout << "Blue  Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;
		}
	}


	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{
		float pColorSum = pPixelObject.RMask + pPixelObject.GMask + pPixelObject.BMask;
		if (pColorSum != 765)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green  Component: " << pPixelObject.GMask << endl;
			cout << "Blue  Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;
		}
	}

	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountOfidenticalPixels = pDifferentPixelAmount;
	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppIdenticalPixelBuffer = pIdenticalPixelOutputArray;
	*ppDifferentPixelBuffer = pDifferentPixelOutputArray;
	*ppImageOneIntensitySumRed = pImageOneIntensitySumRed;
	*ppImageOneIntensitySumGreen = pImageOneIntensitySumGreen;
	*ppImageOneIntensitySumBlue = pImageOneIntensitySumBlue;
	*ppImageOutputIntensitySumRed = pOutputArrayIntensitySumRed;
	*ppImageOutputIntensitySumGreen = pOutputArrayIntensitySumGreen;
	*ppImageOneIntensityAverageRed = pImageOneRedAverage;
	*ppImageOneIntensityAverageGreen = pImageOneGreenAverage;
	*ppImageOneIntensityAverageBlue = pImageOneBlueAverage;
	*ppImageOutputIntensityAverageRed = pOutputArrayRedAverage;
	*ppImageOutputIntensityAverageGreen = pOutputArrayGreenAverage;
	*ppImageIdenticalIntensityAverageRed = pIdenticalArrayRedAverage;
	*ppImageIdenticalIntensityAverageGreen = pIdenticalArrayGreenAverage;
	*ppImageDifferentIntensityAverageRed = pDifferentArrayRedAverage;
	*ppImageDifferentIntensityAverageGreen = pDifferentArrayGreenAverage;
	*ppImageDifferenttIntensityAverageBlue = pDifferentArrayBlueAverage;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SubtractColorFromRGBImageIdentical(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObject> pixelArrayOne,
	float pSampleRed,
	float pSampleGreen,
	float pSampleBlue,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBufferRGB> *ppOutputPixelData,
	vector<PixelObject> *ppIdenticalPixelBuffer,
	vector<PixelObject> *ppDifferentPixelBuffer,
	float *ppImageOneIntensitySumRed,
	float *ppImageOneIntensitySumGreen,
	float *ppImageOneIntensitySumBlue,
	float *ppImageOutputIntensitySumRed,
	float *ppImageOutputIntensitySumGreen,
	float *ppImageOutputputIntensitySumBlue,
	float *ppImageIdenticalIntensitySumRed,
	float *ppImageIdenticalIntensitySumGreen,
	float *ppImageIdenticaltIntensitySumBlue,
	float *ppImageDifferentIntensitySumRed,
	float *ppImageDifferentIntensitySumGreen,
	float *ppImageDifferenttIntensitySumBlue,
	float *ppImageOneIntensityAverageRed,
	float *ppImageOneIntensityAverageGreen,
	float *ppImageOneIntensityAverageBlue,
	float *ppImageOutputIntensityAverageRed,
	float *ppImageOutputIntensityAverageGreen,
	float *ppImageOutputputIntensityAverageBlue,
	float *ppImageIdenticalIntensityAverageRed,
	float *ppImageIdenticalIntensityAverageGreen,
	float *ppImageIdenticaltIntensityAverageBlue,
	float *ppImageDifferentIntensityAverageRed,
	float *ppImageDifferentIntensityAverageGreen,
	float *ppImageDifferenttIntensityAverageBlue,
	BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBufferRGB> pPixelArrayOutputBuffer = vector<OutputPixelBufferRGB>();
	vector<PixelObject> pIdenticalPixelOutputArray = vector<PixelObject>();
	vector<PixelObject> pDifferentPixelOutputArray = vector<PixelObject>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySumRed = 0.0f;
	float pImageOneIntensitySumGreen = 0.0f;
	float pImageOneIntensitySumBlue = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneRedAverage = 0.0f;
	float pImageOneGreenAverage = 0.0f;
	float pImageOneBlueAverage = 0.0f;

	float pImageTwoIntensitySumRed = 0.0f;
	float pImageTwoIntensitySumGreen = 0.0f;
	float pImageTwoIntensitySumBlue = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoRedAverage = 0.0f;
	float pImageTwoGreenAverage = 0.0f;
	float pImageTwoBlueAverage = 0.0f;


	float pOutputArrayIntensitySumRed = 0.0f;
	float pOutputArrayIntensitySumGreen = 0.0f;
	float pOutputArrayIntensitySumBlue = 0.0f;
	float pOutputArrayArraySize = 0.0f;
	float pOutputArrayRedAverage = 0.0f;
	float pOutputArrayGreenAverage = 0.0f;
	float pOutputArrayBlueAverage = 0.0f;



	float pIdenticalArrayIntensitySumRed = 0.0f;
	float pIdenticalArrayIntensitySumGreen = 0.0f;
	float pIdenticalArrayIntensitySumBlue = 0.0f;
	float pIdenticalArrayArraySize = 0.0f;
	float pIdenticalArrayRedAverage = 0.0f;
	float pIdenticalArrayGreenAverage = 0.0f;
	float pIdenticalArrayBlueAverage = 0.0f;

	float pDifferentArrayIntensitySumRed = 0.0f;
	float pDifferentArrayIntensitySumGreen = 0.0f;
	float pDifferentArrayIntensitySumBlue = 0.0f;
	float pDifferentArrayArraySize = 0.0f;
	float pDifferentArrayRedAverage = 0.0f;
	float pDifferentArrayGreenAverage = 0.0f;
	float pDifferentArrayBlueAverage = 0.0f;




	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObject pPixelObject : pixelArrayOne)
	{
		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green Component: " << pPixelObject.GMask << endl;
			cout << "Blue Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue Component: " << pPixelObject.BMask << endl;

		}

		pImageOneIntensitySumRed = pImageOneIntensitySumRed + pPixelObject.RMask;
		pImageOneIntensitySumGreen = pImageOneIntensitySumGreen + pPixelObject.GMask;
		pImageOneIntensitySumBlue = pImageOneIntensitySumBlue + pPixelObject.BMask;



	}

	pImageOneRedAverage = pImageOneIntensitySumRed / pixelArrayOne.size();
	pImageOneGreenAverage = pImageOneIntensitySumGreen / pixelArrayOne.size();
	pImageOneBlueAverage = pImageOneIntensitySumBlue / pixelArrayOne.size();



	cout << "Image One Intensity Sum Red = " << pImageOneIntensitySumRed << endl;
	cout << "Image One Intensity Sum Green = " << pImageOneIntensitySumGreen << endl;
	cout << "Image One Intensity Sum Blue = " << pImageOneIntensitySumBlue << endl;
	cout << "Image One Average Intensity Red = " << pImageOneRedAverage << endl;
	cout << "Image One Average Intensity Green = " << pImageOneGreenAverage << endl;
	cout << "Image One Average Intensity Blue = " << pImageOneBlueAverage << endl;




	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;





	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	CBColorSubtraction pSubtractionVar;

	pSubtractionVar.pRedValue = pSampleRed;
	pSubtractionVar.pGreenValue = pSampleGreen;
	pSubtractionVar.pBlueValue = pSampleBlue;

	hr = InitializeIdentityVerificationResourcesRGBAgainstAColor(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pSampleRed,
		pSampleGreen,
		pSampleBlue,
		pixelArrayOne,
		&ppComputeShaderForImageComparison,
		&pConstantBufferObject,
		&pInputDataBufferImageOne,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}


	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperationRGBAgainstAColor(hInstance, hWnd, ppComputeShaderForImageComparison,
		pConstantBufferObject,
		pInputDataSRVImageOne,
		pOutputUnorderedView,
		1, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBufferRGB* pOutputDataImages = (OutputPixelBufferRGB*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBufferRGB pOutputPixelValue = pOutputDataImages[pIndex];
		pOutputPixelValue.pixelNumber = pIndex;

		if (pOutputPixelValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputPixelValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputPixelValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputPixelValue.pAmountOfDifferentPixels = pDifferentPixelAmount;


		pPixelArrayOutputBuffer.push_back(pOutputPixelValue);



		pOutputArrayIntensitySumRed = pOutputArrayIntensitySumRed + pOutputPixelValue.pOutputComparisonValueRed;
		pOutputArrayIntensitySumGreen = pOutputArrayIntensitySumGreen + pOutputPixelValue.pOutputComparisonValueGreen;
		pOutputArrayIntensitySumBlue = pOutputArrayIntensitySumBlue + pOutputPixelValue.pOutputComparisonValueBlue;

		if ((pOutputPixelValue.pOutputComparisonValueRed == 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen == 0.0f) && (pOutputPixelValue.pOutputComparisonValueRed == 0.0f))
		{
			PixelObject identicalPixel = PixelObject(pOutputPixelValue.pixelNumber,
				pOutputPixelValue.xPosition,
				pOutputPixelValue.yPosition,
				pOutputPixelValue.pRedValue0,
				pOutputPixelValue.pGreenValue0,
				pOutputPixelValue.pBlueValue0);
			pIdenticalPixelOutputArray.push_back(identicalPixel);

		}
		else if (((pOutputPixelValue.pOutputComparisonValueRed != 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen != 0.0f) && (pOutputPixelValue.pOutputComparisonValueRed != 0.0f)))
		{
			PixelObject differentPixel = PixelObject(pOutputPixelValue.pixelNumber,
				pOutputPixelValue.xPosition,
				pOutputPixelValue.yPosition,
				pOutputPixelValue.pRedValue0,
				pOutputPixelValue.pGreenValue0,
				pOutputPixelValue.pBlueValue0);
			pDifferentPixelOutputArray.push_back(differentPixel);

		}




	}

	pOutputArrayRedAverage = pOutputArrayIntensitySumRed / pPixelArrayOutputBuffer.size();
	pOutputArrayGreenAverage = pOutputArrayIntensitySumGreen / pPixelArrayOutputBuffer.size();
	pOutputArrayBlueAverage = pOutputArrayIntensitySumBlue / pPixelArrayOutputBuffer.size();


	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{


		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;

		}





		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pIdenticalArrayIntensitySumRed = pIdenticalArrayIntensitySumRed + pPixelObject.RMask;
		pIdenticalArrayIntensitySumGreen = pIdenticalArrayIntensitySumGreen + pPixelObject.GMask;
		pIdenticalArrayIntensitySumBlue = pIdenticalArrayIntensitySumBlue + pPixelObject.BMask;




	}


	pIdenticalArrayRedAverage = pIdenticalArrayIntensitySumRed / pIdenticalPixelOutputArray.size();
	pIdenticalArrayGreenAverage = pIdenticalArrayIntensitySumGreen / pIdenticalPixelOutputArray.size();
	pIdenticalArrayBlueAverage = pIdenticalArrayIntensitySumBlue / pIdenticalPixelOutputArray.size();



	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{



		if ((pPixelObject.RMask != 255.0f) && (pPixelObject.GMask != 255.0f) && (pPixelObject.BMask != 255.0f))
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red CompTwont: " << pPixelObject.RMask << endl;
			cout << "Green CompTwont: " << pPixelObject.GMask << endl;
			cout << "Blue CompTwont: " << pPixelObject.BMask << endl;

		}

		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Red CompTwont: " << pPixelObject.RMask << endl;
		cout << "Green CompTwont: " << pPixelObject.GMask << endl;
		cout << "Blue CompTwont: " << pPixelObject.BMask << endl;



		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Red CompTwont: " << pPixelObject.RMask << endl;
		imageMaskLog << "Green CompTwont: " << pPixelObject.GMask << endl;
		imageMaskLog << "Blue CompTwont: " << pPixelObject.BMask << endl;

		pDifferentArrayIntensitySumRed = pDifferentArrayIntensitySumRed + pPixelObject.RMask;
		pDifferentArrayIntensitySumGreen = pDifferentArrayIntensitySumGreen + pPixelObject.GMask;
		pDifferentArrayIntensitySumBlue = pDifferentArrayIntensitySumBlue + pPixelObject.BMask;




	}



	pDifferentArrayRedAverage = pDifferentArrayIntensitySumRed / pDifferentPixelOutputArray.size();
	pDifferentArrayGreenAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();
	pDifferentArrayBlueAverage = pDifferentArrayIntensitySumGreen / pDifferentPixelOutputArray.size();




	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;
	float pColorSum = 0.0f;

	for (OutputPixelBufferRGB pOutputPixelValue : pPixelArrayOutputBuffer)
	{

		if ((pOutputPixelValue.pOutputComparisonValueRed == 0.0f) && (pOutputPixelValue.pOutputComparisonValueGreen == 0.0f) && (pOutputPixelValue.pOutputComparisonValueBlue == 0.0f))
		{

			cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			cout << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			cout << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;




			imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
			imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
			imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
			imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
			imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
			imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
			imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
			imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
			imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
			imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
			imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
			imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
			imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;
			imageMaskLog << "Amount of Identical Pixels =" << pOutputPixelValue.pAmountOfIdenticalPixels << endl;
			imageMaskLog << "Amount of Different Pixels =" << pOutputPixelValue.pAmountOfDifferentPixels << endl;
		}
	}
	cout << "Printing Identical Pixel Array Buffer" << endl;
	imageMaskLog << "Printing Identical Pixel Array Bufffer" << endl;

	for (PixelObject pPixelObject : pIdenticalPixelOutputArray)
	{
		float pColorSum = pPixelObject.RMask + pPixelObject.GMask + pPixelObject.BMask;
		if (pColorSum != 765)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green  Component: " << pPixelObject.GMask << endl;
			cout << "Blue  Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;
		}
	}


	for (PixelObject pPixelObject : pDifferentPixelOutputArray)
	{
		float pColorSum = pPixelObject.RMask + pPixelObject.GMask + pPixelObject.BMask;
		if (pColorSum != 765)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.yPosition << endl;
			cout << "Red Component: " << pPixelObject.RMask << endl;
			cout << "Green  Component: " << pPixelObject.GMask << endl;
			cout << "Blue  Component: " << pPixelObject.BMask << endl;



			imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
			imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
			imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
			imageMaskLog << "Red  Component: " << pPixelObject.RMask << endl;
			imageMaskLog << "Green  Component: " << pPixelObject.GMask << endl;
			imageMaskLog << "Blue  Component: " << pPixelObject.BMask << endl;
		}
	}

	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountOfidenticalPixels = pDifferentPixelAmount;
	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppIdenticalPixelBuffer = pIdenticalPixelOutputArray;
	*ppDifferentPixelBuffer = pDifferentPixelOutputArray;
	*ppImageOneIntensitySumRed = pImageOneIntensitySumRed;
	*ppImageOneIntensitySumGreen = pImageOneIntensitySumGreen;
	*ppImageOneIntensitySumBlue = pImageOneIntensitySumBlue;
	*ppImageOutputIntensitySumRed = pOutputArrayIntensitySumRed;
	*ppImageOutputIntensitySumGreen = pOutputArrayIntensitySumGreen;
	*ppImageOneIntensityAverageRed = pImageOneRedAverage;
	*ppImageOneIntensityAverageGreen = pImageOneGreenAverage;
	*ppImageOneIntensityAverageBlue = pImageOneBlueAverage;
	*ppImageOutputIntensityAverageRed = pOutputArrayRedAverage;
	*ppImageOutputIntensityAverageGreen = pOutputArrayGreenAverage;
	*ppImageIdenticalIntensityAverageRed = pIdenticalArrayRedAverage;
	*ppImageIdenticalIntensityAverageGreen = pIdenticalArrayGreenAverage;
	*ppImageDifferentIntensityAverageRed = pDifferentArrayRedAverage;
	*ppImageDifferentIntensityAverageGreen = pDifferentArrayGreenAverage;
	*ppImageDifferenttIntensityAverageBlue = pDifferentArrayBlueAverage;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResourcesRGBAgainstAColorMultiplication(HINSTANCE hInstance, HWND hWnd,
	float pImageWidth, float pImageHeight,
	float pSampleRed, float pSampleGreen, float pSampleBlue,
	vector<PixelObject> pixelArrayOne, ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBufferOne,
	ID3D11Buffer** ppOutputBuffer, ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObjectOutput, ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	CBColorSubtraction pColorCB;
	pColorCB.pRedValue = pSampleRed;
	pColorCB.pGreenValue = pSampleGreen;
	pColorCB.pBlueValue = pSampleBlue;

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSMultiplyImagePixelIntensityByANumber.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBColorSubtraction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pColorCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pData1, &pConstantBuffer);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBufferRGB);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBufferOne = pInputBuffer1;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunImageIdentityVerificationOperationRGBAgainstAColor(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11UnorderedAccessView* pUAVObjectOutput,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);

	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1};
	ID3D11UnorderedAccessView* ppUAV[] = { pUAVObjectOutput };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr};
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	ID3D11Buffer* ppCB = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &ppCB);
	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SplitResultsOfImageComparisonIntoBundles(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<OutputPixelBufferRGB> pixelArrayOne,
	vector<PixelBundle> *ppOutputBundleVector)
	
{
	HRESULT hr = S_OK;
	
	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	
	BOOL pImagesIdentical = FALSE;
	vector<PixelBundle> pPixelArrayOutputBuffer = vector<PixelBundle>();
	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBufferRGB pOutputPixelValue : pixelArrayOne)
	{
		cout << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		cout << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		cout << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		cout << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		cout << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		cout << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		cout << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		cout << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		cout << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		cout << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		cout << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Red Component: " << " = " << pOutputPixelValue.pRedValue0 << endl;
		imageMaskLog << "Image Two Red Component: " << " = " << pOutputPixelValue.pRedValue1 << endl;
		imageMaskLog << "Image One Green Component: " << " = " << pOutputPixelValue.pGreenValue0 << endl;
		imageMaskLog << "Image Two Green Component: " << " = " << pOutputPixelValue.pGreenValue1 << endl;
		imageMaskLog << "Image One Blue Component: " << " = " << pOutputPixelValue.pBlueValue0 << endl;
		imageMaskLog << "Image Two Blue Component: " << " = " << pOutputPixelValue.pBlueValue1 << endl;
		imageMaskLog << "Red Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueRed << endl;
		imageMaskLog << "Green Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueGreen << endl;
		imageMaskLog << "Blue Difference: " << " = " << pOutputPixelValue.pOutputComparisonValueBlue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputPixelValue.arePixelsIdenticalVal << endl;

		pIndex++;
	}



	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedViewOutput = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	hr = InitializeBundleSplittingOperationRGB(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pixelArrayOne,
		&ppComputeShaderForImageComparison,
		&pInputDataBufferImageOne,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pOutputUnorderedViewOutput,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedViewOutput };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunBundleSplittingOperationRGB(hInstance, hWnd, ppComputeShaderForImageComparison,
		pInputDataSRVImageOne,
		pOutputUnorderedViewOutput,
		1, 1,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	PixelBundle* pOutputDataImages = (PixelBundle*)pMammedResource.pData;




	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		PixelBundle pPixelBundleObject = pOutputDataImages[pIndex];
		int pBundleId = pPixelBundleObject.pBundleId;
	
		cout << "Bundle id:" << pBundleId << endl;
		cout << "Pixel One Details: " << endl;
		cout << "X Position 0: " << pPixelBundleObject.xPosition << endl;
		cout << "Y Position 0: " << pPixelBundleObject.yPosition << endl;
		cout << "Red Component0: " << pPixelBundleObject.pRedValue0 << endl;
		cout << "Green Component0: " << pPixelBundleObject.pGreenValue0 << endl;
		cout << "Blue Component0" << pPixelBundleObject.pBlueValue0 << endl;
		cout << "Red Component1: " << pPixelBundleObject.pRedValue1 << endl;
		cout << "Green Component1: " << pPixelBundleObject.pGreenValue1 << endl;
		cout << "Blue Component1" << pPixelBundleObject.pBlueValue1 << endl;
		cout << "Red Component2: " << pPixelBundleObject.pRedValue2 << endl;
		cout << "Green Component2: " << pPixelBundleObject.pGreenValue2 << endl;
		cout << "Blue Component2" << pPixelBundleObject.pBlueValue2 << endl;
		cout << "Is Pixel Valid" << pPixelBundleObject.pIsBundleValid << endl;


		imageMaskLog << "Bundle id:" << pBundleId << endl;
		imageMaskLog << "Pixel One Details: " << endl;
		imageMaskLog << "X Position 0: " << pPixelBundleObject.xPosition << endl;
		imageMaskLog << "Y Position 0: " << pPixelBundleObject.yPosition << endl;
		imageMaskLog << "Red Component0: " << pPixelBundleObject.pRedValue0 << endl;
		imageMaskLog << "Green Component0: " << pPixelBundleObject.pGreenValue0 << endl;
		imageMaskLog << "Blue Component0" << pPixelBundleObject.pBlueValue0 << endl;
		imageMaskLog << "Red Component1: " << pPixelBundleObject.pRedValue1 << endl;
		imageMaskLog << "Green Component1: " << pPixelBundleObject.pGreenValue1 << endl;
		imageMaskLog << "Blue Component1" << pPixelBundleObject.pBlueValue1 << endl;
		imageMaskLog << "Red Component2: " << pPixelBundleObject.pRedValue2 << endl;
		imageMaskLog << "Green Component2: " << pPixelBundleObject.pGreenValue2 << endl;
		imageMaskLog << "Blue Component2" << pPixelBundleObject.pBlueValue2 << endl;
		imageMaskLog << "Is Pixel Valid" << pPixelBundleObject.pIsBundleValid << endl;


		pPixelArrayOutputBuffer.push_back(pPixelBundleObject);

	}


	for (PixelBundle pPixelBundleObject : pPixelArrayOutputBuffer)
	{




		cout << "Bundle id:" << pPixelBundleObject.pBundleId << endl;
		cout << "Pixel One Details: " << endl;
		cout << "X Position 0: " << pPixelBundleObject.xPosition << endl;
		cout << "Y Position 0: " << pPixelBundleObject.yPosition << endl;
		cout << "Red Component0: " << pPixelBundleObject.pRedValue0 << endl;
		cout << "Green Component0: " << pPixelBundleObject.pGreenValue0 << endl;
		cout << "Blue Component0" << pPixelBundleObject.pBlueValue0 << endl;
		cout << "Red Component1: " << pPixelBundleObject.pRedValue1 << endl;
		cout << "Green Component1: " << pPixelBundleObject.pGreenValue1 << endl;
		cout << "Blue Component1" << pPixelBundleObject.pBlueValue1 << endl;
		cout << "Red Component2: " << pPixelBundleObject.pRedValue2 << endl;
		cout << "Green Component2: " << pPixelBundleObject.pGreenValue2 << endl;
		cout << "Blue Component2" << pPixelBundleObject.pBlueValue2 << endl;
		cout << "Is Pixel Valid" << pPixelBundleObject.pIsBundleValid << endl;


		imageMaskLog << "Pixel One Details: " << endl;
		imageMaskLog << "X Position 0: " << pPixelBundleObject.xPosition << endl;
		imageMaskLog << "Y Position 0: " << pPixelBundleObject.yPosition << endl;
		imageMaskLog << "Red Component0: " << pPixelBundleObject.pRedValue0 << endl;
		imageMaskLog << "Green Component0: " << pPixelBundleObject.pGreenValue0 << endl;
		imageMaskLog << "Blue Component0" << pPixelBundleObject.pBlueValue0 << endl;
		imageMaskLog << "Red Component1: " << pPixelBundleObject.pRedValue1 << endl;
		imageMaskLog << "Green Component1: " << pPixelBundleObject.pGreenValue1 << endl;
		imageMaskLog << "Blue Component1" << pPixelBundleObject.pBlueValue1 << endl;
		imageMaskLog << "Red Component2: " << pPixelBundleObject.pRedValue2 << endl;
		imageMaskLog << "Green Component2: " << pPixelBundleObject.pGreenValue2 << endl;
		imageMaskLog << "Blue Component2" << pPixelBundleObject.pBlueValue2 << endl;
		imageMaskLog << "Is Pixel Valid" << pPixelBundleObject.pIsBundleValid << endl;



	}


	*ppOutputBundleVector = pPixelArrayOutputBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeBundleSplittingOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	vector<OutputPixelBufferRGB> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBufferImageOne,
	ID3D11Buffer** ppOutputBufferIdentical,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObjectOutput,
	ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\SplitPixelOutputVectorIntoPixelArrays.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBufferRGB);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(OutputPixelBufferRGB);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	

	cout << "Creating the Output Buffer Object For" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelBundle);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelBundle);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelBundle);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(PixelBundle);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferImageOne = pInputBuffer1;
	*ppOutputBufferIdentical = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunBundleSplittingOperationRGB(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11UnorderedAccessView* pUAVObjectOutput,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUAVObjectOutput };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResourcesDecomposed(HINSTANCE hInstance,
	HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBufferImageOne,
	ID3D11Buffer** ppInputBufferImageTwo,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObjectOutput,
	ID3D11Buffer** ppReadbackBufferOutput)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;	



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CheckIfTwoImagesAreIdenticalProceduredOptimized.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayTwo.size() * sizeof(OutputPixelBuffer);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBuffer);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBuffer);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBuffer);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	



	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferImageOne = pInputBuffer1;
	*ppInputBufferImageTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdenticalDecomposed(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBuffer> *ppOutputPixelData,
	vector<PixelObjectGrayScale> *ppOutputPixelDataBuffer,
	vector<PixelObjectGrayScale> *ppIdenticalPixelBuffer,
	vector<PixelObjectGrayScale> *ppDifferentPixelBuffer,
	float *ppImageOneIntensitySum,
	float *ppImageOneAverage,
	float *ppImageTwoIntensitySum,
	float *ppImageTwoAverage,
	float *ppOutputArrayIntensitySum,
	float *ppOutputArrayAverage,
	float *ppIdenticalPixelsIntensitySum,
	float *ppIdenticalPixelsAverage,
	float *ppDifferentPixelsIntensitySum,
	float *ppDifferentPixelsAverage,
	BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBuffer> pPixelArrayOutputBuffer = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pOutputPixelDataBufferArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentPixelOutputArray = vector<PixelObjectGrayScale>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArraySize = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelArrayIntensitySum = 0.0f;
	float pIdenticalPixelArraySize = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArrayIntensitySum = 0.0f;
	float pDifferentPixelArraySize = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;


	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;


	for (PixelObjectGrayScale pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pImageOneIntensitySum = pImageOneIntensitySum + pPixelObject.pGreyLevel;

	}
	pImageOneAverage = pImageOneIntensitySum / pixelArrayOne.size();

	cout << "Image One Intensity Sum = " << pImageOneIntensitySum << endl;
	cout << "Image One Array Size = " << pixelArrayOne.size();
	cout << "Image One Average Intensity = " << pImageOneAverage << endl;

	imageMaskLog << "Image One Intensity Sum = " << pImageOneIntensitySum << endl;
	imageMaskLog << "Image One Array Size = " << pixelArrayOne.size();
	imageMaskLog << "Image One Average Intensity = " << pImageOneAverage << endl;

	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;


	for (PixelObjectGrayScale pPixelObject : pixelArrayTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pImageTwoIntensitySum = pImageTwoIntensitySum + pPixelObject.pGreyLevel;
	}

	pImageTwoAverage = pImageTwoIntensitySum / pixelArrayTwo.size();
	cout << "Image Two Intensity Sum = " << pImageTwoIntensitySum << endl;
	cout << "Image Two Array Size = " << pixelArrayTwo.size();
	cout << "Image Two Average Intensity = " << pImageTwoAverage << endl;

	imageMaskLog << "Image Two Intensity Sum = " << pImageTwoIntensitySum << endl;
	imageMaskLog << "Image Two Array Size = " << pixelArrayTwo.size();
	imageMaskLog << "Image Two Average Intensity = " << pImageTwoAverage << endl;


	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pInputDataBufferImageTwo = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pOutputBufferForIdenticalPixels = nullptr;
	ID3D11Buffer* pOutputBufferForDiffrentPixels = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageTwo = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11UnorderedAccessView* pIdenticalPixelsUnorderedView = nullptr;
	ID3D11UnorderedAccessView* pDiffrentPixelsOutputView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;
	ID3D11Buffer* pReadbackBufferForIdenticalPixels = nullptr;
	ID3D11Buffer* pReadbackBufferForDiffrentPixels = nullptr;

	ID3D11Buffer* ppReadbackBuffer = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	hr = InitializeIdentityVerificationResourcesDecomposed(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pixelArrayOne,
		pixelArrayTwo,
		&ppComputeShaderForImageComparison,
		&pInputDataBufferImageOne,
		&pInputDataBufferImageTwo,
		&pOutputDataBuffer,
		&pInputDataSRVImageOne,
		&pInputDataSRVImageTwo,
		&pOutputUnorderedView,
		&pReadbackBufferOutput);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne, pInputDataSRVImageTwo };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView, pIdenticalPixelsUnorderedView, pDiffrentPixelsOutputView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperation(hInstance, hWnd, ppComputeShaderForImageComparison,
		pInputDataSRVImageOne,
		pInputDataSRVImageTwo,
		pOutputUnorderedView,
		pIdenticalPixelsUnorderedView,
		pDiffrentPixelsOutputView,
		2, 3,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBuffer* pOutputDataImages = (OutputPixelBuffer*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBuffer pOutputValue = pOutputDataImages[pIndex];
		pOutputValue.pixelNumber = pIndex;

		if (pOutputValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputValue.pAmountOfDifferentPixels = pDifferentPixelAmount;

		cout << "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << pOutputValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << pOutputValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << pOutputValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical =" << pOutputValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << pOutputValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << pOutputValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << pOutputValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;

		pPixelArrayOutputBuffer.push_back(pOutputValue);
	}

	cout << "Retrieving the Data For Identical Pixels Buffer" << endl;
	imageMaskLog << "Retrieving the Data For Identical Pixels Buffer" << endl;
	
	hr = RestoreOutputPixelsFromImageComparisonGrayScale(hInstance,
		hWnd,
		pPixelArrayOutputBuffer,
		&pOutputPixelDataBufferArray);


	cout << "Retrieving the Data For Identical Pixels Buffer" << endl;
	imageMaskLog << "Retrieving the Data For Identical Pixels Buffer" << endl;

	hr = RestoreIdenticalPixelsFromImageComparisonGrayScale(hInstance,
		hWnd,
		pPixelArrayOutputBuffer,
		&pIdenticalPixelOutputArray);

	cout << "Retrieving the Data For Different Pixels Buffer" << endl;
	imageMaskLog << "Retrieving the Data For Different Pixels Buffer" << endl;

	hr = RestoreDifferentPixelsFromImageComparison(hInstance,
		hWnd,
		pPixelArrayOutputBuffer,
		&pDifferentPixelOutputArray);



	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : pPixelArrayOutputBuffer)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of identical pixel = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixel = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;
	}

	pOutputArraySize = pPixelArrayOutputBuffer.size();

	if (pOutputArraySize > 0)
	{
		pOutputArrayAverage = pOutputArrayIntensitySum / pPixelArrayOutputBuffer.size();
	}
	else
	{
		pOutputArrayAverage = 0;
	}
	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << pOutputArraySize << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;

	imageMaskLog << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageMaskLog << "Output Array Size = " << pOutputArraySize << endl;
	imageMaskLog << "Output Array Average = " << pOutputArrayAverage << endl;


	pIdenticalPixelArraySize = pIdenticalPixelOutputArray.size();
	cout << "Printing Out the Identical Pixels" << endl;
	imageMaskLog << "Printing Out the Identical Pixels" << endl;
	for (PixelObjectGrayScale pPixelObject : pIdenticalPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIdenticalPixelArrayIntensitySum = pIdenticalPixelArrayIntensitySum + pPixelObject.pGreyLevel;
	}
	if (pIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelArrayIntensitySum / pIdenticalPixelOutputArray.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}
	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArrayIntensitySum << endl;
	cout << "Identical Pixel Array Size = " << pIdenticalPixelArraySize << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	imageMaskLog << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArrayIntensitySum << endl;
	imageMaskLog << "Identical Pixel Array Size = " << pIdenticalPixelArraySize << endl;
	imageMaskLog << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	cout << "Printing Out the Different Pixels" << endl;
	imageMaskLog << "Printing Out the Different Pixels" << endl;
	pDifferentPixelArraySize = pDifferentPixelOutputArray.size();
	for (PixelObjectGrayScale pPixelObject : pDifferentPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIntensityDifferenceSum = pIntensityDifferenceSum + pPixelObject.pGreyLevel;
	}
	if (pDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pIntensityDifferenceSum / pDifferentPixelOutputArray.size();
	}
	else
	{
		pDifferentPixelArrayAverage = 0;
	}
	cout << "Different Pixel Array Intensity Sum = " << pIntensityDifferenceSum << endl;
	cout << "Different Pixel Array Size = " << pDifferentPixelArraySize << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	imageMaskLog << "Different Pixel Array Intensity Sum = " << pIntensityDifferenceSum << endl;
	imageMaskLog << "Different Pixel Array Size = " << pDifferentPixelArraySize << endl;
	imageMaskLog << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;

	pIdenticalPixelAmount = pIdenticalPixelOutputArray.size();
	pDifferentPixelAmount = pDifferentPixelOutputArray.size();


	cout << "Comparing the Sum of Differences against 0" << endl;
	BOOL pComparisonResult = FALSE;
	if (pIntensityDifferenceSum == 0)
	{
		pComparisonResult = TRUE;
	}

	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppOutputPixelDataBuffer = pOutputPixelDataBufferArray;
	*ppIdenticalPixelBuffer = pIdenticalPixelOutputArray;
	*ppDifferentPixelBuffer = pDifferentPixelOutputArray;
	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountODifferentPixels = pDifferentPixelAmount;
	*pAreIdenticalOutput = pComparisonResult;
	*ppImageOneIntensitySum = pImageOneIntensitySum;
	*ppImageOneAverage = pImageOneAverage;
	*ppImageTwoIntensitySum = pImageTwoIntensitySum;
	*ppImageTwoAverage = pImageTwoAverage;
	*ppOutputArrayIntensitySum = pOutputArrayIntensitySum;
	*ppOutputArrayAverage = pOutputArrayAverage;
	*ppIdenticalPixelsIntensitySum = pIdenticalPixelArrayIntensitySum;
	*ppIdenticalPixelsAverage = pIdenticalPixelArrayAverage;
	*ppDifferentPixelsIntensitySum = pIntensityDifferenceSum;
	*ppDifferentPixelsAverage = pDifferentPixelArrayAverage;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::CheckIfImagesAreIdentical(HINSTANCE hInstance,
	HWND hWnd,
	UINT pImageWidth,
	UINT pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	int *pAmountOfidenticalPixels,
	int *pAmountODifferentPixels,
	vector<OutputPixelBuffer> *ppOutputPixelData,
	vector<PixelObjectGrayScale> *ppIdenticalPixelBuffer,
	vector<PixelObjectGrayScale> *ppDifferentPixelBuffer,
	float *ppImageOneIntensitySum,
	float *ppImageOneAverage,
	float *ppImageTwoIntensitySum,
	float *ppImageTwoAverage,
	float *ppOutputArrayIntensitySum,
	float *ppOutputArrayAverage,
	float *ppIdenticalPixelsIntensitySum,
	float *ppIdenticalPixelsAverage,
	float *ppDifferentPixelsIntensitySum,
	float *ppDifferentPixelsAverage,
	BOOL *pAreIdenticalOutput)
{
	HRESULT hr = S_OK;
	BOOL pImagesIdentical = FALSE;
	vector<OutputPixelBuffer> pPixelArrayOutputBuffer = vector<OutputPixelBuffer>();
	vector<PixelObjectGrayScale> pIdenticalPixelOutputArray = vector<PixelObjectGrayScale>();
	vector<PixelObjectGrayScale> pDifferentPixelOutputArray = vector<PixelObjectGrayScale>();
	float pIntensityDifference = 0.0;
	float pIntensityDifferenceSum = 0.0;
	float pIdenticalPixelAmount = 0.0f;
	float pDifferentPixelAmount = 0.0f;

	float pImageOneIntensitySum = 0.0f;
	float pImageOneArraySize = 0.0f;
	float pImageOneAverage = 0.0f;
	float pImageTwoIntensitySum = 0.0f;
	float pImageTwoArraySize = 0.0f;
	float pImageTwoAverage = 0.0f;
	float pOutputArrayIntensitySum = 0.0f;
	float pOutputArraySize = 0.0f;
	float pOutputArrayAverage = 0.0f;
	float pIdenticalPixelArrayIntensitySum = 0.0f;
	float pIdenticalPixelArraySize = 0.0f;
	float pIdenticalPixelArrayAverage = 0.0f;
	float pDifferentPixelArrayIntensitySum = 0.0f;
	float pDifferentPixelArraySize = 0.0f;
	float pDifferentPixelArrayAverage = 0.0f;


	fstream imageMaskLog("С:\\pixels\\ImageIdentityOperationPreOutput.txt");
	imageMaskLog.clear();

	cout << "Printing the Initial Image Pixel Contents" << endl;
	imageMaskLog << "Printing the Initial Image Pixel Contents" << endl;

	cout << "Printing the Contents of the Image One" << endl;
	imageMaskLog << "Printing the Contents of the Image One" << endl;
	

	for (PixelObjectGrayScale pPixelObject : pixelArrayOne)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pImageOneIntensitySum = pImageOneIntensitySum + pPixelObject.pGreyLevel;

	}
	pImageOneAverage = pImageOneIntensitySum / pixelArrayOne.size();

	cout << "Image One Intensity Sum = " << pImageOneIntensitySum << endl;
	cout << "Image One Array Size = " << pixelArrayOne.size();
	cout << "Image One Average Intensity = " << pImageOneAverage << endl;

	imageMaskLog << "Image One Intensity Sum = " << pImageOneIntensitySum << endl;
	imageMaskLog << "Image One Array Size = " << pixelArrayOne.size();
	imageMaskLog << "Image One Average Intensity = " << pImageOneAverage << endl;

	cout << "Printing the Contents of the Image Two" << endl;
	imageMaskLog << "Printing the Contents of the Image Two" << endl;
	

	for (PixelObjectGrayScale pPixelObject : pixelArrayTwo)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pImageTwoIntensitySum = pImageTwoIntensitySum + pPixelObject.pGreyLevel;
	}

	pImageTwoAverage = pImageTwoIntensitySum / pixelArrayTwo.size();
	cout << "Image Two Intensity Sum = " << pImageTwoIntensitySum << endl;
	cout << "Image Two Array Size = " << pixelArrayTwo.size();
	cout << "Image Two Average Intensity = " << pImageTwoAverage << endl;

	imageMaskLog << "Image Two Intensity Sum = " << pImageTwoIntensitySum << endl;
	imageMaskLog << "Image Two Array Size = " << pixelArrayTwo.size();
	imageMaskLog << "Image Two Average Intensity = " << pImageTwoAverage << endl;


	ID3D11ComputeShader* ppComputeShaderForImageComparison = nullptr;
	ID3D11Buffer* pInputDataBufferImageOne = nullptr;
	ID3D11Buffer* pInputDataBufferImageTwo = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11Buffer* pOutputBufferForIdenticalPixels = nullptr;
	ID3D11Buffer* pOutputBufferForDiffrentPixels = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageOne = nullptr;
	ID3D11ShaderResourceView* pInputDataSRVImageTwo = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedView = nullptr;
	ID3D11UnorderedAccessView* pIdenticalPixelsUnorderedView = nullptr;
	ID3D11UnorderedAccessView* pDiffrentPixelsOutputView = nullptr;
	ID3D11Buffer* pReadbackBufferOutput = nullptr;
	ID3D11Buffer* pReadbackBufferForIdenticalPixels = nullptr;
	ID3D11Buffer* pReadbackBufferForDiffrentPixels = nullptr;

	ID3D11Buffer* ppReadbackBuffer = nullptr;

	cout << "Initializing the Resources for Image Identity Simulations" << endl;
	imageMaskLog << "Initializing the Resources for Image Identity Simulations" << endl;

	UINT pImageArraySize = pImageWidth * pImageHeight;

	hr = InitializeIdentityVerificationResources(hInstance,
		hWnd,
		pImageWidth,
		pImageHeight,
		pixelArrayOne,
		pixelArrayTwo,
		&ppComputeShaderForImageComparison,
		&pInputDataBufferImageOne,
		&pInputDataBufferImageTwo,
		&pOutputDataBuffer,
		&pOutputBufferForIdenticalPixels,
		&pOutputBufferForDiffrentPixels,
		&pInputDataSRVImageOne,
		&pInputDataSRVImageTwo,
		&pOutputUnorderedView,
		&pIdenticalPixelsUnorderedView,
		&pDiffrentPixelsOutputView,
		&pReadbackBufferOutput,
		&pReadbackBufferForIdenticalPixels,
		&pReadbackBufferForDiffrentPixels);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		imageMaskLog << "Unable to Initialize the Resources for the Image Identity Simulation: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResources[] = { pInputDataSRVImageOne, pInputDataSRVImageTwo };
	ID3D11UnorderedAccessView* ppuUAViews[] = { pOutputUnorderedView, pIdenticalPixelsUnorderedView, pDiffrentPixelsOutputView };


	cout << "Starting our Computer Simulation" << endl;
	imageMaskLog << "Starting our Computer Simulation" << endl;


	hr = RunImageIdentityVerificationOperation(hInstance, hWnd, ppComputeShaderForImageComparison,
		pInputDataSRVImageOne,
		pInputDataSRVImageTwo,
		pOutputUnorderedView,
		pIdenticalPixelsUnorderedView,
		pDiffrentPixelsOutputView,
		2, 3,
		256, 1, 1);

	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data from Output Byffer" << endl;
	imageMaskLog << "Retrieving Results Data from Output Byffer" << endl;

	m_pD3DCompContext->CopyResource(pReadbackBufferOutput, pOutputDataBuffer);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferOutput, 0, D3D11_MAP_READ, 0, &pMammedResource);
	OutputPixelBuffer* pOutputDataImages = (OutputPixelBuffer*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pixelArrayOne.size(); ++pIndex)
	{
		OutputPixelBuffer pOutputValue = pOutputDataImages[pIndex];
		pOutputValue.pixelNumber = pIndex;

		if (pOutputValue.arePixelsIdenticalVal == 255)
		{
			pIdenticalPixelAmount++;
		}
		if (pOutputValue.arePixelsIdenticalVal == 0)
		{
			pDifferentPixelAmount++;
		}
		pOutputValue.pAmountOfIdenticalPixels = pIdenticalPixelAmount;
		pOutputValue.pAmountOfDifferentPixels = pDifferentPixelAmount;

		cout << "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << pOutputValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << pOutputValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << pOutputValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical =" << pOutputValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;

		imageMaskLog << "Pixel Number: " << " = " << pOutputValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << pOutputValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << pOutputValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << pOutputValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << pOutputValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical =" << pOutputValue.arePixelsIdenticalVal << endl;
		cout << "Amount Of Identical Pixels =" << pOutputValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixels = " << pOutputValue.pAmountOfDifferentPixels << endl;

		pPixelArrayOutputBuffer.push_back(pOutputValue);
	}

	cout << "Retrieving the Data For Identical Pixels Buffer" << endl;
	imageMaskLog << "Retrieving the Data For Identical Pixels Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferForIdenticalPixels, pOutputBufferForIdenticalPixels);
	D3D11_MAPPED_SUBRESOURCE pMappedSubresourceIdentical;
	m_pD3DCompContext->Map(pReadbackBufferForIdenticalPixels, 0, D3D11_MAP_READ, 0, &pMappedSubresourceIdentical);
	PixelObjectGrayScale* pIdenticalPixelOutput = (PixelObjectGrayScale*)pMappedSubresourceIdentical.pData;


	for (UINT pIndex = 0; pIndex < pIdenticalPixelAmount; ++pIndex)
	{

			PixelObjectGrayScale pOutputIdenticalValue = pIdenticalPixelOutput[pIndex];
			pOutputIdenticalValue.pixelNumber = pIndex;
		
			
				cout << "Pixel Number: " << " = " << pOutputIdenticalValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputIdenticalValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputIdenticalValue.yPosition << endl;
				cout << "Image One Pixel Value: = " << pOutputIdenticalValue.pGreyLevel << endl;

				imageMaskLog << "Pixel Number: " << " = " << pOutputIdenticalValue.pixelNumber << endl;
				imageMaskLog << "X Position: " << " = " << pOutputIdenticalValue.xPosition << endl;
				imageMaskLog << "Y Position: " << " = " << pOutputIdenticalValue.yPosition << endl;
				imageMaskLog << "Image One Pixel Value: = " << pOutputIdenticalValue.pGreyLevel << endl;
				pIdenticalPixelOutputArray.push_back(pOutputIdenticalValue);
			
			
		
	}

	cout << "Retrieving Data For Different Pixels Buffer" << endl;
	imageMaskLog << "Retrieving Data For Different Pixels Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferForDiffrentPixels, pOutputBufferForDiffrentPixels);
	D3D11_MAPPED_SUBRESOURCE pMappedSubresourceDifferent;
	m_pD3DCompContext->Map(pReadbackBufferForDiffrentPixels, 0, D3D11_MAP_READ, 0, &pMappedSubresourceDifferent);
	PixelObjectGrayScale* pDifferentPixelArrayData = (PixelObjectGrayScale*)pMappedSubresourceDifferent.pData;


	for (UINT pIndex = 0; pIndex < pDifferentPixelAmount; ++pIndex)
	{
		
			PixelObjectGrayScale pOutputDifferentValue = pDifferentPixelArrayData[pIndex];
			pOutputDifferentValue.pixelNumber = pIndex;
		
				cout << "Pixel Number: " << " = " << pOutputDifferentValue.pixelNumber << endl;
				cout << "X Position: " << " = " << pOutputDifferentValue.xPosition << endl;
				cout << "Y Position: " << " = " << pOutputDifferentValue.yPosition << endl;
				cout << "Image One Pixel Value: = " << pOutputDifferentValue.pGreyLevel << endl;

				imageMaskLog << "Pixel Number: " << " = " << pOutputDifferentValue.pixelNumber << endl;
				imageMaskLog << "X Position: " << " = " << pOutputDifferentValue.xPosition << endl;
				imageMaskLog << "Y Position: " << " = " << pOutputDifferentValue.yPosition << endl;
				imageMaskLog << "Image One Pixel Value: = " << pOutputDifferentValue.pGreyLevel << endl;
				pDifferentPixelOutputArray.push_back(pOutputDifferentValue);
			
			
		
	
	}

	

	UINT pIndex = 0;
	cout << "Printing out the Output the Experiment" << endl;

	for (OutputPixelBuffer ppOutputPixelValue : pPixelArrayOutputBuffer)
	{
		cout << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		cout << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		cout << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		cout << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		cout << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		cout << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		cout << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		cout << "Amount of identical pixel = " << ppOutputPixelValue.pAmountOfIdenticalPixels << endl;
		cout << "Amount of Different Pixel = " << ppOutputPixelValue.pAmountOfDifferentPixels << endl;
	
		imageMaskLog << "Pixel Number: " << " = " << ppOutputPixelValue.pixelNumber << endl;
		imageMaskLog << "X Position: " << " = " << ppOutputPixelValue.xPosition << endl;
		imageMaskLog << "Y Position: " << " = " << ppOutputPixelValue.yPosition << endl;
		imageMaskLog << "Image One Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue0 << endl;
		imageMaskLog << "Image Two Pixel Value: " << " = " << ppOutputPixelValue.grayScaleValue1 << endl;
		imageMaskLog << "Final Output Intensity Value: " << " = " << ppOutputPixelValue.outputComparisonValue << endl;
		imageMaskLog << "Are Pixels Identical = " << ppOutputPixelValue.arePixelsIdenticalVal << endl;
		pOutputArrayIntensitySum = pOutputArrayIntensitySum + ppOutputPixelValue.outputComparisonValue;
		pIndex++;
	}

	pOutputArraySize = pPixelArrayOutputBuffer.size();

	if (pOutputArraySize > 0)
	{
		pOutputArrayAverage = pOutputArrayIntensitySum / pPixelArrayOutputBuffer.size();
	}
	else
	{
		pOutputArrayAverage = 0;
	}
	cout << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	cout << "Output Array Size = " << pOutputArraySize << endl;
	cout << "Output Array Average = " << pOutputArrayAverage << endl;

	imageMaskLog << "Output Array Intensity Sum = " << pOutputArrayIntensitySum << endl;
	imageMaskLog << "Output Array Size = " << pOutputArraySize << endl;
	imageMaskLog << "Output Array Average = " << pOutputArrayAverage << endl;


	pIdenticalPixelArraySize = pIdenticalPixelOutputArray.size();
	cout << "Printing Out the Identical Pixels" << endl;
	imageMaskLog << "Printing Out the Identical Pixels" << endl;
	for (PixelObjectGrayScale pPixelObject : pIdenticalPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIdenticalPixelArrayIntensitySum = pIdenticalPixelArrayIntensitySum + pPixelObject.pGreyLevel;
	}
	if (pIdenticalPixelOutputArray.size() > 0)
	{
		pIdenticalPixelArrayAverage = pIdenticalPixelArrayIntensitySum / pIdenticalPixelOutputArray.size();
	}
	else
	{
		pIdenticalPixelArrayAverage = 0;
	}
	cout << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArrayIntensitySum << endl;
	cout << "Identical Pixel Array Size = " << pIdenticalPixelArraySize << endl;
	cout << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	imageMaskLog << "Identical Pixel Array Intensity Sum = " << pIdenticalPixelArrayIntensitySum << endl;
	imageMaskLog << "Identical Pixel Array Size = " << pIdenticalPixelArraySize << endl;
	imageMaskLog << "Identical Pixel Array Average = " << pIdenticalPixelArrayAverage << endl;


	cout << "Printing Out the Different Pixels" << endl;
	imageMaskLog << "Printing Out the Different Pixels" << endl;
	pDifferentPixelArraySize = pDifferentPixelOutputArray.size();
	for (PixelObjectGrayScale pPixelObject : pDifferentPixelOutputArray)
	{
		cout << "Pixel Number: " << pPixelObject.pixelNumber;
		cout << "X Position: " << pPixelObject.xPosition << endl;
		cout << "Y Position: " << pPixelObject.yPosition << endl;
		cout << "Grey Level: " << pPixelObject.pGreyLevel << endl;


		imageMaskLog << "Pixel Number: " << pPixelObject.pixelNumber;
		imageMaskLog << "X Position: " << pPixelObject.xPosition << endl;
		imageMaskLog << "Y Position: " << pPixelObject.yPosition << endl;
		imageMaskLog << "Grey Level: " << pPixelObject.pGreyLevel << endl;
		pIntensityDifferenceSum = pIntensityDifferenceSum + pPixelObject.pGreyLevel;
	}
	if (pDifferentPixelOutputArray.size() > 0)
	{
		pDifferentPixelArrayAverage = pIntensityDifferenceSum / pDifferentPixelOutputArray.size();
	}
	else
	{
		pDifferentPixelArrayAverage = 0;
	}
	cout << "Different Pixel Array Intensity Sum = " << pIntensityDifferenceSum << endl;
	cout << "Different Pixel Array Size = " << pDifferentPixelArraySize << endl;
	cout << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;


	imageMaskLog << "Different Pixel Array Intensity Sum = " << pIntensityDifferenceSum << endl;
	imageMaskLog << "Different Pixel Array Size = " << pDifferentPixelArraySize << endl;
	imageMaskLog << "Different Pixel Array Average = " << pDifferentPixelArrayAverage << endl;

	pIdenticalPixelAmount = pIdenticalPixelOutputArray.size();
	pDifferentPixelAmount = pDifferentPixelOutputArray.size();


	cout << "Comparing the Sum of Differences against 0" << endl;
	BOOL pComparisonResult = FALSE;
	if (pIntensityDifferenceSum == 0)
	{
		pComparisonResult = TRUE;
	}

	*ppOutputPixelData = pPixelArrayOutputBuffer;
	*ppIdenticalPixelBuffer = pIdenticalPixelOutputArray;
	*ppDifferentPixelBuffer = pDifferentPixelOutputArray;
	*pAmountOfidenticalPixels = pIdenticalPixelAmount;
	*pAmountODifferentPixels = pDifferentPixelAmount;
	*pAreIdenticalOutput = pComparisonResult;
	*ppImageOneIntensitySum = pImageOneIntensitySum;
	*ppImageOneAverage = pImageOneAverage;
	*ppImageTwoIntensitySum = pImageTwoIntensitySum;
	*ppImageTwoAverage = pImageTwoAverage;
	*ppOutputArrayIntensitySum = pOutputArrayIntensitySum;
	*ppOutputArrayAverage = pOutputArrayAverage;
	*ppIdenticalPixelsIntensitySum = pIdenticalPixelArrayIntensitySum;
	*ppIdenticalPixelsAverage = pIdenticalPixelArrayAverage;
	*ppDifferentPixelsIntensitySum = pIntensityDifferenceSum;
	*ppDifferentPixelsAverage = pDifferentPixelArrayAverage;
	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeIdentityVerificationResources(HINSTANCE hInstance,
	HWND hWnd,
	float pImageWidth,
	float pImageHeight,
	vector<PixelObjectGrayScale> pixelArrayOne,
	vector<PixelObjectGrayScale> pixelArrayTwo,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBufferImageOne,
	ID3D11Buffer** ppInputBufferImageTwo,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11Buffer** ppOutputBufferIdenticalPixels,
	ID3D11Buffer** ppOutputBufferDifferentPixels,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObjectOutput,
	ID3D11UnorderedAccessView** ppUAVObjectIdentical,
	ID3D11UnorderedAccessView** ppUAVObjectDifferent,
	ID3D11Buffer** ppReadbackBufferOutput,
	ID3D11Buffer** ppReadbackBufferIdentical,
	ID3D11Buffer** ppReadbackBufferDifferent)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputPixelBuffer = nullptr;
	ID3D11Buffer* pOutputIdenticalPixelBuffer = nullptr;
	ID3D11Buffer* pOutputDifferentPixelBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pPixelOutputUAV = nullptr;
	ID3D11UnorderedAccessView* pIdenticalPixelsOutputUAV = nullptr;
	ID3D11UnorderedAccessView* pDifferentPixelsOutputUAV = nullptr;
	ID3D11Buffer* pReadbackOutputBuffer = nullptr;
	ID3D11Buffer* pReadbackIdenticalPixelBuffer = nullptr;
	ID3D11Buffer* pReadbackDifferentPixelBuffer = nullptr;



	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CheckIfTwoImagesAreIdenticalProcedured.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc2, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer Object" << endl;
	imageMaskLog << "Creating the Output Buffer Object" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayTwo.size() * sizeof(OutputPixelBuffer);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputPixelBuffer);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Output Buffer Object for Identical Pixels" << endl;
	imageMaskLog << "Creating the Output Buffer Object Identical Pixels" << endl;

	D3D11_BUFFER_DESC buffer_desc_output_identical;
	buffer_desc_output_identical.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output_identical.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_identical.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_identical.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_identical.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output_identical.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_identical, nullptr, &pOutputIdenticalPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer For Identical Pixels Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer For Identical Pixels Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Output Buffer Object for Different Pixels" << endl;
	imageMaskLog << "Creating the Output Buffer Object Different Pixels" << endl;

	D3D11_BUFFER_DESC buffer_desc_output_different;
	buffer_desc_output_different.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output_different.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output_different.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output_different.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output_different.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output_different.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output_different, nullptr, &pOutputDifferentPixelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer For Identical Pixels Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer For Identical Pixels Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc1));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output;
	ZeroMemory(&uavbuffer_desc_output, sizeof(uavbuffer_desc_output));
	uavbuffer_desc_output.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputPixelBuffer, &uavbuffer_desc_output, &pPixelOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Created" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Output Buffer Has Been Terminated with error : " << pLastError << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Identical Pixels Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output_identical;
	ZeroMemory(&uavbuffer_desc_output_identical , sizeof(uavbuffer_desc_output_identical));
	uavbuffer_desc_output_identical.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output_identical.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output_identical.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputIdenticalPixelBuffer, &uavbuffer_desc_output_identical, &pIdenticalPixelsOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода для Одинаовых Кадров", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Idenitical Pixels Output Buffer Has Been  Created : " << endl;
		imageMaskLog << "The Unordered Access View For Output Buffer Has Been Terminated with error: " << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Unordered Access View For Identical Buffer Has Been Terminated with error " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Different Pixels Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Different Pixels Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc_output_different;
	ZeroMemory(&uavbuffer_desc_output_different, sizeof(uavbuffer_desc_output_different));
	uavbuffer_desc_output_different.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc_output_different.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc_output_different.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputDifferentPixelBuffer, &uavbuffer_desc_output_different, &pDifferentPixelsOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода для Одинаовых Кадров", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Readback Buffer for Output" << endl;
	imageMaskLog << "Creating the Readback Buffer for Output" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_output;
	ZeroMemory(&readback_buffer_desc_output, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(OutputPixelBuffer);
	readback_buffer_desc_output.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_output.StructureByteStride = sizeof(OutputPixelBuffer);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_output, nullptr, &pReadbackOutputBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Readback Buffer for Identical Pixels" << endl;
	imageMaskLog << "Creating the Readback Buffer for Identical Pixels" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_identical;
	ZeroMemory(&readback_buffer_desc_identical, sizeof(readback_buffer_desc_output));
	readback_buffer_desc_identical.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc_identical.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_identical.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_identical.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_identical, nullptr, &pReadbackIdenticalPixelBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Readback Buffer for Different Pixels" << endl;
	imageMaskLog << "Creating the Readback Buffer for Different" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc_different;
	ZeroMemory(&readback_buffer_desc_different, sizeof(readback_buffer_desc_different));
	readback_buffer_desc_different.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc_different.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc_different.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc_different.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc_different, nullptr, &pReadbackDifferentPixelBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Чтения Данных Выходного Буффера", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBufferImageOne = pInputBuffer1;
	*ppInputBufferImageTwo = pInputBuffer2;
	*ppOutputBuffer = pOutputPixelBuffer;
	*ppOutputBufferIdenticalPixels = pOutputIdenticalPixelBuffer;
	*ppOutputBufferDifferentPixels = pOutputDifferentPixelBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObjectOutput = pPixelOutputUAV;
	*ppUAVObjectIdentical = pIdenticalPixelsOutputUAV;
	*ppUAVObjectDifferent = pDifferentPixelsOutputUAV;
	*ppReadbackBufferOutput = pReadbackOutputBuffer;
	*ppReadbackBufferIdentical = pReadbackIdenticalPixelBuffer;
	*ppReadbackBufferDifferent = pReadbackDifferentPixelBuffer;
	
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunImageIdentityVerificationOperation(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* ppSRV1,
	ID3D11ShaderResourceView* ppSRV2,
	ID3D11UnorderedAccessView* pUAVObjectOutput,
	ID3D11UnorderedAccessView* pUAVObjectOutputIdentical,
	ID3D11UnorderedAccessView* pUAVObjectOutputDifferent,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppSRV1, ppSRV2 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUAVObjectOutput, pUAVObjectOutputIdentical, pUAVObjectOutputDifferent};
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, nullptr, nullptr};
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeImageGrayScaleConversionResourcesLuminosity(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSConvertRGBImageToGrayscaleLuminosity.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::InitializeImageGrayScaleConversionResources(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	vector<PixelObject> pixelArrayOne,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\ImageToGrayScaleConvertionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeRGBToGrayScaleViaAverage.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		}
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		}
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		if (DO_YOU_WANT_MESSAGES == 1)
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		}
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunImageToGrayScaleConvertionInts(HINSTANCE hInstance,
	HWND hWnd, ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV,
	UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunImageToGrayScaleConvertion(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pPixelObjectArrayImageOne,
	ID3D11Buffer* pInputBufferOne,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeImageHSIConversionResources(
	HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"E:\\С\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\RGBToHSIConvertionCS.hlsl", 
    "CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectHSI);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectHSI);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObjectHSI);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectHSI);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunImageToHSIConversion(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObject> pPixelObjectArrayImageOne,
	ID3D11Buffer* pInputBufferOne,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0};
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateLaplacianOfGaussianFilteringOnSelectedImage(HINSTANCE hInstance,
	HWND hWnd, vector<PixelObjectGrayScale> pInputImageData,
	float pi_var,
	float pStandardDeviationVar,
	vector<GaussianOutputVar> *ppGaussianBlurOutputVar)
{
	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCS.txt");

	cout << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	UINT pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObjectGray : pInputImageData)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.yPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "The Function Applies Laplacianr of Gaussian Filter" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;

	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;


	pOutputFileStream << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	pOutputFileStream << "First We Have to initialize Our Computational Resources that Include: " << endl;
	pOutputFileStream << "1 Compute Shader Structure" << endl;
	pOutputFileStream << "1 Constant Buffer for the Coefficients" << endl;
	pOutputFileStream << "1 Buffer for Input Data" << endl;
	pOutputFileStream << "1 Buffer for Output Data" << endl;
	pOutputFileStream << "1 Shader Resource View For the Input Buffer" << endl;
	pOutputFileStream << "1 Unordered Access View for the Input Buffer" << endl;
	pOutputFileStream << "1 Readback Buffer for Output Data" << endl;


	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<GaussianOutputVar> pOutputDataArray = vector<GaussianOutputVar>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;



	CBGaussianBlurConstantBuffer pGaussianBlurCB;
	pGaussianBlurCB.pi_var = 3.14;
	pGaussianBlurCB.pStandardDeviationVar = pStandardDeviationVar;





	hr = InitializeLaplacianofGaussianFilteringResources(hInstance, hWnd,
		pInputImageData,
		pGaussianBlurCB,
		&pComputeShaderAlgorithm,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pShaderResourceView,
		&pOutputBufferObject,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		hr = RunGaussianFilteringComputeShaderCS(hInstance, hWnd,
			pInputImageData, pGaussianBlurCB,
			pConstantBufferObject,
			pInputBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView,
			pUnorderedAccessView,
			1, 1,
			NUM_ELEMENTS, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	GaussianOutputVar* pOutputDataBuffer = (GaussianOutputVar*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pInputImageData.size(); ++pIndex)
	{
		GaussianOutputVar pOutputValue = pOutputDataBuffer[pIndex];
		cout << "Pixel Number: " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Intensity Value: " << " = " << pOutputValue.pIntensityValue << endl;
		cout << "Laplacian of Gaussian Function Value: " << " = " << pOutputValue.pGaussianValueF << endl;
	
		pOutputDataArray.push_back(pOutputValue);
	}



	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;




	pIndex = 0;
	for (GaussianOutputVar pBufItem : pOutputDataArray)
	{

		cout << "Pixel Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position: " << " = " << pBufItem.yPosition << endl;
		cout << "Intensity " << " = " << pBufItem.pIntensityValue << endl;
		cout << "Laplacian Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pBufItem.yPosition << endl;
		pOutputFileStream << "Intensity " << " = " << pBufItem.pIntensityValue << endl;
		pOutputFileStream << "Laplacian Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;


		pIndex++;

	}










	pOutputFileStream.close();
	*ppGaussianBlurOutputVar = pOutputDataArray;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SimulateGaussianFilteringOnSelectedImage1D(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> ppPixeInputArray,
	float pi_var, float pStandardDeviationVar,
	vector<GaussianOutputVar> *ppGaussianBlurOutputVar)
{

	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCSXValues.txt");

	cout << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	UINT pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObjectGray : ppPixeInputArray)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.yPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "The Function Applies Gau" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;

	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;


	pOutputFileStream << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	pOutputFileStream << "First We Have to initialize Our Computational Resources that Include: " << endl;
	pOutputFileStream << "1 Compute Shader Structure" << endl;
	pOutputFileStream << "1 Constant Buffer for the Coefficients" << endl;
	pOutputFileStream << "1 Buffer for Input Data" << endl;
	pOutputFileStream << "1 Buffer for Output Data" << endl;
	pOutputFileStream << "1 Shader Resource View For the Input Buffer" << endl;
	pOutputFileStream << "1 Unordered Access View for the Input Buffer" << endl;
	pOutputFileStream << "1 Readback Buffer for Output Data" << endl;


	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<GaussianOutputVar> pOutputDataArray = vector<GaussianOutputVar>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;



	CBGaussianBlurConstantBuffer pGaussianBlurCB;
	pGaussianBlurCB.pi_var = pi_var;
	pGaussianBlurCB.pStandardDeviationVar = pStandardDeviationVar;





	hr = InitializeGaussianFilteringResources1D(hInstance, hWnd,
		ppPixeInputArray,
		pGaussianBlurCB,
		&pComputeShaderAlgorithm,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pShaderResourceView,
		&pOutputBufferObject,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		hr = RunGaussianFilteringComputeShaderCS(hInstance, hWnd,
			ppPixeInputArray, pGaussianBlurCB,
			pConstantBufferObject,
			pInputBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView,
			pUnorderedAccessView,
			1, 1,
			256, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	GaussianOutputVar* pOutputDataBuffer = (GaussianOutputVar*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < ppPixeInputArray.size(); ++pIndex)
	{
		GaussianOutputVar pOutputValue = pOutputDataBuffer[pIndex];
		cout << "Pixel Number: " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Gaussian Function Value: " << pIndex << " = " << pOutputValue.pGaussianValueF << endl;

		pOutputDataArray.push_back(pOutputValue);
	}















	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;


	auto ItA = ppPixeInputArray.begin();
	auto ItB = pOutputDataArray.begin();

	cout << "Fixing the Coordinates for the Output Vector" << endl;


	while (ItA < end(ppPixeInputArray) && ItB < end(pOutputDataArray))
	{
		cout << "Processing Item At Index: " << pIndex << endl;
		ItB->pixelNumber = ItA->pixelNumber;
		ItB->xPosition = ItA->xPosition;
		ItB->yPosition  = ItA->yPosition;
		++ItA;
		++ItB;
		pIndex = pIndex + 1;
	}

	pIndex = 0;
	for (GaussianOutputVar pBufItem : pOutputDataArray)
	{

		cout << "Pixel Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position: " << " = " << pBufItem.yPosition << endl;
		cout << "Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pBufItem.yPosition << endl;
		pOutputFileStream << "Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;



	}



	pOutputFileStream.close();
	*ppGaussianBlurOutputVar = pOutputDataArray;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateGaussianFilteringOnSelectedImage1DY(HINSTANCE hInstance, HWND hWnd,
	vector<GaussianOutputVar> pGaussianBlurInputY,
	float pi_var,
	float pStandardDeviationVar,
	vector<GaussianOutputVar> *ppGaussianBlurOutputVar)
{
	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCSYValues.txt");

	cout << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	UINT pIndexValue = 0;

	for (GaussianOutputVar pPixelObjectGray : pGaussianBlurInputY)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.xPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGaussianValueF;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "The Function Applies Gau" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;

	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;


	pOutputFileStream << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	pOutputFileStream << "First We Have to initialize Our Computational Resources that Include: " << endl;
	pOutputFileStream << "1 Compute Shader Structure" << endl;
	pOutputFileStream << "1 Constant Buffer for the Coefficients" << endl;
	pOutputFileStream << "1 Buffer for Input Data" << endl;
	pOutputFileStream << "1 Buffer for Output Data" << endl;
	pOutputFileStream << "1 Shader Resource View For the Input Buffer" << endl;
	pOutputFileStream << "1 Unordered Access View for the Input Buffer" << endl;
	pOutputFileStream << "1 Readback Buffer for Output Data" << endl;


	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<GaussianOutputVar> pOutputDataArray = vector<GaussianOutputVar>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;



	CBGaussianBlurConstantBuffer pGaussianBlurCB;
	pGaussianBlurCB.pi_var = pi_var;
	pGaussianBlurCB.pStandardDeviationVar = pStandardDeviationVar;





	hr = InitializeGaussianFilteringResources1DY(hInstance, hWnd,
		pGaussianBlurInputY,
		pGaussianBlurCB,
		&pComputeShaderAlgorithm,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pShaderResourceView,
		&pOutputBufferObject,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		hr = RunGaussianFilteringComputeShaderCSY(hInstance, hWnd,
			pGaussianBlurInputY, pGaussianBlurCB,
			pConstantBufferObject,
			pInputBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView,
			pUnorderedAccessView,
			1, 1,
			256, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	GaussianOutputVar* pOutputDataBuffer = (GaussianOutputVar*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pGaussianBlurInputY.size(); ++pIndex)
	{
		GaussianOutputVar pOutputValue = pOutputDataBuffer[pIndex];
		cout << "Pixel Number: " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Gaussian Function Value: " << pIndex << " = " << pOutputValue.pGaussianValueF << endl;

		pOutputDataArray.push_back(pOutputValue);
	}















	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;


	auto ItA = pGaussianBlurInputY.begin();
	auto ItB = pOutputDataArray.begin();

	cout << "Fixing the Coordinates for the Output Vector" << endl;


	while (ItA < end(pGaussianBlurInputY) && ItB < end(pOutputDataArray))
	{
		cout << "Processing Item At Index: " << pIndex << endl;
		ItB->pixelNumber = ItA->pixelNumber;
		ItB->xPosition = ItA->xPosition;
		ItB->yPosition = ItA->yPosition;
		++ItA;
		++ItB;
		pIndex = pIndex + 1;
	}

	pIndex = 0;
	for (GaussianOutputVar pBufItem : pOutputDataArray)
	{

		cout << "Pixel Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position: " << " = " << pBufItem.yPosition << endl;
		cout << "Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pBufItem.yPosition << endl;
		pOutputFileStream << "Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;



	}
	pOutputFileStream.close();
	*ppGaussianBlurOutputVar = pOutputDataArray;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateGaussianFilteringOnSelectedImageOneDimension(HINSTANCE hInstance,
	HWND hWnd, vector<PixelObjectGrayScale> ppPixeInputArray, float pi_var, float pStandardDeviationVar, vector<GaussianOutputVar> *pGaussianOutputVarX, vector<GaussianOutputVar> *ppGaussianBlurOutputVar)
{

	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCS1D.txt");

	cout << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	UINT pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObjectGray : ppPixeInputArray)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.yPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}

	cout << "First We Will Filter The Image with Gaussian Kernel For X Values" << endl;
	pOutputFileStream << "First We Will Filter The Image with Gaussian Kernel For X Values" << endl;

	vector<GaussianOutputVar> ppGaussianBlurOutputArrayX = vector<GaussianOutputVar>();

	hr = SimulateGaussianFilteringOnSelectedImage1D(hInstance, hWnd,
		ppPixeInputArray, pi_var, pStandardDeviationVar, &ppGaussianBlurOutputArrayX);

	cout << "Printing the Results of the First Simulation" << endl;
	pOutputFileStream << "Printing the Results of the First Simulation" << endl;
	int pIndex = 0;
	for (GaussianOutputVar pBufItem : ppGaussianBlurOutputArrayX)
	{

		cout << "Pixel Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Gaussian Function Value X: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Gaussian Function Value X: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pIndex++;

	}

	cout << "Next We Will Filter The Image with Gaussian Kernel For Y  Values" << endl;
	pOutputFileStream << "Next We Will Filter The Image with Gaussian Kernel For Y Values" << endl;

	vector<GaussianOutputVar> ppGaussianBlurOutputArrayFinal = vector<GaussianOutputVar>();

	hr = SimulateGaussianFilteringOnSelectedImage1DY(hInstance, hWnd,
		ppGaussianBlurOutputArrayX, pi_var, pStandardDeviationVar, &ppGaussianBlurOutputArrayFinal);

	cout << "Printing the Results of the Last Simulation" << endl;
     pIndex = 0;
	for (GaussianOutputVar pBufItem : ppGaussianBlurOutputArrayFinal)
	{

		cout << "Pixel Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Gaussian Function Value Y: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Gaussian Function Value Y: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pIndex++;

	}

	*pGaussianOutputVarX = ppGaussianBlurOutputArrayX;
	*ppGaussianBlurOutputVar = ppGaussianBlurOutputArrayFinal;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::SimulateGaussianFilteringOnSelectedImage2D(HINSTANCE hInstance, 
	HWND hWnd, vector<PixelObjectGrayScale> pInputImageData,
	float pi_var, 
	float pStandardDeviationVar,
	vector<GaussianOutputVar> *ppGaussianBlurOutputVar)
{

	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCS.txt");

	cout << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	UINT pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObjectGray : pInputImageData)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.yPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "The Function Applies Gau" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;

	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;


	pOutputFileStream << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	pOutputFileStream << "First We Have to initialize Our Computational Resources that Include: " << endl;
	pOutputFileStream << "1 Compute Shader Structure" << endl;
	pOutputFileStream << "1 Constant Buffer for the Coefficients" << endl;
	pOutputFileStream << "1 Buffer for Input Data" << endl;
	pOutputFileStream << "1 Buffer for Output Data" << endl;
	pOutputFileStream << "1 Shader Resource View For the Input Buffer" << endl;
	pOutputFileStream << "1 Unordered Access View for the Input Buffer" << endl;
	pOutputFileStream << "1 Readback Buffer for Output Data" << endl;


	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<GaussianOutputVar> pOutputDataArray = vector<GaussianOutputVar>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;



	CBGaussianBlurConstantBuffer pGaussianBlurCB;
	pGaussianBlurCB.pi_var = pi_var;
	pGaussianBlurCB.pStandardDeviationVar = pStandardDeviationVar;





	hr = InitializeGaussianFilteringResources(hInstance, hWnd,
		pInputImageData,
		pGaussianBlurCB,
		&pComputeShaderAlgorithm,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pShaderResourceView,
		&pOutputBufferObject,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		hr = RunGaussianFilteringComputeShaderCS(hInstance, hWnd,
			pInputImageData, pGaussianBlurCB,
			pConstantBufferObject,
			pInputBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView,
			pUnorderedAccessView,
			1, 1,
			256, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	GaussianOutputVar* pOutputDataBuffer = (GaussianOutputVar*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pInputImageData.size(); ++pIndex)
	{
		GaussianOutputVar pOutputValue = pOutputDataBuffer[pIndex];
		cout << "Pixel Number: " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Intensity Value: " << pOutputValue.pIntensityValue << endl;
		cout << "Gradient Value" << " = " << pOutputValue.pGradientValue << endl;
		cout << "Gaussian Function Value: " << pOutputValue.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pOutputValue.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pOutputValue.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		pOutputFileStream << "Intensity Value: " << pOutputValue.pIntensityValue << endl;
		pOutputFileStream << "Gradient Value" << " = " << pOutputValue.pGradientValue << endl;
		pOutputFileStream << "Gaussian Function Value: " << pOutputValue.pGaussianValueF << endl;

		pOutputDataArray.push_back(pOutputValue);
	}















	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;


	auto ItA = pInputImageData.begin();
	auto ItB = pOutputDataArray.begin();

	cout << "Fixing the Coordinates for the Output Vector" << endl;




	pIndex = 0;
	for (GaussianOutputVar pBufItem : pOutputDataArray)
	{

		cout << "Pixel Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position: " << " = " << pBufItem.yPosition << endl;
		cout << "Intensity Value: " << pBufItem.pIntensityValue << endl;
		cout << "Gradient Value" << " = " << pBufItem.pGradientValue << endl;
		cout << "Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;

		pOutputFileStream << "Pixel Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << " = " << pBufItem.yPosition << endl;
		pOutputFileStream << "Intensity Value: " << pBufItem.pIntensityValue << endl;
		pOutputFileStream << "Gradient Value: " << " = " << pBufItem.pGradientValue << endl;
		pOutputFileStream << "Gaussian Function Value: " << pIndex << " = " << pBufItem.pGaussianValueF << endl;


	}
	pOutputFileStream.close();
	*ppGaussianBlurOutputVar = pOutputDataArray;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::SimulateCannyEdgeDetectionFilteringOnSelectedImage2D(HINSTANCE hInstance,
	HWND hWnd, vector<PixelObjectGrayScale> pInputImageData,
	float pi_var,
	float pStandardDeviationVar,
	vector<CannyOutputVar> *ppGaussianBlurOutputVar)
{

	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCS.txt");

	cout << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Gaussian Filter Object " << endl;
	UINT pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObjectGray : pInputImageData)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.yPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}


	cout << "The Function Applies Gau" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;

	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;


	pOutputFileStream << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	pOutputFileStream << "First We Have to initialize Our Computational Resources that Include: " << endl;
	pOutputFileStream << "1 Compute Shader Structure" << endl;
	pOutputFileStream << "1 Constant Buffer for the Coefficients" << endl;
	pOutputFileStream << "1 Buffer for Input Data" << endl;
	pOutputFileStream << "1 Buffer for Output Data" << endl;
	pOutputFileStream << "1 Shader Resource View For the Input Buffer" << endl;
	pOutputFileStream << "1 Unordered Access View for the Input Buffer" << endl;
	pOutputFileStream << "1 Readback Buffer for Output Data" << endl;


	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<CannyOutputVar> pOutputDataArray = vector<CannyOutputVar>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;



	CBGaussianBlurConstantBuffer pGaussianBlurCB;
	pGaussianBlurCB.pi_var = pi_var;
	pGaussianBlurCB.pStandardDeviationVar = pStandardDeviationVar;





	hr = InitializeCannyEdgeDetectionFilteringResources(hInstance, hWnd,
		pInputImageData,
		pGaussianBlurCB,
		&pComputeShaderAlgorithm,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pShaderResourceView,
		&pOutputBufferObject,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		hr = RunCannyFilteringComputeShaderCS(hInstance, hWnd,
			pInputImageData, pGaussianBlurCB,
			pConstantBufferObject,
			pInputBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView,
			pUnorderedAccessView,
			1, 1,
			256, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	CannyOutputVar* pOutputDataBuffer = (CannyOutputVar*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pInputImageData.size(); ++pIndex)
	{
		CannyOutputVar pOutputValue = pOutputDataBuffer[pIndex];
		cout << "Pixel Number: " << pOutputValue.pixelNumber << endl;
		cout << "X Position: " << " = " << pOutputValue.xPosition << endl;
		cout << "Y Position: " << " = " << pOutputValue.yPosition << endl;
		cout << "Gaussian Function Value: " << pIndex << " = " << pOutputValue.pGaussianValueF << endl;
		cout << "Canny X Direction Value: " << pOutputValue.pCannyEdgeDetectorX << endl;
		cout << "Canny Y Direction Value: " << pOutputValue.pCannyEdgeDetectorY << endl;
		cout << "Canny Filter Magnitude: " << pOutputValue.pCannyMagnitude << endl;
		cout << "Canny Filter Direction" << pOutputValue.pCannyDirection << endl;

		
		pOutputDataArray.push_back(pOutputValue);
	}















	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;


	auto ItA = pInputImageData.begin();
	auto ItB = pOutputDataArray.begin();

	cout << "Fixing the Coordinates for the Output Vector" << endl;


	while (ItA < end(pInputImageData) && ItB < end(pOutputDataArray))
	{
		cout << "Processing Item At Index: " << pIndex << endl;
		ItB->pixelNumber = ItA->pixelNumber;
		ItB->xPosition = ItA->xPosition;
		ItB->yPosition = ItA->yPosition;
		++ItA;
		++ItB;
		pIndex = pIndex + 1;
	}

	pIndex = 0;
	for (CannyOutputVar pBufItem : pOutputDataArray)
	{

		cout << "Pixel Number = " << pBufItem.pixelNumber << endl;
		cout << "X Position  =  " << " = " << pBufItem.xPosition << endl;
		cout << "Y Position = " << " = " << pBufItem.yPosition << endl;
		cout << "Gaussian Function Value =  " << pIndex << " = " << pBufItem.pGaussianValueF << endl;
		cout << "Canny X Direction Value =  " << pBufItem.pCannyEdgeDetectorX << endl;
		cout << "Canny Y Direction Value =  " << pBufItem.pCannyEdgeDetectorY << endl;
		cout << "Canny Filter Magnitude =  " << pBufItem.pCannyMagnitude << endl;
		cout << "Canny Filter Direction = " << pBufItem.pCannyDirection << endl;

		pOutputFileStream << "Pixel Numberv " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position =  " << " = " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position =  " << " = " << pBufItem.yPosition << endl;
		pOutputFileStream << "Gaussian Function Value =  " << pIndex << " = " << pBufItem.pGaussianValueF << endl;
		pOutputFileStream << "Canny X Direction Value =  " << pBufItem.pCannyEdgeDetectorX << endl;
		pOutputFileStream << "Canny Y Direction Value =  " << pBufItem.pCannyEdgeDetectorY << endl;
		pOutputFileStream << "Canny Filter Magnitude =  " << pBufItem.pCannyMagnitude << endl;
		pOutputFileStream << "Canny Filter Direction = " << pBufItem.pCannyDirection << endl;



	}
	pOutputFileStream.close();
	*ppGaussianBlurOutputVar = pOutputDataArray;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeCannyEdgeDetectionFilteringResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pInputDataBuffer,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** pGaussianBlurConstantBuffer,
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome,
	ID3D11Buffer** ppReadbackDataBufferOutcome)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSCannyEdgeDetector.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object for Gaussian Blur" << endl;
	imageMaskLog << "Creating the Constant Buffer Object for Gaussian Blur" << endl;


	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBGaussianBlurConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pGaussianBlurData;
	pGaussianBlurData.pSysMem = &pConstantBufferCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pGaussianBlurData, &pConstantBufferObject);


	cout << "Creating the Input Buffer For Gaussian Blur Data" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataBuffer.size() * sizeof(CannyOutputVar);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(CannyOutputVar);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(CannyOutputVar);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(CannyOutputVar);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppGaussianBlurComputeShader = pComputeShaderObject;
	*pGaussianBlurConstantBuffer = pConstantBufferObject;
	*ppInputBufferGaussianBlur = pInputBuffer1;
	*ppOutputBufferGaussianBlur = pOutputBuffer;
	*ppGaussianBlurSRV = pInputSRV1;
	*ppOutputBufferForOutcome = pOutputUAV;
	*ppReadbackDataBufferOutcome = pReadbackBuffer;

	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::RunApplyGaussianFilteringComputeShaderCS(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

}














HRESULT DirectXStandardAlgorithmExecutor::ApplyGaussianFilterToImage(HINSTANCE hInstance,
	HWND hWnd,
	float pStandardDeviationVar,
	vector<PixelObjectGrayScale> pInputImage,
	vector<GaussianOutputVar> *ppGaussianBlurInputVar)
{

	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels\\GaussianFilterObjectCS.txt");
	vector<GaussianOutputVar> ppPixelObjectOutputArray = vector<GaussianOutputVar>();

	cout << "Printing the Initial Values for the Image Filter Object Object " << endl;
	pOutputFileStream << "Printing the Initial Values for the Image Filter Object Object " << endl;
	UINT pIndexValue = 0;

	for (PixelObjectGrayScale pPixelObjectGray : pInputImage)
	{
		float pPixelNumber = pIndexValue;
		float pXValue = pPixelObjectGray.xPosition;
		float pYValue = pPixelObjectGray.yPosition;
		float pPixeoObjectGrayScale = pPixelObjectGray.pGreyLevel;

		cout << "Step: " << pIndexValue << endl;
		cout << "X Value = " << pXValue << endl;
		cout << "Y Value = " << pYValue << endl;
		cout << "GrayScale Value = " << pPixeoObjectGrayScale << endl;

		pOutputFileStream << "Step: " << pIndexValue << endl;
		pOutputFileStream << "X Value = " << pXValue << endl;
		pOutputFileStream << "Y Value = " << pYValue << endl;
		pOutputFileStream << "GrayScale Value = " << pPixeoObjectGrayScale << endl;


		pIndexValue++;
	}



	cout << "For the Convolution Operation We would use the following resources" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "1 Input Buffer for the Image" << endl;
	cout << "1 Input Buffer for the Kernel" << endl;
	cout << "1 Shader Resource View for the Image" << endl;
	cout << "1 Shader Resource View for the Kernel" << endl;
	cout << "1 Unordered Access  View for the Output" << endl;
	cout << "1 Readback Buffer" << endl;


	pOutputFileStream << "For the Convolution Operation We would use the following resources" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "1 Input Buffer for the Image" << endl;
	pOutputFileStream << "1 Input Buffer for the Kernel" << endl;
	pOutputFileStream << "1 Shader Resource View for the Image" << endl;
	pOutputFileStream << "1 Shader Resource View for the Kernel" << endl;
	pOutputFileStream << "1 Unordered Access  View for the Output" << endl;
	pOutputFileStream << "1 Readback Buffer" << endl;






	ID3D11ComputeShader* ppFilterApplicationComputeShader = nullptr;
	ID3D11Buffer* ppGaussianBlurConstantBuffer = nullptr;
	ID3D11Buffer* ppInputImageObject = nullptr;
	ID3D11Buffer* ppInputKernelObject = nullptr;
	ID3D11Buffer* ppOutputFilterObject = nullptr;
	ID3D11ShaderResourceView* ppInputImageObjectSRV = nullptr;
	ID3D11ShaderResourceView* ppInputKernelObjectSRV = nullptr;
	ID3D11UnorderedAccessView* ppUnorderedAccessOutputUAV = nullptr;
	ID3D11Buffer* ppReadbackOutputBuffer = nullptr;

	cout << "Initializing The Resources For Image Convolution Operation" << endl;
	pOutputFileStream << "Initializing The Resources For Image Convolution Operation" << endl;

	CBGaussianBlurConstantBuffer pConstantBuffer;
	pConstantBuffer.pi_var = XM_PI;
	pConstantBuffer.pStandardDeviationVar = pStandardDeviationVar;


	hr = InitializeGaussianFilteringResources(hInstance,
		hWnd, pInputImage,
		pConstantBuffer,
		&ppFilterApplicationComputeShader,
		&ppGaussianBlurConstantBuffer,
		&ppInputImageObject,
		&ppInputImageObjectSRV,
		&ppOutputFilterObject,
		&ppUnorderedAccessOutputUAV,
		&ppReadbackOutputBuffer);
	
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}


	ID3D11ShaderResourceView* ppInputShaderResources[] = { ppInputImageObjectSRV, ppInputKernelObjectSRV };

	cout << "Running Image Convolution Simulation" << endl;
	hr = RunGaussianFilteringComputeShaderCS(hInstance, hWnd,
		pInputImage,
		pConstantBuffer,
		ppGaussianBlurConstantBuffer,
		ppInputImageObject,
		ppFilterApplicationComputeShader,
		ppInputImageObjectSRV,
		ppUnorderedAccessOutputUAV,
		2, 1, 256, 1, 1);


	cout << "Compute Simulation has been Completed" << endl;
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		cout << "Copying Data From GPU To CPU" << endl;

		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(ppReadbackOutputBuffer, ppOutputFilterObject);
		hr = m_pD3DCompContext->Map(ppReadbackOutputBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		GaussianOutputVar* p = (GaussianOutputVar*)MappedResource.pData;
		for (int i = 0; i < pInputImage.size(); ++i)
		{
			ppPixelObjectOutputArray.push_back(p[i]);
		}





		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (GaussianOutputVar pPixelObject : ppPixelObjectOutputArray)
		{
			cout << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			cout << "X Position: " << pPixelObject.xPosition << endl;
			cout << "Y Position: " << pPixelObject.xPosition << endl;
			cout << "Intensity Value: " << pPixelObject.pIntensityValue << endl;
			cout << "Gaussian Filter Value: " << pPixelObject.pGradientValue << endl;
			cout << "Filtered Image Value: " << pPixelObject.pGaussianValueF << endl;



			pOutputFileStream << "Pixel Number: " << pPixelObject.pixelNumber << endl;
			pOutputFileStream << "X Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Y Position: " << pPixelObject.xPosition << endl;
			pOutputFileStream << "Intensity Value: " << pPixelObject.pIntensityValue << endl;
			pOutputFileStream << "Gaussian Filter Value: " << pPixelObject.pGradientValue << endl;
			pOutputFileStream << "Filtered Image Value: " << pPixelObject.pGaussianValueF << endl;

		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		pOutputFileStream << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;



	}

	*ppGaussianBlurInputVar = ppPixelObjectOutputArray;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeApplyGaussianFilteringResources(HINSTANCE hInstance, HWND hWnd, vector<PixelObjectGrayScale> pInputDataBuffer, vector<GaussianOutputVar> pFilteredArrayVar,
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11Buffer** pGaussianBlurInputBuffer,
	ID3D11ShaderResourceView** ppInputImageSRV,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome,
	ID3D11Buffer** ppReadbackDataBufferOutcome)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputImageBuffer = nullptr;
	ID3D11Buffer* pInputKernelBuffer = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputKernelSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"С:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeGaussianBlur.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object for Gaussian Blur" << endl;
	imageMaskLog << "Creating the Constant Buffer Object for Gaussian Blur" << endl;


	cout << "Creating the Input Buffer For Gaussian Blur Data" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputImageBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_gaussian;
	ZeroMemory(&buffer_desc_gaussian, sizeof(buffer_desc_gaussian));
	buffer_desc_gaussian.ByteWidth = pFilteredArrayVar.size() * sizeof(GaussianOutputVar);
	buffer_desc_gaussian.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_gaussian.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_gaussian.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_gaussian.StructureByteStride = sizeof(GaussianOutputVar);
	buffer_desc_gaussian.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA ppGaussianData;
	ppGaussianData.pSysMem = &pFilteredArrayVar[0];

	cout << "Creating the Kernel Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_gaussian, &ppGaussianData, &pInputKernelBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer E,rror: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer" << endl;
	imageMaskLog << "Creating the Output Buffer" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputImageBuffer, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Shader Resource View for Kernel";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_kernel;
	ZeroMemory(&srvbuffer_desc_kernel, sizeof(srvbuffer_desc_kernel));
	srvbuffer_desc_kernel.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_kernel.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_kernel.Buffer.ElementWidth = pFilteredArrayVar.size();
	srvbuffer_desc_kernel.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputKernelBuffer, &srvbuffer_desc_kernel, &pInputKernelSRV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}




	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppGaussianBlurComputeShader = pComputeShaderObject;
	*ppInputBufferGaussianBlur = pInputImageBuffer;
	*pGaussianBlurInputBuffer = pInputKernelBuffer;
	*ppOutputBufferGaussianBlur = pOutputBuffer;
	*ppGaussianBlurSRV = pInputKernelSRV;
	*ppInputImageSRV = pInputSRV1;
	*ppOutputBufferForOutcome = pOutputUAV;
	*ppReadbackDataBufferOutcome = pReadbackBuffer;

	return hr;
}










HRESULT DirectXStandardAlgorithmExecutor::InitializeLaplacianofGaussianFilteringResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pInputDataBuffer,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** pGaussianBlurConstantBuffer,
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome,
	ID3D11Buffer** ppReadbackDataBufferOutcome)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\LaplacianOfGaussianCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object for Gaussian Blur" << endl;
	imageMaskLog << "Creating the Constant Buffer Object for Gaussian Blur" << endl;


	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBGaussianBlurConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pGaussianBlurData;
	pGaussianBlurData.pSysMem = &pConstantBufferCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pGaussianBlurData, &pConstantBufferObject);


	cout << "Creating the Input Buffer For Gaussian Blur Data" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(GaussianOutputVar);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(GaussianOutputVar);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppGaussianBlurComputeShader = pComputeShaderObject;
	*pGaussianBlurConstantBuffer = pConstantBufferObject;
	*ppInputBufferGaussianBlur = pInputBuffer1;
	*ppOutputBufferGaussianBlur = pOutputBuffer;
	*ppGaussianBlurSRV = pInputSRV1;
	*ppOutputBufferForOutcome = pOutputUAV;
	*ppReadbackDataBufferOutcome = pReadbackBuffer;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeGaussianFilteringResources(HINSTANCE hInstance, 
	HWND hWnd, 
	vector<PixelObjectGrayScale> pInputDataBuffer,
	CBGaussianBlurConstantBuffer pConstantBufferCB, 
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** pGaussianBlurConstantBuffer, 
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome, 
	ID3D11Buffer** ppReadbackDataBufferOutcome)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeGaussianBlur.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object for Gaussian Blur" << endl;
	imageMaskLog << "Creating the Constant Buffer Object for Gaussian Blur" << endl;


	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBGaussianBlurConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pGaussianBlurData;
	pGaussianBlurData.pSysMem = &pConstantBufferCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pGaussianBlurData, &pConstantBufferObject);


	cout << "Creating the Input Buffer For Gaussian Blur Data" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(GaussianOutputVar);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(GaussianOutputVar);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppGaussianBlurComputeShader = pComputeShaderObject;
	*pGaussianBlurConstantBuffer = pConstantBufferObject;
	*ppInputBufferGaussianBlur = pInputBuffer1;
	*ppOutputBufferGaussianBlur = pOutputBuffer;
	*ppGaussianBlurSRV = pInputSRV1;
	*ppOutputBufferForOutcome = pOutputUAV;
	*ppReadbackDataBufferOutcome = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeGaussianFilteringResources1D(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pInputDataBuffer,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** pGaussianBlurConstantBuffer,
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome,
	ID3D11Buffer** ppReadbackDataBufferOutcome)
{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeGaussianBlurX.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object for Gaussian Blur" << endl;
	imageMaskLog << "Creating the Constant Buffer Object for Gaussian Blur" << endl;


	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBGaussianBlurConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pGaussianBlurData;
	pGaussianBlurData.pSysMem = &pConstantBufferCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pGaussianBlurData, &pConstantBufferObject);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Constant Buffer: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Gaussian Blur Data" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputDataBuffer.size() * sizeof(PixelObjectGrayScale);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(GaussianOutputVar);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(GaussianOutputVar);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppGaussianBlurComputeShader = pComputeShaderObject;
	*pGaussianBlurConstantBuffer = pConstantBufferObject;
	*ppInputBufferGaussianBlur = pInputBuffer1;
	*ppOutputBufferGaussianBlur = pOutputBuffer;
	*ppGaussianBlurSRV = pInputSRV1;
	*ppOutputBufferForOutcome = pOutputUAV;
	*ppReadbackDataBufferOutcome = pReadbackBuffer;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeGaussianFilteringResources1DY(HINSTANCE hInstance,
	HWND hWnd,
	vector<GaussianOutputVar> pInputDataBuffer,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** pGaussianBlurConstantBuffer,
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome,
	ID3D11Buffer** ppReadbackDataBufferOutcome)

{
	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog("С:\\pixels\\HSIConversionPreOutput.txt");
	imageMaskLog.clear();


	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeGaussianBlurY.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object for Gaussian Blur" << endl;
	imageMaskLog << "Creating the Constant Buffer Object for Gaussian Blur" << endl;


	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBGaussianBlurConstantBuffer) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pGaussianBlurData;
	pGaussianBlurData.pSysMem = &pConstantBufferCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pGaussianBlurData, &pConstantBufferObject);


	cout << "Creating the Input Buffer For Gaussian Blur Data" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(GaussianOutputVar);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(GaussianOutputVar);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(GaussianOutputVar);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(GaussianOutputVar);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppGaussianBlurComputeShader = pComputeShaderObject;
	*pGaussianBlurConstantBuffer = pConstantBufferObject;
	*ppInputBufferGaussianBlur = pInputBuffer1;
	*ppOutputBufferGaussianBlur = pOutputBuffer;
	*ppGaussianBlurSRV = pInputSRV1;
	*ppOutputBufferForOutcome = pOutputUAV;
	*ppReadbackDataBufferOutcome = pReadbackBuffer;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::RunCannyFilteringComputeShaderCS(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> pImageArrayOne,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11Buffer* pConstantBuffer,
	ID3D11Buffer* pInputBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;
	m_pD3DCompContext->UpdateSubresource(pInputBuffer, 0, nullptr, &pImageArrayOne[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(pConstantBuffer, 0, nullptr, &pConstantBufferCB, 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunGaussianFilteringComputeShaderCS(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> pImageArrayOne,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11Buffer* pConstantBuffer,
	ID3D11Buffer* pInputBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunGaussianFilteringComputeShaderCSY(HINSTANCE hInstance, HWND hWnd,
	vector<GaussianOutputVar> pImageArrayOne,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11Buffer* pConstantBuffer,
	ID3D11Buffer* pInputBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;
	m_pD3DCompContext->UpdateSubresource(pInputBuffer, 0, nullptr, &pImageArrayOne[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(pConstantBuffer, 0, nullptr, &pConstantBufferCB, 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);


	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateStandardDeviationOnSelectedImageOnCPU(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pInputPixelDataArray,
	float *ppStandardDeviationVar)
{
	HRESULT hr = S_OK;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\StandardDeviationCPU.txt");

	cout << "This Function Will Simulate The Computation of Standard Deviation On CPU" << endl;
	cout << "First We Will have to compute the Average for the Intensity Set" << endl;
	int pIntensitySum = 0;
	pOutputFileStream << "Creating the Resources For Formulae One" << endl;
	pOutputFileStream << "Transforming the Input Buffer to Correct Format" << endl;



	float pSumValue = 0.0f;
	float pAverage = 0.0f;

	cout << "Summing Up the Elements" << endl;
	pOutputFileStream << "Summing Up the Elements" << endl;

	for (PixelObjectGrayScale pValue : pInputPixelDataArray)
	{
		pSumValue = pSumValue + pValue.pGreyLevel;
	}

	cout << "Sum Value: " << pSumValue << endl;
	pOutputFileStream << "Sum Value: " << pSumValue << endl;

	cout << "Computing the Average Value: " << endl;
	pOutputFileStream << "Computing the Average Value: " << endl;

	pAverage = pSumValue / pInputPixelDataArray.size();

	cout << "Amount of Vector Elements: " << pInputPixelDataArray.size();
	cout << "Sum Of Vector Elements: " << pSumValue << endl;
	cout << "Average Value: " << pAverage << endl;
	 



	cout << "Computing of Standard Deviation Started" << endl;
	cout << "First we have to compute the amount of squared differences" << endl;

	float pDifferenceVar = 0.0f;
	float pDifferenceSquaredSum = 0.0f;
	float pDifferenceSquared = 0.0f;
	float pVarianceValue = 0.0f;
	float pStandardDeviationVar = 0.0f;
	for (PixelObjectGrayScale pValue : pInputPixelDataArray)
	{
		cout << "Pixel Number = " << pValue.pixelNumber << endl;
		cout << "X Position  = " << pValue.xPosition << endl;
		cout << "Y Position = " << pValue.yPosition << endl;
		cout << "GrayScale Value = " << pValue.pGreyLevel << endl;
		pDifferenceVar = abs(pValue.pGreyLevel - pAverage);
		pDifferenceSquared = pow(abs(pDifferenceVar), 2);
		pDifferenceSquaredSum = pDifferenceSquaredSum + pDifferenceSquared;
		cout << "Current Difference Value = " << pDifferenceVar << endl;
		cout << "Current Difference Value Squared = " << pDifferenceSquared << endl;

		pOutputFileStream << "Pixel Number = " << pValue.pixelNumber << endl;
		pOutputFileStream << "X Position  = " << pValue.xPosition << endl;
		pOutputFileStream << "Y Position = " << pValue.yPosition << endl;
		pOutputFileStream << "GrayScale Value = " << pValue.pGreyLevel << endl;
		pOutputFileStream << "Current Difference Value = " << pDifferenceVar << endl;
		pOutputFileStream << "Current Difference Value Squared = " << pDifferenceSquared << endl;


	}

	cout << "Difference Squared Sum = " << pDifferenceSquaredSum << endl;
	pOutputFileStream << "Difference Squared Sum = " << pDifferenceSquaredSum << endl;

	pVarianceValue = pDifferenceSquaredSum / pInputPixelDataArray.size();
	cout << "Current Variance Value = " << pVarianceValue << endl;
	pOutputFileStream << "Current Variance Value = " << pVarianceValue << endl;

	pStandardDeviationVar = sqrt(pVarianceValue);
	cout << "Standard Deviation Var = " << pStandardDeviationVar << endl;
	pOutputFileStream << "Standard Deviation Var = " << pStandardDeviationVar << endl;

	*ppStandardDeviationVar = pStandardDeviationVar;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateStandardOnSelectedImage(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pInputPixelDataArray,
	vector<CStandardDeviationImageOutputType> *ppImageDeviationOutputVar)

{
	HRESULT hr = S_OK;

	ofstream pOutputFileStream("C:\\\pixels5\\StandardDeviationOnImageIntensityValues.txt");
	pOutputFileStream.clear();

	cout << "The Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;


	pOutputFileStream << "The Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Fomula One" << endl;

	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;

	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pCopyBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11ShaderResourceView* pCopyShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<BufType> pInputBufferArray = vector<BufType>();
	vector<CStandardDeviationImageOutputType> pOutputDataArray = vector<CStandardDeviationImageOutputType>();
	vector<float> pOutputArray = vector<float>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;

	pOutputFileStream << "Creating the Resources For Formulae One" << endl;
	pOutputFileStream << "Transforming the Input Buffer to Correct Format" << endl;



	float pSumValue = 0.0f;
	float pAverage = 0.0f;

	cout << "Summing Up the Elements" << endl;
	pOutputFileStream << "Summing Up the Elements" << endl;

	for (PixelObjectGrayScale pValue : pInputPixelDataArray)
	{
		pSumValue = pSumValue + pValue.pGreyLevel;
	}

	cout << "Sum Value: " << pSumValue << endl;
	pOutputFileStream << "Sum Value: " << pSumValue << endl;

	cout << "Computing the Average Value: " << endl;
	pOutputFileStream << "Computing the Average Value: " << endl;

	pAverage = pSumValue / pInputPixelDataArray.size();

	cout << "Amount of Vector Elements: " << pInputPixelDataArray.size();
	cout << "Sum Of Vector Elements: " << pSumValue << endl;
	cout << "Average Value: " << pAverage << endl;


	pOutputFileStream << "Amount of Vector Elements: " << pInputPixelDataArray.size();
	pOutputFileStream << "Sum Of Vector Elements: " << pSumValue << endl;
	pOutputFileStream << "Average Value: " << pAverage << endl;

	cout << "Filling the Constant Buffer" << endl;
	pOutputFileStream << "Filling the Constant Buffer" << endl;

	CBStandardDeviation pStandardDeviationCB;
	pStandardDeviationCB.pAverageValue = pAverage;





	hr = InitializeStandardDeviationForImageResources(hInstance, hWnd,
		pInputPixelDataArray,
		pStandardDeviationCB,
		&pComputeShaderAlgorithm,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pShaderResourceView,
		&pOutputBufferObject,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		pOutputFileStream << "Unable to Create the Resources for the Standard Deviation Function One" << endl;

		return hr;
	}
	cout << "Performing The Simulation Task" << endl;
	pOutputFileStream << "Performing The Simulation Task" << endl;




	if (SUCCEEDED(hr))
	{
		RunStandardDeviationForImagesCS(hInstance,
			hWnd,
			pInputPixelDataArray,
			pStandardDeviationCB,
			pConstantBufferObject,
			pInputBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView,
			pUnorderedAccessView,
			1, 1, NUM_ELEMENTS, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		pOutputFileStream << "Unable to Complete the Computation Buffer" << endl;

		return hr;
	}

	cout << "Retrieving Results Data Buffer" << endl;
	pOutputFileStream << "Retrieving Results Data Buffer" << endl;


	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	CStandardDeviationImageOutputType* pOutputDataBuffer = (CStandardDeviationImageOutputType*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pInputPixelDataArray.size(); ++pIndex)
	{
		CStandardDeviationImageOutputType pOutputValue = pOutputDataBuffer[pIndex];
		pOutputValue.pStandardDeviationVar = round(pOutputValue.pStandardDeviationVar);

		pOutputDataArray.push_back(pOutputValue);
	}


	auto ItA = pInputPixelDataArray.begin();
	auto ItB = pOutputDataArray.begin();
	cout << "Fixing Output Indexes" << endl;
	int pItemCounter = 0;
	while (ItA != pInputPixelDataArray.end() || ItB != pOutputDataArray.end())
	{
		ItB->pixelNumber = ItA->pixelNumber;
		ItB->xPosition = ItA->xPosition;
		ItB->yPosition = ItA->yPosition;

		if (ItA != pInputPixelDataArray.end())
		{
			++ItA;
		}
		if (ItB != pOutputDataArray.end())
		{
			++ItB;
		}
		pItemCounter++;
	}


	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;


	for (CStandardDeviationImageOutputType pBufItem : pOutputDataArray)
	{
		float pValue = pBufItem.pStandardDeviationVar;
		float zValue = (pValue + 0.005) * 100;
		float yValue = zValue / 100;
		pBufItem.pStandardDeviationVar = yValue;

		cout << "Item Number: " << pBufItem.pixelNumber << endl;
		cout << "X Position: " << pBufItem.xPosition << endl;
		cout << "Y Position: " << pBufItem.yPosition << endl;
		cout << "Standard Deviation Var: " << pIndex << " = " << pBufItem.pStandardDeviationVar << endl;

		pOutputFileStream << "Item Number: " << pBufItem.pixelNumber << endl;
		pOutputFileStream << "X Position: " << pBufItem.xPosition << endl;
		pOutputFileStream << "Y Position: " << pBufItem.yPosition << endl;
		pOutputFileStream << "Standard Deviation Var: " << pIndex << " = " << pBufItem.pStandardDeviationVar << endl;


		pIndex++;
	}
	pOutputFileStream.close();


	*ppImageDeviationOutputVar = pOutputDataArray;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunGaussianFilteringComputeShaderCSX(HINSTANCE hInstance, HWND hWnd,
	vector<PixelObjectGrayScale> pImageArrayOne,
	CBGaussianBlurConstantBuffer pConstantBufferCB,
	ID3D11Buffer* pConstantBuffer,
	ID3D11Buffer* pInputBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;
	m_pD3DCompContext->UpdateSubresource(pInputBuffer, 0, nullptr, &pImageArrayOne[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(pConstantBuffer, 0, nullptr, &pConstantBufferCB, 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);


	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateStandardDeviationComputationP(HINSTANCE hInstance, HWND hWnd, vector<InputItemType> pInputDataArray,
	vector<CStandardDeviationOutputType> *pFunctionOutput, int* pOutputValue)
{
	HRESULT hr = S_OK;
	ofstream pOutputFileStream("C:\\\pixels5\\StandardDeviationFunctionFormulaeOne.txt");

	cout << "The Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	cout << "First We Will Compute The Value for Fomula One" << endl;
	
	pOutputFileStream << "This Function Computes the Standard Deviation Set for a Given Array of Data" << endl;
	pOutputFileStream << "First We Will Compute The Value for Formula One" << endl;
	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;

	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<CStandardDeviationOutputType> pOutputDataArray = vector<CStandardDeviationOutputType>();
	vector<float> pOutputArray = vector<float>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;

	cout << "Summing Up the Elements" << endl;

	for (InputItemType pValue : pInputDataArray)
	{
		pSumValue = pSumValue + pValue.pItemValue;
	}

	cout << "Computing the Average Value: " << endl;

	pAverage = pSumValue / pInputDataArray.size();

	cout << "Amount of Vector Elements: " << pInputDataArray.size();
	cout << "Sum Of Vector Elements: " << pSumValue << endl;
	cout << "Average Value: " << pAverage << endl;

	cout << "Filling the Constant Buffer" << endl;

	CBStandardDeviation pStandardDeviationCB;
	pStandardDeviationCB.pAverageValue = pAverage;





	hr = InitializeStandardDeviationStepOneFunctionResources(hInstance, hWnd,
		&pComputeShaderAlgorithm,
		pInputDataArray,
		pStandardDeviationCB,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		 RunStandardDeviationAlgorithmStepOne(hInstance,
			hWnd,
			pStandardDeviationCB,
			pConstantBufferObject,
			pComputeShaderAlgorithm,
			pShaderResourceView, pUnorderedAccessView, 1, 1, 256, 1, 1);
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	CStandardDeviationOutputType* pOutputDataBuffer = (CStandardDeviationOutputType*)pMammedResource.pData;


	for (UINT pIndex = 0; pIndex < pInputDataArray.size(); ++pIndex)
	{
		CStandardDeviationOutputType pOutputValue = pOutputDataBuffer[pIndex];
		cout << "Item Index: " << pOutputValue.pItemIndex << endl;
		cout << "Input Item Value = " << pOutputValue.pInputValue << endl;
		cout << "Output Item Value =" << pOutputValue.pOutputValue << endl;

		pOutputDataArray.push_back(pOutputValue);
	}



	

	*pFunctionOutput = pOutputDataArray;
	return hr;
}






HRESULT DirectXStandardAlgorithmExecutor::SimulateStandardDeviationComputationStepTwo(HINSTANCE hInstance,
	HWND hWnd,
	vector<float> pInitialData,
	vector<float> *pFunctionOutput)
{
	HRESULT hr = S_OK;

	cout << "Simulating the Step One For the Standard Devication Algorithm" << endl;
	cout << "First We Have to initialize Our Computational Resources that Include: " << endl;
	cout << "1 Compute Shader Structure" << endl;
	cout << "1 Constant Buffer for the Coefficients" << endl;
	cout << "1 Buffer for Input Data" << endl;
	cout << "1 Buffer for Output Data" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "1 Unordered Access View for the Input Buffer" << endl;
	cout << "1 Readback Buffer for Output Data" << endl;

	ID3D11ComputeShader* pComputeShaderAlgorithm = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputBufferObject = nullptr;
	ID3D11Buffer* pOutputBufferObject = nullptr;
	ID3D11ShaderResourceView* pShaderResourceView = nullptr;
	ID3D11UnorderedAccessView* pUnorderedAccessView = nullptr;
	ID3D11Buffer* pReadbackBufferResources = nullptr;
	vector<BufType> pInputBufferArray = vector<BufType>();
	vector<BufType> pOutputDataArray = vector<BufType>();
	vector<float> pOutputArray = vector<float>();

	cout << "Creating the Resources For Formulae One" << endl;
	cout << "Transforming the Input Buffer to Correct Format" << endl;
	float pSumValue = 0.0f;
	float pAverage = 0.0f;

	cout << "Summing Up the Elements" << endl;

	for (float pValue : pInitialData)
	{
		pSumValue = pSumValue + pValue;
	}

	cout << "Computing the Average Value: " << endl;

	pAverage = pSumValue / pInitialData.size();

	cout << "Amount of Vector Elements: " << pInitialData.size();
	cout << "Sum Of Vector Elements: " << pSumValue << endl;
	cout << "Average Value: " << pAverage << endl;

	cout << "Filling the Constant Buffer" << endl;

	CBStandardDeviation pStandardDeviationCB;
	pStandardDeviationCB.pAverageValue = pAverage;




	for (float pValue : pInitialData)
	{
		BufType pCurrentVal;
		pCurrentVal.f = pValue;
		pCurrentVal.d = (double)pValue;
		pCurrentVal.i = (int)pValue;
		pInputBufferArray.push_back(pCurrentVal);
	}


	hr = InitializeStandardDeviationStepTwoFunctionResources(hInstance, hWnd,
		&pComputeShaderAlgorithm,
		pInitialData,
		&pConstantBufferObject,
		&pInputBufferObject,
		&pOutputBufferObject,
		&pShaderResourceView,
		&pUnorderedAccessView,
		&pReadbackBufferResources);

	if (FAILED(hr))
	{
		cout << "Unable to Create the Resources for the Standard Deviation Function One" << endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;



	if (SUCCEEDED(hr))
	{
		
	}
	if (FAILED(hr))
	{
		cout << "Unable to Complete the Computation Buffer" << endl;
		return hr;
	}
	cout << "Retrieving Results Data Buffer" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBufferResources, pOutputBufferObject);
	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	BufType* pOutputDataBuffer = nullptr;
	m_pD3DCompContext->Map(pReadbackBufferResources, 0, D3D11_MAP_READ, 0, &pMammedResource);
	pOutputDataBuffer = (BufType*)pMammedResource.pData;
	cout << "Generating the Temporary Vector" << endl;

	for (UINT pIndexValue = 0; pIndexValue <= pInitialData.size(); ++pIndexValue)
	{
		cout << "Current Item to Process Has Index: " << pIndexValue << endl;
		pOutputDataArray.push_back(pOutputDataBuffer[pIndexValue]);
	}

	cout << "Generating the Output Data Buffer Vector" << endl;
	int pIndex = 0;
	for (BufType pBufItem : pOutputDataArray)
	{
		float pFinalOutput = sqrtf(pBufItem.f);
		cout << "Float Output Result At Index: " << pIndex << " = " << pFinalOutput << endl;
		cout << "Int Output Result At Index: " << pIndex << " = " << pFinalOutput << endl;
		cout << "Double Output Result At Index  " << pIndex << " = " << pFinalOutput << endl;
		pOutputArray.push_back(pFinalOutput);
	}

	*pFunctionOutput = pOutputArray;
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::InitializeStandardDeviationForImageResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<PixelObjectGrayScale> pInputDataBuffer,
	CBStandardDeviation ppConstantBufferCB,
	ID3D11ComputeShader** ppGaussianBlurComputeShader,
	ID3D11Buffer** ppGaussianBlurConstantBuffer,
	ID3D11Buffer** ppInputBufferGaussianBlur,
	ID3D11ShaderResourceView** ppGaussianBlurSRV,
	ID3D11Buffer** ppOutputBufferGaussianBlur,
	ID3D11UnorderedAccessView** ppOutputBufferForOutcome,
	ID3D11Buffer** ppReadbackDataBufferOutcome)
{

	HRESULT hr = S_OK;

	ID3DBlob* pMemoryBuffer = nullptr;
	ID3D11ComputeShader* pExponentialFunctionComputeShader = nullptr;
	ID3D11Buffer* pConstantBufferB = nullptr;
	ID3D11Buffer* pExponentialInputBuffer = nullptr;
	ID3D11Buffer* pExponentialOutputBuffer = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionOutputUAV = nullptr;
	ID3D11ShaderResourceView* pExponentialInputBufferSRV = nullptr;

	ID3D11Buffer* pExponentialFunctionReadbackBuffer = nullptr;
	vector<BData> pInputStructuresArray = vector<BData>();
	cout << "Copying data to array of Structures" << endl;
	int iIndex = 0;
	UINT pAmountOfSamples = pInputDataBuffer.size();


	cout << "Initializing Direct3D11 Device" << endl;

	hr = InitializeD3D11Device(hWnd, 0);



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}

	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	fstream myfile;
	myfile.open("C:\\pixels5\\StandardDeviationOnImageIntensityValuesSetup.txt", fstream::in | fstream::out | fstream::trunc);

	vector<UINT> pOutputArrayData = vector<UINT>();

	cout << "Compiling The Shader for Standard Deviation" << endl;
	myfile << "Compiling The Shader for Standard Deviation" << endl;

	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeStandardDeviationForPixelValues.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		cout << "Creating the Shader Object" << endl;
		myfile << "Creating the Shader Object" << endl;

		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pExponentialFunctionComputeShader);
	}
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}

	//Create the Const Buffer


	cout << "Creating the Constant Buffers" << endl;
	myfile << "Creating the Constant Buffers" << endl;

	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBStandardDeviation) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pSubresourceData;
	pSubresourceData.pSysMem = &ppConstantBufferCB;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pSubresourceData, &pConstantBufferB);

	cout << "Creating the input buffers" << endl;
	myfile << "Creating the input bufferd" << endl;

	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.StructureByteStride = sizeof(PixelObjectGrayScale);
	buffer_desc.ByteWidth = pAmountOfSamples * sizeof(PixelObjectGrayScale);
	buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];



	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pExponentialInputBuffer);

	cout << "Creating the OutputBuffer for Standard Deviation Values" << endl;
	myfile << "Creating the OutputBuffer for Standard Deviation Values" << endl;


	D3D11_BUFFER_DESC outputBufferDesc;
	ZeroMemory(&outputBufferDesc, sizeof(outputBufferDesc));
	outputBufferDesc.StructureByteStride = sizeof(CStandardDeviationImageOutputType);
	outputBufferDesc.ByteWidth = pAmountOfSamples * sizeof(CStandardDeviationImageOutputType);
	outputBufferDesc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	outputBufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	outputBufferDesc.Usage = D3D11_USAGE_DEFAULT;


	hr = m_pD3DCompDevice->CreateBuffer(&outputBufferDesc, NULL, &pExponentialOutputBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the standard deviation function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Shader Resource View for the Standard Deviation Function" << endl;
	myfile << "Creating the Shader Resource View for the Standard Deviation Function" << endl;

	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pAmountOfSamples;
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pExponentialInputBuffer, &srvbuffer_desc, &pExponentialInputBufferSRV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the  standard deviation function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	cout << "Creating the Unordered Access view for the Buffer" << endl;
	myfile << "Creating the Unordered Access view for the Buffer" << endl;

	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 0;
	uavbuffer_desc.Buffer.NumElements = pAmountOfSamples;
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBuffer, &uavbuffer_desc, &pExponentialFunctionOutputUAV);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Вид Ввода-Вывода выходного буффера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the  standard deviation function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс ВВОД/ВЫВОД для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of A UAV Terminated with error: " << pLastError << endl;
		return hr;

	}


	cout << "Creating the Readback Buffer" << endl;
	myfile << "Creating the Readback Buffer" << endl;



	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pAmountOfSamples * sizeof(CStandardDeviationImageOutputType);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(CStandardDeviationImageOutputType);
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pExponentialFunctionReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of A UAV Terminated with error: " << pLastError << endl;
		return hr;
	}




	ID3D11ShaderResourceView* pShaderResourceViews[] = { pExponentialInputBufferSRV };
	ID3D11UnorderedAccessView* ppUAVViews[] = { pExponentialFunctionOutputUAV };
	*ppGaussianBlurConstantBuffer = pConstantBufferB;
	*ppGaussianBlurComputeShader = pExponentialFunctionComputeShader;
	*ppInputBufferGaussianBlur = pExponentialInputBuffer;
	*ppGaussianBlurSRV = pExponentialInputBufferSRV;
	*ppOutputBufferGaussianBlur = pExponentialOutputBuffer;
	*ppOutputBufferForOutcome = pExponentialFunctionOutputUAV;
	*ppReadbackDataBufferOutcome = pExponentialFunctionReadbackBuffer;
	myfile.close();

	return hr;
}



	HRESULT DirectXStandardAlgorithmExecutor::InitializeStandardDeviationStepOneFunctionResources(HINSTANCE hInstance,
		HWND hWnd,
		ID3D11ComputeShader** ppComputeShaderObject,
		vector<InputItemType> pInitialDataSet,
		CBStandardDeviation pStandardDeviationCB,
		ID3D11Buffer** ppConstantBuffer,
		ID3D11Buffer** ppInputDataBuffer,
		ID3D11Buffer** ppOutputDataBuffer,
		ID3D11ShaderResourceView** ppInputDataSRV,
		ID3D11UnorderedAccessView** ppOutputDataUAV,
		ID3D11Buffer** ppReadbackDataBuffer)
	{

		HRESULT hr = S_OK;

		ID3DBlob* pMemoryBuffer = nullptr;
		ID3D11ComputeShader* pExponentialFunctionComputeShader = nullptr;
		ID3D11Buffer* pConstantBufferB = nullptr;
		ID3D11Buffer* pExponentialInputBuffer = nullptr;
		ID3D11Buffer* pExponentialOutputBuffer = nullptr;
		ID3D11UnorderedAccessView* pExponentialFunctionOutputUAV = nullptr;
		ID3D11ShaderResourceView* pExponentialInputBufferSRV = nullptr;
		ID3D11Buffer* pExponentialFunctionReadbackBuffer = nullptr;
		vector<BData> pInputStructuresArray = vector<BData>();
		cout << "Copying data to array of Structures" << endl;
		int iIndex = 0;
		UINT pAmountOfSamples = pInitialDataSet.size();


		cout << "Initializing Direct3D11 Device" << endl;

		hr = InitializeD3D11Device(hWnd, 0);



		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
			return hr;
		}

		printf("done\n");
		ID3DBlob* pMemoryDataBlob = nullptr;
		printf("Creating Compute Shader...");
		// Compile the Bitonic Sort Compute Shader
		ofstream myfile;
		myfile.open("ArrayAdditionFile.txt");
		vector<UINT> pOutputArrayData = vector<UINT>();

		cout << "Compiling the Compute Shader Object";

		hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeStandardDeviation.hlsl", "CS_ComputePreOutput", "cs_5_0", &pMemoryDataBlob);
		if (SUCCEEDED(hr))
		{
			hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pExponentialFunctionComputeShader);
		}
		if (FAILED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
			return hr;
		}

		//Create the Const Buffer
		cout << "Creating the Constant Buffer" << endl;
	
		
		// Create the Const Buffer
		D3D11_BUFFER_DESC constant_buffer_desc;
		ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
		constant_buffer_desc.ByteWidth = sizeof(CBStandardDeviation) * 16;
		constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
		constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		constant_buffer_desc.CPUAccessFlags = 0;

		D3D11_SUBRESOURCE_DATA pResourceData;
		pResourceData.pSysMem = &pStandardDeviationCB;

		hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &pConstantBufferB);

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Unable to Create the Constant Buffer for Standard Deviation Operation" << endl;
			return hr;
		}



		cout << "Creating the input buffer" << endl;

		// Create 2 buffers for switching between when performing the transpose
		D3D11_BUFFER_DESC buffer_desc;
		ZeroMemory(&buffer_desc, sizeof(buffer_desc));
		buffer_desc.StructureByteStride = sizeof(InputItemType);
		buffer_desc.ByteWidth = pInitialDataSet.size() * sizeof(InputItemType);
		buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
		buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
		buffer_desc.Usage = D3D11_USAGE_DEFAULT;
		buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

		D3D11_SUBRESOURCE_DATA pData;
		pData.pSysMem = &pInitialDataSet[0];



		cout << "Creating the OutputBuffer for Standard Deviation Values" << endl;

		hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pExponentialInputBuffer);
		
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "Unable to Create the Constant Buffer for Standard Deviation Operation" << endl;
			return hr;
		}



		D3D11_BUFFER_DESC outputBufferDesc;
		ZeroMemory(&outputBufferDesc, sizeof(outputBufferDesc));
		outputBufferDesc.StructureByteStride = sizeof(CStandardDeviationOutputType);
		outputBufferDesc.ByteWidth = pInitialDataSet.size() * sizeof(CStandardDeviationOutputType);
		outputBufferDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
		outputBufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
		outputBufferDesc.Usage = D3D11_USAGE_DEFAULT;
		outputBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


		
		hr = m_pD3DCompDevice->CreateBuffer(&outputBufferDesc, NULL, &pExponentialOutputBuffer);
		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для экспонентой Функции", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the standard deviation function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
			return hr;
		}


		// Create the Shader Resource View for the Buffers
		// This is used for reading the buffer during the transpose
		D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
		ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
		srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
		srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
		srvbuffer_desc.Buffer.ElementWidth = pInitialDataSet.size();
		srvbuffer_desc.Buffer.ElementOffset = 0;



		hr = m_pD3DCompDevice->CreateShaderResourceView(pExponentialInputBuffer, &srvbuffer_desc, &pExponentialInputBufferSRV);
		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для экспонентой Функции", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the  standard deviation function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
			return hr;
		}



		cout << "Creating the Unordered Access view for the Buffer" << endl;
		// Create the Unordered Access View for the Buffers
		// This is used for writing the buffer during the sort and transpose
		D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
		ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
		uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
		uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
		uavbuffer_desc.Buffer.FirstElement = 0;
		uavbuffer_desc.Buffer.NumElements = pInitialDataSet.size();
		uavbuffer_desc.Buffer.Flags = 0;

		hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBuffer, &uavbuffer_desc, &pExponentialFunctionOutputUAV);

		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан Вид Ввода-Вывода выходного буффера для экспонентой Функции", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the  standard deviation function has been successfully created" << endl;
		}

		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс ВВОД/ВЫВОД для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of A UAV Terminated with error: " << pLastError << endl;
			return hr;

		}



		


		// Create the Readback Buffer
		// This is used to read the results back to the CPU
		D3D11_BUFFER_DESC readback_buffer_desc;
		ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
		readback_buffer_desc.ByteWidth = pInitialDataSet.size() * sizeof(CStandardDeviationOutputType);
		readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
		readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
		readback_buffer_desc.StructureByteStride = sizeof(CStandardDeviationOutputType);
		hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pExponentialFunctionReadbackBuffer);
		
		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of A UAV Terminated with error: " << pLastError << endl;
			return hr;
		}




		ID3D11ShaderResourceView* pShaderResourceViews[] = { pExponentialInputBufferSRV };
		ID3D11UnorderedAccessView* ppUAVViews[] = { pExponentialFunctionOutputUAV };
		*ppConstantBuffer = pConstantBufferB;
		*ppComputeShaderObject = pExponentialFunctionComputeShader;
		*ppInputDataBuffer = pExponentialInputBuffer;
		*ppInputDataSRV = pExponentialInputBufferSRV;
		*ppOutputDataUAV = pExponentialFunctionOutputUAV;
		*ppOutputDataBuffer = pExponentialOutputBuffer;
		*ppReadbackDataBuffer = pExponentialFunctionReadbackBuffer;
		return hr;
	}



	HRESULT DirectXStandardAlgorithmExecutor::InitializeStandardDeviationStepTwoFunctionResources(
		HINSTANCE hInstance,
		HWND hWnd,
		ID3D11ComputeShader** ppComputeShaderObject,
		vector<float> pInputDataArray,
		ID3D11Buffer** ppConstantBuffer,
		ID3D11Buffer** ppInputDataBuffer,
		ID3D11Buffer** ppOutputDataBuffer,
		ID3D11ShaderResourceView** ppInputDataSRV,
		ID3D11UnorderedAccessView** ppOutputDataUAV,
		ID3D11Buffer** ppReadbackDataBuffer)
{
	HRESULT hr = S_OK;
	
	ID3DBlob* pMemoryBuffer = nullptr;
	ID3D11ComputeShader* pExponentialFunctionComputeShader = nullptr;
	ID3D11Buffer* pConstantBufferB = nullptr;
	ID3D11Buffer* pExponentialInputBuffer = nullptr;
	ID3D11Buffer* pExponentialOutputBuffer = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionOutputUAV = nullptr;
	ID3D11ShaderResourceView* pExponentialInputBufferSRV = nullptr;
	ID3D11Buffer* pExponentialFunctionReadbackBuffer = nullptr;
	vector<BufType> pInputStructuresArray = vector<BufType>();
	cout << "Copying data to array of Structures" << endl;
	int iIndex = 0;
	UINT pAmountOfSamples = pInputDataArray.size();



	vector<BufType> pInputBufferObjectTwo = vector<BufType>();

	for (UINT pArrayValue : pInputDataArray)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputStructuresArray.push_back(pParameterVar);
	}
	vector<BufType> pInitialDataSet = vector<BufType>();

	cout << "Initializing Direct3D11 Device" << endl;

	hr = InitializeD3D11Device(hWnd, 0);



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}

	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	vector<UINT> pOutputArrayData = vector<UINT>();


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeStandardDeviation.hlsl", "CS_ComputePreOutput", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pExponentialFunctionComputeShader);
	}
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}

	//Create the Const Buffer
	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBStandardDeviation) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &pConstantBufferB);




	cout << "Creating the input buffer" << endl;

	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.StructureByteStride = sizeof(BufType);
	buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BufType);
	buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputStructuresArray[0];




	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pExponentialInputBuffer);
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, NULL, &pExponentialOutputBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the standard deviation function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pAmountOfSamples;
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pExponentialInputBuffer, &srvbuffer_desc, &pExponentialInputBufferSRV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the  standard deviation function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	cout << "Creating the Unordered Access view for the Buffer" << endl;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 0;
	uavbuffer_desc.Buffer.NumElements = pAmountOfSamples;
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBuffer, &uavbuffer_desc, &pExponentialFunctionOutputUAV);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Вид Ввода-Вывода выходного буффера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the  standard deviation function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс ВВОД/ВЫВОД для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of A UAV Terminated with error: " << pLastError << endl;
		return hr;

	}






	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BData);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(BufType);
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pExponentialFunctionReadbackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of A UAV Terminated with error: " << pLastError << endl;
		return hr;
	}




	ID3D11ShaderResourceView* pShaderResourceViews[] = { pExponentialInputBufferSRV };
	ID3D11UnorderedAccessView* ppUAVViews[] = { pExponentialFunctionOutputUAV };
	*ppComputeShaderObject = pExponentialFunctionComputeShader;
	*ppConstantBuffer = pConstantBufferB;
	*ppInputDataBuffer = pExponentialInputBuffer;
	*ppInputDataSRV = pExponentialInputBufferSRV;
	*ppOutputDataUAV = pExponentialFunctionOutputUAV;
	*ppOutputDataBuffer = pExponentialOutputBuffer;
	*ppReadbackDataBuffer = pExponentialFunctionReadbackBuffer;
	return hr;
}


	HRESULT DirectXStandardAlgorithmExecutor::RunStandardDeviationForImagesCS(HINSTANCE hInstance,
		HWND hWnd,
		vector<PixelObjectGrayScale> pImageArrayOne,
		CBStandardDeviation pConstantBufferCB,
		ID3D11Buffer* pConstantBuffer,
		ID3D11Buffer* pInputBuffer,
		ID3D11ComputeShader* pComputeShaderObject,
		ID3D11ShaderResourceView* pShaderResourceView0,
		ID3D11UnorderedAccessView* pUnorderedUAV, UINT pNumberOfSRV, UINT pNumberOfUAV, UINT X, UINT Y, UINT Z)
	{

	//	m_pD3DCompContext->UpdateSubresource(pConstantBuffer, 0, nullptr, &pConstantBufferCB, 0, 0);
		m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
		m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, &pNumberOfUAV);
		m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);

		try
		{
			m_pD3DCompContext->Dispatch(X, Y, Z);
		}

		catch (std::exception ex)
		{
			cout << "Exeption Error :" << ex.what() << endl;
			throw ex;
		}

		m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
		ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
		ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
		m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);
	}


	void DirectXStandardAlgorithmExecutor::RunStandardDeviationAlgorithmStepOne(HINSTANCE hInstance,
		HWND hWnd,
		CBStandardDeviation pStandardDeviationBuffer,
		ID3D11Buffer* ppConstantBufferObject, ID3D11ComputeShader* pComputeShaderObject,
		ID3D11ShaderResourceView* pShaderResourceView0,
		ID3D11UnorderedAccessView* pUnorderedUAV,
		UINT pNumberOfSRV, UINT pNumberOfUAV,
		UINT X, UINT Y, UINT Z)
	{
		m_pD3DCompContext->UpdateSubresource(ppConstantBufferObject, 0, nullptr, &pStandardDeviationBuffer, 0, 0);
		m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
		m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, &pNumberOfUAV);
		m_pD3DCompContext->CSSetConstantBuffers(0, 1, &ppConstantBufferObject);

		try
		{
			m_pD3DCompContext->Dispatch(X, Y, Z);
		}
		
		catch (std::exception ex)
		{
			cout << "Exeption Error :" << ex.what() << endl;
			throw ex;
		}

		m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
		ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
		ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
		m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);

	}



	HRESULT DirectXStandardAlgorithmExecutor::RunStandardDeviationAlgorithmStepTwo(HINSTANCE hInstance, HWND hWnd,
		CBStandardDeviation pStandardDeviationBuffer,
		ID3D11Buffer* pInputBufferOne,
		ID3D11Buffer* pConstantBuffer,
		ID3D11ComputeShader* pComputeShaderObject,
		ID3D11ShaderResourceView* pShaderResourceView0,
		ID3D11UnorderedAccessView* pUnorderedUAV,
		UINT pNumberOfSRV, UINT pNumberOfUAV,
		UINT X, UINT Y, UINT Z)
	{
		m_pD3DCompContext->UpdateSubresource(pConstantBuffer, 0, nullptr, &pStandardDeviationBuffer, 0, 0);
		m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
		m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, &pNumberOfUAV);
		m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);

		try
		{
			m_pD3DCompContext->Dispatch(X, Y, Z);
		}

		catch (std::exception ex)
		{
			cout << "Exeption Error :" << ex.what() << endl;
			throw ex;
		}

		m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
		ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
		ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
		m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);
	}




HRESULT DirectXStandardAlgorithmExecutor::InitializeImageSubtractionFunctionResources(HINSTANCE hInstance,
	HWND hWnd,
	UINT ppAmountOfSamples,
	ID3D11ComputeShader** ppComputeShaderObject,
	vector<PixelObject> pixelArrayOne,
	vector<PixelObject> pixelArrayTwo,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppInputBuffer2,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11ShaderResourceView** ppSRV2,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;
	cout << "Compiling the Compute Shader Object" << endl;
	hr = InitializeD3D11Device(hWnd, 0);

	fstream imageMaskLog;
	imageMaskLog.open("С:\\pixels\\ImageMaskPreOutput.txt", std::ios_base::out);
	imageMaskLog.clear();

	
	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;


	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ImageMaskComputeShadetObjectSubtraction.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(PixelObject);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pixelArrayOne[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image Two Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Two One Object" << endl;

	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc2));
	buffer_desc2.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObject);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags =  D3D11_BIND_SHADER_RESOURCE;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(PixelObject);
	buffer_desc2.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pixelArrayTwo[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc2, &pData1, &pInputBuffer2);


	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 2 for Pixel Array Two" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc2));
	buffer_desc_output.ByteWidth = pixelArrayTwo.size() * sizeof(PixelObject);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(PixelObject);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pixelArrayOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer Two";
	imageMaskLog << "Creating the Shader Resource View for input Buffer Two";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pixelArrayTwo.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для второго изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog.close();
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Второго Изображения", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View For Image Two Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pixelArrayOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pixelArrayOne.size() * sizeof(PixelObject);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(PixelObject);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppInputBuffer2 = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRV1;
	*ppSRV2 = pInputSRV2;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulateAddition(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	int aIndex = 0;
	int bIndex = 0;
	int cIndex = 0;
	printf("enter number A");
	scanf_s("%d", aIndex);
	printf("Enter number B");
	scanf_s("%d", bIndex);
	cIndex = aIndex + bIndex;
	printf("Your Result" + cIndex);
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::CreateGasDynamicsConstantBuffer(HINSTANCE hInstance, HWND hWnd, GasDynamicsConstantBuffer pGasDynamicsData, ID3D11Buffer* ppGasDynamicsConstantBuffer)
{
	HRESULT hr = S_OK;
	GasDynamicsConstantBuffer pGasDynamicsConstantBufferObject;
	pGasDynamicsConstantBufferObject.pGammaVar = 1.6f;
	pGasDynamicsConstantBufferObject.pRValue = 8314.0f;
	pGasDynamicsConstantBufferObject.pGasMass = 39.35f;


	float argondata[] = { pGasDynamicsConstantBufferObject.pGammaVar, pGasDynamicsConstantBufferObject.pRValue, pGasDynamicsConstantBufferObject.pGasMass };
	D3D11_BUFFER_DESC constBufferDesc;
	constBufferDesc.ByteWidth = 256;
	constBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	constBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	constBufferDesc.MiscFlags = 0;
	constBufferDesc.StructureByteStride = 0;

	D3D11_SUBRESOURCE_DATA InitData;
	InitData.pSysMem = argondata;
	InitData.SysMemPitch = 0;
	InitData.SysMemSlicePitch = 0;

	hr = m_pD3DCompDevice->CreateBuffer(&constBufferDesc,
		&InitData, &pGasDynamicsConstantBuffer);
	if (SUCCEEDED(hr))
	{
		ppGasDynamicsConstantBuffer = pGasDynamicsConstantBuffer;
	}
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::CreateStructuredBufferForTemperatureValues(HINSTANCE hInstance, HWND hWnd, vector<TemperatureStructure> pTempRanageBuffer, ID3D11Buffer* ppGasTempBuffer,
	ID3D11ShaderResourceView* ppGasDynamicsTempBufferSRV)
{
	HRESULT hr = S_OK;
	pAtomTempBuffSRV = nullptr;
	int pLastError = 0;
	D3D11_BUFFER_DESC tempBufferDesc;
	memset(&tempBufferDesc, NULL, sizeof(tempBufferDesc));
	tempBufferDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	tempBufferDesc.ByteWidth = sizeof(float);
	tempBufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	tempBufferDesc.StructureByteStride = 4;

	D3D11_SUBRESOURCE_DATA InitData;
	InitData.pSysMem = pTempRanageBuffer.data();

	hr = m_pD3DCompDevice->CreateBuffer(&tempBufferDesc, &InitData, &pAtomTempDataBuff);

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не Удалось Создвть Структурный Буффер Tемператур Газа", (LPCSTR)"Message", 0);
		pLastError = GetLastError();
		cout << "Unable to Create the Temperature Buffer Error: " << pLastError;
		return hr;
	}

	if (SUCCEEDED(hr))
	{
		D3D11_SHADER_RESOURCE_VIEW_DESC tempSRVDesc;
		memset(&tempSRVDesc, NULL, sizeof(tempSRVDesc));
		tempSRVDesc.Format = DXGI_FORMAT_UNKNOWN;
		tempSRVDesc.BufferEx.NumElements = tempBufferDesc.ByteWidth / tempBufferDesc.StructureByteStride;
		tempSRVDesc.ViewDimension = D3D_SRV_DIMENSION_BUFFER;
		hr = m_pD3DCompDevice->CreateShaderResourceView(pAtomTempDataBuff,
			&tempSRVDesc, &pAtomTempBuffSRV);

	}
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не Удалось Создать Ресурсс Шейдера для Буффера Температур", (LPCSTR)"Message", 0);
		pLastError = GetLastError();
		cout << "Unable to Create the Temperatures Shader Resource View: " << pLastError;
		return hr;
	}
	ppGasTempBuffer = pAtomTempDataBuff;
	ppGasDynamicsTempBufferSRV = pAtomTempBuffSRV;
	return hr;
}



BOOL DirectXStandardAlgorithmExecutor::LocateImageFile(HWND hWnd, LPWSTR pszFileName, DWORD cbFileName)
{
	pszFileName[0] = L'\0';
	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(ofn));

	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.lpstrFilter = L"All Image Files\0"              L"*.bmp;*.dib;*.wdp;*.mdp;*.hdp;*.gif;*.png;*.jpg;*.jpeg;*.tif;*.ico\0"
		L"Windows Bitmap\0"               L"*.bmp;*.dib\0"
		L"High Definition Photo\0"        L"*.wdp;*.mdp;*.hdp\0"
		L"Graphics Interchange Format\0"  L"*.gif\0"
		L"Portable Network Graphics\0"    L"*.png\0"
		L"JPEG File Interchange Format\0" L"*.jpg;*.jpeg\0"
		L"Tiff File\0"                    L"*.tif\0"
		L"Icon\0"                         L"*.ico\0"
		L"All Files\0"                    L"*.*\0"
		L"\0";
	ofn.lpstrFile = pszFileName;
	ofn.nMaxFile = cbFileName;
	ofn.lpstrTitle = L"Open Image";
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

	return GetOpenFileName(&ofn);

}




HRESULT DirectXStandardAlgorithmExecutor::ComputeMatrixDeterminant(HINSTANCE hInstance,
	HWND hWnd, vector<float> pImageArrayOne,
	UINT pMatrixAWidth,
	UINT pMatrixAHeight,
	UINT pMatrixOutWidth,
	UINT pMatrixOutHeight,
	vector<BufType> *ppMatrixVariableOutputType)
{
	HRESULT hr = S_OK;
	hr = InitializeD3D11Device(hWnd, 0);

	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\MatrixOperationMainProcLog.txt");

	pOutputFileStream.clear();
	vector<PixelObjectHSI> ppOutputDataBuffer = vector<PixelObjectHSI>();

	cout << "This Function Computes the Product of Two Image Intensity Matrux" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "2 Input Buffers Of HSI Pixels" << endl;
	cout << "1 Output Buffer of Matrix Variable Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of HSI Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of MatrixVarialble Type" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Computes the Product of Two Image Intensity Matrux" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "2 Input Buffers Of HSI Pixels" << endl;
	pOutputFileStream << "1 Output Buffer of Matrix Variable Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of HSI Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of MatrixVarialble Type" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	MatrixDeterminantCB pConstantBuffer;
	pConstantBuffer.pHeightA = pMatrixAHeight;
	pConstantBuffer.pWidthA = pMatrixAWidth;
	pConstantBuffer.pWidthOut = pMatrixOutWidth;
	pConstantBuffer.pHeightOut = pMatrixOutHeight;


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;


	ID3DBlob* pMatrixShaderBlob = nullptr;
	ID3D11ComputeShader* pMatrixComputeShaderBuffer = nullptr;

	MessageBoxA(hWnd, (LPCSTR)"Эта Программная Процедура Вычисляет Детерминанты Матриц", (LPCSTR)"Message", 0);
	cout << "This Procedure Simulates Matrix Multiplication algorithm" << endl;

	vector<BufType> pMatrixVariableInputArrayOne = vector<BufType>();
    vector<BufType> ppMatrixVariableOutputTypeVector = vector<BufType>();





	cout << "Stage One: Preparing the data for computations" << endl;
	cout << "Let Us View The First Matrix For Computation" << endl;
	pOutputFileStream << "Stage One: Preparing the data for computations" << endl;
	pOutputFileStream << "Let Us View The First Matrix For Computation" << endl;


	int xValue = 0;
	int yValue = 0;


	cout << "Filling the Data Buffer for Matrix One" << endl;
	pOutputFileStream << "Filling the Data Buffer for Matrix One" << endl;

	float pXPosition = 0;
	float pYPosition = 0;
	for (UINT pPixelObjectHSI : pImageArrayOne)
	{

		cout << "Matrix One Element At X = " << pXPosition << "And Y = " << pYPosition << " = " << pPixelObjectHSI << endl;
		pOutputFileStream << "Matrix One Element At X = " << pXPosition << "And Y = " << pYPosition << " = " << pPixelObjectHSI << endl;
		BufType  pMatrixVariableVar;
		pMatrixVariableVar.d = (double)pPixelObjectHSI;
		pMatrixVariableVar.i = pPixelObjectHSI;
		pMatrixVariableVar.f = pPixelObjectHSI;
		pXPosition = pXPosition + 1;

		if (pXPosition == pMatrixAWidth)
		{
			pYPosition = pYPosition + 1;
			pXPosition = 0;
		}
		pMatrixVariableInputArrayOne.push_back(pMatrixVariableVar);

	}




	cout << "First We have to Initialize our Matrix Multiplication " << endl;
	pOutputFileStream << "First We have to Initialize our Matrix Multiplication Machine" << endl;

	ID3D11ComputeShader* pMatrixMultplyComputeShader = nullptr;
	ID3D11Buffer* pMatrixMultiplyConstantBuffer = nullptr;
	ID3D11Buffer* pMatrixMultiplyInputBufferOne = nullptr;
	ID3D11Buffer* pMatrixMultiplyOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pMatrixInputBufferSRVA = nullptr;
	ID3D11UnorderedAccessView* pMatrixOutputDataBufferUAV = nullptr;
	ID3D11Buffer* pMatrixMultiplyReadbackBuffer = nullptr;




	hr = InitializeMatrixDeterminantResources(hInstance,
		hWnd,
		pMatrixVariableInputArrayOne,
		pMatrixAHeight,
		pMatrixAWidth,
		pMatrixOutHeight,
		pMatrixOutWidth,
		&pMatrixMultplyComputeShader,
		&pMatrixMultiplyConstantBuffer,
		&pMatrixMultiplyInputBufferOne,
		&pMatrixMultiplyOutputBuffer,
		&pMatrixInputBufferSRVA,
		&pMatrixOutputDataBufferUAV);

	if (FAILED(hr))
	{
		cout << "Unable To Initialize the Resource for Matrix Multiply Operation" << endl;
		pOutputFileStream << "Unable To Initialize the Resource for Matrix Multiply Operation" << endl;
		return hr;
	}

	cout << "Running Our Matrix Multiplication Operation" << endl;
	pOutputFileStream << "Running Our Matrix Multiplication Operation" << endl;

	if (SUCCEEDED(hr))
	{
		cout << "Setting the Compute Shader For Matrix Multiply" << endl;
		m_pD3DCompContext->CSSetShader(pMatrixMultplyComputeShader, NULL, 0);
		ID3D11ShaderResourceView* ppShaderResourceViews[1] = { pMatrixInputBufferSRVA};
		m_pD3DCompContext->CSSetShaderResources(0, 1, ppShaderResourceViews);
		ID3D11UnorderedAccessView* ppUnorderedAccessViews[1] = { pMatrixOutputDataBufferUAV };
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUnorderedAccessViews, NULL);
		m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pMatrixMultiplyConstantBuffer);
		m_pD3DCompContext->Dispatch(pMatrixAWidth, pMatrixAHeight, 1);
	}

	cout << "Creating the Readback Buffer" << endl;
	pOutputFileStream << "Creating the Readback Buffer" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	pMatrixMultiplyOutputBuffer->GetDesc(&readback_buffer_desc);

	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.BindFlags = 0;
	readback_buffer_desc.MiscFlags = 0;

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, NULL, &pMatrixMultiplyReadbackBuffer);

	cout << "Copying Data From Output Buffer to Readback Buffer" << endl;

	m_pD3DCompContext->CopyResource(pMatrixMultiplyReadbackBuffer, pMatrixMultiplyOutputBuffer);


	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pMatrixMultiplyReadbackBuffer, 0, D3D11_MAP_READ, 0, &pMammedResource);
	BufType *pOutputData = (BufType*)pMammedResource.pData;

	for (UINT pHeightIndex = 0; pHeightIndex < pMatrixOutHeight; pHeightIndex++)
	{
		for (UINT pWidthIndex = 0; pWidthIndex < pMatrixOutWidth; pWidthIndex++)
		{
			cout << "Processing Matrix Row" << pHeightIndex << endl;
			cout << "Processing Matrix Column:" << pWidthIndex << endl;


			UINT pIndexValue = pHeightIndex * pMatrixOutWidth + pWidthIndex;
			float pMatixValueF = pOutputData[pHeightIndex * pMatrixOutWidth + pWidthIndex].f;
			int pMatixValueI = pOutputData[pHeightIndex * pMatrixOutWidth + pWidthIndex].i;
			double pMatixValueD = pOutputData[pHeightIndex * pMatrixOutWidth + pWidthIndex].d;

			cout << "Row Number: " << pWidthIndex << endl;
			cout << "Column Number: " << pWidthIndex << endl;

			cout << "Output Matrix ElementIndex: " << pIndexValue << endl;
			cout << "Float Value: " << pMatixValueF << endl;
			cout << "Int Value " << pMatixValueI << endl;
			cout << "Double: " << pMatixValueD << endl;



			pOutputFileStream << "Row Number: " << pWidthIndex << endl;
			pOutputFileStream << "Column Number: " << pWidthIndex << endl;

			pOutputFileStream << "Output Matrix ElementIndex: " << pIndexValue << endl;
			pOutputFileStream << "Float Value: " << pMatixValueF << endl;
			pOutputFileStream << "Int Value " << pMatixValueI << endl;
			pOutputFileStream << "Double: " << pMatixValueD << endl;
			BufType pOutputStruct;
			pOutputStruct.f = pMatixValueF;
			pOutputStruct.i = pMatixValueI;
			pOutputStruct.d = pMatixValueD;
			ppMatrixVariableOutputTypeVector.push_back(pOutputStruct);
		}
	}

	pOutputFileStream.close();
	*ppMatrixVariableOutputType = ppMatrixVariableOutputTypeVector;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SimulateMatrixMultiplicationForImages(HINSTANCE hInstance,
	HWND hWnd, vector<float> pImageArrayOne,
	vector<float> pImageArrayTwo,
	UINT pMatrixAWidth,
	UINT pMatrixAHeight,
	UINT pMatrixBWidth,
	UINT pMatrixBHeight,
	UINT pMatrixOutWidth,
	UINT pMatrixOutHeight,
	vector<BufType> *ppMatrixVariableOutputType)
{
	HRESULT hr = S_OK;
	hr = InitializeD3D11Device(hWnd, 0);

	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;

	fstream pOutputFileStream;
	pOutputFileStream.open("C:\\\pixels\\MatrixOperationMainProcLog.txt");

	pOutputFileStream.clear();
	vector<PixelObjectHSI> ppOutputDataBuffer = vector<PixelObjectHSI>();

	cout << "This Function Computes the Product of Two Image Intensity Matrux" << endl;
	cout << "For this Simulation We Will Use" << endl;
	cout << "1 Compute Shader" << endl;
	cout << "2 Input Buffers Of HSI Pixels" << endl;
	cout << "1 Output Buffer of Matrix Variable Output" << endl;
	cout << "1 Shader Resource View For Input Buffer of HSI Pixels" << endl;
	cout << "1 Unordered Access View for Output Buffer of MatrixVarialble Type" << endl;
	cout << "1 Readback Data Buffer" << endl;

	pOutputFileStream << "This Function Computes the Product of Two Image Intensity Matrux" << endl;
	pOutputFileStream << "For this Simulation We Will Use" << endl;
	pOutputFileStream << "1 Compute Shader" << endl;
	pOutputFileStream << "2 Input Buffers Of HSI Pixels" << endl;
	pOutputFileStream << "1 Output Buffer of Matrix Variable Output" << endl;
	pOutputFileStream << "1 Shader Resource View For Input Buffer of HSI Pixels" << endl;
	pOutputFileStream << "1 Unordered Access View for Output Buffer of MatrixVarialble Type" << endl;
	pOutputFileStream << "1 Readback Data Buffer" << endl;




	MatrixMultiplyCB pConstantBuffer;
	pConstantBuffer.pHeightA = pMatrixAHeight;
	pConstantBuffer.pHeigtB = pMatrixBHeight;
	pConstantBuffer.pWidthA = pMatrixAWidth;
	pConstantBuffer.pWidthB = pMatrixBWidth;
	pConstantBuffer.pWidthOut = pMatrixOutWidth;
	pConstantBuffer.pHeightOut = pMatrixOutHeight;


	cout << "We Will Start By Printing Out our Pixel Data" << endl;
	int pIndex = 0;


	ID3DBlob* pMatrixShaderBlob = nullptr;
	ID3D11ComputeShader* pMatrixComputeShaderBuffer = nullptr;

	MessageBoxA(hWnd, (LPCSTR)"Эта Программная Процедура выполняет перемножение матриц", (LPCSTR)"Message", 0);
	cout << "This Procedure Simulates Matrix Multiplication algorithm" << endl;

	vector<BufType> pMatrixVariableInputArrayOne = vector<BufType>();
	vector<BufType> pMatrixVariableInputArrayTwo = vector<BufType>();
	vector<BufType> ppMatrixVariableOutputTypeVector = vector<BufType>();





	cout << "Stage One: Preparing the data for computations" << endl;
	cout << "Let Us View The First Matrix For Computation" << endl;
	pOutputFileStream << "Stage One: Preparing the data for computations" << endl;
	pOutputFileStream << "Let Us View The First Matrix For Computation" << endl;


	int xValue = 0;
	int yValue = 0;


	cout << "Filling the Data Buffer for Matrix One" << endl;
	pOutputFileStream << "Filling the Data Buffer for Matrix One" << endl;

	float pXPosition = 0;
	float pYPosition = 0;
	for (UINT pPixelObjectHSI : pImageArrayOne)
	{

		cout << "Matrix One Element At X = " << pXPosition << "And Y = " << pYPosition << " = " << pPixelObjectHSI << endl;
		pOutputFileStream << "Matrix One Element At X = " << pXPosition << "And Y = " << pYPosition << " = " << pPixelObjectHSI << endl;
		BufType  pMatrixVariableVar;
		pMatrixVariableVar.d = (double)pPixelObjectHSI;
		pMatrixVariableVar.i = pPixelObjectHSI;
		pMatrixVariableVar.f = pPixelObjectHSI;
		pXPosition = pXPosition + 1;

		if (pXPosition == pMatrixAWidth)
		{
			pYPosition = pYPosition + 1;
			pXPosition = 0;
		}
		pMatrixVariableInputArrayOne.push_back(pMatrixVariableVar);

	}

	cout << "Filling the Data Buffer For Matrix Two" << endl;
	pOutputFileStream << "Filling the Data Buffer For Matrix Two" << endl;

	for (UINT pPixelObjectHSI : pImageArrayTwo)
	{
		cout << "Matrix Two Element At X = " << pXPosition << "And Y = " << pYPosition << " = " << pPixelObjectHSI << endl;
		pOutputFileStream << "Matrix One Element At X = " << pXPosition << "And Y = " << pYPosition << " = " << pPixelObjectHSI << endl;
		BufType  pMatrixVariableVar;
		pMatrixVariableVar.d = (double)pPixelObjectHSI;
		pMatrixVariableVar.i = pPixelObjectHSI;
		pMatrixVariableVar.f = pPixelObjectHSI;

		pMatrixVariableInputArrayTwo.push_back(pMatrixVariableVar);

		if (pXPosition == pMatrixAWidth)
		{
			pYPosition = pYPosition + 1;
			pXPosition = 0;
		}

	}


	cout << "First We have to Initialize our Matrix Multiplication " << endl;
	pOutputFileStream << "First We have to Initialize our Matrix Multiplication Machine" << endl;

	ID3D11ComputeShader* pMatrixMultplyComputeShader = nullptr;
	ID3D11Buffer* pMatrixMultiplyConstantBuffer = nullptr;
	ID3D11Buffer* pMatrixMultiplyInputBufferOne = nullptr;
	ID3D11Buffer* pMatrixMultiplyInputBufferTwo = nullptr;
	ID3D11Buffer* pMatrixMultiplyOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pMatrixInputBufferSRVA = nullptr;
	ID3D11ShaderResourceView* pMatrixInputBufferSRVB = nullptr;
	ID3D11UnorderedAccessView* pMatrixOutputDataBufferUAV = nullptr;
	ID3D11Buffer* pMatrixMultiplyReadbackBuffer = nullptr;




	hr = InitializeMatrixMultiplicationResources(hInstance,
		hWnd,
		pMatrixVariableInputArrayOne,
		pMatrixVariableInputArrayTwo,
		pMatrixAHeight,
		pMatrixAWidth,
		pMatrixBHeight,
		pMatrixBWidth,
		pMatrixOutHeight,
		pMatrixOutWidth,
		&pMatrixMultplyComputeShader,
		&pMatrixMultiplyConstantBuffer,
		&pMatrixMultiplyInputBufferOne,
		&pMatrixMultiplyInputBufferTwo,
		&pMatrixMultiplyOutputBuffer,
		&pMatrixInputBufferSRVA,
		&pMatrixInputBufferSRVB,
		&pMatrixOutputDataBufferUAV);

	if (FAILED(hr))
	{
		cout << "Unable To Initialize the Resource for Matrix Multiply Operation" << endl;
		pOutputFileStream << "Unable To Initialize the Resource for Matrix Multiply Operation" << endl;
		return hr;
	}

	cout << "Running Our Matrix Multiplication Operation" << endl;
	pOutputFileStream << "Running Our Matrix Multiplication Operation" << endl;

    if (SUCCEEDED(hr))
	{
		cout << "Setting the Compute Shader For Matrix Multiply" << endl;
		m_pD3DCompContext->CSSetShader(pMatrixMultplyComputeShader, NULL, 0);
		ID3D11ShaderResourceView* ppShaderResourceViews[2] = { pMatrixInputBufferSRVA, pMatrixInputBufferSRVB };
		m_pD3DCompContext->CSSetShaderResources(0, 2, ppShaderResourceViews);
		ID3D11UnorderedAccessView* ppUnorderedAccessViews[1] = { pMatrixOutputDataBufferUAV };
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUnorderedAccessViews, NULL);
		m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pMatrixMultiplyConstantBuffer);
		m_pD3DCompContext->Dispatch(pMatrixBWidth, pMatrixAHeight, 1);
	}
	
	cout << "Creating the Readback Buffer" << endl;
	pOutputFileStream << "Creating the Readback Buffer" << endl;

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	pMatrixMultiplyOutputBuffer->GetDesc(&readback_buffer_desc);

	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.BindFlags = 0;
	readback_buffer_desc.MiscFlags = 0;

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, NULL, &pMatrixMultiplyReadbackBuffer);

	cout << "Copying Data From Output Buffer to Readback Buffer" << endl;

	m_pD3DCompContext->CopyResource(pMatrixMultiplyReadbackBuffer, pMatrixMultiplyOutputBuffer);


	D3D11_MAPPED_SUBRESOURCE pMammedResource;
	m_pD3DCompContext->Map(pMatrixMultiplyReadbackBuffer, 0, D3D11_MAP_READ, 0, &pMammedResource);
	BufType *pOutputData = (BufType*)pMammedResource.pData;

	for (UINT pHeightIndex = 0; pHeightIndex < pMatrixOutHeight; pHeightIndex++)
	{
		for (UINT pWidthIndex = 0; pWidthIndex < pMatrixOutWidth; pWidthIndex++)
		{
			cout << "Processing Matrix Row" << pHeightIndex << endl;
			cout << "Processing Matrix Column:" << pWidthIndex << endl;


			UINT pIndexValue = pHeightIndex * pMatrixOutWidth + pWidthIndex;
			float pMatixValueF = pOutputData[pHeightIndex * pMatrixOutWidth + pWidthIndex].f;
			int pMatixValueI = pOutputData[pHeightIndex * pMatrixOutWidth + pWidthIndex].i;
			double pMatixValueD = pOutputData[pHeightIndex * pMatrixOutWidth + pWidthIndex].d;

			cout << "Row Number: " << pWidthIndex << endl;
			cout << "Column Number: " << pWidthIndex << endl;

			cout << "Output Matrix ElementIndex: " << pIndexValue << endl;
			cout << "Float Value: " << pMatixValueF << endl;
			cout << "Int Value " << pMatixValueI << endl;
			cout << "Double: " << pMatixValueD << endl;



			pOutputFileStream << "Row Number: " << pWidthIndex << endl;
			pOutputFileStream << "Column Number: " << pWidthIndex << endl;

			pOutputFileStream << "Output Matrix ElementIndex: " << pIndexValue << endl;
			pOutputFileStream << "Float Value: " << pMatixValueF << endl;
			pOutputFileStream << "Int Value " << pMatixValueI << endl;
			pOutputFileStream << "Double: " << pMatixValueD << endl;
			BufType pOutputStruct;
			pOutputStruct.f = pMatixValueF;
			pOutputStruct.i = pMatixValueI;
			pOutputStruct.d = pMatixValueD;
			ppMatrixVariableOutputTypeVector.push_back(pOutputStruct);
		}
	}
	
	pOutputFileStream.close();
	*ppMatrixVariableOutputType = ppMatrixVariableOutputTypeVector;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateMatrixMultiplicatonOnCPU(HINSTANCE hInstance,
	HWND hWnd,
	vector<float>
	pMatrixArrayOne,
	vector<float> pMatrixArrayTwo, 
	vector<float> *pOutputVector)
{
	HRESULT hr = S_OK;
	ofstream pFileLogObject("C:\\\pixels\\MatrixMultiplicationOnCPU.txt");
	vector<float> pOutputDataVector = vector<float>();
	cout << "This Function Will Simulate the multiplication of two Matrices on CPU" << endl;
	cout << "For this Operation We will Use the DirectX Math Library" << endl;
	cout << "We will be using a XMMATRIX object class";

	cout << "Let us print the Contents for the Vector Of the First Matrix" << endl;

	pFileLogObject << "This Function Will Simulate the multiplication of two Matrices on CPU" << endl;
	pFileLogObject << "For this Operation We will Use the DirectX Math Library" << endl;
	pFileLogObject << "We will be using a XMMATRIX object class";
	pFileLogObject << "Let us print the Contents for the Vector Of the First Matrix" << endl;

	int pIndex = 0;

	for (float pMatrixValue : pMatrixArrayOne)
	{
		cout << "The Element of The First Matrix at Index: " << pIndex << " = " << pMatrixValue << endl;
		pFileLogObject << "The Element of The First Matrix at Index: " << pIndex << " = " << pMatrixValue << endl;
		pIndex = pIndex + 1;
	}

	cout << "Let Us Print the contents of the Second Matrix" << endl;
	pFileLogObject << "Let Us Print the contents of the Second Matrix" << endl;

	pIndex = 0;

	for (float pMatrixValue : pMatrixArrayOne)
	{
		cout << "The Element of The Second Matrix at Index: " << pIndex << " = " << pMatrixValue << endl;
		pFileLogObject << "The Element of The Second Matrix at Index: " << pIndex << " = " << pMatrixValue << endl;
		pIndex = pIndex + 1;
	}

	DirectX::XMMATRIX pMatrixObjectA = DirectX::XMMATRIX(&pMatrixArrayOne[0]);
	DirectX::XMMATRIX pMatrixObjectB = DirectX::XMMATRIX(&pMatrixArrayTwo[0]);

	DirectX::XMMATRIX pOutputMatrix = DirectX::XMMatrixMultiply(pMatrixObjectA, pMatrixObjectB);
	DirectX::XMFLOAT4X4 pOutputMatrixVar = DirectX::XMFLOAT4X4();
	DirectX::XMStoreFloat4x4(&pOutputMatrixVar, pOutputMatrix);
	pOutputDataVector.push_back(pOutputMatrixVar._11);
	pOutputDataVector.push_back(pOutputMatrixVar._12);
	pOutputDataVector.push_back(pOutputMatrixVar._14);
	pOutputDataVector.push_back(pOutputMatrixVar._13);
	pOutputDataVector.push_back(pOutputMatrixVar._21);
	pOutputDataVector.push_back(pOutputMatrixVar._22);
	pOutputDataVector.push_back(pOutputMatrixVar._23);
	pOutputDataVector.push_back(pOutputMatrixVar._24);
	pOutputDataVector.push_back(pOutputMatrixVar._31);
	pOutputDataVector.push_back(pOutputMatrixVar._32);
	pOutputDataVector.push_back(pOutputMatrixVar._33);
	pOutputDataVector.push_back(pOutputMatrixVar._34);
	pOutputDataVector.push_back(pOutputMatrixVar._41);
	pOutputDataVector.push_back(pOutputMatrixVar._42);
	pOutputDataVector.push_back(pOutputMatrixVar._43);
	pOutputDataVector.push_back(pOutputMatrixVar._44);

	cout << "Printing the Contents Of the Output Array" << endl;
	pIndex = 0;
	for (float pFloatValue : pOutputDataVector)
	{
		cout << "The Matrix Item At Index: " << pIndex << " = " << pFloatValue << endl;
		pFileLogObject << "The Matrix Item At Index: " << pIndex << " = " << pFloatValue << endl;
		pIndex = pIndex + 1;
	}

	*pOutputVector = pOutputDataVector;

	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::CreateStructuredBufferForSpeedValues(HINSTANCE hInstance, HWND hWnd, ID3D11Buffer* ppSpeedValuesBuffer, ID3D11UnorderedAccessView* ppSpeedResultsBufferUAV)
{
	HRESULT hr = S_OK;
	int pLastError = 0;

	D3D11_BUFFER_DESC outputBufferDesc;
	memset(&outputBufferDesc, NULL, sizeof(outputBufferDesc));
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = NUM_ELEMENTS * sizeof(SpeedValue);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = 4;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, NULL, &pAtomSpeedBufferW);
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не Удалось Создвть Структурный Буффер Скорости Газа", (LPCSTR)"Message", 0);
		pLastError = GetLastError();
		cout << "Unable to Create the Speed Output Buffer Error: " << pLastError << endl;
		return hr;
	}

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Структурный Буффер Скорости Газа", (LPCSTR)"Message", 0);
		cout << "The output buffer for speed values has been successfully created" << endl;

		D3D11_BUFFER_DESC outputBufferDescription;
		memset(&outputBufferDescription, NULL, sizeof(outputBufferDescription));
		pAtomSpeedBufferW->GetDesc(&outputBufferDescription);

		D3D11_UNORDERED_ACCESS_VIEW_DESC descView;
		memset(&descView, NULL, sizeof(descView));
		descView.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
		descView.Buffer.FirstElement = 0;
		descView.Format = DXGI_FORMAT_UNKNOWN;
		descView.Buffer.NumElements = buffer_desc.ByteWidth / buffer_desc.StructureByteStride;
		hr = m_pD3DCompDevice->CreateUnorderedAccessView(pAtomSpeedBufferW, &descView, &pGasSpeedOutputUAV);
	}
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не Удалось Создвть Буффер Ввода/Вывода для Скорости Звука в Газе", (LPCSTR)"Message", 0);
		pLastError = GetLastError();
		cout << "Unable to Create the Speed Output Buffer Unordered Access View: " << pLastError << endl;
	}
	ppSpeedValuesBuffer = pAtomSpeedBufferW;
	ppSpeedResultsBufferUAV = pGasSpeedOutputUAV;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::ComputeGasSpeed(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	cout << "Let Us Simulate Our Gas Dynamics Experiment" << endl;
	printf("Our first step is to prepare upcoming Data \n");
	
	GasDynamicsConstantBuffer pGasDynamicsConstantBufferObject;
	pGasDynamicsConstantBufferObject.pGammaVar = 1.6f;
	pGasDynamicsConstantBufferObject.pRValue = 8314.0f;
	pGasDynamicsConstantBufferObject.pGasMass = 39.35f;

	pTemperatureValues = vector<TemperatureStructure>();
	pSpeedValues = vector<SpeedValue>();

	vector<float> pTempValues = vector<float>();
	vector<float> pOutputSpeedResults = vector<float>();

	int pGetLastError = 0;
	cout << "Let's Update our DirectX Graphics Device" << endl;
	hr = InitializeD3D11Device(hWnd, 0);



	
	printf("Our Next Step is to Compile the Shader Program and Create the Actual Shader");




	printf("Our Shader has been compiled successfully");

	DWORD dwShaderFlags = D3DCOMPILE_ENABLE_STRICTNESS;
#ifdef _DEBUG
	// Set the D3DCOMPILE_DEBUG flag to embed debug information in the shaders.
	// Setting this flag improves the shader debugging experience, but still allows 
	// the shaders to be optimized and to run exactly the way they will run in 
	// the release configuration of this program.
	dwShaderFlags |= D3DCOMPILE_DEBUG;

	// Disable optimizations to further improve shader debugging
	dwShaderFlags |= D3DCOMPILE_SKIP_OPTIMIZATION;
#endif

	D3D_SHADER_MACRO defines[] =
	{
#ifdef USE_STRUCTURED_BUFFERS
		"USE_STRUCTURED_BUFFERS", "1",
#endif

#ifdef TEST_DOUBLE
		"TEST_DOUBLE", "1",
#endif
		nullptr, nullptr
	};

	// We generally prefer to use the higher CS shader profile when possible as CS 5.0 is better performance on 11-class hardware
	LPCSTR pProfile = (m_pD3DCompDevice->GetFeatureLevel() >= D3D_FEATURE_LEVEL_11_0) ? "cs_5_0" : "cs_4_0";

	ID3DBlob* pErrorBlob = nullptr;
	ID3DBlob* pBlob = nullptr;




	try
	{
		cout << "Creating device..." << endl;
		if (FAILED(hr))
			return 1;
		cout << "done\n" << endl;


		MessageBoxA(NULL, (LPCSTR)L"Начинаем наш эксперимент с подготовки констант", (LPCSTR)"Message", 0);
		cout << "Let Us Prepare Constants Values for the experiment" << endl;

		GasDynamicsConstantBuffer pGasDynamicsConstantBufferDesc;
		pGasDynamicsConstantBufferDesc.pGammaVar = 1.6f;
		pGasDynamicsConstantBufferDesc.pRValue = 8314.0f;
		pGasDynamicsConstantBufferDesc.pGasMass = 39.95f;

		cout << "Our Selected Gas is Argon" << endl;
		cout << "The Mass of Argon = " << pGasDynamicsConstantBufferDesc.pGasMass << endl;
		cout << "The R Constant Value = " << pGasDynamicsConstantBufferDesc.pRValue << endl;
		cout << "The Gamma Constant Value = " << pGasDynamicsConstantBufferDesc.pGammaVar << endl;

		cout << "Our Next step is to prepare the Temperature Value Range" << endl;
		MessageBoxA(hWnd, (LPCSTR)"Cледующим шагом готовим массив температур", (LPCSTR)"Message", 0);
		
		int indexVal = 0;
		for (float pTemperature = 1.0f; pTemperature <= 300.0f; ++pTemperature)
		{
			pTempValues.push_back(pTemperature);
			TemperatureStructure tempStruct;
			tempStruct.pTemperatureValue = pTemperature;
			pTemperatureValues.push_back(tempStruct);
			cout << "Temperature № " << indexVal << " Value = " << pTemperature << endl;
		}



		cout << "Creating Compute Shader..." << endl;
		// Compile the Bitonic Sort Compute Shader

		hr = CompileD3DShaderFromFileW(L"E:\\С\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ComputeGasSpeed1.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
		if (SUCCEEDED(hr))
		{
			hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &ppGasDynamicsComputeShaderW);
		}
		if (FAILED(hr))
		{
			pGetLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Произошла ошибка при создании Газодинамического шейдера", (LPCSTR)"Message", 0);
			cout << "We were unable to compile the Gas Dynamics Shader Program" << pGetLastError << endl;
			return hr;
		}

		

		hr = CreateGasDynamicsConstantBuffer(hInstance, hWnd, pGasDynamicsConstantBufferDesc, pGasDynamicsConstantBuffer);


		if (FAILED(hr))
		{
			pGetLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Произошла ошибка при создании констант газодинамической системы", (LPCSTR)"Message", 0);
			cout << "Unable to create the Constant Buffer for Gas Dynamics Shader Experiment" << pGetLastError << endl;
			return hr;
		}

		if (SUCCEEDED(hr))
		{
			cout << "The Constant Buffer For Gas Dynamics System Has Beeb Successfuly created has been successfully created" << endl;
			cout << "Now We will prepare the buffer for temperature values" << endl;
			MessageBoxA(hWnd, (LPCSTR)"Создаем Буффер Массива Температур", (LPCSTR)"Message", 0);
					
		hr = CreateStructuredBufferForTemperatureValues(hInstance,
			hWnd, pTemperatureValues, pAtomTempDataBuff, pAtomTempBuffSRV);
	
			
		}

		if (FAILED(hr))
		{
			pGetLastError = GetLastError();
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер Температур Газа", (LPCSTR)"Message", 0);
			cout << "Unable to Create the Structured Buffer" << pGetLastError;
			return hr;
		}

		if (SUCCEEDED(hr))
		{
			cout << "The Shader Resource View for the temperature Buffer Has Been Created" << endl;
			MessageBoxA(hWnd, (LPCSTR)"Создан структурный Буффер Температур Газа", (LPCSTR)"Message", 0);
			hr = CreateStructuredBufferForSpeedValues(hInstance, hWnd, pAtomSpeedBufferW,
				pGasSpeedOutputUAV);
			
		}
		if (SUCCEEDED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Создан структурный Буффер скорости звука в газе", (LPCSTR)"Message", 0);
			cout << "An output buffer for the speed values has been successfully created" << endl;
		}



		if (FAILED(hr))
		{
			MessageBoxA(hWnd, (LPCSTR)"Не удалось создать структурный Буффер скорости звука в газе", (LPCSTR)"Message", 0);
			pGetLastError = GetLastError();
			cout << "Unable To Create the Output Buffer for the Speed Values" << pGetLastError << endl;
			return hr;
		}

		try
		{
			
			printf("Runnig Compute Shader");
			hr = ExecuteGasDynamicsComputeShaderAlgorithm(hInstance,
			hWnd, ppGasDynamicsComputeShaderW,
			pGasDynamicsConstantBuffer, pConstantData, pAtomTempBuffSRV,
			pGasSpeedOutputUAV, NUM_ELEMENTS, 1, 1);
		

			//RunComputeShader(m_pD3DCompContext, ppGasDynamicsComputeShaderW,
			//	1, &pAtomTempBuffSRV, pGasDynamicsConstantBuffer, pConstantData, sizeof(pConstantData),
			//	ppGasSpeedDynamicsUAV, NUM_ELEMENTS, 1, 1);

			//			ExecuteGasDynamicsComputeShaderAlgorithm(hInstance, hWnd,
			//				ppGasDynamicsComputeShaderW, pGasDynamicsConstantBuffer, pConstantData,
			//				pAtomTempBuffSRV, pChannelHeightBufferSRV, pResultUAV, NUM_ELEMENTS, 1, 1);

		

			ID3D11Buffer* pReadBackOutputBuffer = nullptr;
			D3D11_MAPPED_SUBRESOURCE MappedResource1;
			float* p;
			BufType *pSpeedArray[NUM_ELEMENTS];
			vector<BufType> pSpeedArrayVector = vector<BufType>();

			D3D11_BUFFER_DESC outputDescBuff;
			ZeroMemory(&outputDescBuff, sizeof(outputDescBuff));
			pAtomSpeedBufferW->GetDesc(&outputDescBuff);

			outputDescBuff.Usage = D3D11_USAGE_STAGING;
			outputDescBuff.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
			outputDescBuff.BindFlags = 0;
			outputDescBuff.MiscFlags = 0;

			hr = m_pD3DCompDevice->CreateBuffer(&outputDescBuff, NULL, &pReadBackOutputBuffer);

		
			if (FAILED(hr))
			{
				cout << "A problem has occurred during function results output" << endl;
				return hr;
			}
			if (SUCCEEDED(hr))
			{
				m_pD3DCompContext->CopyResource(pReadBackOutputBuffer, pAtomSpeedBufferW);
				
				D3D11_MAPPED_SUBRESOURCE mappedResource;
				
				m_pD3DCompContext->Map(pReadBackOutputBuffer, 0, D3D11_MAP_READ, 0, &mappedResource);
				cout << "Your results are ready please enjoy" << endl;
				SpeedValue* pSpeedDataOutput[] = { (SpeedValue*)mappedResource.pData };
				vector<SpeedValue*> pFloatVector(pSpeedDataOutput, pSpeedDataOutput + sizeof(pSpeedDataOutput) / sizeof(pSpeedDataOutput[0]));
				int i = 0;
				for each (SpeedValue* pResult1 in pSpeedDataOutput)
				{
					float pResult = round(pResult1->pSpeedValue);
					cout << "Current Gas Speed Item at index" << pResult << endl;
					i = i + 1;
				}
			}

	
			// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
			// This is also a common trick to debug CS programs.
			cout << "Now We Will Try The same Computation of Sound Speed on the CPU" << endl;
			hr = ComputeGasDynamicsFormulaOneOnCPU(hInstance, hWnd);

		}
		catch (std::exception ex)
		{
			throw ex;
		}

	}
	catch (std::exception ex)
	{
		throw ex;
	}
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ComputeGasDynamicsFormulaTwoOnCPU(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
	ofstream myfile("gasdynamics2.txt");
	cout << "Let Us Simulate Gas Dynamics Experiment On CPU" << endl;
	myfile << "Let Us Simulate Gas Dynamics Experiment On CPU" << endl;

	cout << "Let Us Set Some Initial Parameters" << endl;
	myfile << "Let Us Set Some Initial Parameters" << endl;


	cout << "Our Selected Gas Is Called Argon" << endl;
	myfile << "Our Selected Gas Is Called Argon" << endl;

	vector<float> pHeightArray = vector<float>();
	vector<float> pSpeedArray = vector<float>();

	//Parameters and Constants
	cout << "Let Us Start by Preparing Our Input Parameters" << endl;
	
	myfile << "Let Us Start by Preparing Our Input Parameters" << endl;

	float pSoundFrequency = 0.0;
	pSoundFrequency = 80.0f * pow(10.0f, 6.0f);
	cout << "Your Sound Frequency = " << pSoundFrequency << endl;
	myfile << "Your Sound Frequency = " << pSoundFrequency << endl;

	float pSoundSpeedInSolid = 0.0f;
	pSoundSpeedInSolid = 3500.0f;
	cout << "The Value of Sound Speed In Solid =" << pSoundSpeedInSolid << endl;
	myfile << "The Value of Sound Speed In Solid =" << pSoundSpeedInSolid << endl;

	float pArgonDensity = 1.78f;
	cout << "The Density of Argon =" << pArgonDensity << endl;
	myfile << "The Density of Argon =" << pArgonDensity << endl;


	float RConst = 8314.0f;
	cout << "The Value Of R constant =" << RConst << endl;
	myfile << "The Value Of R constant =" << RConst << endl;

	float pArgonMass = 39.95f;
	cout << "The Mass Of Argon =" << pArgonMass << endl;
	myfile << "The Mass Of Argon =" << pArgonMass << endl;

	float pGasTemperature = 295.0f;
	cout << "The Temperature of the Gas = " << pGasTemperature << endl;
	myfile << "The Temperature of the Gas = " << pGasTemperature << endl;

	float pA0 = 0.0f;
	pA0 = 8.0f * pow(10, -10);
	cout << "The Value Of A0 =" << pA0 << endl;
	myfile << "The Value Of A0 =" << pA0 << endl;

	float pGammaVar = 1.6f;
	cout << "The Gamma Value" << pGammaVar << endl;;
	myfile << "The Gamma Value" << pGammaVar << endl;;

	float pDynamicArgonThickness = 0.0f;
	pDynamicArgonThickness = 22.75f * pow(10.0f, -6.0f);
	cout << "The Dynamic Gas Thickness Of Argon = " << pDynamicArgonThickness << endl;
	myfile << "The Dynamic Gas Thickness Of Argon = " << pDynamicArgonThickness << endl;

	float pHeatTansferCoefficient = 0.0178f;
	cout << "The Value of Heat Transfer Coefficent = " << pHeatTansferCoefficient << endl;
	myfile << "The Value of Heat Transfer Coefficent = " << pHeatTansferCoefficient << endl;

	float pHeatCapacityConstPressureArgon = 522.0f;
	cout << "The Argon Heat Capacity under Constant Pressure =" << pHeatCapacityConstPressureArgon << endl;
	myfile << "The Argon Heat Capacity under Constant Pressure =" << pHeatCapacityConstPressureArgon << endl;

	float pHeatCapacityConstVolumeArgon = 326.0f;
	cout << "The Argon Heat Capacity under Constant Volume =" << pHeatCapacityConstVolumeArgon << endl;
	myfile << "The Argon Heat Capacity under Constant Volume =" << pHeatCapacityConstVolumeArgon << endl;

	cout << "The Preparation Of Parameters Is Over" << endl;
	myfile << "The Preparation Of Parameters Is Over" << endl;




	cout << "Now We Will Start The Computations Step" << endl;
	myfile << "Now We Will Start The Computations Step" << endl;

	float pSoundOfSpeedInGas = 0;
	pSoundOfSpeedInGas = sqrt((RConst * pGasTemperature * pGammaVar) / pArgonMass);
	
	cout << "The Sound Speed in Argon =" << pSoundOfSpeedInGas << endl;
	myfile << "The Sound Speed in Argon =" << pSoundOfSpeedInGas << endl;

	cout << "The Mass Of Argon =" << pArgonMass << endl;
	myfile << "The Mass Of Argon =" << pArgonMass << endl;

	float pCyclicSoundFrequency = 0.0f;
	float pi_const = 3.14f;
	pCyclicSoundFrequency = 2 * pi_const * pSoundFrequency;
	cout << "Cyclic Sound Frequency = " << pCyclicSoundFrequency << endl;
	myfile << "Cyclic Sound Frequency = " << pCyclicSoundFrequency << endl;
	
	float pInitialSoundSpeed = 0.0f;
	float pVolumetricThickness = 0.0f;
	pInitialSoundSpeed = pCyclicSoundFrequency * pA0;
	cout << "Speed Amplitude Deviant =" << pInitialSoundSpeed << endl;
	myfile << "Speed Amplitude Deviant =" << pInitialSoundSpeed << endl;

	float pACoefficient = 0.0f;
	pACoefficient = ((4.0f * pDynamicArgonThickness) / 3.0f) + pVolumetricThickness + pHeatTansferCoefficient * ((1 / pHeatCapacityConstVolumeArgon) - (1 / pHeatCapacityConstPressureArgon)) / (pArgonDensity * pow(pSoundOfSpeedInGas, 2));
	cout << "The A Coeffficient = " << pACoefficient << endl;
	myfile << "Speed Amplitude Deviant =" << pInitialSoundSpeed << endl;

	float pXValue = 0.0f;
	float pYValue = 0.0f;
	pXValue = (pA0 * pow(pCyclicSoundFrequency, 2.0f)) / (2 * pSoundOfSpeedInGas);
	pYValue = (pCyclicSoundFrequency * pSoundOfSpeedInGas)* sqrt(1 - (pow(pSoundOfSpeedInGas, 2) / pow(pSoundSpeedInSolid, 2)));
	
	cout << "the value of X Variable = " << pXValue;
	cout << "the value of Y Variable = " << pYValue;
	
	float pXVarFactor = pYValue / pXValue;
	cout << "yVar / xVar =" << pXVarFactor; 
	float pAHash = atan(pXVarFactor);
	cout << "The A Hash Value =" << pAHash << endl;
	myfile << "Speed Amplitude Deviant =" << pInitialSoundSpeed << endl;

	float pSoundSpeedValue = 0.0f;
	float pVar1 = 0.0f;
	float pVar2 = 0.0f;
	float pVar3 = 0.0f;
	float pVar4 = 0.0f;
	float pXVarSum1 = 0.0f; 
	float pXVarSum2 = 0.0f;
	float pXVarSum3 = 0.0f;
	float pXVarSum4 = 0.0f;
	float pXVarSum5 = 0.0f;

	float pMinVarHeight = pow(10, -6);
	float pMaxVarHeight = pow(10, -4);
	float pStepVal = pow(10, -8);

	float pStep = pow(10, -8);
	int counterVar = 0;


//	for (float pHeightVar = pMinVarHeight; pHeightVar <= pMaxVarHeight; ++pStepVal)
//	{
		float pHeightVar = pow(10, -6);
		cout << "The Current Value Of Height =" << pHeightVar << endl;
		
		myfile << "The Current Value Of Height =" << pHeightVar << endl;

		pVar1 = (pArgonDensity * pow(pInitialSoundSpeed, 2) * pCyclicSoundFrequency) / (8.0f * pDynamicArgonThickness * pSoundSpeedInSolid);
		cout << "The Value of THE FIRST SEGMENT = " << pVar1 << endl;

			float pHypCos = ComputeHyperBolicCos(2 * pXValue * pHeightVar);
		cout << "The Value of hyperbolic cos var =" << pHypCos << endl;
		
		float pHypSin = ComputeHyperBolicSin(2 * pXValue * pHeightVar);
		cout << "The Value of Hyperbolic Sin Var= " << pHypSin << endl;

		float pSinVar = sin(2 * pACoefficient);
		cout << "the value under sin =" << pSinVar << endl;
		float pCosVar = cos(2 * pYValue * pHeightVar);
		cout << "the value under cosine =" << pCosVar << endl;
		pVar2 = (pSinVar) / (pHypCos - pCosVar);
		cout << "The Value of THE SECOND SEGMENT = " << pVar2 << endl;

		float pVarHSin = pow((2 * pXValue * pHeightVar), -1) * pHypSin;
		float pVarHCos = 0.5 * (1 + pHypCos);
		pVar3 = (pow(pXValue, -2) * ((1 / (2 * pXValue * pHeightVar) * pHypSin)) - 0.5 * (1 + pHypCos));
		cout << "The Value of the Third Segment = " << pVar3 << endl;

		pVar4 = pow(pYValue, -2) * pow((2 * pYValue * pHeightVar), -1) * sin(2 * pYValue * pHeightVar) - 0.5 * (1 + cos(2 * pYValue * pHeightVar));
		cout << "The Value of the Fourth Segment = " << pVar4 << endl;

		pSoundSpeedValue = pVar1 * pVar2 * (pVar3 - pVar4);

		cout << "Height = " << pHeightVar << "Speed = " << pSoundSpeedValue << endl;
		myfile << "Height = " << pHeightVar << "Speed = " << pSoundSpeedValue << endl;

		pSpeedArray.push_back(pSoundSpeedValue);
		
		counterVar = counterVar + 1;
		cout << "counter = " << counterVar << endl;
		myfile << "counter = " << counterVar << endl;

	//} 
	myfile.close();
	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::ComputeGasDynamicsFormulaOneOnCPU(HINSTANCE hInstance, HWND hWnd)
{



	HRESULT hr = S_OK;
	ofstream myfile("gasdynamics1.txt");

	GasDynamicsConstantBuffer pGasDynamicsConstantBufferDesc;
	pGasDynamicsConstantBufferDesc.pGammaVar = 1.6f;
	pGasDynamicsConstantBufferDesc.pRValue = 8314.0f;
	pGasDynamicsConstantBufferDesc.pGasMass = 39.95f;

	myfile << "Experiment Started" << endl;

	pTemperatureValues = vector<TemperatureStructure>();
	pSpeedValues = vector<SpeedValue>();

	vector<float> pTempValues = vector<float>();
	vector<float> pOutputSpeedResults = vector<float>();


	cout << "Our Selected Gas is Argon" << endl;
	cout << "The Mass of Argon = " << pGasDynamicsConstantBufferDesc.pGasMass << endl;
	cout << "The R Constant Value = " << pGasDynamicsConstantBufferDesc.pRValue << endl;
	cout << "The Gamma Constant Value = " << pGasDynamicsConstantBufferDesc.pGammaVar << endl;

	myfile << "Our Selected Gas is Argon" << endl;
	myfile << "The Mass of Argon = " << pGasDynamicsConstantBufferDesc.pGasMass << endl;
	myfile << "The R Constant Value = " << pGasDynamicsConstantBufferDesc.pRValue << endl;
	myfile << "The Gamma Constant Value = " << pGasDynamicsConstantBufferDesc.pGammaVar << endl;




	cout << "Our Next step is to prepare the Temperature Value Range" << endl;
	myfile << "Our Next step is to prepare the Temperature Value Range" << endl;

	MessageBoxA(hWnd, (LPCSTR)"Cледующим шагом готовим массив температур", (LPCSTR)"Message", 0);

	int indexVal = 0;
	for (float pTemperature = 1.0f; pTemperature <= 300.0f; ++pTemperature)
	{
		pTempValues.push_back(pTemperature);
		TemperatureStructure tempStruct;
		tempStruct.pTemperatureValue = pTemperature;
		pTemperatureValues.push_back(tempStruct);
		cout << "Temperature № " << indexVal << " Value = " << pTemperature << endl;
		myfile << "Temperature № " << indexVal << " Value = " << pTemperature << endl;
	}


	
	cout << "Now We Will Try The same Computation of Sound Speed on the CPU" << endl;
	
	vector <float> pSpeedDataVals = vector<float>();
	for each (TemperatureStructure pTempStruct in pTemperatureValues)
	{
		float pTemperature = pTempStruct.pTemperatureValue;
		float pGasMass = pGasDynamicsConstantBufferDesc.pGasMass;
		float pVal = (pTemperature * pGasDynamicsConstantBufferDesc.pRValue * pGasDynamicsConstantBufferDesc.pGammaVar) / pGasMass;
		float pSpeedVal = sqrt(pVal);
		pSpeedDataVals.push_back(round(pSpeedVal));
	}
	int itemIndex = 1;
	for each (float pSpeedValue in pSpeedDataVals)
	{
		cout << "Current Gas Speed Parameter " << itemIndex << " = " << pSpeedValue << endl;
		myfile << "Current Gas Speed Parameter " << itemIndex << " = " << pSpeedValue << endl;

	}
	myfile.close();
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ExecuteGasDynamicsComputeShaderAlgorithm(HINSTANCE hInstance, HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11Buffer* pConstantBuffer, void* pCSDData,
	ID3D11ShaderResourceView* pAtomTempBuffSRV1, ID3D11UnorderedAccessView* pSpeedUAV1,
	int xVal, int yVal, int zVal)
{

	HRESULT hr = S_OK;
	cout << "First We Will Setup the Compute Shader" << endl;
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	cout << "Next We Will Setup the Shader Resource View" << endl;
	m_pD3DCompContext->CSSetShaderResources(0, 1, &pAtomTempBuffSRV1);
	cout << "Next We Will Setup the Unordered Access View" << endl;
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pSpeedUAV1, 0);


	if (pCSDData)
	{
		cout << "Now we will install the constant buffers" << endl;

		D3D11_MAPPED_SUBRESOURCE mappedResource;
		hr = m_pD3DCompContext->Map(pConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
		memcpy(mappedResource.pData, pCSDData, sizeof(mappedResource.pData));
		m_pD3DCompContext->Unmap(pConstantBuffer, 0);
		ID3D11Buffer* ppCurrentBuffers[1] = { pConstantBuffer };
		m_pD3DCompContext->CSSetConstantBuffers(0, 1, ppCurrentBuffers);
	}
	cout << "Now it is time to execute the Compute Shader" << endl;
	try
	{
		m_pD3DCompContext->Dispatch(xVal, yVal, zVal);
	}

	catch (std::exception ex)
	{
		throw ex;
	}

	return hr;
}


DirectXStandardAlgorithmExecutor* DirectXStandardAlgorithmExecutor::Instance(HINSTANCE hInstance, HWND hWnd)
{
	if (_algorithmExecutorInstance == 0)
	{
		_algorithmExecutorInstance = new DirectXStandardAlgorithmExecutor(hInstance, hWnd);
	}
	return _algorithmExecutorInstance;
}




DirectXStandardAlgorithmExecutor::~DirectXStandardAlgorithmExecutor(void)
{
}

void DirectXStandardAlgorithmExecutor::Render()
{

}

const std::string DirectXStandardAlgorithmExecutor::OutputCurrentTime()
{
	
		time_t     now = time(0);
		struct tm  tstruct;
		char       buf[80];
	
		// Visit http://en.cppreference.com/w/cpp/chrono/c/strftime
		// for more information about date/time format
		strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);

		return buf;
	
}

void DirectXStandardAlgorithmExecutor::CreateNewComputationTask(LPCSTR fName, LPCSTR dataSet, LPCSTR output)
{

}


ID3D11Buffer* DirectXStandardAlgorithmExecutor::CreateAndCopyToDebugBufferW(ID3D11Buffer* pBuffer, ID3D11Device *pDevice, ID3D11DeviceContext *pContextOut)  //release the returned buffer
{
	ID3D11Buffer* debugbuf = NULL;

	D3D11_BUFFER_DESC desc;
	ZeroMemory(&desc, sizeof(desc));
	pBuffer->GetDesc(&desc);
	desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	desc.Usage = D3D11_USAGE_STAGING;
	desc.BindFlags = 0;
	desc.MiscFlags = 0;


	pDevice->CreateBuffer(&desc, NULL, &debugbuf);
	pContextOut->CopyResource(debugbuf, pBuffer);

	return debugbuf;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeMatrixDeterminantResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pMatrixOne,
	UINT pMatrixAHeight,
	UINT pMatrixAWidth,
	UINT pMatrixOutHeight,
	UINT pMatrixOutWidth,
	ID3D11ComputeShader** ppMatrixComputeShader,
	ID3D11Buffer** ppMatrixMultiplyConstantBuffer,
	ID3D11Buffer** ppMatrixMultiplyInputBufferB,
	ID3D11Buffer** ppMatrixMultiplyOutputBuffer,
	ID3D11ShaderResourceView** pOutputSRV0,
	ID3D11UnorderedAccessView** pOutputUAV)
{

	HRESULT hr = S_OK;
	fstream pMatrixInitializationLog("C:\\\pixels\\MatrixMulInit.txt");

	cout << "This Function Is Used To Initialize The Resources for Matrix Muliply" << endl;
	cout << "For This Function We Will Use" << endl;
	cout << "1 Compute Shader Object" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "2 Main Input Data Buffers" << endl;
	cout << "1 Output Data Buffers" << endl;
	cout << "2 Shader Resource Views" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	pMatrixInitializationLog << "This Function Is Used To Initialize The Resources for Matrix Muliply" << endl;
	pMatrixInitializationLog << "For This Function We Will Use" << endl;
	pMatrixInitializationLog << "1 Compute Shader Object" << endl;
	pMatrixInitializationLog << "1 Constant Buffer" << endl;
	pMatrixInitializationLog << "2 Main Input Data Buffers" << endl;
	pMatrixInitializationLog << "1 Output Data Buffers" << endl;
	pMatrixInitializationLog << "2 Shader Resource Views" << endl;
	pMatrixInitializationLog << "1 Unordered Access View" << endl;
	pMatrixInitializationLog << "1 Readback Buffer" << endl;

	UINT pAmountOfSamples = pMatrixOne.size();
	UINT uiElementSize = sizeof(BufType);
	ID3DBlob* pMatrixMultiplyCS = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputDataBufferA = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataBufferSRVOne = nullptr;
	ID3D11UnorderedAccessView* pOutputDataBufferUAV = nullptr;
	ID3D11Buffer* pReadbackDataBuffer = nullptr;
	ID3D11ComputeShader* pMatrixMultiplyComputeShader = nullptr;


	const UINT uiElementSizeA = sizeof(BufType);
	const UINT uNumElementsA = uiElementSizeA * pMatrixOne.size();

	cout << "Creating The Initial Data Storing Buffers for Matrix A and B" << endl;

	D3D11_SUBRESOURCE_DATA pMatrixAData;
	ZeroMemory(&pMatrixAData, sizeof(pMatrixAData));
	pMatrixAData.pSysMem = &pMatrixOne[0];



	cout << "Creating the Structured Buffer for Matrix A" << endl;
	pMatrixInitializationLog << "Creating the Structured Buffer for Matrix A" << endl;

	D3D11_BUFFER_DESC buffer_desc_matrix_one;
	ZeroMemory(&buffer_desc_matrix_one, sizeof(buffer_desc_matrix_one));
	buffer_desc_matrix_one.ByteWidth = sizeof(BufType) * uNumElementsA;
	buffer_desc_matrix_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_matrix_one.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_matrix_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_matrix_one.StructureByteStride = sizeof(BufType);


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_matrix_one, &pMatrixAData, &pMatrixObjectBuffer0);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Buffer for Matrix0 exit Returned An Error: " << pLastError << endl;
		pMatrixInitializationLog << "Buffer for Matrix0 exit Returned An Error: " << pLastError << endl;

		return hr;

	}


	cout << "Creating the Shader Resource View for MatrixB Buffer" << endl;
	pMatrixInitializationLog << "Creating the Shader Resource View for MatrixB Buffer" << endl;

	cout << "Setting Parameters" << endl;
	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_matrix_one;
	ZeroMemory(&srvbuffer_desc_matrix_one, sizeof(srvbuffer_desc_matrix_one));
	srvbuffer_desc_matrix_one.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_matrix_one.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_matrix_one.Buffer.FirstElement = 0;
	srvbuffer_desc_matrix_one.Buffer.NumElements = pMatrixOne.size();
	cout << "Creating the Shader Resource View For Matrix A" << endl;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pMatrixObjectBuffer0, &srvbuffer_desc_matrix_one, &pMatrixBufferZeroSRV);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Shader Resource View for MatrixA Completed With Errorw: " << pLastError << endl;

		return hr;

	}



	cout << "Creating the Output Data Buffer " << endl;



	D3D11_BUFFER_DESC buffer_desc_out;
	ZeroMemory(&buffer_desc_out, sizeof(buffer_desc_out));
	buffer_desc_out.StructureByteStride = sizeof(BufType);
	buffer_desc_out.ByteWidth = sizeof(BufType) * uNumElementsA;
	buffer_desc_out.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_out.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_out.Usage = D3D11_USAGE_DEFAULT;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_out, NULL, &pMatrixComputeOuptutDataBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Buffer1 CreateBuffer Stage Returned An Error: " << pLastError << endl;
		return hr;

	}

	cout << "Creating the Unordered Access View for the Output" << endl;

	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));

	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 0;
	uavbuffer_desc.Buffer.NumElements = pMatrixOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pMatrixComputeOuptutDataBuffer, &uavbuffer_desc, &pMatrixOutputBufferUAV);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unordered Access View Resource exit CreateUnorderedAcccessView  Stage Returned An Error: " << pLastError << endl;
		return hr;

	}





	cout << "Compiling The Matrix Multiply Compute Shader" << endl;
	pMatrixInitializationLog << "Compiling The Matrix Multiply Compute Shader" << endl;





	cout << "Creating the Constant Buffer " << endl;
	pMatrixInitializationLog << "Creating the Constant Buffer " << endl;



	D3D11_BUFFER_DESC matrix_constant_buffer_desc;
	ZeroMemory(&matrix_constant_buffer_desc, sizeof(matrix_constant_buffer_desc));
	matrix_constant_buffer_desc.ByteWidth = 16 * ((sizeof(MatrixDeterminantCB) + 15) / 16);
	matrix_constant_buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
	matrix_constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	matrix_constant_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;


	hr = m_pD3DCompDevice->CreateBuffer(&matrix_constant_buffer_desc, NULL, &pConstantBufferObject);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << " Unable to Create The Constant Buffer for Matrix Multiply " << pLastError << endl;
		pMatrixInitializationLog << " Unable to Create The Constant Buffer for Matrix Multiply " << pLastError << endl;

		return hr;
	}

	D3D11_MAPPED_SUBRESOURCE MappedSubresource;
	m_pD3DCompContext->Map(pConstantBufferObject, 0, D3D11_MAP_WRITE_DISCARD, 0, &MappedSubresource);

    MatrixDeterminantCB* pConstantBufferDataArr = (MatrixDeterminantCB*)MappedSubresource.pData;
	pConstantBufferDataArr->pWidthA = pMatrixAWidth;
	pConstantBufferDataArr->pHeightA = pMatrixAHeight;
	pConstantBufferDataArr->pWidthOut = pMatrixOutWidth;
	pConstantBufferDataArr->pHeightOut = pMatrixOutHeight;

	m_pD3DCompContext->Unmap(pConstantBufferObject, 0);




	cout << "Compiling the Compute Shader Object" << endl;
	ID3DBlob* ppOutputBlob = nullptr;
	ID3DBlob* pErrorBlob = nullptr;

	D3D10_SHADER_MACRO pShaderMacro[3] = { { "GROUP_SIZE_X", "1" }, { "GROUP_SIZE_Y", "1" },
	{ NULL, NULL } };

	LPCWSTR szFileName = L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeMatrixDeterminant.hlsl";

	hr = D3DCompileFromFile(szFileName, pShaderMacro, D3D_COMPILE_STANDARD_FILE_INCLUDE, "CS_Main", "cs_5_0",
		NULL, NULL, &ppOutputBlob, &pErrorBlob);

	if (pErrorBlob)
	{
		OutputDebugString((LPCWSTR)pErrorBlob->GetBufferPointer());
		printf((char*)pErrorBlob->GetBufferPointer());
	}

	if (FAILED(hr))
	{
		int pError = GetLastError();
		cout << "Unable To Compile the Compute Shader Object Error: " << endl;


		if (pError == ERROR_ARITHMETIC_OVERFLOW)
		{
			MessageBoxA(NULL, (LPCSTR)L"При компиляции шейдера произошло переполнение памяти", (LPCSTR)"Message", 0);
		}


		SafeReleaseA(&pErrorBlob);

		return hr;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Matrix Determinant Shader Compilation terminated with Error: " << pLastError << endl;
		pMatrixInitializationLog << "Matrix Multipication Shader Compilation terminated with Error: " << pLastError << endl;
		return hr;
	}

	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(ppOutputBlob->GetBufferPointer(), ppOutputBlob->GetBufferSize(), nullptr, &pMatrixMultiplyComputeShader);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Matrix Multipication Shader exit terminated with Error: " << pLastError << endl;
		pMatrixInitializationLog << "Matrix Multipication Shader Compilation terminated with Error: " << pLastError << endl;
		return hr;
	}



	*ppMatrixComputeShader = pMatrixMultiplyComputeShader;
	*ppMatrixMultiplyConstantBuffer = pConstantBufferObject;
	*ppMatrixMultiplyInputBufferB = pMatrixObjectBuffer1;
	*ppMatrixMultiplyOutputBuffer = pMatrixComputeOuptutDataBuffer;
	*pOutputSRV0 = pMatrixBufferZeroSRV;
	*pOutputUAV = pMatrixOutputBufferUAV;
	pMatrixInitializationLog.close();

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitializeMatrixMultiplicationResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pMatrixOne,
	vector<BufType> pMatrixTwo,
	UINT pMatrixAHeight,
	UINT pMatrixAWidth,
	UINT pMatrixBHeight,
	UINT pMatrixBWidth,
	UINT pMatrixOutHeight,
	UINT pMatrixOutWidth,
	ID3D11ComputeShader** ppMatrixComputeShader,
	ID3D11Buffer** ppMatrixMultiplyConstantBuffer,
	ID3D11Buffer** ppMatrixMultiplyInputBufferA,
	ID3D11Buffer** ppMatrixMultiplyInputBufferB,
	ID3D11Buffer** ppMatrixMultiplyOutputBuffer,
	ID3D11ShaderResourceView** pOutputSRV0,
	ID3D11ShaderResourceView** pOutputSRV1,
	ID3D11UnorderedAccessView** pOutputUAV)
{

	HRESULT hr = S_OK;
	fstream pMatrixInitializationLog("C:\\pixels\\MatrixMulInit.txt");

	cout << "This Function Is Used To Initalize The Resources for Matrix Muliply" << endl;
	cout << "For This Function We Will Use" << endl;
	cout << "1 Compute Shader Object" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "2 Main Input Data Buffers" << endl;
	cout << "1 Output Data Buffers" << endl;
	cout << "2 Shader Resource Views" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	pMatrixInitializationLog << "This Function Is Used To Initialize The Resources for Matrix Muliply" << endl;
	pMatrixInitializationLog << "For This Function We Will Use" << endl;
	pMatrixInitializationLog << "1 Compute Shader Object" << endl;
	pMatrixInitializationLog << "1 Constant Buffer" << endl;
	pMatrixInitializationLog << "2 Main Input Data Buffers" << endl;
	pMatrixInitializationLog << "1 Output Data Buffers" << endl;
	pMatrixInitializationLog << "2 Shader Resource Views" << endl;
	pMatrixInitializationLog << "1 Unordered Access View" << endl;
	pMatrixInitializationLog << "1 Readback Buffer" << endl;

	UINT pAmountOfSamples = pMatrixOne.size();
	UINT uiElementSize = sizeof(BufType);
	ID3DBlob* pMatrixMultiplyCS = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pInputDataBufferA = nullptr;
	ID3D11Buffer* pInputDataBufferB = nullptr;
	ID3D11Buffer* pOutputDataBuffer = nullptr;
	ID3D11ShaderResourceView* pInputDataBufferSRVOne = nullptr;
	ID3D11ShaderResourceView* pInputDataBufferSRVTwo = nullptr;
	ID3D11UnorderedAccessView* pOutputDataBufferUAV = nullptr;
	ID3D11Buffer* pReadbackDataBuffer = nullptr;
	ID3D11ComputeShader* pMatrixMultiplyComputeShader = nullptr;


	const UINT uiElementSizeA = sizeof(BufType);
	const UINT uNumElementsA = uiElementSizeA * pMatrixOne.size();
	const UINT uNumElementsB = uiElementSizeA * pMatrixTwo.size();

	cout << "Creating The Initial Data Storing Buffers for Matrix A and B" << endl;

	D3D11_SUBRESOURCE_DATA pMatrixAData;
	ZeroMemory(&pMatrixAData, sizeof(pMatrixAData));
	pMatrixAData.pSysMem = &pMatrixOne[0];

	D3D11_SUBRESOURCE_DATA pMatrixBData;
	ZeroMemory(&pMatrixBData, sizeof(pMatrixBData));
	pMatrixBData.pSysMem = &pMatrixTwo[0];


	cout << "Creating the Structured Buffer for Matrix A" << endl;
	pMatrixInitializationLog << "Creating the Structured Buffer for Matrix A" << endl;

	D3D11_BUFFER_DESC buffer_desc_matrix_one;
	ZeroMemory(&buffer_desc_matrix_one, sizeof(buffer_desc_matrix_one));
	buffer_desc_matrix_one.ByteWidth = sizeof(BufType) * uNumElementsA;
	buffer_desc_matrix_one.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_matrix_one.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_matrix_one.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_matrix_one.StructureByteStride = sizeof(BufType);


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_matrix_one, &pMatrixAData, &pMatrixObjectBuffer0);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Buffer for Matrix0 exit Returned An Error: " << pLastError << endl;
		pMatrixInitializationLog << "Buffer for Matrix0 exit Returned An Error: " << pLastError << endl;

		return hr;

	}

	cout << "Creating the Structured Buffer for Matrix B" << endl;
	pMatrixInitializationLog << "Creating the Structured Buffer for Matrix B" << endl;


	D3D11_BUFFER_DESC buffer_desc_matrix_two;
	ZeroMemory(&buffer_desc_matrix_two, sizeof(buffer_desc_matrix_two));
	buffer_desc_matrix_two.ByteWidth = sizeof(BufType) * uNumElementsB;
	buffer_desc_matrix_two.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_matrix_two.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
	buffer_desc_matrix_two.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_matrix_two.StructureByteStride = sizeof(BufType);


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_matrix_two, &pMatrixBData, &pMatrixObjectBuffer1);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Buffer for MatrixB exit Returned An Error: " << pLastError << endl;
		pMatrixInitializationLog << "Buffer for MatrixB exit Returned An Error: " << pLastError << endl;

		return hr;

	}



	cout << "Creating the Shader Resource View for MatrixB Buffer" << endl;
	pMatrixInitializationLog << "Creating the Shader Resource View for MatrixB Buffer" << endl;

	cout << "Setting Parameters" << endl;
	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_matrix_one;
	ZeroMemory(&srvbuffer_desc_matrix_one, sizeof(srvbuffer_desc_matrix_one));
	srvbuffer_desc_matrix_one.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_matrix_one.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_matrix_one.Buffer.FirstElement = 0;
	srvbuffer_desc_matrix_one.Buffer.NumElements = pMatrixOne.size();
	cout << "Creating the Shader Resource View For Matrix A" << endl;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pMatrixObjectBuffer0, &srvbuffer_desc_matrix_one, &pMatrixBufferZeroSRV);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Shader Resource View for MatrixA Completed With Errorw: " << pLastError << endl;

		return hr;

	}

	cout << "Creating the Shader Resource View for MatrixB Buffer" << endl;
	pMatrixInitializationLog << "Creating the Shader Resource View for MatrixB Buffer" << endl;

	cout << "Setting Parameters" << endl;
	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_matrix_two;
	ZeroMemory(&srvbuffer_desc_matrix_two, sizeof(srvbuffer_desc_matrix_two));
	srvbuffer_desc_matrix_two.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_matrix_two.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_matrix_two.Buffer.FirstElement = 0;
	srvbuffer_desc_matrix_two.Buffer.NumElements = pMatrixTwo.size();
	cout << "Creating the Shader Resource View For Matrix A" << endl;


	hr = m_pD3DCompDevice->CreateShaderResourceView(pMatrixObjectBuffer1, &srvbuffer_desc_matrix_two, &pMatrixBufferOneSRV);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Shader Resource View for MatrixA Completed With Errorw: " << pLastError << endl;

		return hr;

	}


	cout << "Creating the Output Data Buffer " << endl;



	D3D11_BUFFER_DESC buffer_desc_out;
	ZeroMemory(&buffer_desc_out, sizeof(buffer_desc_out));
	buffer_desc_out.StructureByteStride = sizeof(BufType);
	buffer_desc_out.ByteWidth = sizeof(BufType) * uNumElementsA;
	buffer_desc_out.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_out.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_out.Usage = D3D11_USAGE_DEFAULT;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_out, NULL, &pMatrixComputeOuptutDataBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Buffer1 CreateBuffer Stage Returned An Error: " << pLastError << endl;
		return hr;

	}

	cout << "Creating the Unordered Access View for the Output" << endl;

	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));

	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 0;
	uavbuffer_desc.Buffer.NumElements = pMatrixOne.size();


	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pMatrixComputeOuptutDataBuffer, &uavbuffer_desc, &pMatrixOutputBufferUAV);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unordered Access View Resource exit CreateUnorderedAcccessView  Stage Returned An Error: " << pLastError << endl;
		return hr;

	}





	cout << "Compiling The Matrix Multiply Compute Shader" << endl;
	pMatrixInitializationLog << "Compiling The Matrix Multiply Compute Shader" << endl;





	cout << "Creating the Constant Buffer " << endl;
	pMatrixInitializationLog << "Creating the Constant Buffer " << endl;



	D3D11_BUFFER_DESC matrix_constant_buffer_desc;
	ZeroMemory(&matrix_constant_buffer_desc, sizeof(matrix_constant_buffer_desc));
	matrix_constant_buffer_desc.ByteWidth = 16 * ((sizeof(MatrixMultiplyCB) + 15) / 16);
	matrix_constant_buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
	matrix_constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	matrix_constant_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;


	hr = m_pD3DCompDevice->CreateBuffer(&matrix_constant_buffer_desc, NULL, &pConstantBufferObject);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << " Unable to Create The Constant Buffer for Matrix Multiply " << pLastError << endl;
		pMatrixInitializationLog << " Unable to Create The Constant Buffer for Matrix Multiply " << pLastError << endl;

		return hr;
	}

	D3D11_MAPPED_SUBRESOURCE MappedSubresource;
	m_pD3DCompContext->Map(pConstantBufferObject, 0, D3D11_MAP_WRITE_DISCARD, 0, &MappedSubresource);

	MatrixMultiplyCB* pConstantBufferDataArr = (MatrixMultiplyCB*)MappedSubresource.pData;
	pConstantBufferDataArr->pWidthA = pMatrixAWidth;
	pConstantBufferDataArr->pHeightA = pMatrixAHeight;
	pConstantBufferDataArr->pWidthB = pMatrixBWidth;
	pConstantBufferDataArr->pHeigtB = pMatrixBHeight;
	pConstantBufferDataArr->pWidthOut = pMatrixOutWidth;
	pConstantBufferDataArr->pHeightOut = pMatrixOutHeight;

	m_pD3DCompContext->Unmap(pConstantBufferObject, 0);




	cout << "Compiling the Compute Shader Object" << endl;
	ID3DBlob* ppOutputBlob = nullptr;
	ID3DBlob* pErrorBlob = nullptr;

	D3D10_SHADER_MACRO pShaderMacro[3] = { { "GROUP_SIZE_X", "1" }, { "GROUP_SIZE_Y", "1" },
	{ NULL, NULL } };

	LPCWSTR szFileName = L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSMatrixMultiplyJasonYang.hlsl";

	hr = D3DCompileFromFile(szFileName, pShaderMacro, D3D_COMPILE_STANDARD_FILE_INCLUDE, "CS_Main", "cs_5_0",
		NULL, NULL, &ppOutputBlob, &pErrorBlob);

	if (pErrorBlob)
	{
		OutputDebugString((LPCWSTR)pErrorBlob->GetBufferPointer());
		printf((char*)pErrorBlob->GetBufferPointer());
	}

	if (FAILED(hr))
	{
		int pError = GetLastError();
		cout << "Unable To Compile the Compute Shader Object Error: " << endl;


		if (pError == ERROR_ARITHMETIC_OVERFLOW)
		{
			MessageBoxA(NULL, (LPCSTR)L"При компиляции шейдера произошло переполнение памяти", (LPCSTR)"Message", 0);
		}


		SafeReleaseA(&pErrorBlob);

		return hr;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Matrix Multipication Shader Compilation terminated with Error: " << pLastError << endl;
		pMatrixInitializationLog << "Matrix Multipication Shader Compilation terminated with Error: " << pLastError << endl;
		return hr;
	}

	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(ppOutputBlob->GetBufferPointer(), ppOutputBlob->GetBufferSize(), nullptr, &pMatrixMultiplyComputeShader);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Matrix Multipication Shader exit terminated with Error: " << pLastError << endl;
		pMatrixInitializationLog << "Matrix Multipication Shader Compilation terminated with Error: " << pLastError << endl;
		return hr;
	}



	*ppMatrixComputeShader = pMatrixMultiplyComputeShader;
	*ppMatrixMultiplyConstantBuffer = pConstantBufferObject;
	*ppMatrixMultiplyInputBufferA = pMatrixObjectBuffer0;
	*ppMatrixMultiplyInputBufferB = pMatrixObjectBuffer1;
	*ppMatrixMultiplyOutputBuffer = pMatrixComputeOuptutDataBuffer;
	*pOutputSRV0 = pMatrixBufferZeroSRV;
	*pOutputSRV1 = pMatrixBufferOneSRV;
	*pOutputUAV = pMatrixOutputBufferUAV;
	pMatrixInitializationLog.close();

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeArrrayAdditionUsingAppendConsumeResources(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppInputBuffer2,
	ID3D11Buffer** ppOutputBuffer,
	vector<UINT> pArrayOneVals,
	vector<UINT> pArrayTwoVals,
	ID3D11ShaderResourceView** ppInputSRV1,
	ID3D11ShaderResourceView** ppInputSRV2,
	ID3D11UnorderedAccessView** ppInputUAV1,
	ID3D11UnorderedAccessView** ppInputUAV2,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer,
	vector<BufType> *ppOutputArr0,
	vector<BufType> *ppOutputArr1)
{

	HRESULT hr = S_OK;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewOne = nullptr;
	ID3D11ShaderResourceView* pShaderResourceViewTwo = nullptr;
	ID3D11UnorderedAccessView* pInputUAV1 = nullptr;
	ID3D11UnorderedAccessView* pInputUAV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<BufType> pInputBufferObjectOne = vector<BufType>();
	vector<BufType> pInputBufferObjectTwo = vector<BufType>();

	for (UINT pArrayValue : pArrayOneVals)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBufferObjectOne.push_back(pParameterVar);
	}

	for (UINT pArrayValue : pArrayTwoVals)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBufferObjectTwo.push_back(pParameterVar);
	}



	// Create the Buffer of Elements
	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(BufType);


	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputBufferObjectOne[0];


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);
	if (FAILED(hr))
	{
		return hr;
	}



	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc2;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc2.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	buffer_desc2.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc2.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc2.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc2.StructureByteStride = sizeof(BufType);


	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pInputBufferObjectTwo[0];




	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);
	if (FAILED(hr))
		return hr;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData1, &pInputBuffer2);

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags |=   D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(BufType);



	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc1;
	ZeroMemory(&uavbuffer_desc1, sizeof(uavbuffer_desc1));
	uavbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc1.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc1.Buffer.NumElements = pInputBufferObjectOne.size();
	uavbuffer_desc1.Buffer.Flags = D3D11_BUFFER_UAV_FLAG_APPEND;


	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc2;
	ZeroMemory(&uavbuffer_desc2, sizeof(uavbuffer_desc2));
	uavbuffer_desc2.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc2.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc2.Buffer.NumElements = pInputBufferObjectTwo.size();
	uavbuffer_desc2.Buffer.Flags = D3D11_BUFFER_UAV_FLAG_APPEND;

	

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pInputBuffer1, &uavbuffer_desc1, &pInputUAV1);
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pInputBuffer2, &uavbuffer_desc2, &pInputUAV2);

	if (FAILED(hr))
		return hr;



	if (FAILED(hr))
		return hr;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputBufferObjectOne.size();
	uavbuffer_desc.Buffer.Flags = D3D11_BUFFER_UAV_FLAG_APPEND;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (FAILED(hr))
		return hr;


	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(BufType);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (FAILED(hr))
		return hr;
	*ppInputBuffer1 = pInputBuffer1;
	*ppInputBuffer2 = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV1 = pShaderResourceViewOne;
	*ppInputSRV2 = pShaderResourceViewTwo;
	*ppInputUAV1 = pInputUAV1;
	*ppInputUAV2 = pInputUAV2;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	*ppOutputArr0 = pInputBufferObjectOne;
	*ppOutputArr1 = pInputBufferObjectTwo;
	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializeArrayAdditionResources(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppInputBuffer2,
	ID3D11Buffer** ppOutputBuffer,
	vector<UINT> pArrayOneVals,
	vector<UINT> pArrayTwoVals,
	ID3D11ShaderResourceView** ppInputSRV1,
	ID3D11ShaderResourceView** ppInputSRV2,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer,
	vector<BufType> *ppOutputArr0,
	vector<BufType> *ppOutputArr1)
{

	HRESULT hr = S_OK;

	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11ShaderResourceView* pOutputSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	ID3D11ShaderResourceView* pAdditionAlgorithmsSRV[2];
	vector<BufType> pInputBufferObjectOne = vector<BufType>();
	vector<BufType> pInputBufferObjectTwo = vector<BufType>();

	for (UINT pArrayValue : pArrayOneVals)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBufferObjectOne.push_back(pParameterVar);
	}

	for (UINT pArrayValue : pArrayTwoVals)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBufferObjectTwo.push_back(pParameterVar);
	}



	// Create the Buffer of Elements
	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(BufType);
	

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputBufferObjectOne[0];

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pInputBufferObjectTwo[0];



	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pInputBuffer1);
	if (FAILED(hr))
		return hr;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData1, &pInputBuffer2);
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, nullptr, &pOutputBuffer);



	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputBufferObjectOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pInputBufferObjectTwo.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;

	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);

	if (FAILED(hr))
		return hr;



	if (FAILED(hr))
		return hr;
	pAdditionAlgorithmsSRV[0] = pInputSRV1;
	pAdditionAlgorithmsSRV[1] = pInputSRV2;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputBufferObjectOne.size();
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (FAILED(hr))
		return hr;


	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(BufType);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (FAILED(hr))
		return hr;
	*ppInputBuffer1 = pInputBuffer1;
	*ppInputBuffer2 = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV1 = pInputSRV1;
	*ppInputSRV2 = pInputSRV2;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	*ppOutputArr0 = pInputBufferObjectOne;
	*ppOutputArr1 = pInputBufferObjectTwo;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeArraySubtractionResources(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppInputBuffer2,
	ID3D11Buffer** ppOutputBuffer,
	vector<UINT> pArrayOneVals,
	vector<UINT> pArrayTwoVals,
	ID3D11ShaderResourceView** ppInputSRV1,
	ID3D11ShaderResourceView** ppInputSRV2,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer,
	vector<BufType> *ppOutputArr0,
	vector<BufType> *ppOutputArr1)
{

	HRESULT hr = S_OK;

	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pInputBuffer2 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11ShaderResourceView* pInputSRV2 = nullptr;
	ID3D11ShaderResourceView* pOutputSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	ID3D11ShaderResourceView* pAdditionAlgorithmsSRV[2];
	vector<BufType> pInputBufferObjectOne = vector<BufType>();
	vector<BufType> pInputBufferObjectTwo = vector<BufType>();

	for (UINT pArrayValue : pArrayOneVals)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBufferObjectOne.push_back(pParameterVar);
	}

	for (UINT pArrayValue : pArrayTwoVals)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBufferObjectTwo.push_back(pParameterVar);
	}



	// Create the Buffer of Elements
	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(BufType);


	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputBufferObjectOne[0];

	D3D11_SUBRESOURCE_DATA pData1;
	pData1.pSysMem = &pInputBufferObjectTwo[0];

	cout << "Creating Input Buffer One" << endl;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer A Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating Input Buffer Two" << endl;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData1, &pInputBuffer2);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer B Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating Output Buffer" << endl;


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, nullptr, &pOutputBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An Output Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputBufferObjectOne.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;
	
	cout << "Creating Shader Resource View 1" << endl;

	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс Шейдера для второго", (LPCSTR)"Message", 0);
		cout << "The exit of A Shader Resource View Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc1;
	ZeroMemory(&srvbuffer_desc1, sizeof(srvbuffer_desc));
	srvbuffer_desc1.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc1.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc1.Buffer.ElementWidth = pInputBufferObjectTwo.size();
	srvbuffer_desc1.Buffer.ElementOffset = 0;


	cout << "Creating Shader Resource View 2" << endl;

	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer2, &srvbuffer_desc1, &pInputSRV2);


	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс Шейдера для второго", (LPCSTR)"Message", 0);
		cout << "The exit of A Shader Resource View Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	pAdditionAlgorithmsSRV[0] = pInputSRV1;
	pAdditionAlgorithmsSRV[1] = pInputSRV2;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose

	cout << "Creating the Unordered Access View" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputBufferObjectOne.size();
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс Шейдера для второго", (LPCSTR)"Message", 0);
		cout << "The exit of A Shader Resource View Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	cout << "Creatinf the Readback Buffer" << endl;
	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputBufferObjectOne.size() * sizeof(BufType);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(BufType);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Ресурс Шейдера для второго", (LPCSTR)"Message", 0);
		cout << "The exit of A Shader Resource View Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}
	*ppInputBuffer1 = pInputBuffer1;
	*ppInputBuffer2 = pInputBuffer2;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV1 = pInputSRV1;
	*ppInputSRV2 = pInputSRV2;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	*ppOutputArr0 = pInputBufferObjectOne;
	*ppOutputArr1 = pInputBufferObjectTwo;
	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SimulateArrayAdditionAlgorithmUsingAppendConsume(HINSTANCE hInstance, HWND hWnd,
	vector<UINT> pArrayOneData, vector<UINT> pArrayTwoData, vector<UINT> *pOutputArrayData)
{
	HRESULT hr = S_OK;




	hr = InitializeD3D11Device(hWnd, 0);
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBufferOne = nullptr;
	ID3D11Buffer* pBufferTwo = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderSRV1 = nullptr;
	ID3D11ShaderResourceView* pShaderSRV2 = nullptr;

	ID3D11UnorderedAccessView* pShaderUAV1 = nullptr;
	ID3D11UnorderedAccessView* pShaderUAV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUav = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<UINT> pOutputArray = vector<UINT>();
	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("С:\\pixels\\ArrayAdditionFile.txt");
	hr = InitializeD3D11Device(hWnd, 0);

	vector<BufType> pInputBuffer0 = vector<BufType>();
	vector<BufType> pInputBuffer1 = vector<BufType>();

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\AddArrayUsingAppendConsume.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);

	}

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}


	printf("Creating buffers and filling them with initial data...");
	cout << "Printing the Contents For Array One" << endl;
	myfile << "Printing the Contents For Array One" << endl;
	int iIndex = 0;
	for (UINT pValue : pArrayOneData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}
	cout << "Printing the Contents For Array Two" << endl;
	myfile << "Printing the Contents For Array Two" << endl;

	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 2 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 2 Element =" << pValue << endl;
		iIndex++;
	}
	

	vector<BufType> pInputBuff0 = vector<BufType>();
	vector<BufType> pInputBuff1 = vector<BufType>();

	for (UINT pIntegerArrOne : pArrayOneData)
	{
		BufType pArrayOneVal;
		pArrayOneVal.d = (double)pIntegerArrOne;
		pArrayOneVal.i = (int)pIntegerArrOne;
		pArrayOneVal.f = (float)pIntegerArrOne;
		pInputBuff0.push_back(pArrayOneVal);
	}


	for (UINT pIntegerArrTwo : pArrayTwoData)
	{
		BufType pArrayTwoVal;
		pArrayTwoVal.d = (double)pIntegerArrTwo;
		pArrayTwoVal.i = (int)pIntegerArrTwo;
		pArrayTwoVal.f = (float)pIntegerArrTwo;
		pInputBuff1.push_back(pArrayTwoVal);
	}

	hr = InitializeArrrayAdditionUsingAppendConsumeResources(hInstance, hWnd, &pBufferOne,
		&pBufferTwo, &pOutputBuffer, pArrayOneData, pArrayTwoData, &pShaderSRV1, &pShaderSRV2,  &pShaderUAV1, &pShaderUAV2, &pOutputUav, &pReadbackBuffer,
		&pInputBuff0, &pInputBuff1);
	
	
	


	printf("done\n");

	printf("Running Compute Shader...");

	ID3D11Buffer* pConstantBuffers[2] = { pBufferOne, pBufferTwo };
	try
	{
		hr = RunArrayAdditionShaderAlgorithmAppendConsume(hInstance, hWnd,
			pInputBuff0, pInputBuff1, pBufferOne, pBufferTwo, pShaderSRV1, pShaderSRV2,   pShaderUAV1,
			pShaderUAV2, pComputeShaderObject, pOutputUav, 256, 1, 1);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackBuffer, pOutputBuffer);
		hr = m_pD3DCompContext->Map(pReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		BufType* p = (BufType*)MappedResource.pData;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		for (int i = 0; i < pArrayOneData.size(); ++i)
		{
			cout << "Summation Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			myfile << "Summation Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			pOutputArray.push_back(p[i].i);

		}
		if (bSuccess)
			printf("succeeded\n");




	}
	myfile.close();
	printf("Cleaning up...\n");
	SafeReleaseA(&pShaderUAV1);
	SafeReleaseA(&pShaderUAV2);
	SafeReleaseA(&pBufferOne);
	SafeReleaseA(&pBufferTwo);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pComputeShaderObject);
	*pOutputArrayData = pOutputArray;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunArrayAdditionShaderAlgorithmAppendConsume(HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pInputArrayA,
	vector<BufType> pInputArrayB,
	ID3D11Buffer* ppInputBufferA,
	ID3D11Buffer* ppInputBufferB,
	ID3D11ShaderResourceView* pSRV1,
	ID3D11ShaderResourceView* pSRV2,
	ID3D11UnorderedAccessView* pUAV0,
	ID3D11UnorderedAccessView* pUAV1,
	ID3D11ComputeShader* ppComputeShaderObject,
	ID3D11UnorderedAccessView* pUAV2,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;
	
	m_pD3DCompContext->CSSetShader(ppComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->UpdateSubresource(ppInputBufferA, 0, nullptr, &pInputArrayA[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(ppInputBufferB, 0, nullptr, &pInputArrayB[0], 0, 0);

	ID3D11ShaderResourceView* ppSRV[] = { pSRV1, pSRV2 };
 	ID3D11UnorderedAccessView* ppUAV[] = {pUAV0, pUAV1, pUAV2 };
	const UINT pUAVFlag = -1;
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAV, &pUAVFlag);
	// Sort the data
	// First sort the rows for the levels <= to the block size

	try
	{
		m_pD3DCompContext->Dispatch(256, 1, 1);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRViewnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, nullptr, nullptr };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRViewnullptr);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 3, ppUAViewnullptr, nullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateSimpleGPUMultiplication(HINSTANCE hInstance, HWND hWnd,
	vector<UINT> pArrayOneData, vector<UINT> pArrayTwoData, vector<UINT> *pOutputArrayData)
{
	HRESULT hr = S_OK;




	hr = InitializeD3D11Device(hWnd, 0);
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBufferOne = nullptr;
	ID3D11Buffer* pBufferTwo = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderSRV1 = nullptr;
	ID3D11ShaderResourceView* pShaderSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUav = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<UINT> pOutputArray = vector<UINT>();
	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("C::\\pixels\\ArrayMultiplicationFile.txt");
	hr = InitializeD3D11Device(hWnd, 0);

	vector<BufType> pInputBuffer0 = vector<BufType>();
	vector<BufType> pInputBuffer1 = vector<BufType>();

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeArrayMultiplication.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);

	}

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}


	printf("Creating buffers and filling them with initial data...");
	cout << "Printing the Contents For Array One" << endl;
	int iIndex = 0;
	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}

	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}
	vector<BufType> pInputBuff0 = vector<BufType>();
	vector<BufType> pInputBuff1 = vector<BufType>();

	hr = InitializeArraySubtractionResources(hInstance, hWnd, &pBufferOne,
		&pBufferTwo, &pOutputBuffer, pArrayOneData, pArrayTwoData, &pShaderSRV1, &pShaderSRV2, &pOutputUav, &pReadbackBuffer,
		&pInputBuff0, &pInputBuff1);

	if (FAILED(hr))
	{
		cout << "Unable to Initialize Resources for Array Subtraction" << endl;
		return hr;
	}

	printf("done\n");

	printf("Running Compute Shader...");

	ID3D11Buffer* pConstantBuffers[2] = { pBufferOne, pBufferTwo };
	ID3D11ShaderResourceView* aRViews[2] = { pShaderSRV1, pShaderSRV2 };
	try
	{
		RunArrayAdditionShaderAlgorithm(hInstance, hWnd, pShaderSRV1,
			pShaderSRV2, pComputeShaderObject, pOutputUav, NUM_ELEMENTS, 1, 1);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackBuffer, pOutputBuffer);
		hr = m_pD3DCompContext->Map(pReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		BufType* p = (BufType*)MappedResource.pData;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		for (int i = 0; i < pArrayOneData.size(); ++i)
		{
			cout << "Subtraction Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			myfile << "Subtraction Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			pOutputArray.push_back(p[i].i);

		}
		if (bSuccess)
			printf("succeeded\n");




	}
	myfile.close();
	printf("Cleaning up...\n");
	SafeReleaseA(&pShaderSRV1);
	SafeReleaseA(&pShaderSRV2);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pBufferOne);
	SafeReleaseA(&pBufferTwo);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pComputeShaderObject);
	*pOutputArrayData = pOutputArray;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateSimpleGPUSubtraction(HINSTANCE hInstance, HWND hWnd,
	vector<UINT> pArrayOneData, vector<UINT> pArrayTwoData, vector<BufType> *pOutputArrayData)
{
	HRESULT hr = S_OK;




	hr = InitializeD3D11Device(hWnd, 0);
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBufferOne = nullptr;
	ID3D11Buffer* pBufferTwo = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderSRV1 = nullptr;
	ID3D11ShaderResourceView* pShaderSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUav = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<BufType> pOutputArray = vector<BufType>();
	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	hr = InitializeD3D11Device(hWnd, 0);

	vector<BufType> pInputBuffer0 = vector<BufType>();
	vector<BufType> pInputBuffer1 = vector<BufType>();

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSSimulateArraySubtraction.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);

	}

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}


	printf("Creating buffers and filling them with initial data...");
	cout << "Printing the Contents For Array One" << endl;
	int iIndex = 0;
	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}

	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}
	vector<BufType> pInputBuff0 = vector<BufType>();
	vector<BufType> pInputBuff1 = vector<BufType>();

	hr = InitializeArraySubtractionResources(hInstance, hWnd, &pBufferOne,
		&pBufferTwo, &pOutputBuffer, pArrayOneData, pArrayTwoData, &pShaderSRV1, &pShaderSRV2, &pOutputUav, &pReadbackBuffer,
		&pInputBuff0, &pInputBuff1);

	if (FAILED(hr))
	{
		cout << "Unable to Initialize Resources for Array Subtraction" << endl;
		return hr;
	}

	printf("done\n");

	printf("Running Compute Shader...");

	ID3D11Buffer* pConstantBuffers[2] = { pBufferOne, pBufferTwo };
	ID3D11ShaderResourceView* aRViews[2] = { pShaderSRV1, pShaderSRV2 };
	try
	{
		RunArrayAdditionShaderAlgorithm(hInstance, hWnd, pShaderSRV1,
			pShaderSRV2, pComputeShaderObject, pOutputUav, NUM_ELEMENTS, 1, 1);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackBuffer, pOutputBuffer);
		hr = m_pD3DCompContext->Map(pReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		BufType* p = (BufType*)MappedResource.pData;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		for (int i = 0; i < pArrayOneData.size(); ++i)
		{
			cout << "Subtraction Result at index Int" << " " << i << " " << "=" << " " << p[i].i << endl;
			myfile << "Subtraction Result at index Int" << " " << i << " " << "=" << " " << p[i].i << endl;
			cout << "Subtraction Result at index Float" << " " << i << " " << "=" << " " << p[i].f << endl;
			myfile << "Subtraction Result at index Float" << " " << i << " " << "=" << " " << p[i].f << endl;
			cout << "Subtraction Result at index Double" << " " << i << " " << "=" << " " << p[i].d << endl;
			myfile << "Subtraction Result at index Double" << " " << i << " " << "=" << " " << p[i].d << endl;

			pOutputArray.push_back(p[i]);

		}
		if (bSuccess)
			printf("succeeded\n");




	}
	myfile.close();
	printf("Cleaning up...\n");
	SafeReleaseA(&pShaderSRV1);
	SafeReleaseA(&pShaderSRV2);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pBufferOne);
	SafeReleaseA(&pBufferTwo);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pComputeShaderObject);
	*pOutputArrayData = pOutputArray;
	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateParrallelReduction(HINSTANCE hInstance, HWND hWnd,
	vector<UINT> pArrayOneData, vector<BufType> *pOutputArrayData)
{
	HRESULT hr = S_OK;




	hr = InitializeD3D11Device(hWnd, 0);
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBufferOne = nullptr;
	ID3D11Buffer* pConstantBufferObject = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUav = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<BufType> pOutputArray = vector<BufType>();

	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	hr = InitializeD3D11Device(hWnd, 0);

	vector<BufType> pInputBuffer0 = vector<BufType>();

	for (UINT pArrayValue : pArrayOneData)
	{
		BufType pParameterVar;
		pParameterVar.i = pArrayValue;
		pParameterVar.f = (float)pArrayValue;
		pParameterVar.d = (double)pArrayValue;
		pInputBuffer0.push_back(pParameterVar);
	}


	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}


	printf("Creating buffers and filling them with initial data...");
	cout << "Printing the Contents For Array One" << endl;
	int iIndex = 0;

	
	vector<BufType> pInputBuff0 = vector<BufType>();
	vector<BufType> pInputBuff1 = vector<BufType>();

	hr = InitializeParallelReductionResources(hInstance, hWnd,
		pInputBuffer0,
		256,
		&pComputeShaderObject,
		&pConstantBufferObject,
		&pBufferOne,
		 &pOutputBuffer,
		 &pShaderSRV1, &pOutputUav, &pReadbackBuffer);



	printf("done\n");

	printf("Running Compute Shader...");

	ID3D11Buffer* pConstantBuffers[2] = { pBufferOne};
	ID3D11ShaderResourceView* aRViews[2] = { pShaderSRV1};
	try
	{
		RunParallelReductionAlgorithm(hInstance, hWnd, pConstantBufferObject, pShaderSRV1, pComputeShaderObject, pOutputUav, NUM_ELEMENTS, 1, 1);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackBuffer, pOutputBuffer);
		hr = m_pD3DCompContext->Map(pReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		BufType* p = (BufType*)MappedResource.pData;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		for (int i = 0; i < pArrayOneData.size(); ++i)
		{
			if (p[i].i != 0 && p[i].f != 0 && p[i].d != 0)
			{
					cout << "Reduction Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
					myfile << "Reduction Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			
					pOutputArray.push_back(p[i]);
				}
		}
		if (bSuccess)
			printf("succeeded\n");




	}
	myfile.close();
	printf("Cleaning up...\n");
	SafeReleaseA(&pShaderSRV1);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pConstantBufferObject);
	SafeReleaseA(&pBufferOne);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pComputeShaderObject);
	*pOutputArrayData = pOutputArray;
	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeParallelReductionResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pArrayOneVals,
	UINT pDispatchSize,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer1,
	ID3D11Buffer** ppOutputBuffer,	
	ID3D11ShaderResourceView** ppInputSRV1,
	ID3D11UnorderedAccessView** ppOutputUAV,
	ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;

	fstream imageMaskLog("С:\\pixels\\ParallelReductionOperationPreOutput.txt");
	imageMaskLog.clear();

	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer1 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pInputSRV1 = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	ID3D11ShaderResourceView* pAdditionAlgorithmsSRV[2];
	vector<BufType> pInputBufferObjectOne = vector<BufType>();

	CBParallelReduction pParallelReductionStruct;
	pParallelReductionStruct.pAmountOfElements = pArrayOneVals.size();
	pParallelReductionStruct.pDispathcThreadX = pDispatchSize;

	
	cout << "Compiling the Compute Shader Object" << endl;

	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSParallelReductionAlgorithmGroupOptimized.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}


	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Constant Buffer For Image One Object" << endl;

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(CBParallelReduction) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA pDataCB;
	pDataCB.pSysMem = &pParallelReductionStruct;


	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &pDataCB, &pConstantBuffer);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Constant Buffer FOR Simulation of reduction" << endl;
		imageMaskLog << "Unable to Create the Constant Buffer FOR Simulation of reduction " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pArrayOneVals.size() * sizeof(BufType);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(BufType);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pArrayOneVals[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pData, &pInputBuffer1);

	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One" << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}


	cout << "Creating the Output Buffer" << endl;
	imageMaskLog << "Creating the Output Buffer" << endl;



	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = sizeof(BufType) * pArrayOneVals.size();
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(BufType);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;


	cout << "Creating the Output Buffer Object" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}



	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pArrayOneVals.size();
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer1, &srvbuffer_desc, &pInputSRV1);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Операции Редуцирования", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Parallel Reduction" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Операции Редуцирования", (LPCSTR)"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of Shader Resource View or Parallel Reduction Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	

	cout << "Creating the Unordered Access View For the Output Buffer For Parallel Reduction" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;

	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pArrayOneVals.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;

	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pArrayOneVals.size() * sizeof(BufType);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(BufType);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}
	*ppConstantBuffer = pConstantBuffer;
	*ppComputeShaderObject = pComputeShaderObject;
	*ppInputBuffer1 = pInputBuffer1;
	*ppOutputBuffer = pOutputBuffer;
	*ppInputSRV1 = pInputSRV1;
	*ppOutputUAV = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::SimulateSimpleGPUAddition(HINSTANCE hInstance, HWND hWnd,
	vector<UINT> pArrayOneData, vector<UINT> pArrayTwoData, vector<UINT> *pOutputArrayData)
{
	HRESULT hr = S_OK;




	hr = InitializeD3D11Device(hWnd, 0);
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pBufferOne = nullptr;
	ID3D11Buffer* pBufferTwo = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderSRV1 = nullptr;
	ID3D11ShaderResourceView* pShaderSRV2 = nullptr;
	ID3D11UnorderedAccessView* pOutputUav = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<UINT> pOutputArray = vector<UINT>();
	printf("Creating device...");
	if (FAILED(hr))
		return 1;
	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	hr = InitializeD3D11Device(hWnd, 0);

	vector<BufType> pInputBuffer0 = vector<BufType>();
	vector<BufType> pInputBuffer1 = vector<BufType>();

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\BasicComputeStart11.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);

	}

	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}


	printf("Creating buffers and filling them with initial data...");
	cout << "Printing the Contents For Array One" << endl;
	int iIndex = 0;
	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}

	for (UINT pValue : pArrayTwoData)
	{
		cout << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		myfile << "Current Index =" << " " << iIndex << " " << "Array 1 Element =" << pValue << endl;
		iIndex++;
	}
	vector<BufType> pInputBuff0 = vector<BufType>();
	vector<BufType> pInputBuff1 = vector<BufType>();

	hr = InitializeArrayAdditionResources(hInstance, hWnd, &pBufferOne,
		&pBufferTwo, &pOutputBuffer, pArrayOneData, pArrayTwoData, &pShaderSRV1, &pShaderSRV2, &pOutputUav, &pReadbackBuffer,
		&pInputBuff0, &pInputBuff1);



	printf("done\n");

	printf("Running Compute Shader...");

	ID3D11Buffer* pConstantBuffers[2] = { pBufferOne, pBufferTwo };
	ID3D11ShaderResourceView* aRViews[2] = { pShaderSRV1, pShaderSRV2 };
	try
	{
		RunArrayAdditionShaderAlgorithm(hInstance, hWnd, pShaderSRV1,
			 pShaderSRV2, pComputeShaderObject, pOutputUav, NUM_ELEMENTS, 1, 1);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadbackBuffer, pOutputBuffer);
		hr = m_pD3DCompContext->Map(pReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		BufType* p = (BufType*)MappedResource.pData;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		for (int i = 0; i < pArrayOneData.size(); ++i)
		{
			cout << "Summation Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			myfile << "Summation Result at index" << " " << i << " " << "=" << " " << p[i].i << endl;
			pOutputArray.push_back(p[i].i);

		}
		if (bSuccess)
			printf("succeeded\n");




	}
	myfile.close();
	printf("Cleaning up...\n");
	SafeReleaseA(&pShaderSRV1);
	SafeReleaseA(&pShaderSRV2);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pBufferOne);
	SafeReleaseA(&pBufferTwo);
	SafeReleaseA(&pOutputUav);
	SafeReleaseA(&pComputeShaderObject);
	*pOutputArrayData = pOutputArray;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::LoadImageDataAsPixelSet(HINSTANCE hInstane, HWND hWnd, LPCWSTR pFileName, vector<PixelObject>* pPixelObject)
{
	HRESULT hr = S_OK;
	return hr;
	

}






HRESULT DirectXStandardAlgorithmExecutor::SimulateMatrixMultiplicationW(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
	ID3D11Device* pDevice = nullptr;
	ID3D11DeviceContext* pContext = nullptr;
	hr = InitializeD3D11Device(hWnd, 0);
	ofstream myfile;
	myfile.open("RandomizationAlgorithmFile.txt");

	std::random_device rd;
	std::mt19937 mt(rd());
	vector<BData> pArrayOneVals = vector<BData>();
	vector<BData> pArrayTwoValues = vector<BData>();


	random_device rnd_device;
	// Specify the engine and distribution.
	mt19937 mersenne_engine(rnd_device());
	uniform_int_distribution<int> dist(1, NUM_ELEMENTS);

	auto gen = std::bind(dist, mersenne_engine);

	pArrayOneVals.clear();
	cout << "We will select an array from 5000  to 6023" << endl;
	int pLimit0 = 0;
	int pLimit1 = 0;
	cout << "Enter the minimum value of the range" << endl;
	cin >> pLimit0;
	cout << "Enter the maximum value of the range" << endl;
	cin >> pLimit1;
	int pArraySize = pLimit1 - pLimit0 + 1;
	cout << "Array Size = " << pArraySize;
	for (int pNumner = pLimit0; pNumner <= pLimit1; ++pNumner)
	{
		BData pData;
		pData.pData = (float)pNumner;
		pArrayOneVals.push_back(pData);

	}
	int pLimit2 = pLimit0 * 6;
	int pLimit3 = pLimit1 * 6;
	for (int pNumber = pLimit2; pNumber <= pLimit3; ++pNumber)
	{
		BData pData;
		pData.pData = (float)pNumber;
		pArrayTwoValues.push_back(pData);
	}




	int pIndex = 0;
	cout << "Enumerating Matrix 1" << endl;

	for (BData pValue : pArrayOneVals)
	{
		cout << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;
		myfile << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;

	}

	cout << "Enumerating Matrix 2" << endl;
	for (int pNumber = pLimit2; pNumber <= pLimit3; ++pNumber)
	{
		BData pData;
		pData.pData = (float)pNumber;
		pArrayTwoValues.push_back(pData);
	}

	for (BData pValue : pArrayTwoValues)
	{
		cout << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;
		myfile << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;

	}



	int pNumElements0 = pArrayOneVals.size();
	int pNumElements1 = pArrayTwoValues.size();



	ID3DBlob* pBlobData = nullptr;
	ID3D11ComputeShader* pRandomAlgorithm = nullptr;
	// Compile the Bitonic Sort Compute Shader
	hr = CompileD3DShaderFromFileW(L"D:\\OLEG\\System GPUDigitalLab ATL Server\\Kernel Final\\Debug\\MatrixMultiplicationCS.hlsl", "CS_Main", "cs_5_0", &pBlobData);
	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateComputeShader(pBlobData->GetBufferPointer(), pBlobData->GetBufferSize(), nullptr, &pRandomAlgorithm);
	if (FAILED(hr))
		return hr;
	SafeReleaseA(&pBlobData);

#if defined(_DEBUG) || defined(PROFILE)
	pRandomAlgorithm->SetPrivateData(WKPDID_D3DDebugObjectName, sizeof("BitonicSort") - 1, "BitonicSort");
#endif

	//Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(ConstantBuffer);
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &m_pBitonicConstantBuffer);



	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = pNumElements0 * sizeof(BData);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(BData);
	buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = pArrayOneVals.data();

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &m_pFirstBuffer);
	if (FAILED(hr))
		return hr;

	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pNumElements1 * sizeof(BData);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(BData);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, nullptr, &m_pSecondBuffer);

	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pNumElements0;
	srvbuffer_desc.Buffer.ElementOffset = 0;
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pFirstBuffer, &srvbuffer_desc, &m_pFirstBufferSRV);
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pSecondBuffer, &srvbuffer_desc, &m_pSecondBufferSRV);

	if (FAILED(hr))
		return hr;



	if (FAILED(hr))
		return hr;
	pAdditionAlgorithmsSRV[0] = m_pFirstBufferSRV;
	pAdditionAlgorithmsSRV[1] = m_pSecondBufferSRV;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pNumElements1;

	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pFirstBuffer, &uavbuffer_desc, &m_pFirstBufferUAV);
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pSecondBuffer, &uavbuffer_desc, &m_pSecondBufferUAV);
	if (FAILED(hr))
		return hr;


	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pNumElements1 * sizeof(UINT);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(UINT);
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &m_pReadBackBuffer);
	if (FAILED(hr))
		return hr;


	ID3D11ShaderResourceView* ppShaderResourceViews[] = { m_pFirstBufferSRV, m_pSecondBufferSRV };
	ID3D11UnorderedAccessView* ppUnorderedAccessViews[] = { m_pFirstBufferUAV, m_pSecondBufferUAV };

	try
	{
		hr = RunComputeShaderAlgorithm(hInstance, hWnd, pArrayOneVals, pRandomAlgorithm, m_pBitonicConstantBuffer, ppShaderResourceViews, ppUnorderedAccessViews);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(m_pReadBackBuffer, m_pSecondBuffer);
		hr = m_pD3DCompContext->Map(m_pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		float* p = (float*)MappedResource.pData;

		cout << "Current Data bEGIN" << endl;
		cout << p << endl;
		cout << "Current Data Emd" << endl;
		vector<float> pOutputData = vector<float>();
		pOutputData.push_back(*p);

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (int pIndex = 0; pIndex < pNumElements0; pIndex++)
		{
			cout << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
			myfile << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
			pOutputData.push_back(pIndex);

		}
		if (bSuccess)
			printf("succeeded\n");




	}

	printf("Cleaning up...\n");
	myfile.close();
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateRandomAlgorithmA(HINSTANCE hInstance, HWND hWND)
{
	HRESULT hr = S_OK;
#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
	ID3D11Device* pDevice = nullptr;
	ID3D11DeviceContext* pContext = nullptr;
	hr = InitializeD3D11Device(hWND, 0);
	ofstream myfile;
	myfile.open("RandomizationAlgorithmFile.txt");

	std::random_device rd;
	std::mt19937 mt(rd());
	vector<BData> pArrayOneVals = vector<BData>();



	random_device rnd_device;
	// Specify the engine and distribution.
	mt19937 mersenne_engine(rnd_device());
	uniform_int_distribution<int> dist(1, NUM_ELEMENTS);

	auto gen = std::bind(dist, mersenne_engine);

	pArrayOneVals.clear();
	cout << "We will select an array from 5000  to 6023" << endl;
	int pLimit0 = 0;
	int pLimit1 = 0;
	cout << "Enter the minimum value of the range" << endl;
	cin >> pLimit0;
	cout << "Enter the maximum value of the range" << endl;
	cin >> pLimit1;
	int pArraySize = pLimit1 - pLimit0 + 1;
	cout << "Array Size = " << pArraySize;
	for (int pNumner = pLimit0; pNumner <= pLimit1; ++pNumner)
	{
		BData pParam;
		pParam.pData = pNumner;
		pArrayOneVals.push_back(pParam);
	}


	int pIndex = 0;
	for (BData pValue : pArrayOneVals)
	{
		cout << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;
		myfile << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;

	}

	int pNumElements = pArrayOneVals.size();

	ID3DBlob* pBlobData = nullptr;
	ID3D11ComputeShader* pRandomAlgorithm = nullptr;
	// Compile the Bitonic Sort Compute Shader
	hr = CompileD3DShaderFromFileW(L"D:\\OLEG\\System GPUDigitalLab ATL Server\\Kernel Final\\Debug\\test.hlsl", "CS_Main", "cs_5_0", &pBlobData);
	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateComputeShader(pBlobData->GetBufferPointer(), pBlobData->GetBufferSize(), nullptr, &pRandomAlgorithm);
	if (FAILED(hr))
		return hr;
	SafeReleaseA(&pBlobData);

#if defined(_DEBUG) || defined(PROFILE)
	pRandomAlgorithm->SetPrivateData(WKPDID_D3DDebugObjectName, sizeof("BitonicSort") - 1, "BitonicSort");
#endif

	//Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(ConstantBuffer);
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &m_pBitonicConstantBuffer);



	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = pNumElements * sizeof(BData);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(BData);
	buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = pArrayOneVals.data();

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &m_pFirstBuffer);
	if (FAILED(hr))
		return hr;

	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pNumElements * sizeof(BData);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(BData);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, nullptr, &m_pSecondBuffer);

	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pNumElements;
	srvbuffer_desc.Buffer.ElementOffset = 0;
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pFirstBuffer, &srvbuffer_desc, &m_pFirstBufferSRV);
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pSecondBuffer, &srvbuffer_desc, &m_pSecondBufferSRV);

	if (FAILED(hr))
		return hr;



	if (FAILED(hr))
		return hr;
	pAdditionAlgorithmsSRV[0] = m_pFirstBufferSRV;
	pAdditionAlgorithmsSRV[1] = m_pSecondBufferSRV;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pNumElements;

	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pFirstBuffer, &uavbuffer_desc, &m_pFirstBufferUAV);
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pSecondBuffer, &uavbuffer_desc, &m_pSecondBufferUAV);
	if (FAILED(hr))
		return hr;


	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pNumElements * sizeof(UINT);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(UINT);
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &m_pReadBackBuffer);
	if (FAILED(hr))
		return hr;


	ID3D11ShaderResourceView* ppShaderResourceViews[] = { m_pFirstBufferSRV, m_pSecondBufferSRV };
	ID3D11UnorderedAccessView* ppUnorderedAccessViews[] = { m_pFirstBufferUAV, m_pSecondBufferUAV };

	try
	{
		hr = RunComputeShaderAlgorithm(hInstance, hWND, pArrayOneVals, pRandomAlgorithm, m_pBitonicConstantBuffer, ppShaderResourceViews, ppUnorderedAccessViews);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(m_pReadBackBuffer, m_pSecondBuffer);
		hr = m_pD3DCompContext->Map(m_pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		float* p = (float*)MappedResource.pData;

		cout << "Current Data bEGIN" << endl;
		cout << p << endl;
		cout << "Current Data Emd" << endl;
		vector<float> pOutputData = vector<float>();
		pOutputData.push_back(*p);

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (int pIndex = 0; pIndex < pNumElements; pIndex++)
		{
			cout << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
			myfile << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
			pOutputData.push_back(pIndex);

		}
		if (bSuccess)
			printf("succeeded\n");




	}

	printf("Cleaning up...\n");
	myfile.close();
	return hr;

}


HRESULT DirectXStandardAlgorithmExecutor::PerformFFTSimulationData(HINSTANCE hInstance, HWND hWnd, vector<float> ppDataObject, vector <float> *ppOutput)
{
	cout << "Preparing The Initial Data" << endl;
	int pIndex = 0;
	vector<BDataComplexNumber> ppOutputData = vector<BDataComplexNumber>();

	for (float pCurrentNumber : ppDataObject)
	{
		cout << "Current Input Value At Index: " << pIndex << " = " << pCurrentNumber << endl;

	}

	HRESULT hr = S_OK;
	ID3D11Buffer* ppBufferOne = nullptr;
	ID3D11Buffer* ppBufferOut = nullptr;
	ID3D11UnorderedAccessView* pUAV0 = nullptr;
	ID3D11UnorderedAccessView* pUAV1 = nullptr;
	ID3D11Device* pDeviceOut = nullptr;
	ID3D11DeviceContext* pContextOut = nullptr;
	fstream pOutputFile;
	pOutputFile.open("C:\\\pixels\\FourierTransform.txt", std::fstream::in | std::fstream::out | std::fstream::binary);
	
	pOutputFile.clear();
	pOutputFile << "New Operation" << endl;
	D3D_FEATURE_LEVEL flOut = D3D_FEATURE_LEVEL_9_1;
	D3D11CreateDevice(NULL, D3D_DRIVER_TYPE_REFERENCE, 0, 0, 0, 0, D3D11_SDK_VERSION, &pDeviceOut, &flOut, &
		pContextOut);
	//just filling up the buffer
	::std::vector<BDataComplexNumber> vBuf1;
	
	ID3D11Buffer* pBufin1 = nullptr;
	hr = CreateByteOrderBufferOnGPU(pDeviceOut, sizeof(float), (UINT)ppDataObject.size(), &ppDataObject[0], &pBufin1);
	ID3D11UnorderedAccessView* pBufin1_UAV = nullptr;
	hr = CreateByteBufferUAV(hInstance, hWnd, pDeviceOut, pBufin1, &pBufin1_UAV);
	D3DX11_FFT_DESC fftdesc = {};
	fftdesc.ElementLengths[0] = fftdesc.ElementLengths[1] = fftdesc.ElementLengths[2] = 1;
	fftdesc.NumDimensions = 1;
	fftdesc.ElementLengths[0] = ppDataObject.size();
	fftdesc.DimensionMask = D3DX11_FFT_DIM_MASK_1D;
	fftdesc.Type = D3DX11_FFT_DATA_TYPE_REAL;
	D3DX11_FFT_BUFFER_INFO fftbufferinfo = {};
	ID3DX11FFT* pFFT = nullptr;
	cout << "creating the FFT Object" << endl;
	pOutputFile << "creating the FFT Object" << endl;
//	hr = D3DX11CreateFFT(pContextOut, &fftdesc, 0, &fftbufferinfo, &pFFT);
	std::vector<ID3D11Buffer *> ArrBufTemp; //temporary buffer required by DX11 FFT
	std::vector<ID3D11UnorderedAccessView *> ArrBufTemp_UAV;
	for (UINT i = 0; i < fftbufferinfo.NumTempBufferSizes; i++)
	{

		ID3D11Buffer *tmp_pBufT1 = 0;
	  hr = CreateByteOrderBufferOnGPU(pDeviceOut, sizeof(float), fftbufferinfo.TempBufferFloatSizes[i], 0,
		  &tmp_pBufT1);
	  ID3D11UnorderedAccessView *tmp_pBufT1_UAV = 0;
	  hr = CreateByteBufferUAV(hInstance, hWnd, pDeviceOut, tmp_pBufT1, &tmp_pBufT1_UAV);
	  ArrBufTemp.push_back(tmp_pBufT1);
	  ArrBufTemp_UAV.push_back(tmp_pBufT1_UAV);
	}
	std::vector<ID3D11Buffer *> ArrBufpreCompu; //temporary buffer required by DX11 FFT
	std::vector<ID3D11UnorderedAccessView *> ArrBufpreCompu_UAV;
	for (UINT i = 0; i < fftbufferinfo.NumPrecomputeBufferSizes; i++)
	{
		ID3D11Buffer *tmp_pBufT1 = 0;
		hr = CreateByteOrderBufferOnGPU(pDeviceOut, sizeof(float), fftbufferinfo.TempBufferFloatSizes[i], 0,
			&tmp_pBufT1);
		ID3D11UnorderedAccessView *tmp_pBufT1_UAV = 0;
		hr = CreateByteBufferUAV(hInstance, hWnd, pDeviceOut, tmp_pBufT1, &tmp_pBufT1_UAV);
		ArrBufpreCompu.push_back(tmp_pBufT1);
		ArrBufpreCompu_UAV.push_back(tmp_pBufT1_UAV);
	}
	hr = pFFT->AttachBuffersAndPrecompute(fftbufferinfo.NumTempBufferSizes, fftbufferinfo.NumTempBufferSizes>
		0 ? &ArrBufTemp_UAV[0] : NULL,
		fftbufferinfo.NumPrecomputeBufferSizes, fftbufferinfo.NumPrecomputeBufferSizes > 0 ? &
		ArrBufpreCompu_UAV[0] : NULL);
	ID3D11UnorderedAccessView* respBufin1_UAV = nullptr;
	ID3D11UnorderedAccessView* respBufin1_UAV1 = nullptr;
	cout << "Simulating the Fast Fourier Transform" << endl;
	pOutputFile << "Simulating the Fast Fourier Transform" << endl;
	hr = pFFT->ForwardTransform(pBufin1_UAV, &respBufin1_UAV);
	ID3D11Buffer* resultOutput = nullptr;
	respBufin1_UAV->GetResource((ID3D11Resource **)&resultOutput);
	ID3D11Buffer* reultoutput_cpuread = nullptr;
	reultoutput_cpuread = CreateAndCopyToDebugBufferW(resultOutput, pDeviceOut, pContextOut);
	D3D11_MAPPED_SUBRESOURCE MappedResource;
	pContextOut->Map(reultoutput_cpuread, 0, D3D11_MAP_READ, 0, &MappedResource);
	float *p = (float*)MappedResource.pData;
	vector<float> pFloatData = vector<float>();
	pFloatData.insert(begin(pFloatData), *p);

	for (UINT pIndex = 0; pIndex < ppDataObject.size(); ++pIndex)
	{
		pFloatData.push_back(p[pIndex]);
	}

	cout << "Printing Output" << endl;
	pIndex = 0;
	for (float pNumber : pFloatData)
	{
		cout << "Output Item AT Index: " << pIndex << " = " << pNumber << endl;
		pOutputFile << "Output Item AT Index: " << pIndex << " = " << pNumber << endl;
	}
	
	
	
	for (UINT i = 0; i < fftbufferinfo.NumTempBufferSizes; i++)
	{
		SafeReleaseA(&ArrBufTemp[i]);
		SafeReleaseA(&ArrBufTemp_UAV[i]);
	}
	for (UINT i = 0; i < fftbufferinfo.NumPrecomputeBufferSizes; i++)
	{
		SafeReleaseA(&ArrBufpreCompu[i]);
		SafeReleaseA(&ArrBufpreCompu_UAV[i]);
	}
	/////////////-------------------------///////////////////
	//to test DX11 FFT output

pOutputFile.close();
*ppOutput = pFloatData;
return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ExecuteFFTSimulationData(HINSTANCE hInstance, HWND hWnd,
	vector<BufType> pInitialDataSet0,
	vector<BufType> pInverseDataFFT,
	ID3D11Buffer* pInputBuffer0,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pHarmonicsSRV,
	ID3D11UnorderedAccessView* pExponentialBufferOutUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{

	HRESULT hr = S_OK;


	ID3D11ShaderResourceView* ppSRV[] = { pShaderResourceView0, pHarmonicsSRV};
	ID3D11UnorderedAccessView* ppUAV[] = {pExponentialBufferOutUAV};
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);



	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunComputeShaderAlgorithmW(HINSTANCE hInstance, HWND hWnd, vector<BData> pValuesData, ID3D11ComputeShader* pComputeShader, ID3D11Buffer* pConstBufferData, ID3D11ShaderResourceView* pSRV, ID3D11UnorderedAccessView* pConnectableUAV)
{
	HRESULT hr = S_OK;
	ConstantBuffer pConstantData;
	pConstantData.iHeight = 100;
	pConstantData.iLevel = 1;
	pConstantData.iLevelMask = 1;
	pConstantData.iWidth = 100;


	UINT pSize = pValuesData.size();
	pSize = pSize / 32;
	// Upload the data
	m_pD3DCompContext->UpdateSubresource(m_pFirstBuffer, 0, nullptr, &pValuesData[0], 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 1, &pSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pConnectableUAV, nullptr);
	// Sort the data
	// First sort the rows for the levels <= to the block size

	try
	{
		m_pD3DCompContext->Dispatch(pSize, 1, 1);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

}

HRESULT DirectXStandardAlgorithmExecutor::RunImageSubtractionFunctionShaderAlgorithm(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11ShaderResourceView* pShaderResourceView1,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = {pShaderResourceView0, pShaderResourceView1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUnorderedUAV };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::RunMatrixMultpilicationAlgorithm(
	HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pMatrixOne,
	vector<BufType> pMatrixTwo,
	ID3D11Buffer* ppInputBufferOne,
	ID3D11Buffer* pInputBufferTwo,
	MatrixMultiplyCB pConstantBufferCB,
	ID3D11Buffer* pMatrixMultiplyConstantBuffer,
	ID3D11ComputeShader* pComputeShader,
	ID3D11ShaderResourceView* pSRV0,
	ID3D11ShaderResourceView* pSRV1,
	ID3D11UnorderedAccessView* pUAV0,
	int xThread, int pYThread, int pZThread)
{
	HRESULT hr = S_OK;
	m_pD3DCompContext->UpdateSubresource(ppInputBufferOne, 0, nullptr, &pMatrixOne[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(pInputBufferTwo, 0, nullptr, &pMatrixTwo[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(pMatrixMultiplyConstantBuffer, 0, nullptr, &pConstantBufferCB, 0, 0);
	UINT pSize = pMatrixOne.size();

	m_pD3DCompContext->CSSetShader(pComputeShader, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { pSRV0, pSRV1 };
	ID3D11UnorderedAccessView* ppUAV[] = { pUAV0 };
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pMatrixMultiplyConstantBuffer);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);

	try
	{
		m_pD3DCompContext->Dispatch(pSize / 16, pSize / 16, 1);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunParallelReductionAlgorithm(
	HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBufferCB,
	ID3D11ShaderResourceView* ppShaderResourceViewOne,
	ID3D11ComputeShader* ppComputeShaderObject,
	ID3D11UnorderedAccessView* ppUnordererdAccessViews,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(ppComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufferCB);
	ID3D11ShaderResourceView* ppSRV[] = { ppShaderResourceViewOne,};
	ID3D11UnorderedAccessView* ppUAV[] = { ppUnordererdAccessViews };
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	// Sort the data
	// First sort the rows for the levels <= to the block size

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::RunArrayAdditionShaderAlgorithm(
	HINSTANCE hInstance, HWND hWnd,
	ID3D11ShaderResourceView* ppShaderResourceViewOne,
	ID3D11ShaderResourceView* ppShaderResourceView,
	ID3D11ComputeShader* ppComputeShaderObject,
	ID3D11UnorderedAccessView* ppUnordererdAccessViews,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(ppComputeShaderObject, nullptr, 0);
	ID3D11ShaderResourceView* ppSRV[] = { ppShaderResourceViewOne, ppShaderResourceView };
	ID3D11UnorderedAccessView* ppUAV[] = { ppUnordererdAccessViews };
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRV);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAV, nullptr);
	// Sort the data
	// First sort the rows for the levels <= to the block size

	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr, nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::SimulateMatrixMultiplicationUsingAMP(HINSTANCE hInstance, HWND hWnd, vector<float> pArrayOne, vector<float> pArrayTwo, UINT amountOfCollMatOne, UINT amountOfRowsMatOne, UINT pAmountOfColsMatTwo, UINT pAmountOfRowsMatTwo, vector<float> *pOutputArrayVar)
{
	HRESULT hr = S_OK;










	return hr;

}




HRESULT DirectXStandardAlgorithmExecutor::RunComputeShaderAlgorithm(HINSTANCE hInstance, HWND hWnd, vector<BData> pValuesData, ID3D11ComputeShader* pComputeShader, ID3D11Buffer* pConstBufferData, ID3D11ShaderResourceView* pSRV[2], ID3D11UnorderedAccessView* pConnectableUAV[2])
{
	HRESULT hr = S_OK;
	ConstantBuffer pConstantData;
	pConstantData.iHeight = 100;
	pConstantData.iLevel = 1;
	pConstantData.iLevelMask = 1;
	pConstantData.iWidth = 100;


	UINT pSize = pValuesData.size();
	pSize = pSize / 32;
	// Upload the data
	m_pD3DCompContext->UpdateSubresource(pConstBufferData, 0, nullptr, &pConstantData, 0, 0);
	m_pD3DCompContext->UpdateSubresource(m_pFirstBuffer, 0, nullptr, &pValuesData[0], 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShader, nullptr, 0);
	m_pD3DCompContext->CSSetShaderResources(0, 2, pSRV);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstBufferData);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 2, pConnectableUAV, nullptr);
	// Sort the data
	// First sort the rows for the levels <= to the block size

	try
	{
		m_pD3DCompContext->Dispatch(pSize, 1, 1);
	}
	catch (std::exception ex)
	{
		throw ex;
	}

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::SimulateMatrixMultiplicationA(HINSTANCE hInstance, HWND hWnd)
{
	HRESULT hr = S_OK;
#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
	ID3D11Device* pDevice = nullptr;
	ID3D11DeviceContext* pContext = nullptr;
	hr = InitializeD3D11Device(hWnd, 0);
	ofstream myfile;
	myfile.open("RandomizationAlgorithmFile.txt");

	std::random_device rd;
	std::mt19937 mt(rd());
	vector<BData> pArrayOneVals = vector<BData>();
	vector<BData> pArrayTwoValues = vector<BData>();


	random_device rnd_device;
	// Specify the engine and distribution.
	mt19937 mersenne_engine(rnd_device());
	uniform_int_distribution<int> dist(1, NUM_ELEMENTS);

	auto gen = std::bind(dist, mersenne_engine);

	pArrayOneVals.clear();
	cout << "We will select an array from 5000  to 6023" << endl;
	int pLimit0 = 0;
	int pLimit1 = 0;
	cout << "Enter the minimum value of the range" << endl;
	cin >> pLimit0;
	cout << "Enter the maximum value of the range" << endl;
	cin >> pLimit1;
	int pArraySize = pLimit1 - pLimit0 + 1;
	cout << "Array Size = " << pArraySize;
	for (int pNumner = pLimit0; pNumner <= pLimit1; ++pNumner)
	{
		BData pData;
		pData.pData = (float)pNumner;
		pArrayOneVals.push_back(pData);

	}
	int pLimit2 = pLimit0 * 6;
	int pLimit3 = pLimit1 * 6;
	for (int pNumber = pLimit2; pNumber <= pLimit3; ++pNumber)
	{
		BData pData;
		pData.pData = (float)pNumber;
		pArrayTwoValues.push_back(pData);
	}




	int pIndex = 0;
	cout << "Enumerating Matrix 1" << endl;

	for (BData pValue : pArrayOneVals)
	{
		cout << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;
		myfile << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;

	}

	cout << "Enumerating Matrix 2" << endl;
	for (int pNumber = pLimit2; pNumber <= pLimit3; ++pNumber)
	{
		BData pData;
		pData.pData = (float)pNumber;
		pArrayTwoValues.push_back(pData);
	}

	for (BData pValue : pArrayTwoValues)
	{
		cout << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;
		myfile << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;

	}



	int pNumElements0 = pArrayOneVals.size();
	int pNumElements1 = pArrayTwoValues.size();



	ID3DBlob* pBlobData = nullptr;
	ID3D11ComputeShader* pRandomAlgorithm = nullptr;
	// Compile the Bitonic Sort Compute Shader
	hr = CompileD3DShaderFromFileW(L"D:\\OLEG\\System GPUDigitalLab ATL Server\\Kernel Final\\Debug\\MatrixMultiplicationCS.hlsl", "CS_Main", "cs_5_0", &pBlobData);
	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateComputeShader(pBlobData->GetBufferPointer(), pBlobData->GetBufferSize(), nullptr, &pRandomAlgorithm);
	if (FAILED(hr))
		return hr;
	SafeReleaseA(&pBlobData);

#if defined(_DEBUG) || defined(PROFILE)
	pRandomAlgorithm->SetPrivateData(WKPDID_D3DDebugObjectName, sizeof("BitonicSort") - 1, "BitonicSort");
#endif

	//Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(ConstantBuffer);
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &m_pBitonicConstantBuffer);



	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = pNumElements0 * sizeof(BData);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(BData);
	buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = pArrayOneVals.data();

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &m_pFirstBuffer);
	if (FAILED(hr))
		return hr;

	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pNumElements1 * sizeof(BData);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(BData);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, nullptr, &m_pSecondBuffer);

	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
srvbuffer_desc.Buffer.ElementWidth = pNumElements0;
srvbuffer_desc.Buffer.ElementOffset = 0;
hr = m_pD3DCompDevice->CreateShaderResourceView(m_pFirstBuffer, &srvbuffer_desc, &m_pFirstBufferSRV);
hr = m_pD3DCompDevice->CreateShaderResourceView(m_pSecondBuffer, &srvbuffer_desc, &m_pSecondBufferSRV);

if (FAILED(hr))
return hr;



if (FAILED(hr))
return hr;
pAdditionAlgorithmsSRV[0] = m_pFirstBufferSRV;
pAdditionAlgorithmsSRV[1] = m_pSecondBufferSRV;
// Create the Unordered Access View for the Buffers
// This is used for writing the buffer during the sort and transpose
D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavbuffer_desc.Buffer.NumElements = pNumElements1;

if (FAILED(hr))
return hr;
hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pFirstBuffer, &uavbuffer_desc, &m_pFirstBufferUAV);
hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pSecondBuffer, &uavbuffer_desc, &m_pSecondBufferUAV);
if (FAILED(hr))
return hr;


// Create the Readback Buffer
// This is used to read the results back to the CPU
D3D11_BUFFER_DESC readback_buffer_desc;
ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
readback_buffer_desc.ByteWidth = pNumElements1 * sizeof(UINT);
readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
readback_buffer_desc.StructureByteStride = sizeof(UINT);
hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &m_pReadBackBuffer);
if (FAILED(hr))
return hr;


ID3D11ShaderResourceView* ppShaderResourceViews[] = { m_pFirstBufferSRV, m_pSecondBufferSRV };
ID3D11UnorderedAccessView* ppUnorderedAccessViews[] = { m_pFirstBufferUAV, m_pSecondBufferUAV };

try
{
	hr = RunComputeShaderAlgorithm(hInstance, hWnd, pArrayOneVals, pRandomAlgorithm, m_pBitonicConstantBuffer, ppShaderResourceViews, ppUnorderedAccessViews);
}
catch (std::exception* e)
{
	OutputDebugString((LPCWSTR)e->what());
	hr = E_INVALIDARG;
	return hr;
}
printf("done\n");

// Read back the result from GPU, verify its correctness against result computed by CPU
{
	D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
	m_pD3DCompContext->CopyResource(m_pReadBackBuffer, m_pSecondBuffer);
	hr = m_pD3DCompContext->Map(m_pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


	// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
	// This is also a common trick to debug CS programs.
	float* p = (float*)MappedResource.pData;

	cout << "Current Data bEGIN" << endl;
	cout << p << endl;
	cout << "Current Data Emd" << endl;
	vector<float> pOutputData = vector<float>();
	pOutputData.push_back(*p);

	// Verify that if Compute Shader has done right
	printf("Verifying against CPU result...");
	bool bSuccess = true;
	int iIndex = 0;
	for (int pIndex = 0; pIndex < pNumElements0; pIndex++)
	{
		cout << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
		myfile << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
		pOutputData.push_back(pIndex);

	}
	if (bSuccess)
		printf("succeeded\n");




}

printf("Cleaning up...\n");
myfile.close();
return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::SimulateFastFourierTransformAlgorithmForward(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	vector<BufType> pInputDataArray0,
	vector<BufType> *pOutputDataArray)
{
	HRESULT hr = S_OK;
	cout << "This Function Allows us to Compute the Fast Fourier Transform Algorithm" << endl;
	UINT pAmountOfHarmonics = 0;
	vector<BufType> ppOutputDataArrayVals = vector<BufType>();

	cout << "We will Start By Allocating Our Buffered Resources," << endl;
	cout << "Enter the Value For K Coefficient" << endl;
	


	cout << "Simulating the Fast Fourier Transform" << endl;
	cout << "Generating the ComplexNumber Array For Output Data" << endl;
	


	cout << "Allocating Data Buffers For Computations" << endl; 
	
	ID3D11ComputeShader* pComputeShaderFFT = nullptr;
	ID3D11Buffer* pFFTInputBuffer0 = nullptr;
	ID3D11ShaderResourceView* pFFTInputBufferSrv0 = nullptr;
	ID3D11Buffer* pFFTInputBufferForBitReverse = nullptr;
	ID3D11ShaderResourceView* pFFTInputBufferSrvBitReverse = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11Buffer* pBitReverseDataBuffer = nullptr;
	ID3D11UnorderedAccessView* pOutputView = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;

	cout << "For the Current Simulation We have the Following Items: " << endl;
	cout << "1 Compute Shader Object" << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer For FFT Simulation" << endl;
	cout << "1 Shader Resource View For the Input Buffer" << endl;
	cout << "2 Output Buffers For FFT Simulation" << endl;
	cout << "2 Unordereded Access Views For Output Buffer" << endl;
	cout << "2 Readback Buffer Object" << endl;

	cout << "Initializing Input Data Buffers" << endl;

	hr = InitializeFFTOneResources(hInstance,
		hWnd, pInputDataArray0.size(),
		pInputDataArray0,
		pInputDataArray0,
		&pComputeShaderFFT,
		&pFFTInputBuffer0,
		&pFFTInputBufferForBitReverse,
		&pFFTInputBufferSrv0,
		&pFFTInputBufferSrvBitReverse,
		&pOutputBuffer,
		&pOutputView,
		&pReadbackBuffer);



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Initialize FFT Data Resources Terminated with Error: " << pLastError << endl;
		return hr;
	}

	m_pD3DCompContext->UpdateSubresource(pFFTInputBuffer0, 0, nullptr, &pInputDataArray0[0], 0, 0);

	cout << "Running the FFT Compute Shader Simulations" << endl;
	
	hr = ExecuteFFTSimulationData(hInstance, hWnd, pInputDataArray0, pInputDataArray0,
		pFFTInputBufferForBitReverse, pComputeShaderFFT,
		pFFTInputBufferSrv0,
		pFFTInputBufferSrvBitReverse,
		pOutputView,
		2, 2, NUM_ELEMENTS,
		1, 1);


	cout << "Copying the Data From GPU TO CPU For Output Values" << endl;
	m_pD3DCompContext->CopyResource(pReadbackBuffer, pOutputBuffer);
	D3D11_MAPPED_SUBRESOURCE pSubresourceDataExponents;
	cout << "Mapping the Readback Buffer FOR EXPONENT OF THE FFT" << endl;
	m_pD3DCompContext->Map(pReadbackBuffer, 0, D3D11_MAP_READ, 0, &pSubresourceDataExponents);
	BufType* pOuputDataExponents = (BufType*)pSubresourceDataExponents.pData;
	for (int i = 0; i < pInputDataArray0.size(); ++i)
	{
		cout << "Current Item At Index: " << i << " Value Int =   " << pOuputDataExponents[i].i << endl;
		cout << "Current Item At Index: " << i << " Value Float =   " << pOuputDataExponents[i].f << endl;
		cout << "Current Item At Index: " << i << " Value Double =   " << pOuputDataExponents[i].d << endl;
		ppOutputDataArrayVals.push_back(pOuputDataExponents[i]);
	}


	
	*pOutputDataArray = ppOutputDataArrayVals;
	

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::ConvertAnArrayOfNumbersToButterFlyConvert(HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pNumberToConvert,
	vector<DivisionRemainder> *ppDivisionRemainders)
{
	HRESULT hr = S_OK;

	cout << "This Function Converts a Vector of Numbers to Butterfly" << endl;
	cout << "We Will now test this Function On Array Of Values" << endl;
	cout << "Initial Array Sizee: " << pNumberToConvert.size();

	int pSize = pNumberToConvert.size();
	if (pSize == 0)
	{
		cout << "You have submitted an empty data array. Terminating the loop" << endl;
		return hr;
	}



	vector<DivisionOutCome> pOutputDataArray = vector<DivisionOutCome>();
	vector<DivisionRemainder> pOutputDataRemaindersArray = vector<DivisionRemainder>();

	ofstream myfile;
	myfile.open("C:\\\pixels\\BitReverseOrder.txt");
	myfile.clear();

	cout << "First We will Print Out Our Input Data" << endl;
	myfile << "First We will Print Out Our Input Data" << endl;

	int pIndex = 0;

	cout << "For This Computer Simulation We Will Need" << endl;
	cout << "1 Compute Shader " << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "2 Unordered Access Views" << endl;
	cout << "2 Readback Buffer" << endl;

	cout << "Now We have to initialize Our Resources" << endl;

	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11Buffer* pInputBufferForBitReverse = nullptr;
	ID3D11ShaderResourceView* pInputBufferSRV = nullptr;
	ID3D11Buffer* pOutputBufferForDivisiors = nullptr;
	ID3D11Buffer* pOutputBufferForRemainders = nullptr;
	ID3D11UnorderedAccessView* pOutDivisorBufferUAV = nullptr;
	ID3D11UnorderedAccessView* pRemainderUAV = nullptr;
	ID3D11Buffer* pDivisorReadbackBuffer = nullptr;
	ID3D11Buffer* pRemainederReadbackBuffer = nullptr;

	myfile << "For This Computer Simulation We Will Need" << endl;
	myfile << "1 Compute Shader " << endl;
	myfile << "1 Input Buffer " << endl;
	myfile << "1 Output Buffer " << endl;
	myfile << "1 Shader Resource View" << endl;
	myfile << "1 Unordered Access View" << endl;
	myfile << "1 Readback Buffer" << endl;

	myfile << "Now We have to initialize Our Resources" << endl;




	cout << "Initializing the Resources For The Simulation" << endl;
	myfile << "Initializing the Resources For The Simulation" << endl;


	hr = InitializeButterFlyConvertionResources(hInstance,
		hWnd, pNumberToConvert,
		&pComputeShaderObject,
		&pInputBufferForBitReverse,
		&pInputBufferSRV,
		&pOutputBufferForDivisiors,
		&pOutputBufferForRemainders,
		&pOutDivisorBufferUAV,
		&pRemainderUAV,
		&pDivisorReadbackBuffer,
		&pRemainederReadbackBuffer);


	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError << endl;
		return hr;
	}

	cout << "Running the Bit Revese Compute Simulations " << endl;

	ID3D11UnorderedAccessView* ppUnorderedViews[] = { pOutDivisorBufferUAV, pRemainderUAV };
	hr = RunButterflyConvertionComputeShader(hInstance, hWnd,
		pNumberToConvert,
		pInputBufferForBitReverse,
		pComputeShaderObject,
		pInputBufferSRV,
		pOutDivisorBufferUAV,
		pRemainderUAV,
		1, 2, NUM_ELEMENTS, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError << endl;
		return hr;
	}

	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;

	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{

		cout << "Copying the Division Output And Remainders" << endl;
		D3D11_MAPPED_SUBRESOURCE MappedResourceOutputs = { 0 };
		D3D11_MAPPED_SUBRESOURCE MappedResourceRemainders = { 0 };

		m_pD3DCompContext->CopyResource(pDivisorReadbackBuffer, pOutputBufferForDivisiors);
		hr = m_pD3DCompContext->Map(pDivisorReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResourceOutputs);
		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		m_pD3DCompContext->CopyResource(pRemainederReadbackBuffer, pOutputBufferForRemainders);
		hr = m_pD3DCompContext->Map(pRemainederReadbackBuffer, 0, D3D11_MAP_READ, 0, &MappedResourceOutputs);



		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		cout << "Priniting Division Outputs" << endl;

		DivisionOutCome* pDivisionResults = (DivisionOutCome*)MappedResourceOutputs.pData;
		for (int pIndex = 0; pIndex < pNumberToConvert.size() / 2; ++pIndex)
		{
			DivisionOutCome pEventOutCome = pDivisionResults[pIndex];
			cout << "Index = " << pIndex << endl;
			cout << "Divident = " << pEventOutCome.pDivident.f << endl;
			cout << "Output = " << pEventOutCome.pOutcome.f << endl;
			pOutputDataArray.push_back(pEventOutCome);
		}
		DivisionRemainder* pRemaindersOutput = (DivisionRemainder*)MappedResourceRemainders.pData;
		for (int pIndex = 0; pIndex < pNumberToConvert.size() / 2; ++pIndex)
		{
			DivisionRemainder pEventOutCome = pRemaindersOutput[pIndex];
			cout << "Index = " << pIndex << endl;
			cout << "Divident = " << pEventOutCome.pDivident.f << endl;
			cout << "Remainder = " << pEventOutCome.pOutcome.f << endl;
			pOutputDataRemaindersArray.push_back(pEventOutCome);
		}




		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";


		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");
	*ppDivisionRemainders = pOutputDataRemaindersArray;
	return hr;


}
	



HRESULT DirectXStandardAlgorithmExecutor::RunButterflyConvertionComputeShader(HINSTANCE hInstance, HWND hWnd,
	vector<BufType> pInitialDataSet,
	ID3D11Buffer* pInputBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAVOutput,
	ID3D11UnorderedAccessView* pRemainderOutputView,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;
	ID3D11UnorderedAccessView* ppUAVCollection[] = { pUnorderedUAVOutput, pRemainderOutputView };
	m_pD3DCompContext->UpdateSubresource(pInputBuffer, 0, nullptr, &pInitialDataSet[0], 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &pUnorderedUAVOutput, nullptr);
	m_pD3DCompContext->CSSetUnorderedAccessViews(1, 1, &pRemainderOutputView, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);

	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}


	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr};
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr, };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetUnorderedAccessViews(1, 1, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, 1, ppSRVnullptr);



	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::MixArrayIntoOddAndEvenElements(HINSTANCE hInstance,
	HWND hWnd,
	vector<UINT> pInputDataArray,
	vector<UINT> *pReverseOrderValues)
{
	HRESULT hr = S_OK;
	cout << "First We Will Allocate the Arrays For Computer Simulation" << endl;
	vector<UINT> pEventElements = vector<UINT>();
	vector<UINT> pOddElements = vector<UINT>();
	vector<UINT> pFinalArray = vector<UINT>();

	cout << "Start Our Array Splitting Algorithm" << endl;

	for (UINT pNumber : pInputDataArray)
	{
		UINT pRemainder = pNumber % 2;
		if (pRemainder == 0)
		{
			pEventElements.push_back(pNumber);
		}
		if (pRemainder == 1)
		{
			pOddElements.push_back(pNumber);
		}

	}

	cout << "shuffling the data in the Vector" << endl;
	std::random_shuffle(pEventElements.begin(), pEventElements.end());
	std::random_shuffle(pOddElements.begin(), pOddElements.end());




	cout << "Joining odd and Even elements into single Array" << endl;
	
	for (UINT pNumber : pEventElements)
	{
		pFinalArray.push_back(pNumber);
	}

	for (UINT pNumber : pOddElements)
	{
		pFinalArray.push_back(pNumber);
	}
	
	*pReverseOrderValues = pFinalArray;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::ConvertAnArrayOfNumbersToButterFlyOnCPU(HINSTANCE hInstance, HWND hWnd, vector<UINT> pInputDataArray, vector<UINT> *pReverseOrderValues)
{
	HRESULT hr = S_OK;

	vector<UINT> pOutputDataArrayValues = vector<UINT>();
	cout << "This Function Will Convert An Array Of Integers to Buttefly values: " << endl;
	UINT pIndex = 0;
	ofstream myfile;
	myfile.open("C:\\\pixels\\BinaryConvertionForArrayOfNumbers.txt");
	UINT pOutputNumber = 0;
	vector<UINT> pRemReverse = vector<UINT>();
	vector<UINT> pRemAfterReverse = vector<UINT>();
	
	for (UINT pInputNumber : pInputDataArray)
	{
		cout << "Computing Item At Index: " << pIndex << "Value: " << pInputNumber << endl;
		myfile << "Computing Item At Index: " << pIndex << "Value: " << pInputNumber << endl;

		pOutputNumber = ReverseBits(pInputNumber);
		cout << "A New Item Converted Has Value" << pIndex << "Has Value: " << pOutputNumber << endl;
		myfile << "A New Item Converted Has Value" << pIndex << "Has Value: " << pOutputNumber << endl;
		pOutputDataArrayValues.push_back(pOutputNumber);
	}

	



	cout << "Let Us Undo the Convertion Operation" << endl;
	vector<UINT> pReverseOutputDataArray = vector<UINT>();
	pIndex = 0;
	for (UINT pInputNumber : pOutputDataArrayValues)
	{
		cout << "Computing Item At Index: " << pIndex << "Value: " << pInputNumber << endl;
		myfile << "Computing Item At Index: " << pIndex << "Value: " << pInputNumber << endl;

		pOutputNumber = ReverseBits(pInputNumber);
		cout << "A New Item Converted Has Value" << pIndex << "Has Value: " << pOutputNumber << endl;
		myfile << "A New Item Converted Has Value" << pIndex << "Has Value: " << pOutputNumber << endl;
		pReverseOutputDataArray.push_back(pOutputNumber);
	}

	cout << "Printing the Contents of the Final Array" << endl;
	pIndex = 0;
	for (UINT pInputNumber : pReverseOutputDataArray)
	{
		cout << "Computing Item At Index: " << pIndex << "Value: " << pInputNumber << endl;
		myfile << "Computing Item At Index: " << pIndex << "Value: " << pInputNumber << endl;
	}



	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::ConvertNumberToBinary(HINSTANCE hInstance, HWND hWnd, UINT pNumberToConvert, vector<float> *ppDivisionSteps, vector<float> *pBinaryNumber)
{
	HRESULT hr = S_OK;
	int a1, a2;
	int tab = 0;
	int maxtab = 0;
	int pIndex = 0;
	vector<float> pDivisionSteps = vector<float>();
	vector<float> pRemaindersReal = vector<float>();
	ofstream myfile;
	myfile.open("C:\\\pixels\\ConvertNumberToBinary.txt");
	cout << "We are Going to Convert A number: " << pNumberToConvert << endl;
	myfile << "We are Going to Convert A number: " << pNumberToConvert << endl;
	UINT pElementIndex = 0;
	long long binaryNumber = 0;
	int remainder, i = 1, step = 1;

	a2 = pNumberToConvert; //we need our number for later on so we save it in another variable

	while (pNumberToConvert != 0) //dividing by two until we hit 0
	{
		pDivisionSteps.push_back(a2);
		float pFactory = pNumberToConvert / 2;
		remainder = a2 % 2; //getting a remainder - decimal number(1 or 0)
		printf("Step %d: %d/2, Remainder = %d, Quotient = %d\n", step++, pNumberToConvert, remainder, pFactory);
		cout << "Remainder Value At Index: " << pIndex << " = " << remainder << endl;
		myfile << "Factory Value At Index: " << pIndex << " = " << pNumberToConvert << endl;
		myfile << "Remainder Value At Index: " << pIndex << " = " << remainder << endl;
		cout << "Factory Value At Index: " << pIndex << " = " << pNumberToConvert << endl;
		binaryNumber += remainder*i;
		i *= 10;
		pNumberToConvert = pNumberToConvert / 2; //dividing our number by two
		maxtab++; //+1 to max elements of the table
		pRemaindersReal.push_back(remainder);
		a2 = pNumberToConvert;
		pIndex++;
	}


	cout << "Printing the Division Results" << endl;

	for (UINT pElement : pDivisionSteps)
	{
		cout << "Factory Item At Index: " << pElementIndex << " = " << pElement << endl;
		myfile << "Factory Item At Index: " << pElementIndex << " = " << pElement << endl;
		pElementIndex++;
	}



	cout << "Printing the Remainders" << endl;
	pElementIndex = 0;
	for (UINT pElement : pRemaindersReal)
	{
		cout << "Remainder Item At Index: " << pElementIndex << " = " << pElement << endl;
		myfile << "Remainder Item At Index: " << pElementIndex << " = " << pElement << endl;
		pElementIndex++;
	}



	

	cout << "Printing the Reverse OF the Bits" << endl;
	myfile << "Printing the Reverse OF the Bits" << endl;

	pElementIndex = 1;
	float pOutputDecimal = 0;
	for (UINT pElement : pRemaindersReal)
	{
		cout << "Output Item At Index: " << pElementIndex << " = " << pElement << endl;
		myfile << "Output Item At Index: " << pElementIndex << " = " << pElement << endl;
		float pValue = pElement * pow(2, pElementIndex - 1);
		pOutputDecimal = pOutputDecimal + pValue;
		pElementIndex++;
	}
	UINT binaryNumber1 = binaryNumber;



	myfile.close();
	*ppDivisionSteps = pDivisionSteps;
	*pBinaryNumber = pRemaindersReal;
	
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::ConvertNumberToBinaryValueAndComputeButterFly(HINSTANCE hInstance, HWND hWnd, UINT pNumberToConvert, vector<UINT> *ppDivisionSteps, vector<UINT> *pRemaindersBeforeReversal, vector<UINT> *pRemaindersAfterReversal, UINT *pReversedNumber)
{
	HRESULT hr = S_OK;
	int a1, a2;
	int tab = 0;
	int maxtab = 0;
	int pIndex = 0;
	vector<UINT> pOutputVector = vector<UINT>();
	vector<UINT> pRemaindersReversed = vector<UINT>();
	vector<UINT> pDivisionSteps = vector<UINT>();
	vector<UINT> pRemaindersReal = vector<UINT>();
	ofstream myfile;
	myfile.open("C:\\\pixels\\ConvertNumberToBinary.txt");
	cout << "We are Going to Convert A number: " << pNumberToConvert << endl;
	myfile << "We are Going to Convert A number: " << pNumberToConvert << endl;
	UINT pElementIndex = 0;
	long long binaryNumber = 0;
	int remainder, i = 1, step = 1;

	a2 = pNumberToConvert; //we need our number for later on so we save it in another variable

	while (pNumberToConvert != 0) //dividing by two until we hit 0
	{
		pDivisionSteps.push_back(a2);
		float pFactory = pNumberToConvert / 2;
		remainder = a2 % 2; //getting a remainder - decimal number(1 or 0)
		printf("Step %d: %d/2, Remainder = %d, Quotient = %d\n", step++, pNumberToConvert, remainder, pFactory);
		cout << "Remainder Value At Index: " << pIndex << " = " << remainder << endl;
		myfile << "Factory Value At Index: " << pIndex << " = " << pNumberToConvert << endl;
		myfile << "Remainder Value At Index: " << pIndex << " = " << remainder << endl;
		cout << "Factory Value At Index: " << pIndex << " = " << pNumberToConvert << endl;
		binaryNumber += remainder*i;
		i *= 10;
		pNumberToConvert = pNumberToConvert / 2; //dividing our number by two
		maxtab++; //+1 to max elements of the table
		pRemaindersReversed.push_back(remainder);
		pRemaindersReal.push_back(remainder);
		a2 = pNumberToConvert;
		pIndex++;
	}

	
	cout << "Printing the Division Results" << endl;
	
	for (UINT pElement : pDivisionSteps)
	{
		cout << "Factory Item At Index: " << pElementIndex << " = " << pElement << endl;
		myfile << "Factory Item At Index: " << pElementIndex << " = " << pElement << endl;
		pElementIndex++;
	}



	cout << "Printing the Remainders" << endl;
	pElementIndex = 0;
	for (UINT pElement : pRemaindersReversed)
	{
		cout << "Remainder Item At Index: " << pElementIndex << " = " << pElement << endl;
		myfile << "Remainder Item At Index: " << pElementIndex << " = " << pElement << endl;
		pElementIndex++;
	}



	cout << "Reversing the Bits Of The Number" << endl;
	myfile << "Reversing the Bits Of The Number" << endl;
	std::reverse(pRemaindersReal.begin(), pRemaindersReal.end());




	pOutputVector.clear();


	cout << "Printing the Reverse OF the Bits" << endl;
	myfile << "Printing the Reverse OF the Bits" << endl;

	 pElementIndex = 1;
	float pOutputDecimal = 0;
	for (UINT pElement : pRemaindersReal)
	{
		cout << "Output Item At Index: " << pElementIndex << " = " << pElement << endl;
		myfile << "Output Item At Index: " << pElementIndex << " = " << pElement << endl;
		float pValue = pElement * pow(2, pElementIndex - 1);
		pOutputDecimal = pOutputDecimal + pValue;
		pElementIndex++;
	}
	UINT binaryNumber1 = binaryNumber;

	
	
	myfile.close();
	*ppDivisionSteps = pDivisionSteps;
	*pRemaindersBeforeReversal = pRemaindersReal;
	*pRemaindersAfterReversal = pRemaindersReversed;
	*pReversedNumber = pOutputDecimal;

	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeButterFlyConvertionResources(HINSTANCE hInstance,
	HWND hWnd,
	vector<BufType> pInputDataBuffer,
	ID3D11ComputeShader** ppConvertToButterFlyComputeShader,
	ID3D11Buffer** ppInputBufferButterfly, 
	ID3D11ShaderResourceView** ppInputButterflySRV,
	ID3D11Buffer**  ppOutputBufferForDivisors,
	ID3D11Buffer** ppOutputBufferForRemainders, 
	ID3D11UnorderedAccessView** ppOutputUAVOutcome, 
	ID3D11UnorderedAccessView** ppUnorderedAccessViewButterFly, 
	ID3D11Buffer** ppReadbackDataBufferOutcome, 
	ID3D11Buffer** pRemainderOutcome)
{
	HRESULT hr = S_OK;
	cout << "This Function Will Be Used to Initialize Data For ButterFly Conversion" << endl;
	cout << "Initializing Direct3D11 Device" << endl;
	UINT pInputSize = 0;
	pInputSize = pInputDataBuffer.size();

	if (pInputSize == 0)
	{
		cout << "You have Submitted an empty input buffer" << endl;
		return hr;
	}	





	hr = InitializeD3D11Device(hWnd, 0);
	UINT pIndex = 0;
	
	UINT pAmountOfSamples = pInputDataBuffer.size();

	vector<DivisionRemainder> pDivisionRemainderObjectArray = vector<DivisionRemainder>();





	
	ID3DBlob* pBlobOut = nullptr;
	ID3D11ComputeShader* pButterFlyComputeShaderCS = nullptr;
	ID3D11Buffer* pButterFlyeInputDataBuffer0 = nullptr;
	ID3D11Buffer* pOutputBufferForDivisors = nullptr;
	ID3D11Buffer* pOutputBufferRemainders = nullptr;
	ID3D11ShaderResourceView* pButterflyInputBufferSRV = nullptr;
	ID3D11UnorderedAccessView* pOutputUnorderedAccessView = nullptr;
	ID3D11UnorderedAccessView* pButterflyOutputUAVRemainders = nullptr;
	ID3D11Buffer* pReadbackBufferRemainders = nullptr;
	ID3D11Buffer* pReadbackBufferForOutcomes = nullptr;



	cout << "Initializing Our Compute Shader Buffer" << endl;

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CSComputeBitReverseShared.hlsl",
		"CS_Main", "cs_5_0", &pBlobOut);

	if (FAILED(hr))
	{
		int pGetLastError = 0;
		pGetLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Скомпилировать Алгоритм Фурье", (LPCSTR)"Message", 0);
		cout << "Error Occured During Shader Data Compilations Error: " << pGetLastError << endl;
		return hr;
	}

	cout << "Creating Compute Bit Reverse Shader Object" << endl;

	hr = m_pD3DCompDevice->CreateComputeShader(pBlobOut->GetBufferPointer(),
		pBlobOut->GetBufferSize(), nullptr,
		&pButterFlyComputeShaderCS);

	if (FAILED(hr))
	{
		int pGetLastError = 0;
		pGetLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Шейер Алгоритма BitReverse", (LPCSTR)"Message", 0);
		cout << "Error Occured During Shader Data Compilations Error: " << pGetLastError << endl;
		return hr;
	}

	cout << "Creating the Input Buffer For Importing the Data For Computations" << endl;

	// Create 2 buffers for switching between when performing the transpose
	
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.StructureByteStride = sizeof(BufType) * 2;
	buffer_desc.ByteWidth = pInputSize * sizeof(BufType);
	buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = &pInputDataBuffer[0];




	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &pButterFlyeInputDataBuffer0);



	if (FAILED(hr))
	{
		int pGetLastError = 0;
		pGetLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать входной буффер данных ", (LPCSTR)"Message", 0);
		cout << "Error Occured During exit of an Input Buffer for Bit Reversal : " << pGetLastError << endl;
		return hr;
	}

	D3D11_BUFFER_DESC output_buffer_desc_outputs;
	ZeroMemory(&output_buffer_desc_outputs, sizeof(output_buffer_desc_outputs));
	output_buffer_desc_outputs.StructureByteStride = sizeof(DivisionOutCome) * 2;
	output_buffer_desc_outputs.ByteWidth = pInputDataBuffer.size() * sizeof(BufType);
	output_buffer_desc_outputs.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	output_buffer_desc_outputs.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	output_buffer_desc_outputs.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	output_buffer_desc_outputs.Usage = D3D11_USAGE_DEFAULT;

	// Create 2 buffers for switching between when performing the transpose



	hr = m_pD3DCompDevice->CreateBuffer(&output_buffer_desc_outputs, NULL, &pOutputBufferForDivisors);

	D3D11_BUFFER_DESC output_buffer_desc_remainders;
	ZeroMemory(&output_buffer_desc_outputs, sizeof(output_buffer_desc_remainders));
	output_buffer_desc_remainders.StructureByteStride = sizeof(DivisionRemainder) * 2;
	output_buffer_desc_remainders.ByteWidth = pInputDataBuffer.size() * sizeof(DivisionRemainder);
	output_buffer_desc_remainders.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	output_buffer_desc_remainders.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	output_buffer_desc_remainders.Usage = D3D11_USAGE_DEFAULT;
	output_buffer_desc_remainders.CPUAccessFlags = D3D11_CPU_ACCESS_READ;



	hr = m_pD3DCompDevice->CreateBuffer(&output_buffer_desc_remainders, NULL, &pOutputBufferRemainders);

	if (FAILED(hr))
	{
		int pGetLastError = 0;
		pGetLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать выходной буффер результатов Деленияс ", (LPCSTR)"Message", 0);
		cout << "Error Occured During exit of an Input Buffer for Bit Reversal : " << pGetLastError << endl;
		return hr;
	}


	

	
	cout << "Creating the Shader Resource for the Input Buffer " << endl;

	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pInputDataBuffer.size() / 2;
	srvbuffer_desc.Buffer.ElementOffset = 0;


	cout << "Creating the Shader Resource View for the Input Data Buffer Buffer" << endl;
	hr = m_pD3DCompDevice->CreateShaderResourceView(pButterFlyeInputDataBuffer0, &srvbuffer_desc, &pButterflyInputBufferSRV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Функции Bit Reverse", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	cout << "Creating the Unordered Access view for the Output Buffer" << endl;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 9;
	uavbuffer_desc.Buffer.NumElements = pInputDataBuffer.size() / 4;
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferForDivisors, &uavbuffer_desc, &pOutputUnorderedAccessView);
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBufferRemainders, &uavbuffer_desc, &pButterflyOutputUAVRemainders);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс ВВода Вывода для Функции BitReverse", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	// This is used to read the results back to the CPU
	
	D3D11_BUFFER_DESC readback_outuput_buffer_desc;
	ZeroMemory(&readback_outuput_buffer_desc, sizeof(readback_outuput_buffer_desc));
	readback_outuput_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(DivisionOutCome);
	readback_outuput_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_outuput_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_outuput_buffer_desc.StructureByteStride = sizeof(DivisionOutCome) / 2;
	cout << "Creating Readback Data Output Buffer for remainders" << endl;



	hr = m_pD3DCompDevice->CreateBuffer(&readback_outuput_buffer_desc, nullptr, &pReadbackBufferForOutcomes);




	D3D11_BUFFER_DESC readback_remainder_buffer_desc;
	ZeroMemory(&readback_remainder_buffer_desc, sizeof(readback_remainder_buffer_desc));
	readback_remainder_buffer_desc.ByteWidth = pInputDataBuffer.size() * sizeof(DivisionRemainder);
	readback_remainder_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_remainder_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_remainder_buffer_desc.StructureByteStride = sizeof(DivisionRemainder) / 2;
	cout << "Creating Readback Data Output Buffer for remainders" << endl;



	hr = m_pD3DCompDevice->CreateBuffer(&readback_remainder_buffer_desc, nullptr, &pReadbackBufferRemainders);


	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Буффер Чтения для Функции BitReverse", (LPCSTR)"Message", 0);
		cout << "The Readback Buffer for Bit Reverse Function Has Been Successfully Created " << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Буффер чтения для остатков дедения", (LPCSTR)"Message", 0);
		cout << "The exit of A Readback Buffer for quotients Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppConvertToButterFlyComputeShader = pButterFlyComputeShaderCS;
	*ppInputBufferButterfly = pButterFlyeInputDataBuffer0;
	*ppOutputBufferForDivisors = pOutputBufferForDivisors;
	*ppOutputBufferForRemainders = pOutputBufferRemainders;
	*ppInputButterflySRV = pButterflyInputBufferSRV;
	*ppOutputUAVOutcome = pOutputUnorderedAccessView;
	*ppUnorderedAccessViewButterFly = pButterflyOutputUAVRemainders;
	*ppReadbackDataBufferOutcome = pReadbackBufferForOutcomes;
	*pRemainderOutcome = pReadbackBufferRemainders;

	return hr;

}



HRESULT DirectXStandardAlgorithmExecutor::InitializeFFTOneResources(HINSTANCE hInstance,
	HWND hWnd,
	UINT pAmountOfSamples,
	vector<BufType> pInputDataArray,
	vector<BufType> pHarmonicsArray,
	ID3D11ComputeShader** ppComputeShaderFFT,
	ID3D11Buffer** ppBufferOneFFT,
	ID3D11Buffer** ppHarmonicsBuffer,
	ID3D11ShaderResourceView** ppSRVOneFFT,
	ID3D11ShaderResourceView** ppHarmonicsSrv,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11UnorderedAccessView** ppOutputView,
	ID3D11Buffer** ppReadbackBuffer)
{
	
	HRESULT hr = S_OK;

	ID3DBlob* ppBlobOut = nullptr;
	ID3D11ComputeShader* ppComputeShaderObject = nullptr;
	ID3D11Buffer* pFFTConstantBuffer = nullptr;
	ID3D11Buffer* pFFTInputDataBuffer0 = nullptr;
	ID3D11Buffer* pOmegaDataBuffer = nullptr;
	ID3D11Buffer* pFFTOutputDataBuffer = nullptr;
	ID3D11Buffer* pFFTOutputIntegralBuffer = nullptr;
	ID3D11Buffer* pHarmonicsBuffer = nullptr;
	ID3D11Buffer* pExponentDataBufferOutput = nullptr;
	ID3D11ShaderResourceView* pFFTInputDataSRV0 = nullptr;
	ID3D11ShaderResourceView* pHarmonicsBufferSRV = nullptr;
	ID3D11UnorderedAccessView* pFFTOutputDataUAV = nullptr;
	ID3D11UnorderedAccessView* pFFTOutputIntegralUAV = nullptr;
	ID3D11Buffer* pFFTReadbackBuffer = nullptr;
	ID3D11Buffer* pFFTIntegralReadbackBuffer = nullptr;
	vector<BData> pInputDataVector = vector<BData>();
	hr = InitializeD3D11Device(hWnd, 0);

	int pDataInputSize = 0;
	cout << "Your Current Input Array Data Size: " << pDataInputSize << endl;
	
	

	cout << "Initializing Our Compute Shader Buffer" << endl;

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\FastFourierTransform.hlsl",
		"CS_Main", "cs_5_0", &ppBlobOut);

	if (FAILED(hr))
	{
		int pGetLastError = 0;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Скомпилировать Алгоритм Фурье", (LPCSTR)"Message", 0);
		cout << "Error Occured During Shader Data Compilations Error: " << pGetLastError << endl;
		return hr;
	}

	cout << "Creating Compute FFT Shader Object" << endl;

	hr = m_pD3DCompDevice->CreateComputeShader(ppBlobOut->GetBufferPointer(),
		ppBlobOut->GetBufferSize(), nullptr,
		&ppComputeShaderObject);

	if (FAILED(hr))
	{
		int pGetLastError = 0;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Шейер Алгоритма Фурье", (LPCSTR)"Message", 0);
		cout << "Error Occured During Shader Data Compilations Error: " << pGetLastError << endl;
		return hr;
	}


	cout << "Creating the Input Data Buffer" << endl;

	cout << "Creating the input buffer" << endl;





	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.StructureByteStride = sizeof(BufType) / 2;
	buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BufType);
	buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;

	D3D11_SUBRESOURCE_DATA inputData;
	inputData.pSysMem = &pInputDataArray[0];


	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &inputData, &pFFTInputDataBuffer0);
	if (FAILED(hr))
	{
		int pGetLastError = 0;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Входной Буффео", (LPCSTR)"Message", 0);
		cout << "Error Occured During Input Buffer exit Error: " << pGetLastError << endl;
		return hr;
	}

	D3D11_BUFFER_DESC harmonics_buffer_desc;
	ZeroMemory(&harmonics_buffer_desc, sizeof(harmonics_buffer_desc));
	harmonics_buffer_desc.StructureByteStride = sizeof(BufType) / 2;
	harmonics_buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BufType);
	harmonics_buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	harmonics_buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	harmonics_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	
	hr = m_pD3DCompDevice->CreateBuffer(&harmonics_buffer_desc, NULL, &pHarmonicsBuffer);



	cout << "Creating the output Buffer Object" << endl;


	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.StructureByteStride = sizeof(BufType) / 2;
	buffer_desc1.ByteWidth = pAmountOfSamples * sizeof(BufType);
	buffer_desc1.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, NULL, &pFFTOutputDataBuffer);
	if (FAILED(hr))
	{
		int pGetLastError = 0;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Cоздать Выходной Буффер Основной Функции", (LPCSTR)"Message", 0);
		cout << "Error Occured During Input Buffer exit Error: " << pGetLastError << endl;
		return hr;
	}
	cout << "Creating the output Buffer Object for integral function output" << endl;

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для Алгоритма фурье", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pAmountOfSamples / 2;
	srvbuffer_desc.Buffer.ElementOffset = 0;


	cout << "Creating the Shader Resource View for the K Coefficients Buffer" << endl;
	hr = m_pD3DCompDevice->CreateShaderResourceView(pFFTInputDataBuffer0, &srvbuffer_desc, &pFFTInputDataSRV0);
	cout << "Creating the Shader Resource View for the J Coefficients Buffer" << endl;
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}




	cout << "Creating the Unordered Access view for the Output Buffer" << endl;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 0;
	uavbuffer_desc.Buffer.NumElements = pAmountOfSamples / 2;
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentDataBufferOutput, &uavbuffer_desc, &pFFTOutputDataUAV);


	cout << "Creating the Unordered Access view for the Output Integral Buffer" << endl;

	
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BData);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(BData) / 2;
	cout << "Creating Readback Data Output Buffer" << endl;
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pFFTReadbackBuffer);

	cout << "Creating Readback Data Output Buffer" << endl;
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Readback Data Buffer: " << pLastError << endl;
		return hr;
	}


	*ppComputeShaderFFT = ppComputeShaderObject;
	*ppBufferOneFFT = pFFTInputDataBuffer0;
	*ppSRVOneFFT = pFFTInputDataSRV0;
	*ppHarmonicsBuffer = pHarmonicsBuffer;
	*ppHarmonicsSrv = pHarmonicsBufferSRV;
	*ppOutputBuffer = pFFTOutputDataBuffer;
	*ppOutputView = pFFTOutputIntegralUAV;
	*ppReadbackBuffer = pFFTIntegralReadbackBuffer;
	return hr;
}


HRESULT DirectXStandardAlgorithmExecutor::SimulateRandomAlgorithm(HINSTANCE hInstance, HWND hWND)
{
	HRESULT hr = S_OK;
#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
	ID3D11Device* pDevice = nullptr;
	ID3D11DeviceContext* pContext = nullptr;
	hr = InitializeD3D11Device(hWND, 0);
	ofstream myfile;
	myfile.open("RandomizationAlgorithmFile.txt");

	std::random_device rd;
	std::mt19937 mt(rd());
	vector<BData> pArrayOneVals = vector<BData>();



	random_device rnd_device;
	// Specify the engine and distribution.
	mt19937 mersenne_engine(rnd_device());
	uniform_int_distribution<int> dist(1, NUM_ELEMENTS);

	auto gen = std::bind(dist, mersenne_engine);

	pArrayOneVals.clear();
	cout << "We will select an array from 5000  to 6023" << endl;
	int pLimit0 = 0;
	int pLimit1 = 0;
	cout << "Enter the minimum value of the range" << endl;
	cin >> pLimit0;
	cout << "Enter the maximum value of the range" << endl;
	cin >> pLimit1;
	int pArraySize = pLimit1 - pLimit0 + 1;
	cout << "Array Size = " << pArraySize;
	for (int pNumner = pLimit0; pNumner <= pLimit1; ++pNumner)
	{
		BData pParam;
		pParam.pData = pNumner;
		pArrayOneVals.push_back(pParam);
	}


	int pIndex = 0;
	for (BData pValue : pArrayOneVals)
	{
		cout << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;
		myfile << "Initial Value Before The Simulation At Index" << pIndex << " = " << pValue.pData << endl;

	}

	int pNumElements = pArrayOneVals.size();

	ID3DBlob* pBlobData = nullptr;
	ID3D11ComputeShader* pRandomAlgorithm = nullptr;
	// Compile the Bitonic Sort Compute Shader
	hr = CompileD3DShaderFromFileW(L"E:\\С\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObject\\stest.hlsl", "CS_Main", "cs_5_0", &pBlobData);
	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateComputeShader(pBlobData->GetBufferPointer(), pBlobData->GetBufferSize(), nullptr, &pRandomAlgorithm);
	if (FAILED(hr))
		return hr;
	SafeReleaseA(&pBlobData);

#if defined(_DEBUG) || defined(PROFILE)
	pRandomAlgorithm->SetPrivateData(WKPDID_D3DDebugObjectName, sizeof("BitonicSort") - 1, "BitonicSort");
#endif

	//Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(ConstantBuffer);
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &m_pBitonicConstantBuffer);



	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = pNumElements * sizeof(BData);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(BData);
	buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pData;
	pData.pSysMem = pArrayOneVals.data();

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, &pData, &m_pFirstBuffer);
	if (FAILED(hr))
		return hr;

	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pNumElements * sizeof(BData);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(BData);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, nullptr, &m_pSecondBuffer);

	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pNumElements;
	srvbuffer_desc.Buffer.ElementOffset = 0;
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pFirstBuffer, &srvbuffer_desc, &m_pFirstBufferSRV);
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pSecondBuffer, &srvbuffer_desc, &m_pSecondBufferSRV);

	if (FAILED(hr))
		return hr;



	if (FAILED(hr))
		return hr;
	pAdditionAlgorithmsSRV[0] = m_pFirstBufferSRV;
	pAdditionAlgorithmsSRV[1] = m_pSecondBufferSRV;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pNumElements;

	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pFirstBuffer, &uavbuffer_desc, &m_pFirstBufferUAV);
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pSecondBuffer, &uavbuffer_desc, &m_pSecondBufferUAV);
	if (FAILED(hr))
		return hr;


	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pNumElements * sizeof(UINT);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(UINT);
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &m_pReadBackBuffer);
	if (FAILED(hr))
		return hr;


	ID3D11ShaderResourceView* ppShaderResourceViews[] = { m_pFirstBufferSRV, m_pSecondBufferSRV };
	ID3D11UnorderedAccessView* ppUnorderedAccessViews[] = { m_pFirstBufferUAV, m_pSecondBufferUAV };

	try
	{
		hr = RunComputeShaderAlgorithm(hInstance, hWND, pArrayOneVals, pRandomAlgorithm, m_pBitonicConstantBuffer, ppShaderResourceViews, ppUnorderedAccessViews);
	}
	catch (std::exception* e)
	{
		OutputDebugString((LPCWSTR)e->what());
		hr = E_INVALIDARG;
		return hr;
	}
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(m_pReadBackBuffer, m_pSecondBuffer);
		hr = m_pD3DCompContext->Map(m_pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);


		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		float* p = (float*)MappedResource.pData;

		cout << "Current Data bEGIN" << endl;
		cout << p << endl;
		cout << "Current Data Emd" << endl;
		vector<float> pOutputData = vector<float>();
		pOutputData.push_back(*p);

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (int pIndex = 0; pIndex < pNumElements; pIndex++)
		{
			cout << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
			myfile << "Computation Results at index:" << " " << iIndex << " " << "=" << " " << p[pIndex] << endl;
			pOutputData.push_back(pIndex);

		}
		if (bSuccess)
			printf("succeeded\n");




	}

	printf("Cleaning up...\n");
	myfile.close();
	return hr;

}


HRESULT DirectXStandardAlgorithmExecutor::PerformExponentialFunctionSimulation(HINSTANCE hInstance, HWND hWnd, float pCoefficientParam, float pFreeCoefficient, vector<BufType> pInputData, vector<BufType> *pOutputData)
{
	HRESULT hr = S_OK;

	cout << "We are Going to Simulate the behaviour of an exponential function " << endl;

	
	vector<double> pOutputDataBuffer = vector<double>();

	
	

	int pIndex = 0;
	cout << "Printing the Initial Data: " << endl;
	for (BufType pDataValue : pInputData)
	{
		cout << "Input Item Int At Index: " << pIndex << " = " << pDataValue.i << endl;
		cout << "Input Item Float At Index: " << pIndex << " = " << pDataValue.f << endl;
		cout << "Input Item Float At Index: " << pIndex << " = " << pDataValue.d << endl;

		pIndex = pIndex + 1;
	}

	vector<BufType> pOutputBufferData = vector<BufType>();
	vector<BufType> pInputParamData = vector<BufType>();

	pIndex = 0;
	cout << "Printing the Initial Data: " << endl;
	
	

	cout << "Performing the Simulation on the GPU" << endl;

	hr = SimulateExponentionaFunction(hInstance, hWnd, pCoefficientParam, pFreeCoefficient, pInputData, &pOutputBufferData);

	cout << "Printing the output results" << endl;

	pIndex = 0;
	for (BufType pDataValue : pOutputBufferData)
	{
		cout << "Output Item Int At Index: " << pIndex << " = " << pDataValue.i << endl;
		cout << "Output Item Float At Index: " << pIndex << " = " << pDataValue.f << endl;
		cout << "Output Item Float At Index: " << pIndex << " = " << pDataValue.d << endl;

		pIndex = pIndex + 1;
	}
	*pOutputData = pOutputBufferData;

	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::SimulateCosineFunctionBehaviour(HINSTANCE hInstance,
	HWND hWnd, 
    float pCosineFunctionCoefficient,
     float pEmptyCoeffient,
      vector<InputStructureForGraph> pInputData,
       vector<OutputStructureForGraph> *pOutputBuffer)
{

#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

	HRESULT hr = S_OK;

	vector <OutputStructureForGraph> pOutpuArray = vector<OutputStructureForGraph>();
	cout << "Creating the Compute Direct3D11 Device" << endl;
	cout << "Preparing the input Data" << endl;

	dataArray.resize(NUM_ELEMENTS);
	ofstream myfile;
	myfile.open("ArraySortingFile.txt");
	int pIndex = 0;
	cout << "Printing Out the Contents Of The Structured Buffer" << endl;
	int pCounterVal = 0;

	for (InputStructureForGraph pBufTypeVar : pInputData)
	{
		cout << "Input Structure Id = " << pBufTypeVar.pInputItemValue << endl;
		cout << "Item Value = " << pBufTypeVar.pInputItemValue << endl;
	}

	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;
	cout << "Now We have to initalize Our Resources" << endl;

	ID3D11ComputeShader* pExponentialComputeShaderCS = nullptr;
	ID3D11Buffer* pConstantBufferForQuadraticFunction = nullptr;
	ID3D11Buffer* pInputBufferForExpFunction = nullptr;
	ID3D11Buffer* pOutputBufferForExpFunction = nullptr;
	ID3D11ShaderResourceView* pExponentinalFunctionSRV0 = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionUAV0 = nullptr;
	cout << "Initializing the Resources For the Simulation" << endl;
	
	hr = InitializeCosineFunctionResources(hInstance,
		hWnd,
	    pCosineFunctionCoefficient,
		pEmptyCoeffient,
		pInputData,
		&pExponentialComputeShaderCS,
		&pConstantBufferForQuadraticFunction,
		&pInputBufferForExpFunction,
		&pOutputBufferForExpFunction,
		&pExponentinalFunctionSRV0,
		&pExponentialFunctionUAV0,
		&pReadBackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError <<
			endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;
	hr = RunCosineFunctionShaderAlgorithm(hInstance,
		hWnd,
		pConstantBufferForQuadraticFunction,
		pExponentialComputeShaderCS,
		pExponentinalFunctionSRV0,
		pExponentialFunctionUAV0,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError <<
			endl;
		return hr;
	}
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;
	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;
	printf("done\n");
	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferForExpFunction);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);
		// Set a break point here and put down the expression "p, 1024" in your watch window to see what hasbeen written out by our CS
		// This is also a common trick to debug CS programs.
		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has	been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputStructureForGraph* pOutputStructureForGraph = (OutputStructureForGraph*)MappedResource.pData;
		for (int iIndex = 0; iIndex < pInputData.size(); ++iIndex)
		{
			OutputStructureForGraph pOutputStructure = pOutputStructureForGraph[iIndex];
			cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
			cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
			pOutpuArray.push_back(pOutputStructure);
		}
		fstream myfile;
		myfile.open("С:\\pixels\\QuadraticFunctionTxt.txt");

		std::time_t t = std::time(0); // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";
		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputStructureForGraph pOutputStructure : pOutpuArray)
		{
			cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
			cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
			myfile << "Item Index = " << pOutputStructure.pItemIndex << endl;
			myfile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			myfile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0); // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile.close();
	}

	printf("Cleaning up...\n");
	SafeReleaseA(&pExponentialComputeShaderCS);
	SafeReleaseA(&pConstantBufferForQuadraticFunction);
	SafeReleaseA(&pInputBufferForExpFunction);
	SafeReleaseA(&pOutputBufferForExpFunction);
	SafeReleaseA(&pExponentinalFunctionSRV0);
	SafeReleaseA(&pExponentialFunctionUAV0);
	SafeReleaseA(&pReadBackBuffer);
	*pOutputBuffer = pOutpuArray;
	return hr;

}


HRESULT DirectXStandardAlgorithmExecutor::InitializeCosineFunctionResources(HINSTANCE hInstance,
	HWND hWnd, 
    float pCosineFunctiooCoefficient, 
    float pEmptyCoeffient, 
    vector<InputStructureForGraph> pInputData,
     ID3D11ComputeShader** ppComputeShaderObject, 
     ID3D11Buffer** ppConstantBuffer,
     ID3D11Buffer** ppInputBuffer, 
     ID3D11Buffer** ppOutputBuffer, 
     ID3D11ShaderResourceView** ppSRV1,
     ID3D11UnorderedAccessView** ppUAVObject1,
     ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;



	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer0 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVO = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<BData> pInputStructuresArray = vector<BData>();
	cout << "Copying data to array of Structures" << endl;

	ConstantBufferCosine pConstantBufferCosine;
	pConstantBufferCosine.pCoefficientParam = pCosineFunctiooCoefficient;
	pConstantBufferCosine.pFunctionFreeParameter = pEmptyCoeffient;
	pConstantBufferCosine.pi_var = DirectX::XM_PI;

	int iIndex = 0;
	UINT pAmountOfSamples = pInputData.size();
	cout << "Initializing Direct3D11 Device" << endl;

	hr = InitializeD3D11Device(hWnd, 0);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}
	printf("done\n");

	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	vector<UINT> pOutputArrayData = vector<UINT>();
	cout << "Compiling the Compute Shader Object" << endl;

	fstream imageMaskLog("С:\\pixels\\CosineFunctionSetup.txt");
	imageMaskLog.clear();

	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\CosineFunctionCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;

	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError <<
			endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0)
			;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));

	constant_buffer_desc.ByteWidth = sizeof(ConstantBufferCosine) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(ConstantBufferCosine);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pConstantBufferCosine;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;
	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputData.size() * sizeof(InputStructureForGraph);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(InputStructureForGraph);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	
    D3D11_SUBRESOURCE_DATA pInputDataCosine;
	pInputDataCosine.pSysMem = &pInputData[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pInputDataCosine, &pInputBuffer0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError <<
			endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputData.size() * sizeof(OutputStructureForGraph);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputStructureForGraph);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	cout << "Creating the Output Buffer Object" << endl;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_quadratic;
	ZeroMemory(&srvbuffer_desc_quadratic, sizeof(srvbuffer_desc_quadratic));

	srvbuffer_desc_quadratic.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_quadratic.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_quadratic.Buffer.ElementWidth = pInputData.size();
	srvbuffer_desc_quadratic.Buffer.ElementOffset = 0;

	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer0, &srvbuffer_desc_quadratic, &pInputSRVO);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)
			"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError <<
			endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " <<
			pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputData.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;
	// Create the Readback Buffer
	// This is used to read the results back to the CPU

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputData.size() * sizeof(OutputStructureForGraph);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputStructureForGraph);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer = pInputBuffer0;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRVO;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunCosineFunctionShaderAlgorithm(HINSTANCE hInstance,
	HWND hWnd,
     ID3D11Buffer* pConstantBuffer,
     ID3D11ComputeShader* pComputeShaderObject,
     ID3D11ShaderResourceView* pShaderResourceView0, 
     ID3D11UnorderedAccessView* pUnorderedUAV, 
     UINT pNumberOfSRV, UINT pNumberOfUAV,
      UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);


	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::SimulateSineFunctionBehaviour(HINSTANCE hInstance,
	HWND hWnd,
	float pCosineFunctionCoefficient,
	float pEmptyCoeffient,
	vector<InputStructureForGraph> pInputData,
	vector<OutputStructureForGraph> *pOutputBuffer)
{

#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

	HRESULT hr = S_OK;

	vector <OutputStructureForGraph> pOutpuArray = vector<OutputStructureForGraph>();
	cout << "Creating the Compute Direct3D11 Device" << endl;
	cout << "Preparing the input Data" << endl;

	dataArray.resize(NUM_ELEMENTS);
	ofstream myfile;
	myfile.open("ArraySortingFile.txt");
	int pIndex = 0;
	cout << "Printing Out the Contents Of The Structured Buffer" << endl;
	int pCounterVal = 0;

	for (InputStructureForGraph pBufTypeVar : pInputData)
	{
		cout << "Input Structure Id = " << pBufTypeVar.pInputItemValue << endl;
		cout << "Item Value = " << pBufTypeVar.pInputItemValue << endl;
	}

	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;
	cout << "Now We have to initalize Our Resources" << endl;

	ID3D11ComputeShader* pExponentialComputeShaderCS = nullptr;
	ID3D11Buffer* pConstantBufferForQuadraticFunction = nullptr;
	ID3D11Buffer* pInputBufferForExpFunction = nullptr;
	ID3D11Buffer* pOutputBufferForExpFunction = nullptr;
	ID3D11ShaderResourceView* pExponentinalFunctionSRV0 = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionUAV0 = nullptr;
	cout << "Initializing the Resources For the Simulation" << endl;

	hr = InitializeSineFunctionResources(hInstance,
		hWnd,
		pCosineFunctionCoefficient,
		pEmptyCoeffient,
		pInputData,
		&pExponentialComputeShaderCS,
		&pConstantBufferForQuadraticFunction,
		&pInputBufferForExpFunction,
		&pOutputBufferForExpFunction,
		&pExponentinalFunctionSRV0,
		&pExponentialFunctionUAV0,
		&pReadBackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError <<
			endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;
	hr = RunSineFunctionShaderAlgorithm(hInstance,
		hWnd,
		pConstantBufferForQuadraticFunction,
		pExponentialComputeShaderCS,
		pExponentinalFunctionSRV0,
		pExponentialFunctionUAV0,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError <<
			endl;
		return hr;
	}
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;
	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;
	printf("done\n");
	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferForExpFunction);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);
		// Set a break point here and put down the expression "p, 1024" in your watch window to see what hasbeen written out by our CS
		// This is also a common trick to debug CS programs.
		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has	been written out by our CS
		// This is also a common trick to debug CS programs.
		OutputStructureForGraph* pOutputStructureForGraph = (OutputStructureForGraph*)MappedResource.pData;
		for (int iIndex = 0; iIndex < pInputData.size(); ++iIndex)
		{
			OutputStructureForGraph pOutputStructure = pOutputStructureForGraph[iIndex];
			cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
			cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
			pOutpuArray.push_back(pOutputStructure);
		}
		fstream myfile;
		myfile.open("С:\\pixels\\QuadraticFunctionTxt.txt");

		std::time_t t = std::time(0); // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";
		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputStructureForGraph pOutputStructure : pOutpuArray)
		{
			cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
			cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
			myfile << "Item Index = " << pOutputStructure.pItemIndex << endl;
			myfile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			myfile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0); // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile.close();
	}

	printf("Cleaning up...\n");
	SafeReleaseA(&pExponentialComputeShaderCS);
	SafeReleaseA(&pConstantBufferForQuadraticFunction);
	SafeReleaseA(&pInputBufferForExpFunction);
	SafeReleaseA(&pOutputBufferForExpFunction);
	SafeReleaseA(&pExponentinalFunctionSRV0);
	SafeReleaseA(&pExponentialFunctionUAV0);
	SafeReleaseA(&pReadBackBuffer);
	*pOutputBuffer = pOutpuArray;
	return hr;

}


HRESULT DirectXStandardAlgorithmExecutor::InitializeSineFunctionResources(HINSTANCE hInstance,
	HWND hWnd,
	float pCosineFunctiooCoefficient,
	float pEmptyCoeffient,
	vector<InputStructureForGraph> pInputData,
	ID3D11ComputeShader** ppComputeShaderObject,
	ID3D11Buffer** ppConstantBuffer,
	ID3D11Buffer** ppInputBuffer,
	ID3D11Buffer** ppOutputBuffer,
	ID3D11ShaderResourceView** ppSRV1,
	ID3D11UnorderedAccessView** ppUAVObject1,
	ID3D11Buffer** ppReadbackBuffer)
{

	HRESULT hr = S_OK;



	ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer0 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVO = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<BData> pInputStructuresArray = vector<BData>();
	cout << "Copying data to array of Structures" << endl;

	ConstantBufferCosine pConstantBufferCosine;
	pConstantBufferCosine.pCoefficientParam = pCosineFunctiooCoefficient;
	pConstantBufferCosine.pFunctionFreeParameter = pEmptyCoeffient;
	pConstantBufferCosine.pi_var = DirectX::XM_PI;

	int iIndex = 0;
	UINT pAmountOfSamples = pInputData.size();
	cout << "Initializing Direct3D11 Device" << endl;

	hr = InitializeD3D11Device(hWnd, 0);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}
	printf("done\n");

	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	vector<UINT> pOutputArrayData = vector<UINT>();
	cout << "Compiling the Compute Shader Object" << endl;

	fstream imageMaskLog("С:\\pixels\\CosineFunctionSetup.txt");
	imageMaskLog.clear();

	hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\SineFunctionCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}

	cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;

	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError <<
			endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0)
			;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer

	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));

	constant_buffer_desc.ByteWidth = sizeof(ConstantBufferCosine) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(ConstantBufferCosine);

	D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pConstantBufferCosine;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;
	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInputData.size() * sizeof(InputStructureForGraph);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(InputStructureForGraph);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

	D3D11_SUBRESOURCE_DATA pInputDataCosine;
	pInputDataCosine.pSysMem = &pInputData[0];

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pInputDataCosine, &pInputBuffer0);

	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError <<
			endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;

	D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInputData.size() * sizeof(OutputStructureForGraph);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputStructureForGraph);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;

	cout << "Creating the Output Buffer Object" << endl;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";

	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_quadratic;
	ZeroMemory(&srvbuffer_desc_quadratic, sizeof(srvbuffer_desc_quadratic));

	srvbuffer_desc_quadratic.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_quadratic.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_quadratic.Buffer.ElementWidth = pInputData.size();
	srvbuffer_desc_quadratic.Buffer.ElementOffset = 0;

	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer0, &srvbuffer_desc_quadratic, &pInputSRVO);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)
			"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError <<
			endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " <<
			pLastError << endl;
		imageMaskLog.close();
		return hr;
	}

	cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInputData.size();

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has been created" << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;
	// Create the Readback Buffer
	// This is used to read the results back to the CPU

	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInputData.size() * sizeof(OutputStructureForGraph);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputStructureForGraph);

	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);

	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}

	*ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer = pInputBuffer0;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRVO;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunSineFunctionShaderAlgorithm(HINSTANCE hInstance,
	HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);


	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulateQuadraticFunction(HINSTANCE hInstance,
	HWND hWnd,
	float pCoeffcientA,
	float pCoefficientB,
	float pCoefficentC,
	vector<InputStructureForGraph> pInputData,
	vector<OutputStructureForGraph> *pOutputBuffer)
{
#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

	HRESULT hr = S_OK;



	vector <OutputStructureForGraph> pOutpuArray = vector<OutputStructureForGraph>();
	cout << "Creating the Compute Direct3D11 Device" << endl;
	cout << "Preparing the input Data" << endl;
	vector<BufType> pDataValuesArray = vector<BufType>();

	dataArray.resize(NUM_ELEMENTS);
	ofstream myfile;
	myfile.open("ArraySortingFile.txt");
	int pIndex = 0;
	cout << "Printing Out the Contents Of The Structured Buffer" << endl;
	int pCounterVal = 0;

	for (InputStructureForGraph pBufTypeVar : pInputData)
	{
		cout << "Input Structure Id = " << pBufTypeVar.pInputItemValue << endl;
		cout << "Item Value = " << pBufTypeVar.pInputItemValue << endl;
	}

	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;
	cout << "Now We have to initalize Our Resources" << endl;

	ID3D11ComputeShader* pExponentialComputeShaderCS = nullptr;
	ID3D11Buffer* pConstantBufferForQuadraticFunction = nullptr;
	ID3D11Buffer* pInputBufferForExpFunction = nullptr;
	ID3D11Buffer* pOutputBufferForExpFunction = nullptr;
	ID3D11ShaderResourceView* pExponentinalFunctionSRV0 = nullptr;
	ID3D11ShaderResourceView* pExponentinalFunctionSRV1 = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionUAV0 = nullptr;
	ID3D11UnorderedAccessView* pExponentialFuntionUAV1 = nullptr;
	ID3D11Buffer* pReadBackBuffer = nullptr;
	ID3D11UnorderedAccessView* ppUnorderedAccessViews = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViews = nullptr;

	cout << "Initializing the Resources For the Simulation" << endl;
	ConstantBufferQuadratic pConstantBufferQuadraticObject;
	pConstantBufferQuadraticObject.pACoefficient = pCoeffcientA;
	pConstantBufferQuadraticObject.pBCoefficient = pCoefficientB;
	pConstantBufferQuadraticObject.pCoefficient = pCoefficentC;
	hr = InitializeQuadraticFunctionResources(hInstance,
		hWnd,
		pConstantBufferQuadraticObject,
		pInputData,
		&pExponentialComputeShaderCS,
		&pConstantBufferForQuadraticFunction,
		&pInputBufferForExpFunction,
		&pOutputBufferForExpFunction,
		&pExponentinalFunctionSRV0,
		&pExponentialFunctionUAV0,
		&pReadBackBuffer);
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError <<
			endl;
		return hr;
	}
	cout << "Performing The Simulation Task" << endl;
	hr = RunQuadraticFunction(hInstance,
		hWnd,
		pConstantBufferForQuadraticFunction,
		pInputBufferForExpFunction,
		pExponentialComputeShaderCS,
		pExponentinalFunctionSRV0,
		pExponentialFunctionUAV0,
		1, 1, 256, 1, 1);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError <<
			endl;
		return hr;
	}
	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;
	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;
	printf("done\n");
	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferForExpFunction);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);
		// Set a break point here and put down the expression "p, 1024" in your watch window to see what hasbeen written out by our CS
			// This is also a common trick to debug CS programs.
			// Set a break point here and put down the expression "p, 1024" in your watch window to see what has	been written out by our CS
			// This is also a common trick to debug CS programs.
			OutputStructureForGraph* pOutputStructureForGraph = (OutputStructureForGraph*)MappedResource.pData;
		for (int iIndex = 0; iIndex < pInputData.size(); ++iIndex)
		{
			OutputStructureForGraph pOutputStructure = pOutputStructureForGraph[iIndex];
			cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
			cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
			pOutpuArray.push_back(pOutputStructure);
		}
		fstream myfile; 
		myfile.open("С:\\pixels\\QuadraticFunctionTxt.txt");
		
        std::time_t t = std::time(0); // get time now
		std::tm* now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n";
		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (OutputStructureForGraph pOutputStructure : pOutpuArray)
		{
			cout << "Item Index = " << pOutputStructure.pItemIndex << endl;
			cout << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			cout << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
			myfile << "Item Index = " << pOutputStructure.pItemIndex << endl;
			myfile << "Input Function Value =" << pOutputStructure.pInputStructureForGraph << endl;
			myfile << "Output Function Value = " << pOutputStructure.pOutputStructureForGraph << endl;
		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0); // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile.close();
	}

	printf("Cleaning up...\n");
	SafeReleaseA(&pExponentialComputeShaderCS);
	SafeReleaseA(&pConstantBufferForQuadraticFunction);
	SafeReleaseA(&pInputBufferForExpFunction);
	SafeReleaseA(&pOutputBufferForExpFunction);
	SafeReleaseA(&pExponentinalFunctionSRV0);
	SafeReleaseA(&pExponentinalFunctionSRV1);
	SafeReleaseA(&pExponentialFunctionUAV0);
	SafeReleaseA(&pExponentialFuntionUAV1);
	SafeReleaseA(&pReadBackBuffer);
	*pOutputBuffer = pOutpuArray;
	return hr;
}





HRESULT DirectXStandardAlgorithmExecutor::InitializeQuadraticFunctionResources(HINSTANCE hInstance,
	HWND hWnd, 
    ConstantBufferQuadratic pConstantBufferQuadratic, 
    vector<InputStructureForGraph> pInitialDataSet,
     ID3D11ComputeShader** ppComputeShaderObject, 
     ID3D11Buffer** ppConstantBuffer, 
     ID3D11Buffer** ppInputBuffer, 
     ID3D11Buffer** ppOutputBuffer, 
     ID3D11ShaderResourceView** ppSRV1, 
     ID3D11UnorderedAccessView** ppUAVObject1,
      ID3D11Buffer** ppReadbackBuffer)
{
	
	HRESULT hr = S_OK;
	
    ID3DBlob* pMemoryDataBlob = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pInputBuffer0 = nullptr;
	ID3D11Buffer* pOutputBuffer = nullptr;
	ID3D11ComputeShader* pComputeShaderObject = nullptr;
	ID3D11ShaderResourceView* pInputSRVO = nullptr;
	ID3D11UnorderedAccessView* pOutputUAV = nullptr;
	ID3D11Buffer* pReadbackBuffer = nullptr;
	vector<BData> pInputStructuresArray = vector<BData>();
    cout << "Copying data to array of Structures" << endl;
	
    int iIndex = 0;
	UINT pAmountOfSamples = pInitialDataSet.size();
	cout << "Initializing Direct3D11 Device" << endl;
	
    hr = InitializeD3D11Device(hWnd, 0);
	
    if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}
	printf("done\n");
	
    printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	vector<UINT> pOutputArrayData = vector<UINT>();
	cout << "Compiling the Compute Shader Object" << endl;
	
    fstream imageMaskLog("С:\\pixels\\CurrencyRelationship.txt");
	imageMaskLog.clear();
	
    hr = CompileD3DShaderFromFileW(L"C:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\QuadraticFunctionCS.hlsl",
		"CS_Main", "cs_5_0", &pMemoryDataBlob);
	
    if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Compile the Image Subtraction Compute Shader Error: " << pLastError << endl;
		return hr;
	}
	
    cout << "Creating the Compute Shader Object" << endl;
	imageMaskLog << "Creating the Compute Shader Object" << endl;
	
    if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(),
			pMemoryDataBlob->GetBufferSize(), nullptr, &pComputeShaderObject);
	}
	
    if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError <<
			endl;
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0)
			;
		imageMaskLog.close();
		return hr;
	}
	
    cout << "Creating the Constant Buffer Object" << endl;
	// Create the Const Buffer
	
    D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	
    constant_buffer_desc.ByteWidth = sizeof(ConstantBufferQuadratic) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	constant_buffer_desc.StructureByteStride = sizeof(ConstantBufferQuadratic);
	
    D3D11_SUBRESOURCE_DATA ppResourceData;
	ppResourceData.pSysMem = &pConstantBufferQuadratic;
	
    hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, &ppResourceData, &pConstantBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Constant Buffer = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Constant Buffer : " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	
    cout << "Creating the Input Buffer For Image One Object" << endl;
	imageMaskLog << "Creating the Input Buffer For Image One Object" << endl;
	D3D11_BUFFER_DESC buffer_desc1;
	ZeroMemory(&buffer_desc1, sizeof(buffer_desc1));
	buffer_desc1.ByteWidth = pInitialDataSet.size() * sizeof(InputStructureForGraph);
	buffer_desc1.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc1.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	buffer_desc1.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc1.StructureByteStride = sizeof(InputStructureForGraph);
	buffer_desc1.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	D3D11_SUBRESOURCE_DATA pInputData;
	pInputData.pSysMem = &pInitialDataSet[0];
	
    hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc1, &pInputData, &pInputBuffer0);
	
    if (FAILED(hr))
	{
		int pLastError = 0;
		pLastError = GetLastError();
		cout << "Unable to Create the Input Buffer 1 for Pixel Array One = " << pLastError << endl;
		imageMaskLog << "Unable to Create the Image Mask Compute Shader Algorithm Error: " << pLastError <<
			endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Output Buffer Financial Space" << endl;
	imageMaskLog << "Creating the Output Buffer Financial Space" << endl;
	
    D3D11_BUFFER_DESC buffer_desc_output;
	ZeroMemory(&buffer_desc_output, sizeof(buffer_desc_output));
	buffer_desc_output.ByteWidth = pInitialDataSet.size() * sizeof(OutputStructureForGraph);
	buffer_desc_output.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc_output.BindFlags = D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc_output.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc_output.StructureByteStride = sizeof(OutputStructureForGraph);
	buffer_desc_output.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	
    cout << "Creating the Output Buffer Object" << endl;
	
    hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc_output, nullptr, &pOutputBuffer);
	if (FAILED(hr))
	{
		int pLastError = 0;
		cout << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog << "Unable to Create the Output Buffer Error: " << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	
    cout << "Creating the Shader Resource View for input Buffer One";
	imageMaskLog << "Creating the Shader Resource View for input Buffer One";
	
    D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc_quadratic;
	ZeroMemory(&srvbuffer_desc_quadratic, sizeof(srvbuffer_desc_quadratic));
	
    srvbuffer_desc_quadratic.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc_quadratic.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc_quadratic.Buffer.ElementWidth = pInitialDataSet.size();
	srvbuffer_desc_quadratic.Buffer.ElementOffset = 0;
	
    hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer0, &srvbuffer_desc_quadratic, &pInputSRVO);
	
    if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для Первого Изображения", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image One Processing Module" << endl;
	}
	
    if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось Создать Ресурс Шейдера для Первого Изображения", (LPCSTR)
			"Message", 0);
		cout << "The exit of Shader Resource View For Image One Terminated with error: " << pLastError <<
			endl;
		imageMaskLog << "The exit of Shader Resource View For Image One Terminated with error: " <<
			pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	
    cout << "Creating the Unordered Access View For the Output Buffer" << endl;
	imageMaskLog << "Creating the Unordered Access View For the Output Buffer" << endl;
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = pInitialDataSet.size();
	
    hr = m_pD3DCompDevice->CreateUnorderedAccessView(pOutputBuffer, &uavbuffer_desc, &pOutputUAV); 

	if (SUCCEEDED(hr))
	{
			MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
			cout << "The Unordered Access View Resource View has been created" << endl;
			imageMaskLog << "The Unordered Access View Resource View has been created" << endl;
	}
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The Unordered Access View Resource View has not been created Error: " << pLastError << endl;
		imageMaskLog << "The Unordered Access View Resource View has been created" << pLastError << endl;
		imageMaskLog.close();
		return hr;
	}
	cout << "Creating the Readback Buffer for image subtraction function" << endl;
	imageMaskLog << "Creating the Readback Buffer for image subtraction function" << endl;
	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	
    D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = pInitialDataSet.size() * sizeof(OutputStructureForGraph);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(OutputStructureForGraph);
	
    hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pReadbackBuffer);
	
    if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Ввода-Вывода", (LPCSTR)"Message", 0);
		cout << "The Shader Resource View For Image Two Processing Module" << endl;
		imageMaskLog << "The Shader Resource View For Image Two Processing Module" << endl;
	}
	
    if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
			cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		imageMaskLog << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	} 
    
    *ppComputeShaderObject = pComputeShaderObject;
	*ppConstantBuffer = pConstantBuffer;
	*ppInputBuffer = pInputBuffer0;
	*ppOutputBuffer = pOutputBuffer;
	*ppSRV1 = pInputSRVO;
	*ppUAVObject1 = pOutputUAV;
	*ppReadbackBuffer = pReadbackBuffer;
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::RunQuadraticFunction(HINSTANCE hInstance, HWND hWnd,
	ID3D11Buffer* pConstantBuffer,
	ID3D11Buffer* pInputBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{
		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	} 
    
    m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr };
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr };
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);
	return hr;
}
























HRESULT DirectXStandardAlgorithmExecutor::SimulateExponentionaFunction(HINSTANCE hInstance, HWND hWnd, float pInputCoefficient, float pFreeCoefficient, vector<BufType> pInputData, vector<BufType> *pOutputBuffer)
{

#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
	HRESULT hr = S_OK;

	cout << "Creating the Compute Direct3D11 Device" << endl;

	cout << "Preparing the input Data" << endl;

	vector<BufType> pDataValuesArray = vector<BufType>();


	dataArray.resize(NUM_ELEMENTS);
	ofstream myfile;
	myfile.open("ArraySortingFile.txt");

	int pIndex = 0;


	cout << "Printing Out the Contents Of The Structured Buffer" << endl;
	int pCounterVal = 0;
	for (BufType pBufTypeVar : pInputData)
	{
		cout << "The Float Parameter For Structure At Index: " << pCounterVal << " = " << pBufTypeVar.f << endl;
		cout << "The Int Parameter For Structure At Index: " << pCounterVal << " = " << pBufTypeVar.i << endl;
		cout << "The Double Parameter For Structure At Index: " << pCounterVal << " = " << pBufTypeVar.d << endl;
	}


	

	cout << "Preparing the Instruments For the Simulation" << endl;
	cout << "They Include: " << endl;
	cout << "1 Compute Shader " << endl;
	cout << "1 Constant Buffer" << endl;
	cout << "1 Input Buffer " << endl;
	cout << "1 Output Buffer " << endl;
	cout << "1 Shader Resource View" << endl;
	cout << "1 Unordered Access View" << endl;
	cout << "1 Readback Buffer" << endl;

	cout << "Now We have to initalize Our Resources" << endl;

	ID3D11ComputeShader* pExponentialComputeShaderCS = nullptr;
	ID3D11Buffer* pExponentialConstantBuffer = nullptr;
	ID3D11Buffer* pInputBufferForExpFunction = nullptr;
	ID3D11Buffer* pOutputBufferForExpFunction = nullptr;
	ID3D11ShaderResourceView* pExponentinalFunctionSRV0 = nullptr;
	ID3D11ShaderResourceView* pExponentinalFunctionSRV1 = nullptr;

	ID3D11UnorderedAccessView* pExponentialFunctionUAV0 = nullptr;
	ID3D11UnorderedAccessView* pExponentialFuntionUAV1 = nullptr;
	ID3D11Buffer* pReadBackBuffer = nullptr;
	ID3D11UnorderedAccessView* ppUnorderedAccessViews = nullptr;
	ID3D11ShaderResourceView* ppShaderResourceViews = nullptr;

	cout << "Initializing the Resources For the Simulation" << endl;
	UINT pAmountOfElements = pInputData.size();

	hr = InitializeExponentialFunctionResources(hInstance,
		hWnd,
		pAmountOfElements,
		&pExponentialComputeShaderCS,
		&pExponentialConstantBuffer,
		&pInputBufferForExpFunction,
		&pOutputBufferForExpFunction,
		&pExponentinalFunctionSRV0,
		&pExponentialFunctionUAV0,
		&pReadBackBuffer);

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError << endl;
		return hr;
	}

	ID3D11ShaderResourceView* ppShaderResourcesArray[] = { pExponentinalFunctionSRV0, pExponentinalFunctionSRV1 };
	ID3D11UnorderedAccessView* ppUnorderedAccessViewsArray[] = { pExponentialFunctionUAV0, pExponentialFuntionUAV1 };
	cout << "Performing The Simulation Task" << endl;
	
	ConstantBufferExponential pConstantBufferExponential;
	pConstantBufferExponential.pCoefficientParam = pInputCoefficient;
	pConstantBufferExponential.pFunctionFreeParameter = pFreeCoefficient;

	m_pD3DCompContext->UpdateSubresource(pExponentialConstantBuffer, 0, nullptr, &pConstantBufferExponential, 0, 0);
	m_pD3DCompContext->UpdateSubresource(pInputBufferForExpFunction, 0, nullptr, &pInputData[0], 0, 0);


	hr = RunExponentialFunction(hInstance, hWnd, pInputData, pConstantBufferExponential, pInputBufferForExpFunction, pExponentialConstantBuffer, pExponentialComputeShaderCS, pExponentinalFunctionSRV0, pExponentialFunctionUAV0, 1, 1, NUM_ELEMENTS, 1, 1);
	
	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Function InitializeExponentialFunctionResources Terminated With Error: " << pLastError << endl;
		return hr;
	}

	cout << "Copying the Results from the Output Buffer to The ReadbackBuffer Object" << endl;

	cout << "Mapping the Content of the Readback Buffer to Shared Memory" << endl;
	
	printf("done\n");

	// Read back the result from GPU, verify its correctness against result computed by CPU
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
		m_pD3DCompContext->CopyResource(pReadBackBuffer, pOutputBufferForExpFunction);
		hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
	
		

		// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
		// This is also a common trick to debug CS programs.
		BufType* p = (BufType*)MappedResource.pData;
		for (int i = 0; i < pAmountOfElements; ++i)
		{
			pDataValuesArray.push_back(p[i]);
		}

		fstream myfile;
		myfile.open("С:\\pixels\\ExponentialFunctionTxt.txt");
		std::time_t t = std::time(0);   // get time now
		std::tm* now = std::localtime(&t);
		std::cout <<  (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< "\n" << endl;

		// Verify that if Compute Shader has done right
		printf("Verifying against CPU result...");
		bool bSuccess = true;
		int iIndex = 0;
		for (BufType pNumberData : pDataValuesArray)
		{
			cout << "Computation Result Int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.i << endl;
			cout << "Computation Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.f << endl;
			cout << "Computation Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.d << endl;
			myfile << "Computation Result Int at index:" << " " << iIndex << " " << "=" << " " << pNumberData.i << endl;
			myfile << "Computation Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.f << endl;
			myfile << "Computation Result Float at index:" << " " << iIndex << " " << "=" << " " << pNumberData.d << endl;


		}
		if (bSuccess)
			printf("succeeded\n");
		t = std::time(0);   // get time now
		now = std::localtime(&t);
		std::cout << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;
		myfile << (now->tm_year + 1900) << '-'
			<< (now->tm_mon + 1) << '-'
			<< now->tm_mday
			<< now->tm_hour
			<< now->tm_min
			<< now->tm_sec
			<< endl;

		myfile.close();

	}

	printf("Cleaning up...\n");
	
	
	

	*pOutputBuffer = pDataValuesArray;

	return hr;
	
}


HRESULT DirectXStandardAlgorithmExecutor::InitializeExponentialFunctionResources(HINSTANCE hInstance, HWND hWnd, UINT pAmountOfSamples,
	ID3D11ComputeShader** pComputeShaderObject, ID3D11Buffer** ppConstantBuffer, ID3D11Buffer** pInputBuffer, ID3D11Buffer** pOutputBuffer, ID3D11ShaderResourceView** ppSRV1,  ID3D11UnorderedAccessView** ppUAVObject1, ID3D11Buffer** ppReadbackBuffer)
{
	HRESULT hr = S_OK;

	ID3DBlob* pMemoryBuffer = nullptr;
	ID3D11ComputeShader* pExponentialFunctionComputeShader = nullptr;
	ID3D11Buffer* pConstantBuffer = nullptr;
	ID3D11Buffer* pExponentialInputBuffer = nullptr;
	ID3D11Buffer* pExponentialOutputBuffer = nullptr;
	ID3D11UnorderedAccessView* pExponentialFunctionOutputUAV = nullptr;
	ID3D11ShaderResourceView* pExponentialInputBufferSRV = nullptr;
	ID3D11Buffer* pExponentialFunctionReadbackBuffer = nullptr;
	vector<BData> pInputStructuresArray = vector<BData>();
	cout << "Copying data to array of Structures" << endl;
	int iIndex = 0;



	cout << "Initializing Direct3D11 Device" << endl;

	hr = InitializeD3D11Device(hWnd, 0);



	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		cout << "Direct3D Device exit Function Terminated with error: " << pLastError << endl;
		return hr;
	}

	printf("done\n");
	ID3DBlob* pMemoryDataBlob = nullptr;
	printf("Creating Compute Shader...");
	// Compile the Bitonic Sort Compute Shader
	ofstream myfile;
	myfile.open("ArrayAdditionFile.txt");
	vector<UINT> pOutputArrayData = vector<UINT>();


	hr = CompileD3DShaderFromFileW(L"C:\\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ExponentialFunctionCS.hlsl", "CS_Main", "cs_5_0", &pMemoryDataBlob);
	if (SUCCEEDED(hr))
	{
		hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &pExponentialFunctionComputeShader);
	}
	if (FAILED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Не удалось скомпилировать шейдер сложения массивов", (LPCSTR)"Message", 0);
		return hr;
	}

	//Create the Const Buffer

	cout << "Creating the input buffer" << endl;

	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(ConstantBufferExponential) * 16;
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;

	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &pConstantBuffer);




	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.StructureByteStride = sizeof(BufType);
	buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BufType);
	buffer_desc.BindFlags |= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_UNORDERED_ACCESS;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;

	
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, NULL, &pExponentialInputBuffer);
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, NULL, &pExponentialOutputBuffer);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан выходной буффер для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}


	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = pAmountOfSamples;
	srvbuffer_desc.Buffer.ElementOffset = 0;



	hr = m_pD3DCompDevice->CreateShaderResourceView(pExponentialInputBuffer, &srvbuffer_desc, &pExponentialInputBufferSRV);
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Ресурс Шейдера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		int pLastError = GetLastError();
		MessageBoxA(hWnd, (LPCSTR)"Не удалось создать Входной Буффер для степенной функции", (LPCSTR)"Message", 0);
		cout << "The exit of An input Buffer Terminated with error: " << pLastError << endl;
		return hr;
	}



	cout << "Creating the Unordered Access view for the Buffer" << endl;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.FirstElement = 0;
	uavbuffer_desc.Buffer.NumElements = pAmountOfSamples;
	uavbuffer_desc.Buffer.Flags = 0;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(pExponentialOutputBuffer, &uavbuffer_desc, &pExponentialFunctionOutputUAV);
	
	if (SUCCEEDED(hr))
	{
		MessageBoxA(hWnd, (LPCSTR)"Создан Вид Ввода-Вывода выходного буффера для экспонентой Функции", (LPCSTR)"Message", 0);
		cout << "The Input Buffer for the exponential function has been successfully created" << endl;
	}

	if (FAILED(hr))
	{
		
			MessageBoxA(hWnd, (LPCSTR)"Создан Вид Ввода-Вывода выходного буффера для экспонентой Функции", (LPCSTR)"Message", 0);
			cout << "The Input Buffer for the exponential function has been successfully created" << endl;

		
	}



		if (FAILED(hr))
			return hr;


		// Create the Readback Buffer
		// This is used to read the results back to the CPU
		D3D11_BUFFER_DESC readback_buffer_desc;
		ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
		readback_buffer_desc.ByteWidth = pAmountOfSamples * sizeof(BufType);
		readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
		readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
		readback_buffer_desc.StructureByteStride = sizeof(float);
		hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &pExponentialFunctionReadbackBuffer);
		if (FAILED(hr))
			return hr;


	


		if (FAILED(hr))
		{
			int pLastError = GetLastError();
			cout << "CreateBuffer Function For Output Terminated with Error: " << pLastError << endl;
			return hr;
		}
		ID3D11ShaderResourceView* pShaderResourceViews[] = { pExponentialInputBufferSRV  };
		ID3D11UnorderedAccessView* ppUAVViews[] = { pExponentialFunctionOutputUAV };
		
		*ppConstantBuffer = pConstantBuffer;
		*pComputeShaderObject = pExponentialFunctionComputeShader;
		*pInputBuffer = pExponentialInputBuffer;
		*ppSRV1 = pExponentialInputBufferSRV;
		*ppUAVObject1 = pExponentialFunctionOutputUAV;
		*pOutputBuffer = pExponentialOutputBuffer;
		*ppReadbackBuffer = pExponentialFunctionReadbackBuffer;
	
		return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::RunExponentialFunction(HINSTANCE hInstance, HWND hWnd,
	vector<BufType> pInitialDataSet,
	ConstantBufferExponential pConstantBufferData,
	ID3D11Buffer* pInputBuffer,
	ID3D11Buffer* pConstantBuffer,
	ID3D11ComputeShader* pComputeShaderObject,
	ID3D11ShaderResourceView* pShaderResourceView0,
	ID3D11UnorderedAccessView* pUnorderedUAV,
	UINT pNumberOfSRV, UINT pNumberOfUAV,
	UINT X, UINT Y, UINT Z)
{
	HRESULT hr = S_OK;

	m_pD3DCompContext->UpdateSubresource(pInputBuffer, 0, nullptr, &pInitialDataSet[0], 0, 0);
	m_pD3DCompContext->UpdateSubresource(pConstantBuffer, 0, nullptr, &pConstantBufferData, 0, 0);
	m_pD3DCompContext->CSSetShader(pComputeShaderObject, nullptr, 0);
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, &pUnorderedUAV, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, &pShaderResourceView0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBuffer);
	try
	{

		m_pD3DCompContext->Dispatch(X, Y, Z);
	}
	catch (std::exception ex)
	{
		cout << "Exeption Error :" << ex.what() << endl;
		throw ex;
	}

	m_pD3DCompContext->CSSetShader(nullptr, nullptr, 0);
	ID3D11ShaderResourceView* ppSRVnullptr[] = { nullptr};
	ID3D11UnorderedAccessView* ppUAViewnullptr[] = { nullptr};
	m_pD3DCompContext->CSSetUnorderedAccessViews(0, pNumberOfUAV, ppUAViewnullptr, nullptr);
	m_pD3DCompContext->CSSetShaderResources(0, pNumberOfSRV, ppSRVnullptr);
	
	
	return hr;
}




HRESULT DirectXStandardAlgorithmExecutor::SimulateSortingAlgorithm(HINSTANCE hInstance, HWND hWnd, vector<UINT> pInputVector, vector<UINT> *pOutputVector)
{
#ifdef _DEBUG
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
	HRESULT hr = S_OK;
	// Generate a random list of numbers to sort
	std::random_device rd;
	std::mt19937 mt(rd());


	vector<UINT> pOutputResults = vector<UINT>();
	vector<UINT> pCPUResults = vector<UINT>();
	ofstream myfile;
	myfile.open("ArraySortingFile.txt");
	int pIndex = 0;
	for (UINT pVariable : pInputVector)
	{
		cout << "Initial Array Element At Index: " << pIndex << " = " << pVariable << endl;
		pIndex++;
	}



	// Create the device
	hr = InitializeD3D11Device(hWnd, 0);
	if (FAILED(hr))
	{
		printf("Failed to create the device.  Exiting.\n");
		return 1;
	}
	cout << "Preparing the Initial Pointers" << endl;

	ID3D11ComputeShader* pBitonicComputeShader = nullptr;
	ID3D11ComputeShader* pTransposeComputeShader = nullptr;
	ID3D11Buffer* pConstantBufferObj = nullptr;
	ID3D11Buffer* pDataBuferOne = nullptr;
	ID3D11Buffer* pSecondBuffer = nullptr;
	ID3D11ShaderResourceView* pShaderSRV0 = nullptr;
	ID3D11ShaderResourceView* pShaderSRV1 = nullptr;
	ID3D11UnorderedAccessView* ppUAV0 = nullptr;
	ID3D11UnorderedAccessView* ppUAV1 = nullptr;
	ID3D11Buffer* ppReadBackBuffer = nullptr;



	hr = InitalizeSortingAlgorithmResources(hInstance, hWnd, &pBitonicComputeShader,
		&pTransposeComputeShader, &pConstantBufferObj,
		&pDataBuferOne, &pSecondBuffer, &pShaderSRV0, &pShaderSRV1,
		&ppUAV0, &ppUAV1, &ppReadBackBuffer);

	// Create the buffers and shaders
	if (FAILED(hr))
	{
		printf("Failed to create resources.  Exiting.\n");
		return 1;
	}

	printf("Sorting %u Elements\n", NUM_ELEMENTS);

	// GPU Bitonic Sort
	printf("Starting GPU Bitonic Sort...\n");
	GPUSort(hInstance, hWnd, pBitonicComputeShader, pTransposeComputeShader,
		pConstantBufferObj, pDataBuferOne, pSecondBuffer, pShaderSRV0, pShaderSRV1,
		ppUAV0, ppUAV1, ppReadBackBuffer, pInputVector, &pOutputResults);



	printf("...GPU Bitonic Sort Finished\n");

	// Sort the data on the CPU to compare for correctness
	printf("Starting CPU Sort...\n");
	CPUSort(pInputVector, &pCPUResults);
	printf("...CPU Sort Finished\n");

	// Compare the results for correctness


	// Cleanup the resources
	SafeReleaseA(&ppReadBackBuffer);
	SafeReleaseA(&ppUAV1);
	SafeReleaseA(&ppUAV0);
	SafeReleaseA(&pShaderSRV1);
	SafeReleaseA(&pShaderSRV1);
	SafeReleaseA(&pSecondBuffer);
	SafeReleaseA(&pDataBuferOne);
	SafeReleaseA(&pConstantBufferObj);
	SafeReleaseA(&pTransposeComputeShader);
	SafeReleaseA(&pBitonicComputeShader);

	*pOutputVector = pOutputResults;

	return hr;
}



HRESULT DirectXStandardAlgorithmExecutor::InitalizeSortingAlgorithmResources(HINSTANCE hInstance, HWND hWnd, ID3D11ComputeShader** pComputeShaderSort, ID3D11ComputeShader** pMatrixTranspose, ID3D11Buffer** pBitonicConstantBuffer,
	ID3D11Buffer** pFirstBuffer, ID3D11Buffer** pSecondBuffer, ID3D11ShaderResourceView** pShaderSRV0, ID3D11ShaderResourceView** pShaderSRV1,
	ID3D11UnorderedAccessView** ppUAV0, ID3D11UnorderedAccessView** ppUAV1,
	ID3D11Buffer** pReadBackBuffer)
{
	HRESULT hr = S_OK;
	ID3DBlob* pMemoryDataBlob = nullptr;

	// Compile the Bitonic Sort Compute Shader
	hr = CompileD3DShaderFromFileW(L"E:\\С\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ComputeShaderSort11.hlsl", "BitonicSort", "cs_4_0", &pMemoryDataBlob);
	if (FAILED(hr))
		return hr;
	hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &m_pComputeShaderBitonic);
	if (FAILED(hr))
		return hr;
	SafeReleaseA(&pMemoryDataBlob);

#if defined(_DEBUG) || defined(PROFILE)
	m_pComputeShaderBitonic->SetPrivateData(WKPDID_D3DDebugObjectName, sizeof("BitonicSort") - 1, "BitonicSort");
#endif

	// Compile the Matrix Transpose Compute Shader
	hr = CompileD3DShaderFromFileW(L"С:\\Parametrized Simulations Kernel Exhibition Model NoteBook\\Kernel Final\\AlgorithmObjects\\ComputeShaderSort11.hlsl", "MatrixTranspose", "cs_4_0", &pMemoryDataBlob);
	if (FAILED(hr))
		return hr;

	// Create the Matrix Transpose Compute Shader
	hr = m_pD3DCompDevice->CreateComputeShader(pMemoryDataBlob->GetBufferPointer(), pMemoryDataBlob->GetBufferSize(), nullptr, &m_pComputeShaderTranspose);
	if (FAILED(hr))
		return hr;
	SafeReleaseA(&pMemoryDataBlob);
#if defined(_DEBUG) || defined(PROFILE)
	m_pComputeShaderTranspose->SetPrivateData(WKPDID_D3DDebugObjectName, sizeof("MatrixTranspose") - 1, "MatrixTranspose");
#endif



	SafeReleaseA(&pMemoryDataBlob);


	// Create the Const Buffer
	D3D11_BUFFER_DESC constant_buffer_desc;
	ZeroMemory(&constant_buffer_desc, sizeof(constant_buffer_desc));
	constant_buffer_desc.ByteWidth = sizeof(ConstantBuffer);
	constant_buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	constant_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	constant_buffer_desc.CPUAccessFlags = 0;
	hr = m_pD3DCompDevice->CreateBuffer(&constant_buffer_desc, nullptr, &m_pBitonicConstantBuffer);
	if (FAILED(hr))
	{

		return hr;
	}

	// Create the Buffer of Elements
	// Create 2 buffers for switching between when performing the transpose
	D3D11_BUFFER_DESC buffer_desc;
	ZeroMemory(&buffer_desc, sizeof(buffer_desc));
	buffer_desc.ByteWidth = NUM_ELEMENTS * sizeof(UINT);
	buffer_desc.Usage = D3D11_USAGE_DEFAULT;
	buffer_desc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
	buffer_desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
	buffer_desc.StructureByteStride = sizeof(UINT);
	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, nullptr, &m_pFirstBuffer);
	if (FAILED(hr))
		return hr;

	hr = m_pD3DCompDevice->CreateBuffer(&buffer_desc, nullptr, &m_pSecondBuffer);




	// Create the Shader Resource View for the Buffers
	// This is used for reading the buffer during the transpose
	D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc;
	ZeroMemory(&srvbuffer_desc, sizeof(srvbuffer_desc));
	srvbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
	srvbuffer_desc.Buffer.ElementWidth = NUM_ELEMENTS;
	srvbuffer_desc.Buffer.ElementOffset = 0;
	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pFirstBuffer, &srvbuffer_desc, &m_pFirstBufferSRV);
	if (FAILED(hr))
		return hr;



	hr = m_pD3DCompDevice->CreateShaderResourceView(m_pSecondBuffer, &srvbuffer_desc, &m_pSecondBufferSRV);
	if (FAILED(hr))
		return hr;
	pAdditionAlgorithmsSRV[0] = m_pFirstBufferSRV;
	pAdditionAlgorithmsSRV[1] = m_pSecondBufferSRV;
	// Create the Unordered Access View for the Buffers
	// This is used for writing the buffer during the sort and transpose
	D3D11_UNORDERED_ACCESS_VIEW_DESC uavbuffer_desc;
	ZeroMemory(&uavbuffer_desc, sizeof(uavbuffer_desc));
	uavbuffer_desc.Format = DXGI_FORMAT_UNKNOWN;
	uavbuffer_desc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	uavbuffer_desc.Buffer.NumElements = NUM_ELEMENTS;
	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pFirstBuffer, &uavbuffer_desc, &m_pFirstBufferUAV);
	if (FAILED(hr))
		return hr;

	hr = m_pD3DCompDevice->CreateUnorderedAccessView(m_pSecondBuffer, &uavbuffer_desc, &m_pSecondBufferUAV);
	if (FAILED(hr))
		return hr;


	// Create the Readback Buffer
	// This is used to read the results back to the CPU
	D3D11_BUFFER_DESC readback_buffer_desc;
	ZeroMemory(&readback_buffer_desc, sizeof(readback_buffer_desc));
	readback_buffer_desc.ByteWidth = NUM_ELEMENTS * sizeof(UINT);
	readback_buffer_desc.Usage = D3D11_USAGE_STAGING;
	readback_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	readback_buffer_desc.StructureByteStride = sizeof(UINT);
	hr = m_pD3DCompDevice->CreateBuffer(&readback_buffer_desc, nullptr, &m_pReadBackBuffer);
	if (FAILED(hr))
		return hr;


	//copying the attributes
	*pComputeShaderSort = m_pComputeShaderBitonic;
	*pMatrixTranspose = m_pComputeShaderTranspose;
	*pBitonicConstantBuffer = m_pBitonicConstantBuffer;
	*pFirstBuffer = m_pFirstBuffer;
	*pSecondBuffer = m_pSecondBuffer;
	*pShaderSRV0 = m_pFirstBufferSRV;
	*pShaderSRV1 = m_pSecondBufferSRV;
	*ppUAV0 = m_pFirstBufferUAV;
	*ppUAV1 = m_pSecondBufferUAV;
	*pReadBackBuffer = m_pReadBackBuffer;
	return hr;
}


void DirectXStandardAlgorithmExecutor::GPUSort(HINSTANCE hInstance, HWND hWnd, ID3D11ComputeShader* pComputeShaderSort, ID3D11ComputeShader* pMatrixTranspose, ID3D11Buffer* pBitonicConstantBuffer,
ID3D11Buffer* pFirstBuffer, ID3D11Buffer* pSecondBuffer, ID3D11ShaderResourceView* pShaderSRV0, ID3D11ShaderResourceView* pShaderSRV1,
ID3D11UnorderedAccessView* ppUAV0, ID3D11UnorderedAccessView* ppUAV1,
ID3D11Buffer* pReadBackBuffer,
vector<UINT> dataArray, vector<UINT> *pSortedData)
{

	HRESULT hr = S_OK;
	vector<UINT> pResults = vector<UINT>(NUM_ELEMENTS);
	vector<UINT> pSortResults = vector<UINT>();
	cout << "Block Size: " << BITONIC_BLOCK_SIZE << endl;
	cout << "Starting Our Sorting Simulation" << endl;

	cout << "Sorting the Levels  less than Block Size" << endl;

	cout << "First We will upload the Data" << endl;
	// Upload the data
	m_pD3DCompContext->UpdateSubresource(pFirstBuffer, 0, nullptr, &dataArray[0], 0, 0);

	// Sort the data
	// First sort the rows for the levels <= to the block size
	for (UINT level = 2; level <= BITONIC_BLOCK_SIZE; level = level * 2)
	{
		cout << "Sorting the Levels less than Block Size" << endl;

		SetConstants(pBitonicConstantBuffer, level, level, MATRIX_HEIGHT, MATRIX_WIDTH);
		// Sort the row data
		m_pD3DCompContext->CSSetShader(pComputeShaderSort, nullptr, 0);
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &ppUAV0, nullptr);
		m_pD3DCompContext->Dispatch(NUM_ELEMENTS / BITONIC_BLOCK_SIZE, 1, 1);
	}

	cout << "Sorting the Levels greater than Block Size" << endl;

	// Then sort the rows and columns for the levels > than the block size
	// Transpose. Sort the Columns. Transpose. Sort the Rows.
	for (UINT level = (BITONIC_BLOCK_SIZE * 2); level <= NUM_ELEMENTS; level = level * 2)
	{

		cout << "Sorting the Levels greater than Block Size" << endl;
		SetConstants(pBitonicConstantBuffer, (level / BITONIC_BLOCK_SIZE), (level & ~NUM_ELEMENTS) / BITONIC_BLOCK_SIZE, MATRIX_WIDTH, MATRIX_HEIGHT);

		cout << "Transposing the data from buffer 1 into buffer 2" << endl;
		// Transpose the data from buffer 1 into buffer 2
		ID3D11ShaderResourceView* pViewnullptr = nullptr;
		m_pD3DCompContext->CSSetShaderResources(0, 1, &pViewnullptr);
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &ppUAV1, nullptr);
		m_pD3DCompContext->CSSetShaderResources(0, 1, &pShaderSRV0);
		m_pD3DCompContext->CSSetShader(pMatrixTranspose, nullptr, 0);
		m_pD3DCompContext->Dispatch(MATRIX_WIDTH / TRANSPOSE_BLOCK_SIZE, MATRIX_HEIGHT / TRANSPOSE_BLOCK_SIZE, 1);

		cout << "Soring Buffer TWO" << endl;
		// Sort the transposed column data
		m_pD3DCompContext->CSSetShader(pComputeShaderSort, nullptr, 0);
		m_pD3DCompContext->Dispatch(NUM_ELEMENTS / BITONIC_BLOCK_SIZE, 1, 1);

		SetConstants(pBitonicConstantBuffer, BITONIC_BLOCK_SIZE, level, MATRIX_HEIGHT, MATRIX_WIDTH);

		cout << "Transposing the data back from buffer 2 to buffer one" << endl;
		// Transpose the data from buffer 2 back into buffer 1
		m_pD3DCompContext->CSSetShaderResources(0, 1, &pViewnullptr);
		m_pD3DCompContext->CSSetUnorderedAccessViews(0, 1, &ppUAV0, nullptr);
		m_pD3DCompContext->CSSetShaderResources(0, 1, &pShaderSRV1);
		m_pD3DCompContext->CSSetShader(pMatrixTranspose, nullptr, 0);
		m_pD3DCompContext->Dispatch(MATRIX_HEIGHT / TRANSPOSE_BLOCK_SIZE, MATRIX_WIDTH / TRANSPOSE_BLOCK_SIZE, 1);

		cout << "Sorting the Rows Data" << endl;
		// Sort the row data
		m_pD3DCompContext->CSSetShader(pComputeShaderSort, nullptr, 0);
		m_pD3DCompContext->Dispatch(NUM_ELEMENTS / BITONIC_BLOCK_SIZE, 1, 1);
	}

	// Download the data
	cout << "Downloading the Result and copying the output to a vector" << endl;


	D3D11_MAPPED_SUBRESOURCE MappedResource = { 0 };
	m_pD3DCompContext->CopyResource(pReadBackBuffer, pFirstBuffer);
	hr = m_pD3DCompContext->Map(pReadBackBuffer, 0, D3D11_MAP_READ, 0, &MappedResource);



	if (SUCCEEDED(hr))
	{

		_Analysis_assume_(MappedResource.pData);
		assert(MappedResource.pData);
		memcpy(&pResults[0], MappedResource.pData, NUM_ELEMENTS * sizeof(UINT));
		m_pD3DCompContext->Unmap(pReadBackBuffer, 0);
	}
	// Set a break point here and put down the expression "p, 1024" in your watch window to see what has been written out by our CS
	// This is also a common trick to debug CS programs.

	int pIndex = 0;
	for (UINT pOutput : pResults)
	{
		pSortResults.push_back(pOutput);
	}

	m_pD3DCompContext->Unmap(pReadBackBuffer, 0);
	*pSortedData = pSortResults;


}


//--------------------------------------------------------------------------------------
// Helper to set the compute shader constants
//--------------------------------------------------------------------------------------
void DirectXStandardAlgorithmExecutor::SetConstants(ID3D11Buffer* pConstantBufer, UINT iLevel, UINT iLevelMask, UINT iWidth, UINT iHeight)
{
	ConstantBuffer cb = { iLevel, iLevelMask, iWidth, iHeight };
	m_pD3DCompContext->UpdateSubresource(pConstantBufer, 0, nullptr, &cb, 0, 0);
	m_pD3DCompContext->CSSetConstantBuffers(0, 1, &pConstantBufer);
}
//--------------------------------------------------------------------------------------
// Helper to set the compute shader constants
//--------------------------------------------------------------------------------------




	



void DirectXStandardAlgorithmExecutor::ExecuteComputeShader(ID3D11DeviceContext* pd3dImmediateContext, ID3D11ComputeShader* pComputeShader, UINT nNumViews, ID3D11ShaderResourceView** pShaderResourceViews, ID3D11Buffer* pCBCS, void* pCSData, DWORD dwNumDataBytes, ID3D11UnorderedAccessView* pUnorderedAccessView, UINT X, UINT Y, UINT Z)
{
	
	ID3D11ShaderResourceView* pSRV1 = nullptr;
	ID3D11ShaderResourceView* pSRV2 = nullptr;
	memcpy(pSRV1, pAdditionAlgorithmsSRV[0], sizeof(pAdditionAlgorithmsSRV[0]));
	memcpy(pSRV2, pAdditionAlgorithmsSRV[1], sizeof(pAdditionAlgorithmsSRV[1]));

	pd3dImmediateContext->CSSetShader(m_pArrayAddititionAlgorithm, nullptr, 0);
	pd3dImmediateContext->CSSetConstantBuffers(0, 1, &m_pFirstBuffer);
	pd3dImmediateContext->CSSetConstantBuffers(1, 1, &m_pSecondBuffer);
	pd3dImmediateContext->CSSetConstantBuffers(2, 1, &m_pReadBackBuffer);
	pd3dImmediateContext->CSSetShaderResources(0, 1, &pSRV1);
	pd3dImmediateContext->CSSetShaderResources(1, 1, &pSRV2);
	pd3dImmediateContext->CSSetUnorderedAccessViews(0, 1, &m_pResultBufferUAV, nullptr);
	
	if (pCBCS && pCSData)
	{
		D3D11_MAPPED_SUBRESOURCE MappedResource;
		pd3dImmediateContext->Map(pCBCS, 0, D3D11_MAP_WRITE_DISCARD, 0, &MappedResource);
		memcpy(MappedResource.pData, pCSData, dwNumDataBytes);
		pd3dImmediateContext->Unmap(pCBCS, 0);
		ID3D11Buffer* ppCB[1] = { pCBCS };
		pd3dImmediateContext->CSSetConstantBuffers(0, 1, ppCB);
	}

	pd3dImmediateContext->Dispatch(X, Y, Z);

	pd3dImmediateContext->CSSetShader(nullptr, nullptr, 0);

	ID3D11UnorderedAccessView* ppUAViewnullptr[1] = { nullptr };
	pd3dImmediateContext->CSSetUnorderedAccessViews(0, 1, ppUAViewnullptr, nullptr);

	ID3D11ShaderResourceView* ppSRVnullptr[2] = { nullptr, nullptr };
	pd3dImmediateContext->CSSetShaderResources(0, 2, ppSRVnullptr);

	ID3D11Buffer* ppCBnullptr[1] = { nullptr };
	pd3dImmediateContext->CSSetConstantBuffers(0, 1, ppCBnullptr);
}





//--------------------------------------------------------------------------------------
// GPU Bitonic Sort
//--------------------------------------------------------------------------------------



	HRESULT DirectXStandardAlgorithmExecutor::PerformFFTSimulation(HINSTANCE hInstance, HWND hWnd, int pJValue, int pKValue, vector<float> pInputData, vector<double> pTimeArray,
	vector<float> *pOutputData)
{
	HRESULT hr = S_OK;

	cout << "We are Going to Simulate the behaviour of an exponential function " << endl;


	vector<float> pOutputDataBuffer = vector<float>();
	vector<float> ppIntegralValues = vector<float>();



	int pIndex = 0;
	cout << "Printing the Initial Data: " << endl;
	for (double pDataValue : pInputData)
	{
		cout << "Input Item At Index: " << pIndex << " = " << pDataValue << endl;
		pIndex = pIndex + 1;
	}


	cout << "Performing the Simulation on the GPU" << endl;


	cout << "Printing the output results" << endl;

	pIndex = 0;
	vector<float> pOutputArray = vector<float>();
	for (float pValueObject : pOutputDataBuffer)
	{
		cout << "Current Output Item at index: " << pIndex << " = " << "data =" << pValueObject << endl;
		pOutputArray.push_back(pValueObject);
		pIndex++;
	}

	*pOutputData = pOutputArray;

	return hr;
}







HRESULT DirectXStandardAlgorithmExecutor::CreateSRVForBuffer(HINSTANCE hInstance, HWND hWnd, ID3D11Buffer* pInputBuffer, ID3D11ShaderResourceView** ppShaderResourceSRV)
{
	HRESULT hr = S_OK;
	D3D11_BUFFER_DESC pBufferDesc;
	cout << "Getting Buffer Description" << endl;
	ID3D11ShaderResourceView* ppShaderSRV = nullptr;
	pInputBuffer->GetDesc(&pBufferDesc);

	D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
	ZeroMemory(&srvDesc, sizeof(srvDesc));
	srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFEREX;
	srvDesc.BufferEx.FirstElement = 0;

	if (pBufferDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS)
	{
		srvDesc.Format = DXGI_FORMAT_R32_TYPELESS;
		srvDesc.BufferEx.Flags = D3D11_BUFFEREX_SRV_FLAG_RAW;
		srvDesc.BufferEx.NumElements = pBufferDesc.ByteWidth / 4;
	}
	else
	{
		if (pBufferDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_STRUCTURED)
		{
			srvDesc.Format = DXGI_FORMAT_UNKNOWN;
			srvDesc.BufferEx.NumElements = pBufferDesc.ByteWidth / pBufferDesc.StructureByteStride;
		}
		else
		{
			hr = E_INVALIDARG;
			return hr;
		}

	}

	hr = m_pD3DCompDevice->CreateShaderResourceView(pInputBuffer, &srvDesc, &ppShaderSRV);
	*ppShaderResourceSRV = ppShaderSRV;

	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::CreateByteOrderBufferOnGPU(ID3D11Device* pDevice, UINT uElementSize, UINT uCount, VOID* pInitData, ID3D11Buffer** ppBufOut)
{
	*ppBufOut = NULL;
	HRESULT hr = S_OK;
	D3D11_BUFFER_DESC desc;
	ZeroMemory(&desc, sizeof(desc));
	desc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE;
	desc.ByteWidth = uElementSize * uCount;
	desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS;
	desc.StructureByteStride = uElementSize;

	if (pInitData)
	{
		D3D11_SUBRESOURCE_DATA InitData;
		InitData.pSysMem = pInitData;
		hr = pDevice->CreateBuffer(&desc, &InitData, ppBufOut);
	}
	else
	{
		hr = pDevice->CreateBuffer(&desc, NULL, ppBufOut);
	}
	
	return hr;
}

HRESULT DirectXStandardAlgorithmExecutor::CreateByteBufferUAV(HINSTANCE hInstance, HWND hWnd, ID3D11Device* pDevice, ID3D11Buffer* ppDataBufferUAV, ID3D11UnorderedAccessView** ppUnorderedAccessView)
{
	HRESULT hr = S_OK;
	D3D11_BUFFER_DESC bufferDesc;
	cout << "Connecting to the input Buffer" << endl;
	ID3D11UnorderedAccessView* ppUnorderedUAView = nullptr;
	ppDataBufferUAV->GetDesc(&bufferDesc);

	 D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
	 ZeroMemory(&uavDesc, sizeof(uavDesc));

	 uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
	 uavDesc.Buffer.FirstElement = 0;

	 if (bufferDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS)
	 {
		 uavDesc.Format = DXGI_FORMAT_R32_TYPELESS;
		 uavDesc.Buffer.Flags = D3D11_BUFFER_UAV_FLAG_RAW;
		 uavDesc.Buffer.NumElements = bufferDesc.ByteWidth / 4;
	 }
	 else
	 {
		 if (bufferDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_STRUCTURED)
		 {
			 uavDesc.Format = DXGI_FORMAT_UNKNOWN;
			 uavDesc.Buffer.NumElements = bufferDesc.ByteWidth / bufferDesc.StructureByteStride;
		 }
		 else
		 {
			 hr = E_INVALIDARG;
			 return hr;
		 }
	 }

	 hr = pDevice->CreateUnorderedAccessView(ppDataBufferUAV, &uavDesc, &ppUnorderedUAView);
	 *ppUnorderedAccessView = ppUnorderedUAView;

	 return hr;
}





//--------------------------------------------------------------------------------------
// CPU Sort
//--------------------------------------------------------------------------------------
void DirectXStandardAlgorithmExecutor::CPUSort(vector<UINT> pDataArray, vector<UINT> *pSortedData)
{
	std::sort(pDataArray.begin(), pDataArray.end());
	*pSortedData = pDataArray;
}

HRESULT DirectXStandardAlgorithmExecutor::InitializeComputationsDevice(HWND hWnd, int adapterIndex)
{
	HRESULT hr = S_OK;
	bool	hasComputeShaders = true;
	RECT rc;
	GetClientRect( hWnd, &rc );
	UINT width = rc.right - rc.left;
	UINT height = rc.bottom - rc.top;

	UINT createDeviceFlags = 0;

#ifdef _DEBUG
	createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

	D3D_DRIVER_TYPE driverTypes[] =
	{
#ifdef WARP
		D3D_DRIVER_TYPE_REFERENCE,
#else
		D3D_DRIVER_TYPE_HARDWARE,        
#endif
	};
	unsigned int numDriverTypes = sizeof( driverTypes ) / sizeof( driverTypes[0] );

	DXGI_SWAP_CHAIN_DESC sd;
	ZeroMemory( &sd, sizeof( sd ) );
	sd.BufferCount = 1;
	sd.BufferDesc.Width = width;
	sd.BufferDesc.Height = height;
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	sd.BufferDesc.RefreshRate.Numerator = 60;
	sd.BufferDesc.RefreshRate.Denominator = 1;
	//sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT | DXGI_USAGE_UNORDERED_ACCESS | DXGI_USAGE_SHADER_INPUT;
	sd.OutputWindow = hWnd;
	sd.SampleDesc.Count = 1;
	sd.SampleDesc.Quality = 0;
	sd.Windowed = TRUE;
	//sd.Windowed = FALSE;
	//sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;



	// try dx 11
	D3D_FEATURE_LEVEL FeatureLevel = D3D_FEATURE_LEVEL_11_0;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT | DXGI_USAGE_UNORDERED_ACCESS | DXGI_USAGE_SHADER_INPUT;

	hr = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)(& m_pAlgorithmComputationsFactory));

	if (SUCCEEDED(hr))
	{
		for ( UINT i = 0;
			 m_pAlgorithmComputationsFactory->EnumAdapters(i, &m_pAlgorithmComputationAdapter) != DXGI_ERROR_NOT_FOUND;
			++i )
		{

			pAdapters.push_back(m_pAlgorithmComputationAdapter); 
		} 

	}

	hr = D3D11CreateDeviceAndSwapChain( pAdapters[adapterIndex], D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, &FeatureLevel,1,  D3D11_SDK_VERSION, &sd, &pSwapChainObject, &m_pAlgoComputeDevice, NULL, &m_pAlgoComputeContext);

	if (hr == S_OK)
		bool	hasComputeShaders = true;
	else
	{
		// try dx 10
		FeatureLevel = D3D_FEATURE_LEVEL_10_0;
		sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		hr = D3D11CreateDeviceAndSwapChain( NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, &FeatureLevel,1,  D3D11_SDK_VERSION, &sd, &pSwapChainObject, &m_pAlgoComputeDevice, NULL, &m_pAlgoComputeContext);
	}

	return hr;

}

